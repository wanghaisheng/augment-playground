This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
app-design-brief.md
development-tasks-updated.md
docs/data-sync-architecture.md
index.html
issue.md
package.json
page-design-document.md
prd.md
prompt.md
public/assets/abilities/bamboo-focus.svg
public/assets/abilities/bamboo-heart.svg
public/assets/abilities/bamboo-master.svg
public/assets/abilities/default-ability.svg
public/assets/abilities/panda-vitality.svg
public/assets/abilities/panda-wisdom.svg
public/assets/bamboo-bg-pattern.svg
public/assets/bamboo-leaves.svg
public/assets/chinese-cloud.svg
public/assets/chinese-knot.svg
public/assets/chinese-lantern.svg
public/assets/chinese-pattern.svg
public/assets/ink-splash.svg
public/assets/lattice-pattern.svg
public/assets/lotus-flower.svg
public/assets/mountain-landscape.svg
public/assets/panda-focused.svg
public/assets/panda-happy.svg
public/assets/panda-normal.svg
public/assets/panda-tired.svg
public/assets/paper-texture.svg
public/assets/rewards/coin.svg
public/assets/rewards/decoration_common.svg
public/assets/rewards/experience.svg
public/assets/rewards/food_common.svg
public/assets/rewards/food_uncommon.svg
public/assets/rewards/item_common.svg
public/assets/rewards/potion_common.svg
public/assets/rewards/scroll_common.svg
public/assets/rewards/toy_common.svg
public/assets/rewards/toy_uncommon.svg
public/assets/scroll-edge.svg
public/assets/sounds/README.md
README.md
src/App.tsx
src/components/animation/AnimatedButton.tsx
src/components/animation/AnimatedContainer.tsx
src/components/animation/AnimatedItem.tsx
src/components/animation/AnimatedTaskCard.tsx
src/components/animation/AnimatedTaskList.tsx
src/components/animation/ChallengeCompletionAnimation.tsx
src/components/animation/GoldenGlow.tsx
src/components/animation/InkSplash.tsx
src/components/animation/PageTransition.tsx
src/components/animation/README.md
src/components/animation/RewardAnimation.tsx
src/components/animation/TaskCompletionAnimation.tsx
src/components/common/Button.tsx
src/components/common/DataLoader.tsx
src/components/common/ErrorDisplay.tsx
src/components/common/LoadingSpinner.tsx
src/components/common/Modal.tsx
src/components/common/ProgressBar.tsx
src/components/common/SyncStatusIndicator.tsx
src/components/decoration/ChineseDecoration.tsx
src/components/decoration/InkAnimation.tsx
src/components/decoration/LanternDecoration.tsx
src/components/game/AbilityCard.tsx
src/components/game/AbilityList.tsx
src/components/game/AbilityUnlockNotification.tsx
src/components/game/ChallengeCard.tsx
src/components/game/ChallengeList.tsx
src/components/game/DialogDemo.tsx
src/components/game/LatticeDialog.tsx
src/components/game/LuckyDraw.tsx
src/components/game/LuckyDrawWheel.tsx
src/components/game/LuckyPointsDisplay.tsx
src/components/game/PandaAvatar.tsx
src/components/game/README.md
src/components/game/ReflectionModule.tsx
src/components/game/ResourceDisplay.tsx
src/components/game/ResourceInventory.tsx
src/components/game/ResourceList.tsx
src/components/game/RewardModal.tsx
src/components/game/ScrollDialog.tsx
src/components/game/TaskCard.tsx
src/components/game/TaskForm.tsx
src/components/game/TaskList.tsx
src/components/game/TimelyRewardCard.tsx
src/components/game/TimelyRewardList.tsx
src/components/layout/AppShell.tsx
src/components/layout/Header.tsx
src/components/layout/Navigation.tsx
src/components/tasks/SubtaskList.tsx
src/context/DataRefreshProvider.tsx
src/context/LanguageProvider.tsx
src/context/PandaStateProvider.tsx
src/db.ts
src/features/home/MoodsSection.tsx
src/features/home/PandaSection.tsx
src/features/home/WelcomeSection.tsx
src/features/settings/LanguageSettingsSection.tsx
src/features/tasks/TaskManager.tsx
src/game-theme.css
src/hooks/useDataRefresh.ts
src/hooks/useInternationalizedQuery.ts
src/hooks/useLocalizedView.ts
src/index.css
src/main.tsx
src/pages/AbilitiesPage.tsx
src/pages/ChallengesPage.tsx
src/pages/HomePage.tsx
src/pages/SettingsPage.tsx
src/pages/TasksPage.tsx
src/pages/TimelyRewardsPage.tsx
src/router.tsx
src/services/challengeService.ts
src/services/dataSyncService.ts
src/services/index.ts
src/services/localizedContentService.ts
src/services/pandaAbilityService.ts
src/services/pandaStateService.ts
src/services/queryClient.ts
src/services/rewardService.ts
src/services/subtaskService.ts
src/services/taskService.ts
src/services/timelyRewardService.ts
src/types/dataRefresh.ts
src/types/index.ts
src/utils/animation.ts
src/utils/dateUtils.ts
src/utils/sound.ts
src/vite-env.d.ts
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="issue.md">
# React Hooks 无限循环调用问题修复报告

## 问题描述

在 PandaHabit 应用中，我们发现了几个组件存在 React Hooks 的使用问题，导致无限循环渲染和以下错误：

1. **Invalid hook call 错误**：
   ```
   Uncaught Error: Invalid hook call. Hooks can only be called inside of the body of a function component.
   ```

2. **Maximum update depth exceeded 警告**：
   ```
   Warning: Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.
   ```

## 问题原因

这些问题主要由以下几个原因导致：

1. **违反 React Hooks 规则**：在非函数组件顶层或自定义 Hook 内部调用 Hooks
2. **依赖数组不正确**：在 useEffect 中使用了会在每次渲染时变化的依赖
3. **循环依赖**：组件之间存在循环依赖关系
4. **直接在组件函数体内调用 Hook**：而不是在 useEffect 或其他 Hook 中调用

## 修复方案

### 1. 修复 `registerTableRefreshListener` 函数

**问题**：
`registerTableRefreshListener` 函数不是一个自定义 Hook（不以 "use" 开头），但它内部使用了 `useDataRefreshContext` Hook。

**修复**：
将其改为自定义 Hook `useRegisterTableRefresh`，并在内部使用 useEffect 处理订阅和清理：

```typescript
// 修改前
export function registerTableRefreshListener(
  table: string,
  callback: (data: any) => void
): () => void {
  const { registerRefreshListener } = useDataRefreshContext();
  return registerRefreshListener(table, callback);
}

// 修改后 (第一次尝试)
export function useRegisterTableRefresh(
  table: string,
  callback: (data: any) => void
): () => void {
  const { registerRefreshListener } = useDataRefreshContext();

  useEffect(() => {
    // 注册表监听器
    const unregister = registerRefreshListener(table, callback);

    // 清理函数
    return unregister;
  }, [table, callback, registerRefreshListener]);

  return () => {}; // 返回一个空函数，实际的取消注册在 useEffect 的清理函数中完成
}

// 最终修复 (使用 useRef 避免依赖变化)
export function useRegisterTableRefresh(
  table: string,
  callback: (data: any) => void
): () => void {
  const { registerRefreshListener } = useDataRefreshContext();

  // 使用 ref 来存储最新的回调函数，避免依赖变化
  const callbackRef = useRef(callback);

  // 更新 callbackRef 当 callback 变化时
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  // 使用 ref 来存储最新的 table 值
  const tableRef = useRef(table);

  // 更新 tableRef 当 table 变化时
  useEffect(() => {
    tableRef.current = table;
  }, [table]);

  // 使用 ref 来存储最新的 registerRefreshListener 函数
  const registerRefreshListenerRef = useRef(registerRefreshListener);

  // 更新 registerRefreshListenerRef 当 registerRefreshListener 变化时
  useEffect(() => {
    registerRefreshListenerRef.current = registerRefreshListener;
  }, [registerRefreshListener]);

  // 只在组件挂载时注册一次监听器
  useEffect(() => {
    // 创建一个稳定的回调函数，它总是使用最新的 callback
    const stableCallback = (data: any) => {
      // 使用 ref 获取最新的 callback
      callbackRef.current(data);
    };

    // 注册表监听器
    const unregister = registerRefreshListenerRef.current(tableRef.current, stableCallback);

    // 清理函数
    return unregister;
  }, []); // 没有依赖项，使用 ref 获取最新的值

  return () => {}; // 返回一个空函数，实际的取消注册在 useEffect 的清理函数中完成
}
```

### 2. 修复 `ChallengeList` 组件

**问题**：
直接在组件函数体内调用 `registerTableRefreshListener`，导致每次渲染都会重新注册监听器。

**修复**：
1. 使用 `useCallback` 包装回调函数
2. 使用新的 `useRegisterTableRefresh` Hook

```typescript
// 修改前
useTableRefresh('challenges', (challengeData) => {
  // 处理逻辑...
});

// 修改后
const handleChallengeDataUpdate = useCallback((challengeData: any) => {
  // 处理逻辑...
}, [loadChallenges, filter]);

// 使用 useRegisterTableRefresh hook 监听挑战表的变化
useRegisterTableRefresh('challenges', handleChallengeDataUpdate);
```

### 3. 修复 `AnimatedTaskList` 组件

**问题**：
与 `ChallengeList` 组件类似，直接在组件函数体内调用 `useTableRefresh`。

**修复**：
1. 使用 `useCallback` 包装回调函数
2. 使用新的 `useRegisterTableRefresh` Hook
3. 使用 `useRef` 避免依赖变化

```typescript
// 修改前
useTableRefresh('tasks', (taskData) => {
  // 处理逻辑...
});

// 修改后 (第一次尝试)
const handleTaskDataUpdate = useCallback((taskData: any) => {
  // 处理逻辑...
}, [loadTasks, filter]);

// 使用 useRegisterTableRefresh hook 监听任务表的变化
useRegisterTableRefresh('tasks', handleTaskDataUpdate);

// 最终修复 (使用 useRef)
// 定义任务数据更新处理函数 - 使用 useRef 来避免依赖变化
const filterRef = React.useRef(filter);
const loadTasksRef = React.useRef(loadTasks);

// 更新 refs 当依赖变化时
React.useEffect(() => {
  filterRef.current = filter;
  loadTasksRef.current = loadTasks;
}, [filter, loadTasks]);

// 使用稳定的回调函数，不依赖于 filter 或 loadTasks
const handleTaskDataUpdate = useCallback((taskData: any) => {
  // 使用 ref 值而不是直接依赖
  const currentFilter = filterRef.current;
  const currentLoadTasks = loadTasksRef.current;

  // 如果有特定任务数据，则更新该任务
  if (taskData && taskData.id) {
    setTasks(prevTasks => {
      // 处理逻辑...
    });
  } else {
    // 如果没有特定任务数据，则重新加载所有任务
    currentLoadTasks();
  }
}, [/* 没有依赖项，使用 ref 来获取最新值 */]);

// 使用 useRegisterTableRefresh hook 监听任务表的变化
useRegisterTableRefresh('tasks', handleTaskDataUpdate);
```

### 4. 修复 `TaskManager` 组件

**问题**：
使用 `useDataRefresh` 监听任务表变化，但没有正确处理依赖关系，导致无限循环。

**修复**：
1. 使用 `useRegisterTableRefresh` 代替 `useDataRefresh`
2. 使用 `useRef` 来避免依赖变化

```typescript
// 修改前
const handleDataRefresh = useCallback(() => {
  setRefreshTrigger(prev => prev + 1);
}, []);

// 监听 'tasks' 表的数据刷新
useDataRefresh(['tasks'], () => handleDataRefresh());

// 修改后 (第一次尝试)
const handleDataRefresh = useCallback(() => {
  setRefreshTrigger(prev => prev + 1);
}, [setRefreshTrigger]); // 明确依赖 setRefreshTrigger

// 使用 useRegisterTableRefresh 监听 'tasks' 表的数据刷新
useRegisterTableRefresh('tasks', handleDataRefresh);

// 最终修复 (使用 useRef)
// 使用 useRef 来避免依赖变化
const setRefreshTriggerRef = React.useRef(setRefreshTrigger);

// 更新 ref 当依赖变化时
React.useEffect(() => {
  setRefreshTriggerRef.current = setRefreshTrigger;
}, [setRefreshTrigger]);

// 使用稳定的回调函数，不依赖于 setRefreshTrigger
const handleDataRefresh = useCallback(() => {
  // 只需要触发刷新，不需要重新获取所有数据
  setRefreshTriggerRef.current(prev => prev + 1);
}, []); // 没有依赖项，使用 ref 来获取最新值

// 使用 useRegisterTableRefresh 监听 'tasks' 表的数据刷新
useRegisterTableRefresh('tasks', handleDataRefresh);
```

### 5. 修复循环依赖问题

**问题**：
`App.tsx` 和 `dataSyncService.ts` 之间存在循环依赖。

**修复**：
创建单独的 `queryClient.ts` 文件，将 `queryClient` 实例移出 `App.tsx`：

```typescript
// src/services/queryClient.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 2, // 2 minutes
      refetchOnWindowFocus: false,
      retry: 1,
    },
  },
});
```

## 全局检查类似问题的方法

为了全局检查类似的问题，可以采取以下步骤：

1. **检查所有直接使用 Hook 的非 Hook 函数**：
   - 搜索所有不以 "use" 开头但内部调用了 React Hooks 的函数
   - 将这些函数改为自定义 Hook（以 "use" 开头）或移除内部的 Hook 调用

2. **检查所有组件中直接在函数体内调用的 Hook**：
   - 搜索所有在组件函数体内直接调用的 Hook（不在 useEffect 等其他 Hook 内部）
   - 将这些调用移到 useEffect 或其他适当的 Hook 中

3. **检查所有 useEffect 的依赖数组**：
   - 确保所有 useEffect 都有正确的依赖数组
   - 使用 ESLint 的 exhaustive-deps 规则检查依赖项是否完整

4. **检查循环依赖**：
   - 分析模块导入关系，找出可能的循环依赖
   - 重构代码，将共享的逻辑或数据移到单独的模块中

5. **使用 React DevTools 的 Profiler**：
   - 监控组件的重新渲染次数
   - 识别渲染次数异常多的组件

## 预防措施

1. **遵循 React Hooks 规则**：
   - 只在 React 函数组件或自定义 Hook 中调用 Hooks
   - 不要在条件语句、循环或嵌套函数中调用 Hooks
   - 确保自定义 Hook 名称以 "use" 开头

2. **正确使用 useEffect 依赖数组**：
   - 包含 effect 中使用的所有外部变量
   - 使用 useCallback 和 useMemo 稳定化依赖项

3. **避免循环依赖**：
   - 设计清晰的模块结构
   - 将共享逻辑抽取到单独的模块

4. **使用 ESLint 插件**：
   - 安装 eslint-plugin-react-hooks
   - 启用 rules-of-hooks 和 exhaustive-deps 规则

通过以上措施，可以有效预防和解决 React Hooks 相关的无限循环渲染问题。

## 多语言支持更新

为了确保所有页面都使用一致的多语言支持方式，我们进行了以下更新：

1. **更新 ChallengesPage**：
   - 使用 `useLocalizedView` 获取多语言标签
   - 将硬编码的文本替换为标签
   - 添加错误处理和加载状态的多语言支持

2. **更新 AbilitiesPage**：
   - 添加 `useLocalizedView` 获取多语言标签
   - 创建相应的类型定义
   - 将硬编码的文本替换为标签
   - 添加错误处理和加载状态的多语言支持

3. **更新 TasksPage**：
   - 修复条件判断和错误处理
   - 添加错误处理和加载状态的多语言支持

4. **更新类型定义**：
   - 为 `TasksPageViewLabelsBundle` 添加缺失的属性
   - 为 `ChallengesPageViewLabelsBundle` 添加缺失的属性
   - 创建 `AbilitiesPageViewLabelsBundle` 类型定义

5. **添加本地化服务函数**：
   - 添加 `fetchAbilitiesPageView` 函数

通过这些更新，所有页面现在都使用了一致的多语言支持方式，并且正确使用了 DataRefreshProvider 来管理数据同步后的局部刷新。
</file>

<file path="public/assets/sounds/README.md">
# 音效文件目录

此目录用于存放游戏中使用的各种音效文件。

## 奖励音效

以下是奖励系统使用的音效文件：

- `reward_common.mp3` - 普通奖励音效
- `reward_uncommon.mp3` - 不常见奖励音效
- `reward_rare.mp3` - 稀有奖励音效
- `reward_epic.mp3` - 史诗奖励音效
- `reward_legendary.mp3` - 传说奖励音效

## 任务相关音效

- `task_complete.mp3` - 普通任务完成音效
- `task_complete_high.mp3` - 高优先级任务完成音效
- `task_complete_main.mp3` - 主线任务完成音效
- `task_failed.mp3` - 任务失败音效
- `task_created.mp3` - 任务创建音效

## 挑战相关音效

- `challenge_complete.mp3` - 普通挑战完成音效
- `challenge_complete_epic.mp3` - 史诗挑战完成音效
- `challenge_complete_legendary.mp3` - 传说挑战完成音效
- `challenge_failed.mp3` - 挑战失败音效
- `challenge_unlocked.mp3` - 挑战解锁音效

## 系统音效

- `level_up.mp3` - 等级提升音效
- `ability_unlocked.mp3` - 能力解锁音效
- `ability_activated.mp3` - 能力激活音效
- `button_click.mp3` - 按钮点击音效
- `error.mp3` - 错误提示音效
- `success.mp3` - 成功提示音效
- `notification.mp3` - 通知提示音效

## 音效格式

- 推荐使用 MP3 格式，文件大小应尽量小（建议小于 100KB）
- 音效时长应简短（通常 1-3 秒）
- 音量应适中，避免过大或过小

## 使用方法

在代码中使用 `sound.ts` 工具类播放音效：

```typescript
import { playSound, SoundType } from '@/utils/sound';

// 播放奖励音效
playSound(SoundType.REWARD_LEGENDARY);

// 控制音量（0-1）
playSound(SoundType.BUTTON_CLICK, 0.3);
```

## 注意事项

1. 添加新音效后，需要在 `sound.ts` 中更新 `SoundType` 枚举和 `soundPaths` 映射
2. 音效文件命名应与 `soundPaths` 中的路径一致
3. 考虑为用户提供音效开关和音量控制选项
</file>

<file path="src/components/animation/ChallengeCompletionAnimation.tsx">
// src/components/animation/ChallengeCompletionAnimation.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { playChallengeCompletionSound } from '@/utils/sound';

interface ChallengeCompletionAnimationProps {
  challengeTitle: string;
  challengeDescription?: string;
  onAnimationComplete?: () => void;
  style?: 'default' | 'epic' | 'legendary';
  playSound?: boolean;
  soundVolume?: number;
}

/**
 * 挑战完成动画组件
 * 在挑战完成时显示动画效果
 */
const ChallengeCompletionAnimation: React.FC<ChallengeCompletionAnimationProps> = ({
  challengeTitle,
  challengeDescription,
  onAnimationComplete,
  style = 'default',
  playSound = true,
  soundVolume = 0.5
}) => {
  const [isAnimating, setIsAnimating] = useState(true);
  const [particles, setParticles] = useState<React.ReactNode[]>([]);

  // 播放音效
  useEffect(() => {
    if (playSound) {
      // 根据动画样式确定挑战难度
      const difficulty = style === 'legendary' ? 'legendary' :
                         style === 'epic' ? 'epic' : 'normal';
      playChallengeCompletionSound(difficulty, soundVolume);
    }
  }, [playSound, style, soundVolume]);

  // 生成粒子效果
  useEffect(() => {
    const particleCount = style === 'legendary' ? 100 : style === 'epic' ? 70 : 40;
    const newParticles = [];

    for (let i = 0; i < particleCount; i++) {
      newParticles.push(generateParticle(i, style));
    }

    setParticles(newParticles);
  }, [style]);

  // 生成单个粒子
  const generateParticle = (index: number, style: string) => {
    // 传说级挑战完成动画
    if (style === 'legendary') {
      // 彩虹色粒子
      const colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];

      // 随机选择粒子类型
      const particleType = Math.random() > 0.7 ? 'star' : Math.random() > 0.5 ? 'circle' : 'square';

      if (particleType === 'star') {
        const size = Math.random() * 20 + 10;
        const angle = Math.random() * 360;
        const distance = Math.random() * 150 + 100;
        const delay = Math.random() * 1;
        const duration = Math.random() * 2 + 2;

        return (
          <motion.div
            key={`star-${index}`}
            style={{
              position: 'absolute',
              width: size,
              height: size,
              top: '50%',
              left: '50%',
              margin: `-${size / 2}px 0 0 -${size / 2}px`,
              clipPath: 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
              backgroundColor: randomColor,
              boxShadow: `0 0 10px ${randomColor}`,
              zIndex: 10
            }}
            initial={{
              x: 0,
              y: 0,
              opacity: 0,
              rotate: 0,
              scale: 0
            }}
            animate={{
              x: Math.cos(angle * Math.PI / 180) * distance,
              y: Math.sin(angle * Math.PI / 180) * distance,
              opacity: [0, 1, 1, 0.8, 0],
              rotate: 360,
              scale: [0, 1.5, 1, 1.2, 0]
            }}
            transition={{
              duration: duration,
              delay: delay,
              ease: 'easeInOut',
              times: [0, 0.2, 0.4, 0.8, 1]
            }}
          />
        );
      } else if (particleType === 'circle') {
        const size = Math.random() * 15 + 5;
        const angle = Math.random() * 360;
        const distance = Math.random() * 200 + 50;
        const delay = Math.random() * 0.8;
        const duration = Math.random() * 2 + 1.5;

        return (
          <motion.div
            key={`circle-${index}`}
            style={{
              position: 'absolute',
              width: size,
              height: size,
              borderRadius: '50%',
              backgroundColor: randomColor,
              boxShadow: `0 0 10px ${randomColor}`,
              top: '50%',
              left: '50%',
              margin: `-${size / 2}px 0 0 -${size / 2}px`,
              zIndex: 10
            }}
            initial={{
              x: 0,
              y: 0,
              opacity: 0,
              scale: 0.5
            }}
            animate={{
              x: Math.cos(angle * Math.PI / 180) * distance,
              y: Math.sin(angle * Math.PI / 180) * distance,
              opacity: [0, 1, 0.8, 0],
              scale: [0.5, 1.5, 1, 0]
            }}
            transition={{
              duration: duration,
              delay: delay,
              ease: 'easeOut',
              times: [0, 0.3, 0.7, 1]
            }}
          />
        );
      } else {
        const size = Math.random() * 12 + 8;
        const angle = Math.random() * 360;
        const distance = Math.random() * 180 + 80;
        const delay = Math.random() * 0.5;
        const duration = Math.random() * 1.5 + 1;
        const rotation = Math.random() * 720 - 360;

        return (
          <motion.div
            key={`square-${index}`}
            style={{
              position: 'absolute',
              width: size,
              height: size,
              backgroundColor: randomColor,
              boxShadow: `0 0 8px ${randomColor}`,
              top: '50%',
              left: '50%',
              margin: `-${size / 2}px 0 0 -${size / 2}px`,
              zIndex: 10
            }}
            initial={{
              x: 0,
              y: 0,
              opacity: 0,
              rotate: 0,
              scale: 0.5
            }}
            animate={{
              x: Math.cos(angle * Math.PI / 180) * distance,
              y: Math.sin(angle * Math.PI / 180) * distance,
              opacity: [0, 1, 0.7, 0],
              rotate: rotation,
              scale: [0.5, 1.2, 0.8, 0]
            }}
            transition={{
              duration: duration,
              delay: delay,
              ease: 'easeOut',
              times: [0, 0.3, 0.7, 1]
            }}
          />
        );
      }
    }
    // 史诗级挑战完成动画
    else if (style === 'epic') {
      const colors = ['#a335ee', '#9370DB', '#8A2BE2', '#9932CC', '#BA55D3'];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];

      const size = Math.random() * 15 + 5;
      const angle = Math.random() * 360;
      const distance = Math.random() * 150 + 50;
      const delay = Math.random() * 0.5;
      const duration = Math.random() * 1.5 + 1;

      return (
        <motion.div
          key={`epic-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            borderRadius: Math.random() > 0.5 ? '50%' : '0%',
            backgroundColor: randomColor,
            boxShadow: `0 0 8px ${randomColor}`,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0,
            rotate: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0],
            rotate: Math.random() > 0.5 ? 360 : 0
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    }
    // 默认挑战完成动画
    else {
      const colors = ['#FFD700', '#FFA500', '#FF8C00', '#FF7F50', '#FF6347'];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];

      const size = Math.random() * 10 + 5;
      const angle = Math.random() * 360;
      const distance = Math.random() * 100 + 50;
      const delay = Math.random() * 0.3;
      const duration = Math.random() * 1 + 0.8;

      return (
        <motion.div
          key={`default-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            borderRadius: '50%',
            backgroundColor: randomColor,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    }
  };

  // 处理动画完成
  const handleAnimationComplete = () => {
    setIsAnimating(false);
    if (onAnimationComplete) {
      onAnimationComplete();
    }
  };

  return (
    <AnimatePresence>
      {isAnimating && (
        <motion.div
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            zIndex: 1000,
            pointerEvents: 'none'
          }}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.3 }}
        >
          {/* 粒子效果 */}
          {particles}

          {/* 中心文本 */}
          <motion.div
            style={{
              backgroundColor: style === 'legendary' ? 'rgba(0, 0, 0, 0.8)' :
                              style === 'epic' ? 'rgba(50, 0, 80, 0.8)' :
                              'rgba(50, 30, 0, 0.8)',
              color: '#fff',
              padding: '30px 50px',
              borderRadius: '15px',
              textAlign: 'center',
              zIndex: 20,
              border: style === 'legendary' ? '3px solid gold' :
                      style === 'epic' ? '2px solid #a335ee' :
                      '1px solid #FFA500',
              boxShadow: style === 'legendary' ? '0 0 20px gold' :
                         style === 'epic' ? '0 0 15px #a335ee' :
                         '0 0 10px #FFA500'
            }}
            initial={{ scale: 0, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0, opacity: 0 }}
            transition={{ duration: 0.5, delay: 0.2 }}
            onAnimationComplete={handleAnimationComplete}
          >
            <motion.h2
              style={{
                fontSize: '2rem',
                marginBottom: '1rem',
                color: style === 'legendary' ? 'gold' :
                       style === 'epic' ? '#a335ee' :
                       '#FFA500'
              }}
              initial={{ y: -20, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ duration: 0.3, delay: 0.3 }}
            >
              挑战完成！
            </motion.h2>
            <motion.h3
              initial={{ y: -10, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ duration: 0.3, delay: 0.5 }}
            >
              {challengeTitle}
            </motion.h3>
            {challengeDescription && (
              <motion.p
                initial={{ y: 20, opacity: 0 }}
                animate={{ y: 0, opacity: 1 }}
                transition={{ duration: 0.3, delay: 0.7 }}
              >
                {challengeDescription}
              </motion.p>
            )}
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default ChallengeCompletionAnimation;
</file>

<file path="src/components/animation/README.md">
# 动画组件文档

## RewardAnimation 组件

`RewardAnimation` 是一个用于展示奖励获取动画的组件，支持多种动画效果和音效，根据奖励的稀有度提供不同的视觉效果。

## TaskCompletionAnimation 组件

`TaskCompletionAnimation` 是一个用于展示任务完成动画的组件，支持多种动画效果和音效，根据任务的优先级和类型提供不同的视觉效果。

## ChallengeCompletionAnimation 组件

`ChallengeCompletionAnimation` 是一个用于展示挑战完成动画的组件，支持多种动画效果和音效，根据挑战的难度提供不同的视觉效果。

### 使用方法

```tsx
import RewardAnimation from '@/components/animation/RewardAnimation';
import { RewardType, RewardRarity } from '@/services/rewardService';

// 基本用法
<RewardAnimation
  type={RewardType.COIN}
  rarity={RewardRarity.COMMON}
  iconPath="/assets/rewards/coin.svg"
  amount={10}
  size={100}
/>

// 高级用法
<RewardAnimation
  type={RewardType.ITEM}
  rarity={RewardRarity.LEGENDARY}
  iconPath="/assets/rewards/legendary_item.svg"
  amount={1}
  size={150}
  animationStyle="burst"
  playSound={true}
  soundVolume={0.7}
  onAnimationComplete={() => console.log('动画播放完成')}
/>
```

### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| type | RewardType | 必填 | 奖励类型 |
| rarity | RewardRarity | 必填 | 奖励稀有度 |
| iconPath | string | 必填 | 奖励图标路径 |
| amount | number | 1 | 奖励数量 |
| size | number | 100 | 动画容器大小（像素） |
| animationStyle | 'default' \| 'burst' \| 'float' \| 'spin' \| 'pulse' | 'default' | 动画样式 |
| playSound | boolean | true | 是否播放音效 |
| soundVolume | number | 0.5 | 音效音量（0-1） |
| onAnimationComplete | () => void | undefined | 动画完成回调函数 |

### 动画样式说明

1. **default**: 默认动画，适用于普通奖励
2. **burst**: 爆发式动画，适用于传说级奖励
3. **spin**: 旋转动画，适用于史诗级奖励
4. **pulse**: 脉冲动画，适用于稀有奖励
5. **float**: 浮动动画，适用于不常见奖励

### 稀有度特效

- **传说级 (Legendary)**: 彩虹边框、星星粒子、金色光晕
- **史诗级 (Epic)**: 紫色边框、强烈光晕效果
- **稀有级 (Rare)**: 蓝色边框、中等光晕效果
- **不常见 (Uncommon)**: 绿色光晕
- **普通 (Common)**: 基础光晕

### 音效系统

组件使用 `sound.ts` 工具类播放音效，根据奖励稀有度播放不同的音效。音效文件应放置在 `/public/assets/sounds/` 目录下。

### 示例代码

```tsx
// 在奖励模态框中使用
const getAnimationStyleForRarity = (rarity: string): 'default' | 'burst' | 'float' | 'spin' | 'pulse' => {
  switch (rarity) {
    case 'legendary': return 'burst';
    case 'epic': return 'spin';
    case 'rare': return 'pulse';
    case 'uncommon': return 'float';
    default: return 'default';
  }
};

<RewardAnimation
  type={reward.type}
  rarity={reward.rarity}
  iconPath={reward.iconPath}
  amount={reward.amount}
  size={120}
  onAnimationComplete={handleAnimationComplete}
  animationStyle={getAnimationStyleForRarity(reward.rarity)}
  playSound={true}
  soundVolume={0.6}
/>
```

## TaskCompletionAnimation 使用方法

```tsx
import TaskCompletionAnimation from '@/components/animation/TaskCompletionAnimation';
import { TaskRecord, TaskPriority, TaskType } from '@/services/taskService';

// 基本用法
<TaskCompletionAnimation
  task={completedTask}
  onAnimationComplete={() => console.log('任务完成动画结束')}
/>

// 高级用法
<TaskCompletionAnimation
  task={completedTask}
  style={completedTask.priority === TaskPriority.HIGH ? 'fireworks' :
         completedTask.type === TaskType.MAIN ? 'stars' : 'confetti'}
  playSound={true}
  soundVolume={0.7}
  onAnimationComplete={handleAnimationComplete}
/>
```

### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| task | TaskRecord | 必填 | 完成的任务 |
| onAnimationComplete | () => void | undefined | 动画完成回调函数 |
| style | 'default' \| 'confetti' \| 'fireworks' \| 'stars' | 'default' | 动画样式 |
| playSound | boolean | true | 是否播放音效 |
| soundVolume | number | 0.5 | 音效音量（0-1） |

## ChallengeCompletionAnimation 使用方法

```tsx
import ChallengeCompletionAnimation from '@/components/animation/ChallengeCompletionAnimation';

// 基本用法
<ChallengeCompletionAnimation
  challengeTitle="每周挑战：竹林探险"
  onAnimationComplete={() => console.log('挑战完成动画结束')}
/>

// 高级用法
<ChallengeCompletionAnimation
  challengeTitle="传说挑战：熊猫大师"
  challengeDescription="完成所有熊猫训练课程"
  style="legendary"
  playSound={true}
  soundVolume={0.8}
  onAnimationComplete={handleAnimationComplete}
/>
```

### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| challengeTitle | string | 必填 | 挑战标题 |
| challengeDescription | string | undefined | 挑战描述 |
| onAnimationComplete | () => void | undefined | 动画完成回调函数 |
| style | 'default' \| 'epic' \| 'legendary' | 'default' | 动画样式 |
| playSound | boolean | true | 是否播放音效 |
| soundVolume | number | 0.5 | 音效音量（0-1） |

## 注意事项

1. 确保音效文件已正确放置在 `/public/assets/sounds/` 目录下
2. 对于高频率触发的动画，考虑设置 `playSound={false}` 以避免音效重叠
3. 动画完成后会调用 `onAnimationComplete` 回调函数，可用于触发后续操作
4. 组件内部使用 `AnimatePresence` 处理动画的进入和退出，确保在父组件中正确处理组件的挂载和卸载
5. 任务和挑战完成动画会根据任务/挑战的重要性自动选择不同的动画效果
6. 所有动画组件都支持自定义样式和音效
</file>

<file path="src/components/animation/TaskCompletionAnimation.tsx">
// src/components/animation/TaskCompletionAnimation.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { TaskRecord } from '@/services/taskService';
import { playTaskCompletionSound } from '@/utils/sound';

interface TaskCompletionAnimationProps {
  task: TaskRecord;
  onAnimationComplete?: () => void;
  style?: 'default' | 'confetti' | 'fireworks' | 'stars';
  playSound?: boolean;
  soundVolume?: number;
}

/**
 * 任务完成动画组件
 * 在任务完成时显示动画效果
 */
const TaskCompletionAnimation: React.FC<TaskCompletionAnimationProps> = ({
  task,
  onAnimationComplete,
  style = 'default',
  playSound = true,
  soundVolume = 0.5
}) => {
  const [isAnimating, setIsAnimating] = useState(true);
  const [particles, setParticles] = useState<React.ReactNode[]>([]);

  // 播放音效
  useEffect(() => {
    if (playSound) {
      playTaskCompletionSound(task.type, task.priority, soundVolume);
    }
  }, [playSound, task.type, task.priority, soundVolume]);

  // 生成粒子效果
  useEffect(() => {
    const particleCount = style === 'confetti' ? 50 : style === 'fireworks' ? 30 : style === 'stars' ? 20 : 10;
    const newParticles = [];

    for (let i = 0; i < particleCount; i++) {
      newParticles.push(generateParticle(i, style));
    }

    setParticles(newParticles);
  }, [style]);

  // 生成单个粒子
  const generateParticle = (index: number, style: string) => {
    const colors = ['#FFD700', '#FF6347', '#7CFC00', '#00BFFF', '#FF69B4', '#9370DB'];
    const randomColor = colors[Math.floor(Math.random() * colors.length)];

    // 根据样式生成不同的粒子
    if (style === 'confetti') {
      const angle = Math.random() * 360;
      const distance = Math.random() * 100 + 50;
      const size = Math.random() * 10 + 5;
      const delay = Math.random() * 0.3;
      const duration = Math.random() * 1 + 1;
      const rotation = Math.random() * 720 - 360;

      return (
        <motion.div
          key={`confetti-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size / 2,
            backgroundColor: randomColor,
            top: '50%',
            left: '50%',
            margin: `-${size / 4}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0,
            rotate: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 1, 0],
            rotate: rotation,
            scale: [1, 1.2, 0.8, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    } else if (style === 'fireworks') {
      const angle = (index / 30) * 360;
      const distance = Math.random() * 50 + 100;
      const size = Math.random() * 6 + 2;
      const delay = Math.random() * 0.2;
      const duration = Math.random() * 0.8 + 0.6;

      return (
        <motion.div
          key={`firework-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            borderRadius: '50%',
            backgroundColor: randomColor,
            boxShadow: `0 0 ${size * 2}px ${randomColor}`,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0,
            scale: 0.5
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0],
            scale: [0.5, 1.5, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    } else if (style === 'stars') {
      const angle = Math.random() * 360;
      const distance = Math.random() * 80 + 40;
      const size = Math.random() * 15 + 10;
      const delay = Math.random() * 0.5;
      const duration = Math.random() * 1 + 1;

      return (
        <motion.div
          key={`star-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            clipPath: 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
            backgroundColor: randomColor,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0,
            rotate: 0,
            scale: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0],
            rotate: 360,
            scale: [0, 1, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    } else {
      // 默认样式
      const angle = Math.random() * 360;
      const distance = Math.random() * 60 + 30;
      const size = Math.random() * 8 + 4;
      const delay = Math.random() * 0.3;
      const duration = Math.random() * 0.7 + 0.5;

      return (
        <motion.div
          key={`default-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            borderRadius: '50%',
            backgroundColor: randomColor,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    }
  };

  // 处理动画完成
  const handleAnimationComplete = () => {
    setIsAnimating(false);
    if (onAnimationComplete) {
      onAnimationComplete();
    }
  };

  return (
    <AnimatePresence>
      {isAnimating && (
        <motion.div
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            zIndex: 1000,
            pointerEvents: 'none'
          }}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.3 }}
        >
          {/* 粒子效果 */}
          {particles}

          {/* 中心文本 */}
          <motion.div
            style={{
              backgroundColor: 'rgba(0, 0, 0, 0.7)',
              color: '#fff',
              padding: '20px 40px',
              borderRadius: '10px',
              textAlign: 'center',
              zIndex: 20
            }}
            initial={{ scale: 0, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0, opacity: 0 }}
            transition={{ duration: 0.5, delay: 0.2 }}
            onAnimationComplete={handleAnimationComplete}
          >
            <motion.h2
              initial={{ y: -20, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ duration: 0.3, delay: 0.3 }}
            >
              任务完成！
            </motion.h2>
            <motion.p
              initial={{ y: 20, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ duration: 0.3, delay: 0.5 }}
            >
              {task.title}
            </motion.p>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default TaskCompletionAnimation;
</file>

<file path="src/components/game/LuckyDrawWheel.tsx">
// src/components/game/LuckyDrawWheel.tsx
import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Button from '@/components/common/Button';
import { RewardRecord, RewardRarity } from '@/services/rewardService';
import { playSound, SoundType } from '@/utils/sound';
import RewardAnimation from '@/components/animation/RewardAnimation';
import ScrollDialog from './ScrollDialog';
import { getLuckyPointsTotal, performLuckyDraw } from '@/services/timelyRewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import LuckyPointsDisplay from './LuckyPointsDisplay';

interface LuckyDrawWheelProps {
  isOpen: boolean;
  onClose: () => void;
  onRewardEarned?: (rewards: RewardRecord[]) => void;
}

/**
 * 幸运抽奖轮盘组件
 * 用于实现带有旋转轮盘的幸运抽奖功能
 */
const LuckyDrawWheel: React.FC<LuckyDrawWheelProps> = ({
  isOpen,
  onClose,
  onRewardEarned
}) => {
  const [isDrawing, setIsDrawing] = useState(false);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [points, setPoints] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showReward, setShowReward] = useState(false);
  const [currentRewardIndex, setCurrentRewardIndex] = useState(0);
  const [selectedPoints, setSelectedPoints] = useState(10); // 默认使用10点
  const wheelRef = useRef<HTMLDivElement>(null);
  const [wheelRotation, setWheelRotation] = useState(0);
  const [isWheelSpinning, setIsWheelSpinning] = useState(false);

  // 抽奖选项
  const drawOptions = [
    { points: 10, label: '基础抽奖', description: '获得普通奖励的机会' },
    { points: 30, label: '高级抽奖', description: '获得稀有奖励的更高机会' },
    { points: 50, label: '豪华抽奖', description: '获得史诗和传说奖励的最高机会' }
  ];

  // 加载幸运点数量
  const loadPoints = async () => {
    try {
      setIsLoading(true);
      const total = await getLuckyPointsTotal();
      setPoints(total);
    } catch (err) {
      console.error('Failed to load lucky points:', err);
      setError('加载幸运点失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    if (isOpen) {
      loadPoints();
    }
  }, [isOpen]);

  // 定义幸运点数据更新处理函数
  const handleLuckyPointsUpdate = () => {
    loadPoints();
  };

  // 使用 useRegisterTableRefresh hook 监听幸运点表的变化
  useRegisterTableRefresh('luckyPoints', handleLuckyPointsUpdate);

  // 处理抽奖
  const handleDraw = async () => {
    if (points < selectedPoints) {
      setError('幸运点不足');
      return;
    }

    try {
      setIsDrawing(true);
      setError(null);
      
      // 播放抽奖音效
      playSound(SoundType.BUTTON_CLICK, 0.5);
      
      // 旋转抽奖轮盘
      setIsWheelSpinning(true);
      const randomRotation = 1080 + Math.random() * 360; // 至少旋转3圈
      setWheelRotation(prevRotation => prevRotation + randomRotation);
      
      // 延迟获取奖励，模拟抽奖过程
      setTimeout(async () => {
        // 执行抽奖
        const result = await performLuckyDraw(selectedPoints);
        
        // 更新幸运点
        setPoints(prev => prev - selectedPoints);
        
        // 设置奖励
        setRewards(result.rewards);
        
        // 停止轮盘旋转
        setIsWheelSpinning(false);
        
        // 显示奖励
        setTimeout(() => {
          setShowReward(true);
          setCurrentRewardIndex(0);
          
          // 播放奖励音效（根据稀有度）
          if (result.rewards.length > 0) {
            const rarity = result.rewards[0].rarity;
            switch (rarity) {
              case RewardRarity.LEGENDARY:
                playSound(SoundType.REWARD_LEGENDARY, 0.7);
                break;
              case RewardRarity.EPIC:
                playSound(SoundType.REWARD_EPIC, 0.7);
                break;
              case RewardRarity.RARE:
                playSound(SoundType.REWARD_RARE, 0.7);
                break;
              case RewardRarity.UNCOMMON:
                playSound(SoundType.REWARD_UNCOMMON, 0.7);
                break;
              default:
                playSound(SoundType.REWARD_COMMON, 0.7);
                break;
            }
          }
          
          // 通知父组件
          if (onRewardEarned) {
            onRewardEarned(result.rewards);
          }
        }, 500);
      }, 3000); // 3秒后显示结果
    } catch (err) {
      console.error('Failed to perform lucky draw:', err);
      setError('抽奖失败，请重试');
      setIsWheelSpinning(false);
    } finally {
      setIsDrawing(false);
    }
  };

  // 处理下一个奖励
  const handleNextReward = () => {
    if (currentRewardIndex < rewards.length - 1) {
      setCurrentRewardIndex(prevIndex => prevIndex + 1);
      
      // 播放奖励音效（根据稀有度）
      const rarity = rewards[currentRewardIndex + 1].rarity;
      switch (rarity) {
        case RewardRarity.LEGENDARY:
          playSound(SoundType.REWARD_LEGENDARY, 0.7);
          break;
        case RewardRarity.EPIC:
          playSound(SoundType.REWARD_EPIC, 0.7);
          break;
        case RewardRarity.RARE:
          playSound(SoundType.REWARD_RARE, 0.7);
          break;
        case RewardRarity.UNCOMMON:
          playSound(SoundType.REWARD_UNCOMMON, 0.7);
          break;
        default:
          playSound(SoundType.REWARD_COMMON, 0.7);
          break;
      }
    } else {
      setShowReward(false);
      setRewards([]);
    }
  };

  // 处理选择抽奖选项
  const handleSelectOption = (points: number) => {
    setSelectedPoints(points);
  };

  // 处理继续抽奖
  const handleContinue = () => {
    setShowReward(false);
    setRewards([]);
  };

  // 渲染抽奖轮盘
  const renderWheel = () => {
    // 轮盘上的奖励类型
    const wheelItems = [
      { type: RewardRarity.COMMON, color: '#cccccc', label: '普通' },
      { type: RewardRarity.UNCOMMON, color: '#4caf50', label: '不常见' },
      { type: RewardRarity.RARE, color: '#2196f3', label: '稀有' },
      { type: RewardRarity.EPIC, color: '#9c27b0', label: '史诗' },
      { type: RewardRarity.LEGENDARY, color: '#ffc107', label: '传说' },
      { type: RewardRarity.COMMON, color: '#cccccc', label: '普通' },
      { type: RewardRarity.UNCOMMON, color: '#4caf50', label: '不常见' },
      { type: RewardRarity.RARE, color: '#2196f3', label: '稀有' }
    ];

    return (
      <div className="lucky-draw-wheel-container relative w-64 h-64 mx-auto my-4">
        {/* 轮盘指针 */}
        <div className="wheel-pointer absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-10">
          <svg width="30" height="30" viewBox="0 0 30 30">
            <polygon points="15,0 30,15 15,30 0,15" fill="#e53935" />
          </svg>
        </div>
        
        {/* 轮盘 */}
        <motion.div
          ref={wheelRef}
          className="lucky-draw-wheel w-full h-full rounded-full border-4 border-gold overflow-hidden relative"
          style={{
            boxShadow: '0 0 20px rgba(255, 215, 0, 0.5)',
            transform: `rotate(${wheelRotation}deg)`,
            transition: isWheelSpinning ? 'transform 3s cubic-bezier(0.2, 0.8, 0.2, 1)' : 'none'
          }}
        >
          {wheelItems.map((item, index) => {
            const angle = (index / wheelItems.length) * 360;
            return (
              <div
                key={`wheel-item-${index}`}
                className="wheel-item absolute w-full h-full"
                style={{
                  transform: `rotate(${angle}deg)`,
                  transformOrigin: 'center',
                  clipPath: `polygon(50% 50%, 50% 0%, ${50 + 50 * Math.cos((angle + 45) * Math.PI / 180)}% ${50 + 50 * Math.sin((angle + 45) * Math.PI / 180)}%)`
                }}
              >
                <div
                  className="w-full h-full flex items-center justify-center"
                  style={{ backgroundColor: item.color }}
                >
                  <span
                    className="text-white font-bold transform rotate-180"
                    style={{
                      position: 'absolute',
                      top: '25%',
                      left: '50%',
                      transform: `translate(-50%, -50%) rotate(${-angle}deg)`,
                      textShadow: '1px 1px 2px rgba(0, 0, 0, 0.5)'
                    }}
                  >
                    {item.label}
                  </span>
                </div>
              </div>
            );
          })}
        </motion.div>
      </div>
    );
  };

  // 渲染奖励展示
  const renderRewardDisplay = () => {
    if (!showReward || rewards.length === 0) return null;

    const currentReward = rewards[currentRewardIndex];

    return (
      <div className="lucky-draw-reward-display flex flex-col items-center justify-center p-4">
        <h3 className="text-xl font-bold mb-4">恭喜获得奖励！</h3>
        
        <div className="reward-animation-container mb-4">
          <RewardAnimation
            type={currentReward.type}
            rarity={currentReward.rarity}
            iconPath={currentReward.iconPath}
            amount={currentReward.amount}
            size={120}
            animationStyle={
              currentReward.rarity === RewardRarity.LEGENDARY ? 'burst' :
              currentReward.rarity === RewardRarity.EPIC ? 'spin' :
              currentReward.rarity === RewardRarity.RARE ? 'pulse' :
              currentReward.rarity === RewardRarity.UNCOMMON ? 'float' : 'default'
            }
            playSound={false}
          />
        </div>
        
        <div className="reward-details text-center mb-4">
          <h4 className="text-lg font-bold">{currentReward.name}</h4>
          <p className="text-sm text-gray-600">{currentReward.description}</p>
          {currentReward.amount > 1 && (
            <p className="text-sm">数量: {currentReward.amount}</p>
          )}
        </div>
        
        <div className="reward-navigation">
          {currentRewardIndex < rewards.length - 1 ? (
            <Button variant="jade" onClick={handleNextReward}>
              下一个奖励
            </Button>
          ) : (
            <Button variant="gold" onClick={handleContinue}>
              继续抽奖
            </Button>
          )}
        </div>
      </div>
    );
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="幸运抽奖"
      closeOnOutsideClick={!isDrawing && !showReward}
      closeOnEsc={!isDrawing && !showReward}
      showCloseButton={!isDrawing && !showReward}
    >
      <div className="lucky-draw-content p-4">
        <AnimatePresence mode="wait">
          {!showReward ? (
            <motion.div
              key="lucky-draw-main"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.3 }}
            >
              <div className="lucky-points-display text-center mb-4">
                <LuckyPointsDisplay variant="large" />
                <p className="text-lg font-bold mt-2">当前幸运点数: <span className="text-gold">{points}</span></p>
              </div>
              
              {renderWheel()}
              
              <div className="lucky-draw-options flex justify-center gap-4 mt-4">
                {drawOptions.map(option => (
                  <motion.div
                    key={option.points}
                    className={`draw-option p-2 border-2 rounded-lg cursor-pointer ${selectedPoints === option.points ? 'border-gold bg-amber-50' : 'border-gray-300'} ${points < option.points ? 'opacity-50 cursor-not-allowed' : ''}`}
                    onClick={() => points >= option.points && handleSelectOption(option.points)}
                    whileHover={{ scale: points >= option.points ? 1.05 : 1 }}
                    whileTap={{ scale: points >= option.points ? 0.95 : 1 }}
                  >
                    <div className="draw-option-header flex items-center justify-between">
                      <div className="draw-option-points flex items-center">
                        <span className="lucky-points-icon mr-1">🍀</span>
                        <span>{option.points}</span>
                      </div>
                      <h3 className="draw-option-label font-bold">{option.label}</h3>
                    </div>
                    <p className="draw-option-description text-xs text-gray-600 mt-1">{option.description}</p>
                  </motion.div>
                ))}
              </div>
              
              <div className="lucky-draw-controls text-center mt-4">
                {error && (
                  <p className="text-red-500 text-sm mb-2">{error}</p>
                )}
                
                <Button
                  variant="gold"
                  onClick={handleDraw}
                  disabled={isDrawing || points < selectedPoints}
                  className="px-8 py-2"
                >
                  {isDrawing ? '抽奖中...' : '抽 奖'}
                </Button>
              </div>
            </motion.div>
          ) : (
            <motion.div
              key="lucky-draw-reward"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.3 }}
            >
              {renderRewardDisplay()}
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </ScrollDialog>
  );
};

export default LuckyDrawWheel;
</file>

<file path="src/components/game/README.md">
# 游戏组件文档

本文档记录了PandaHabit应用中的游戏组件，包括它们的功能、属性和使用方法。

## 奖励和资源组件

### RewardModal

`RewardModal` 是一个用于展示任务完成后获得的奖励的模态框组件。它以卷轴风格展示奖励，并支持多个奖励的展示。

#### 属性

| 属性名 | 类型 | 描述 |
|--------|------|------|
| isOpen | boolean | 控制模态框是否显示 |
| onClose | () => void | 关闭模态框的回调函数 |
| rewards | RewardRecord[] | 要展示的奖励列表 |

#### 使用示例

```tsx
<RewardModal
  isOpen={showRewardModal}
  onClose={handleCloseRewardModal}
  rewards={rewards}
/>
```

### ResourceDisplay

`ResourceDisplay` 是一个用于显示各种类型资源（经验、金币、物品等）的组件。它支持不同的尺寸、动画效果和点击交互。

#### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| type | RewardType | 必填 | 资源类型 |
| amount | number | 必填 | 资源数量 |
| rarity | RewardRarity | COMMON | 资源稀有度 |
| iconPath | string | 根据类型自动选择 | 资源图标路径 |
| size | 'small' \| 'medium' \| 'large' | 'medium' | 组件尺寸 |
| showLabel | boolean | true | 是否显示资源类型标签 |
| showAnimation | boolean | false | 是否显示数量变化动画 |
| onClick | () => void | undefined | 点击回调函数 |
| className | string | '' | 自定义CSS类名 |

#### 使用示例

```tsx
<ResourceDisplay
  type={RewardType.COIN}
  amount={100}
  rarity={RewardRarity.RARE}
  size="large"
  showAnimation={true}
  onClick={() => console.log('Clicked on coins')}
/>
```

### ResourceList

`ResourceList` 是一个用于显示多种资源的列表组件。它可以水平或垂直排列多个ResourceDisplay组件。

#### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| resources | ResourceItem[] | 必填 | 资源列表 |
| size | 'small' \| 'medium' \| 'large' | 'medium' | 资源显示尺寸 |
| showLabels | boolean | true | 是否显示资源类型标签 |
| showAnimation | boolean | false | 是否显示数量变化动画 |
| onResourceClick | (resource: ResourceItem) => void | undefined | 资源点击回调函数 |
| orientation | 'horizontal' \| 'vertical' | 'horizontal' | 列表排列方向 |
| className | string | '' | 自定义CSS类名 |

#### 使用示例

```tsx
<ResourceList
  resources={[
    { id: 1, type: RewardType.EXPERIENCE, amount: 100 },
    { id: 2, type: RewardType.COIN, amount: 50 }
  ]}
  size="medium"
  showAnimation={true}
  onResourceClick={(resource) => console.log('Clicked on', resource)}
/>
```

### ResourceInventory

`ResourceInventory` 是一个用于显示玩家资源库存的组件。它自动从服务中获取最新的资源数据并显示。

#### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| showExperience | boolean | true | 是否显示经验值 |
| showCoins | boolean | true | 是否显示金币 |
| showItems | boolean | false | 是否显示物品 |
| showBadges | boolean | false | 是否显示徽章 |
| showAnimation | boolean | true | 是否显示数量变化动画 |
| size | 'small' \| 'medium' \| 'large' | 'medium' | 资源显示尺寸 |
| className | string | '' | 自定义CSS类名 |

#### 使用示例

```tsx
<ResourceInventory
  showExperience={true}
  showCoins={true}
  size="medium"
  showAnimation={true}
/>
```

## 抽奖和反思组件

### LuckyDraw

`LuckyDraw` 是一个用于实现幸运抽奖功能的组件。它允许用户使用幸运点进行抽奖，并显示抽奖结果。

#### 属性

| 属性名 | 类型 | 描述 |
|--------|------|------|
| onClose | () => void | 关闭抽奖组件的回调函数 |
| onRewardEarned | (rewards: RewardRecord[]) => void | 获得奖励后的回调函数 |

#### 使用示例

```tsx
<LuckyDraw
  onClose={handleCloseLuckyDraw}
  onRewardEarned={handleRewardEarned}
/>
```

### LuckyDrawWheel

`LuckyDrawWheel` 是一个带有旋转轮盘的幸运抽奖组件。它提供了更华丽的抽奖体验，包括轮盘旋转动画和奖励展示。

#### 属性

| 属性名 | 类型 | 描述 |
|--------|------|------|
| isOpen | boolean | 控制抽奖组件是否显示 |
| onClose | () => void | 关闭抽奖组件的回调函数 |
| onRewardEarned | (rewards: RewardRecord[]) => void | 获得奖励后的回调函数 |

#### 使用示例

```tsx
<LuckyDrawWheel
  isOpen={showLuckyDrawWheel}
  onClose={handleCloseLuckyDrawWheel}
  onRewardEarned={handleRewardEarned}
/>
```

### ReflectionModule

`ReflectionModule` 是一个用于帮助用户反思任务完成情况和情绪状态的组件。它提供了一个温和、非判断性的对话系统，帮助用户探索困难并提供支持。

#### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| isOpen | boolean | 必填 | 控制反思模块是否显示 |
| onClose | () => void | 必填 | 关闭反思模块的回调函数 |
| taskName | string | undefined | 相关任务名称 |
| taskId | number | undefined | 相关任务ID |
| mood | 'happy' \| 'neutral' \| 'sad' \| 'concerned' | undefined | 初始心情状态 |
| onReflectionComplete | (reflectionData) => void | undefined | 反思完成后的回调函数 |

#### 使用示例

```tsx
<ReflectionModule
  isOpen={showReflectionModule}
  onClose={handleCloseReflectionModule}
  taskName="每日冥想"
  taskId={123}
  mood="concerned"
  onReflectionComplete={handleReflectionComplete}
/>
```

## 注意事项

1. 所有组件都遵循华丽游戏风格设计，包括中国风元素、动画效果和音效。
2. 组件使用Framer Motion实现动画效果，确保流畅的用户体验。
3. 组件与数据服务集成，自动更新和同步数据。
4. 所有组件都支持自定义样式和行为，可以根据需要进行定制。
5. 组件使用TypeScript编写，提供类型安全和代码提示。
</file>

<file path="src/components/game/ReflectionModule.tsx">
// src/components/game/ReflectionModule.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Button from '@/components/common/Button';
import ScrollDialog from './ScrollDialog';
import { playSound, SoundType } from '@/utils/sound';
import { TaskRecord } from '@/services/taskService';
import { getPandaMood, updatePandaMood } from '@/services/pandaStateService';

interface ReflectionModuleProps {
  isOpen: boolean;
  onClose: () => void;
  taskName?: string;
  taskId?: number;
  mood?: 'happy' | 'neutral' | 'sad' | 'concerned';
  onReflectionComplete?: (reflectionData: {
    taskId?: number;
    mood?: string;
    reflection: string;
    action: string;
  }) => void;
}

/**
 * 反思模块组件
 * 用于帮助用户反思任务完成情况和情绪状态
 */
const ReflectionModule: React.FC<ReflectionModuleProps> = ({
  isOpen,
  onClose,
  taskName,
  taskId,
  mood: initialMood,
  onReflectionComplete
}) => {
  const [step, setStep] = useState(1);
  const [mood, setMood] = useState<string>(initialMood || 'neutral');
  const [reflection, setReflection] = useState('');
  const [action, setAction] = useState('');
  const [suggestedActions, setSuggestedActions] = useState<string[]>([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [pandaMessage, setPandaMessage] = useState('');

  // 根据任务名称和心情设置熊猫消息
  useEffect(() => {
    if (taskName) {
      if (mood === 'sad' || mood === 'concerned') {
        setPandaMessage(`我注意到你最近在"${taskName}"这个任务上遇到了一些困难。想聊聊吗？`);
      } else {
        setPandaMessage('今天感觉如何？想花点时间反思一下吗？');
      }
    } else if (mood === 'sad' || mood === 'concerned') {
      setPandaMessage('我注意到你最近心情不太好。想聊聊吗？');
    } else {
      setPandaMessage('今天感觉如何？想花点时间反思一下吗？');
    }
  }, [taskName, mood]);

  // 根据反思内容生成建议行动
  useEffect(() => {
    if (reflection && step === 2) {
      // 这里可以根据反思内容生成建议行动
      // 在实际应用中，可以使用更复杂的算法或API来生成建议
      const lowerReflection = reflection.toLowerCase();
      
      if (lowerReflection.includes('压力') || lowerReflection.includes('焦虑') || lowerReflection.includes('紧张')) {
        setSuggestedActions([
          '尝试5分钟的深呼吸冥想',
          '出去散步15分钟',
          '与朋友聊天分享感受',
          '写下三件让你感到感激的事情'
        ]);
      } else if (lowerReflection.includes('疲惫') || lowerReflection.includes('累') || lowerReflection.includes('没精力')) {
        setSuggestedActions([
          '确保今晚早点休息',
          '尝试20分钟的午休',
          '减少今天的任务量',
          '喝足够的水，吃些健康的食物'
        ]);
      } else if (lowerReflection.includes('拖延') || lowerReflection.includes('专注') || lowerReflection.includes('分心')) {
        setSuggestedActions([
          '使用番茄工作法，专注25分钟',
          '将大任务分解成小步骤',
          '创建一个无干扰的工作环境',
          '设置一个小的、可实现的目标'
        ]);
      } else {
        setSuggestedActions([
          '花5分钟进行深呼吸冥想',
          '写下三件让你感到感激的事情',
          '设定一个小的、可实现的目标',
          '与朋友或家人分享你的感受'
        ]);
      }
    }
  }, [reflection, step]);

  // 处理提交反思
  const handleSubmit = async () => {
    try {
      setIsSubmitting(true);
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 如果心情不好，尝试更新为中性
      if (mood === 'sad' || mood === 'concerned') {
        await updatePandaMood('neutral');
      }
      
      // 通知父组件
      if (onReflectionComplete) {
        onReflectionComplete({
          taskId,
          mood,
          reflection,
          action
        });
      }
      
      // 重置状态
      setStep(1);
      setReflection('');
      setAction('');
      
      // 关闭对话框
      onClose();
    } catch (error) {
      console.error('Failed to submit reflection:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  // 处理选择建议行动
  const handleSelectAction = (selectedAction: string) => {
    setAction(selectedAction);
  };

  // 渲染步骤1：反思输入
  const renderStep1 = () => (
    <div className="reflection-step">
      <div className="panda-message mb-4 p-3 bg-amber-50 rounded-lg border border-amber-200">
        <div className="flex items-start">
          <div className="panda-avatar mr-2">
            <span className="text-2xl">🐼</span>
          </div>
          <div className="panda-text">
            <p>{pandaMessage}</p>
          </div>
        </div>
      </div>
      
      <div className="reflection-input mb-4">
        <label htmlFor="reflection" className="block text-sm font-medium text-gray-700 mb-1">
          分享你的想法（可以是任何感受、困难或成就）
        </label>
        <textarea
          id="reflection"
          className="w-full h-32 p-2 border border-gray-300 rounded-md focus:ring-jade focus:border-jade"
          value={reflection}
          onChange={(e) => setReflection(e.target.value)}
          placeholder="今天我感觉..."
        />
      </div>
      
      <div className="reflection-actions flex justify-end">
        <Button variant="jade" onClick={() => setStep(2)} disabled={!reflection.trim()}>
          继续
        </Button>
      </div>
    </div>
  );

  // 渲染步骤2：行动选择
  const renderStep2 = () => (
    <div className="reflection-step">
      <div className="panda-message mb-4 p-3 bg-amber-50 rounded-lg border border-amber-200">
        <div className="flex items-start">
          <div className="panda-avatar mr-2">
            <span className="text-2xl">🐼</span>
          </div>
          <div className="panda-text">
            <p>谢谢你的分享。以下是一些可能对你有帮助的小行动，你可以选择一个尝试，或者创建自己的行动。</p>
          </div>
        </div>
      </div>
      
      <div className="suggested-actions mb-4">
        <h3 className="text-sm font-medium text-gray-700 mb-2">建议的行动</h3>
        <div className="grid grid-cols-1 gap-2">
          {suggestedActions.map((suggestedAction, index) => (
            <motion.div
              key={index}
              className={`p-2 border rounded-md cursor-pointer ${action === suggestedAction ? 'border-jade bg-jade-50' : 'border-gray-300'}`}
              onClick={() => handleSelectAction(suggestedAction)}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
            >
              {suggestedAction}
            </motion.div>
          ))}
        </div>
      </div>
      
      <div className="custom-action mb-4">
        <label htmlFor="custom-action" className="block text-sm font-medium text-gray-700 mb-1">
          或者，创建你自己的行动
        </label>
        <input
          id="custom-action"
          type="text"
          className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade focus:border-jade"
          value={action}
          onChange={(e) => setAction(e.target.value)}
          placeholder="我将..."
        />
      </div>
      
      <div className="reflection-actions flex justify-between">
        <Button variant="secondary" onClick={() => setStep(1)}>
          返回
        </Button>
        <Button variant="gold" onClick={handleSubmit} disabled={!action.trim() || isSubmitting}>
          {isSubmitting ? '提交中...' : '完成反思'}
        </Button>
      </div>
    </div>
  );

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="静心茶室"
      closeOnOutsideClick={false}
      closeOnEsc={true}
      showCloseButton={true}
    >
      <div className="reflection-module p-4">
        <AnimatePresence mode="wait">
          <motion.div
            key={`step-${step}`}
            initial={{ opacity: 0, x: step === 1 ? -20 : 20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: step === 1 ? 20 : -20 }}
            transition={{ duration: 0.3 }}
          >
            {step === 1 ? renderStep1() : renderStep2()}
          </motion.div>
        </AnimatePresence>
      </div>
    </ScrollDialog>
  );
};

export default ReflectionModule;
</file>

<file path="src/components/game/ResourceDisplay.tsx">
// src/components/game/ResourceDisplay.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { RewardType, RewardRarity } from '@/services/rewardService';
import { playSound, SoundType } from '@/utils/sound';

interface ResourceDisplayProps {
  type: RewardType;
  amount: number;
  rarity?: RewardRarity;
  iconPath?: string;
  size?: 'small' | 'medium' | 'large';
  showLabel?: boolean;
  showAnimation?: boolean;
  onClick?: () => void;
  className?: string;
}

/**
 * 资源显示组件
 * 用于显示各种类型的资源（经验、金币、物品等）
 */
const ResourceDisplay: React.FC<ResourceDisplayProps> = ({
  type,
  amount,
  rarity = RewardRarity.COMMON,
  iconPath,
  size = 'medium',
  showLabel = true,
  showAnimation = false,
  onClick,
  className = ''
}) => {
  const [isAnimating, setIsAnimating] = useState(false);
  const [displayAmount, setDisplayAmount] = useState(amount);
  const [prevAmount, setPrevAmount] = useState(amount);

  // 当金额变化时触发动画
  useEffect(() => {
    if (amount !== prevAmount && showAnimation) {
      // 播放音效
      if (amount > prevAmount) {
        // 增加资源时播放获得音效
        playSound(SoundType.SUCCESS, 0.3);
      } else if (amount < prevAmount) {
        // 减少资源时播放消耗音效
        playSound(SoundType.BUTTON_CLICK, 0.3);
      }

      // 触发动画
      setIsAnimating(true);
      
      // 更新显示金额
      const diff = amount - prevAmount;
      const duration = 1000; // 动画持续时间（毫秒）
      const steps = 20; // 动画步数
      const stepTime = duration / steps;
      const stepAmount = diff / steps;
      
      let currentStep = 0;
      const interval = setInterval(() => {
        currentStep++;
        setDisplayAmount(prevAmount + stepAmount * currentStep);
        
        if (currentStep >= steps) {
          clearInterval(interval);
          setDisplayAmount(amount);
          setIsAnimating(false);
        }
      }, stepTime);
      
      // 更新前一个金额
      setPrevAmount(amount);
      
      // 清理函数
      return () => {
        clearInterval(interval);
      };
    } else if (amount !== prevAmount) {
      // 如果不显示动画，直接更新金额
      setDisplayAmount(amount);
      setPrevAmount(amount);
    }
  }, [amount, prevAmount, showAnimation]);

  // 获取资源类型的中文名称
  const getTypeName = (): string => {
    switch (type) {
      case RewardType.EXPERIENCE:
        return '经验';
      case RewardType.COIN:
        return '竹币';
      case RewardType.ITEM:
        return '物品';
      case RewardType.BADGE:
        return '徽章';
      default:
        return '资源';
    }
  };

  // 获取默认图标路径
  const getDefaultIconPath = (): string => {
    switch (type) {
      case RewardType.EXPERIENCE:
        return '/assets/rewards/experience.svg';
      case RewardType.COIN:
        return '/assets/rewards/coin.svg';
      case RewardType.ITEM:
        return `/assets/rewards/item_${rarity.toLowerCase()}.svg`;
      case RewardType.BADGE:
        return `/assets/rewards/badge_${rarity.toLowerCase()}.svg`;
      default:
        return '/assets/rewards/item_common.svg';
    }
  };

  // 获取尺寸样式
  const getSizeStyle = (): { containerSize: string, iconSize: string, fontSize: string } => {
    switch (size) {
      case 'small':
        return {
          containerSize: 'w-16 h-8',
          iconSize: 'w-6 h-6',
          fontSize: 'text-xs'
        };
      case 'large':
        return {
          containerSize: 'w-32 h-16',
          iconSize: 'w-12 h-12',
          fontSize: 'text-lg'
        };
      default: // medium
        return {
          containerSize: 'w-24 h-12',
          iconSize: 'w-8 h-8',
          fontSize: 'text-sm'
        };
    }
  };

  // 获取稀有度样式
  const getRarityStyle = (): { borderColor: string, glowColor: string, textColor: string } => {
    switch (rarity) {
      case RewardRarity.LEGENDARY:
        return {
          borderColor: 'border-gold',
          glowColor: 'shadow-gold',
          textColor: 'text-gold'
        };
      case RewardRarity.EPIC:
        return {
          borderColor: 'border-purple-500',
          glowColor: 'shadow-purple',
          textColor: 'text-purple-500'
        };
      case RewardRarity.RARE:
        return {
          borderColor: 'border-blue-500',
          glowColor: 'shadow-blue',
          textColor: 'text-blue-500'
        };
      case RewardRarity.UNCOMMON:
        return {
          borderColor: 'border-green-500',
          glowColor: 'shadow-green',
          textColor: 'text-green-500'
        };
      default:
        return {
          borderColor: 'border-gray-300',
          glowColor: 'shadow-sm',
          textColor: 'text-gray-700'
        };
    }
  };

  const { containerSize, iconSize, fontSize } = getSizeStyle();
  const { borderColor, glowColor, textColor } = getRarityStyle();

  return (
    <motion.div
      className={`resource-display flex items-center ${containerSize} ${borderColor} border rounded-full bg-white ${glowColor} ${className}`}
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
      onClick={onClick}
      style={{ cursor: onClick ? 'pointer' : 'default' }}
    >
      {/* 资源图标 */}
      <div className={`resource-icon ${iconSize} flex-shrink-0 ml-1`}>
        <img
          src={iconPath || getDefaultIconPath()}
          alt={getTypeName()}
          className="w-full h-full object-contain"
          onError={(e) => {
            const target = e.target as HTMLImageElement;
            target.onerror = null;
            target.src = getDefaultIconPath();
          }}
        />
      </div>

      {/* 资源数量 */}
      <div className="resource-amount flex flex-col justify-center ml-1 flex-grow">
        <AnimatePresence mode="wait">
          <motion.div
            key={`amount-${displayAmount}`}
            initial={isAnimating ? { y: -10, opacity: 0 } : { y: 0, opacity: 1 }}
            animate={{ y: 0, opacity: 1 }}
            exit={{ y: 10, opacity: 0 }}
            transition={{ duration: 0.2 }}
            className={`${fontSize} font-bold ${textColor} text-center`}
          >
            {Math.round(displayAmount)}
          </motion.div>
        </AnimatePresence>
        
        {/* 资源类型标签 */}
        {showLabel && (
          <div className={`resource-label text-xs text-gray-500 text-center`}>
            {getTypeName()}
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default ResourceDisplay;
</file>

<file path="src/components/game/ResourceInventory.tsx">
// src/components/game/ResourceInventory.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ResourceList from './ResourceList';
import ResourceDisplay from './ResourceDisplay';
import { RewardType, RewardRarity, getPlayerCoins } from '@/services/rewardService';
import { getPandaExperience } from '@/services/pandaStateService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import LoadingSpinner from '@/components/common/LoadingSpinner';

interface ResourceInventoryProps {
  showExperience?: boolean;
  showCoins?: boolean;
  showItems?: boolean;
  showBadges?: boolean;
  showAnimation?: boolean;
  size?: 'small' | 'medium' | 'large';
  className?: string;
}

/**
 * 资源库存组件
 * 用于显示玩家的资源库存
 */
const ResourceInventory: React.FC<ResourceInventoryProps> = ({
  showExperience = true,
  showCoins = true,
  showItems = false,
  showBadges = false,
  showAnimation = true,
  size = 'medium',
  className = ''
}) => {
  const [experience, setExperience] = useState<number>(0);
  const [coins, setCoins] = useState<number>(0);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // 加载资源数据
  const loadResourceData = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // 获取经验值
      if (showExperience) {
        const exp = await getPandaExperience();
        setExperience(exp);
      }

      // 获取金币
      if (showCoins) {
        const playerCoins = await getPlayerCoins();
        setCoins(playerCoins);
      }

      // 获取物品和徽章的逻辑可以在这里添加

    } catch (err) {
      console.error('Failed to load resource data:', err);
      setError('加载资源数据失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadResourceData();
  }, [showExperience, showCoins, showItems, showBadges]);

  // 注册数据刷新监听
  const handleResourceDataUpdate = () => {
    loadResourceData();
  };

  // 监听奖励表的变化
  useRegisterTableRefresh('rewards', handleResourceDataUpdate);

  // 监听熊猫状态表的变化
  useRegisterTableRefresh('pandaState', handleResourceDataUpdate);

  // 创建资源列表
  const resources = [];

  if (showExperience) {
    resources.push({
      id: 1,
      type: RewardType.EXPERIENCE,
      amount: experience,
      rarity: RewardRarity.COMMON,
      iconPath: '/assets/rewards/experience.svg',
      name: '经验值'
    });
  }

  if (showCoins) {
    resources.push({
      id: 2,
      type: RewardType.COIN,
      amount: coins,
      rarity: RewardRarity.COMMON,
      iconPath: '/assets/rewards/coin.svg',
      name: '竹币'
    });
  }

  // 容器变体
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        duration: 0.3
      }
    },
    exit: {
      opacity: 0,
      transition: {
        duration: 0.2
      }
    }
  };

  if (isLoading) {
    return (
      <div className={`resource-inventory-loading flex justify-center items-center p-4 ${className}`}>
        <LoadingSpinner variant="jade" size="small" />
      </div>
    );
  }

  if (error) {
    return (
      <div className={`resource-inventory-error text-red-500 text-center p-4 ${className}`}>
        {error}
      </div>
    );
  }

  return (
    <AnimatePresence mode="wait">
      <motion.div
        key="resource-inventory"
        className={`resource-inventory ${className}`}
        variants={containerVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <ResourceList
          resources={resources}
          size={size}
          showLabels={true}
          showAnimation={showAnimation}
          orientation="horizontal"
        />
      </motion.div>
    </AnimatePresence>
  );
};

export default ResourceInventory;
</file>

<file path="src/components/game/ResourceList.tsx">
// src/components/game/ResourceList.tsx
import React from 'react';
import { motion } from 'framer-motion';
import ResourceDisplay from './ResourceDisplay';
import { RewardType, RewardRarity } from '@/services/rewardService';

interface ResourceItem {
  id?: number;
  type: RewardType;
  amount: number;
  rarity?: RewardRarity;
  iconPath?: string;
  name?: string;
}

interface ResourceListProps {
  resources: ResourceItem[];
  size?: 'small' | 'medium' | 'large';
  showLabels?: boolean;
  showAnimation?: boolean;
  onResourceClick?: (resource: ResourceItem) => void;
  orientation?: 'horizontal' | 'vertical';
  className?: string;
}

/**
 * 资源列表组件
 * 用于显示多种资源
 */
const ResourceList: React.FC<ResourceListProps> = ({
  resources,
  size = 'medium',
  showLabels = true,
  showAnimation = false,
  onResourceClick,
  orientation = 'horizontal',
  className = ''
}) => {
  // 容器变体
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // 项目变体
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  // 处理资源点击
  const handleResourceClick = (resource: ResourceItem) => {
    if (onResourceClick) {
      onResourceClick(resource);
    }
  };

  return (
    <motion.div
      className={`resource-list ${orientation === 'horizontal' ? 'flex flex-row flex-wrap gap-2' : 'flex flex-col gap-2'} ${className}`}
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      {resources.map((resource, index) => (
        <motion.div
          key={`resource-${resource.id || index}`}
          variants={itemVariants}
          className="resource-list-item"
        >
          <ResourceDisplay
            type={resource.type}
            amount={resource.amount}
            rarity={resource.rarity}
            iconPath={resource.iconPath}
            size={size}
            showLabel={showLabels}
            showAnimation={showAnimation}
            onClick={() => handleResourceClick(resource)}
          />
        </motion.div>
      ))}
    </motion.div>
  );
};

export default ResourceList;
</file>

<file path="src/components/tasks/SubtaskList.tsx">
// src/components/tasks/SubtaskList.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { SubtaskRecord } from '@/services/subtaskService';
import { TaskStatus } from '@/services/taskService';
import { getSubtasks, updateSubtask, completeSubtask, deleteSubtask, createSubtask } from '@/services/subtaskService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';
import { updateSubtaskOrder } from '@/services/subtaskService';
import { playSound, SoundType } from '@/utils/sound';

interface SubtaskListProps {
  parentTaskId: number;
  onSubtasksChange?: (hasSubtasks: boolean) => void;
}

/**
 * 子任务列表组件
 * 用于显示和管理任务的子任务
 */
const SubtaskList: React.FC<SubtaskListProps> = ({ parentTaskId, onSubtasksChange }) => {
  const [subtasks, setSubtasks] = useState<SubtaskRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [newSubtaskTitle, setNewSubtaskTitle] = useState('');
  const [isAddingSubtask, setIsAddingSubtask] = useState(false);

  // 加载子任务
  const loadSubtasks = async () => {
    try {
      setIsLoading(true);
      setError(null);
      const loadedSubtasks = await getSubtasks(parentTaskId);
      setSubtasks(loadedSubtasks);
      
      // 通知父组件子任务状态变化
      if (onSubtasksChange) {
        onSubtasksChange(loadedSubtasks.length > 0);
      }
    } catch (err) {
      console.error('Failed to load subtasks:', err);
      setError('加载子任务失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadSubtasks();
  }, [parentTaskId]);

  // 注册数据刷新监听
  useRegisterTableRefresh('subtasks', loadSubtasks);

  // 处理添加子任务
  const handleAddSubtask = async () => {
    if (!newSubtaskTitle.trim()) return;

    try {
      setIsAddingSubtask(true);
      await createSubtask({
        parentTaskId,
        title: newSubtaskTitle.trim()
      });
      setNewSubtaskTitle('');
      playSound(SoundType.BUTTON_CLICK, 0.3);
      await loadSubtasks();
    } catch (err) {
      console.error('Failed to add subtask:', err);
      setError('添加子任务失败，请重试');
    } finally {
      setIsAddingSubtask(false);
    }
  };

  // 处理完成子任务
  const handleCompleteSubtask = async (subtaskId: number) => {
    try {
      await completeSubtask(subtaskId);
      playSound(SoundType.SUCCESS, 0.3);
      // 数据会通过刷新机制自动更新
    } catch (err) {
      console.error('Failed to complete subtask:', err);
      setError('完成子任务失败，请重试');
    }
  };

  // 处理删除子任务
  const handleDeleteSubtask = async (subtaskId: number) => {
    try {
      await deleteSubtask(subtaskId);
      playSound(SoundType.BUTTON_CLICK, 0.3);
      // 数据会通过刷新机制自动更新
    } catch (err) {
      console.error('Failed to delete subtask:', err);
      setError('删除子任务失败，请重试');
    }
  };

  // 处理拖放结束
  const handleDragEnd = async (result: any) => {
    if (!result.destination) return;

    const sourceIndex = result.source.index;
    const destinationIndex = result.destination.index;

    if (sourceIndex === destinationIndex) return;

    try {
      // 获取被拖动的子任务
      const draggedSubtask = subtasks[sourceIndex];
      
      // 更新子任务顺序
      await updateSubtaskOrder(draggedSubtask.id!, destinationIndex);
      
      // 重新加载子任务以获取最新顺序
      await loadSubtasks();
    } catch (err) {
      console.error('Failed to reorder subtasks:', err);
      setError('重新排序子任务失败，请重试');
    }
  };

  // 子任务项变体
  const subtaskVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 },
    exit: { opacity: 0, x: -20 }
  };

  if (isLoading && subtasks.length === 0) {
    return (
      <div className="subtask-list-loading flex justify-center items-center p-4">
        <LoadingSpinner variant="jade" size="small" />
      </div>
    );
  }

  return (
    <div className="subtask-list mt-4">
      <h3 className="text-lg font-bold mb-2">子任务</h3>
      
      {error && (
        <div className="error-message text-red-500 mb-2">{error}</div>
      )}
      
      <DragDropContext onDragEnd={handleDragEnd}>
        <Droppable droppableId="subtasks-list">
          {(provided) => (
            <div
              className="subtasks-container"
              {...provided.droppableProps}
              ref={provided.innerRef}
            >
              <AnimatePresence>
                {subtasks.map((subtask, index) => (
                  <Draggable
                    key={subtask.id}
                    draggableId={`subtask-${subtask.id}`}
                    index={index}
                    isDragDisabled={subtask.status === TaskStatus.COMPLETED}
                  >
                    {(provided, snapshot) => (
                      <motion.div
                        ref={provided.innerRef}
                        {...provided.draggableProps}
                        {...provided.dragHandleProps}
                        className={`subtask-item flex items-center p-2 mb-2 rounded-md border ${
                          subtask.status === TaskStatus.COMPLETED
                            ? 'border-gray-300 bg-gray-50'
                            : 'border-jade-300 bg-white'
                        } ${snapshot.isDragging ? 'shadow-md' : ''}`}
                        variants={subtaskVariants}
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        transition={{ duration: 0.2 }}
                      >
                        <div className="subtask-checkbox mr-2">
                          <input
                            type="checkbox"
                            checked={subtask.status === TaskStatus.COMPLETED}
                            onChange={() => {
                              if (subtask.status !== TaskStatus.COMPLETED) {
                                handleCompleteSubtask(subtask.id!);
                              }
                            }}
                            className="form-checkbox h-5 w-5 text-jade-500 rounded"
                          />
                        </div>
                        <div className="subtask-content flex-grow">
                          <p className={`subtask-title ${
                            subtask.status === TaskStatus.COMPLETED ? 'line-through text-gray-500' : 'text-gray-800'
                          }`}>
                            {subtask.title}
                          </p>
                        </div>
                        <div className="subtask-actions">
                          <button
                            onClick={() => handleDeleteSubtask(subtask.id!)}
                            className="text-red-500 hover:text-red-700"
                            aria-label="删除子任务"
                          >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                              <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" />
                            </svg>
                          </button>
                        </div>
                      </motion.div>
                    )}
                  </Draggable>
                ))}
                {provided.placeholder}
              </AnimatePresence>
            </div>
          )}
        </Droppable>
      </DragDropContext>
      
      <div className="add-subtask-form mt-4">
        <div className="flex">
          <input
            type="text"
            value={newSubtaskTitle}
            onChange={(e) => setNewSubtaskTitle(e.target.value)}
            placeholder="添加新子任务..."
            className="flex-grow p-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-2 focus:ring-jade-500"
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                handleAddSubtask();
              }
            }}
          />
          <Button
            variant="jade"
            onClick={handleAddSubtask}
            disabled={!newSubtaskTitle.trim() || isAddingSubtask}
            className="rounded-l-none"
          >
            {isAddingSubtask ? (
              <LoadingSpinner variant="white" size="small" />
            ) : (
              '添加'
            )}
          </Button>
        </div>
      </div>
    </div>
  );
};

export default SubtaskList;
</file>

<file path="src/services/subtaskService.ts">
// src/services/subtaskService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { TaskRecord, TaskStatus, updateTask } from './taskService';

// 子任务记录类型
export interface SubtaskRecord {
  id?: number;
  parentTaskId: number;
  title: string;
  description?: string;
  status: TaskStatus;
  order: number;
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
}

/**
 * 创建子任务
 * @param subtask 子任务数据
 */
export async function createSubtask(
  subtask: Omit<SubtaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status' | 'order'>
): Promise<SubtaskRecord> {
  // 获取父任务
  const parentTask = await db.table('tasks').get(subtask.parentTaskId);
  if (!parentTask) {
    throw new Error(`Parent task with id ${subtask.parentTaskId} not found`);
  }

  // 获取当前子任务数量，用于设置顺序
  const existingSubtasks = await getSubtasks(subtask.parentTaskId);
  const order = existingSubtasks.length;

  const now = new Date();
  const newSubtask: SubtaskRecord = {
    ...subtask,
    status: TaskStatus.TODO,
    order,
    createdAt: now,
    updatedAt: now
  };

  // 添加子任务到数据库
  const id = await db.table('subtasks').add(newSubtask);
  const createdSubtask = { ...newSubtask, id: id as number };

  // 添加到同步队列
  await addSyncItem('subtasks', 'create', createdSubtask);

  return createdSubtask;
}

/**
 * 获取任务的所有子任务
 * @param parentTaskId 父任务ID
 */
export async function getSubtasks(parentTaskId: number): Promise<SubtaskRecord[]> {
  return db.table('subtasks')
    .where('parentTaskId')
    .equals(parentTaskId)
    .sortBy('order');
}

/**
 * 更新子任务
 * @param id 子任务ID
 * @param updates 更新数据
 */
export async function updateSubtask(
  id: number,
  updates: Partial<Omit<SubtaskRecord, 'id' | 'parentTaskId' | 'createdAt'>>
): Promise<SubtaskRecord> {
  const subtask = await db.table('subtasks').get(id);
  if (!subtask) {
    throw new Error(`Subtask with id ${id} not found`);
  }

  const updatedSubtask = {
    ...subtask,
    ...updates,
    updatedAt: new Date()
  };

  // 更新数据库
  await db.table('subtasks').update(id, updatedSubtask);

  // 添加到同步队列
  await addSyncItem('subtasks', 'update', updatedSubtask);

  // 如果状态变为已完成，更新完成时间
  if (updates.status === TaskStatus.COMPLETED && !updatedSubtask.completedAt) {
    updatedSubtask.completedAt = new Date();
    await db.table('subtasks').update(id, { completedAt: updatedSubtask.completedAt });
  }

  // 更新父任务进度
  await updateParentTaskProgress(subtask.parentTaskId);

  return updatedSubtask;
}

/**
 * 完成子任务
 * @param id 子任务ID
 */
export async function completeSubtask(id: number): Promise<SubtaskRecord> {
  return updateSubtask(id, {
    status: TaskStatus.COMPLETED,
    completedAt: new Date()
  });
}

/**
 * 删除子任务
 * @param id 子任务ID
 */
export async function deleteSubtask(id: number): Promise<void> {
  const subtask = await db.table('subtasks').get(id);
  if (!subtask) {
    throw new Error(`Subtask with id ${id} not found`);
  }

  // 删除子任务
  await db.table('subtasks').delete(id);

  // 添加到同步队列
  await addSyncItem('subtasks', 'delete', { id });

  // 更新父任务进度
  await updateParentTaskProgress(subtask.parentTaskId);

  // 重新排序剩余子任务
  const remainingSubtasks = await getSubtasks(subtask.parentTaskId);
  for (let i = 0; i < remainingSubtasks.length; i++) {
    if (remainingSubtasks[i].order !== i) {
      await updateSubtask(remainingSubtasks[i].id!, { order: i });
    }
  }
}

/**
 * 更新子任务顺序
 * @param id 子任务ID
 * @param newOrder 新顺序
 */
export async function updateSubtaskOrder(id: number, newOrder: number): Promise<void> {
  const subtask = await db.table('subtasks').get(id);
  if (!subtask) {
    throw new Error(`Subtask with id ${id} not found`);
  }

  const oldOrder = subtask.order;
  if (oldOrder === newOrder) {
    return; // 顺序没有变化
  }

  // 获取所有同级子任务
  const siblingSubtasks = await getSubtasks(subtask.parentTaskId);

  // 更新受影响的子任务顺序
  for (const sibling of siblingSubtasks) {
    if (sibling.id === id) {
      // 更新当前子任务的顺序
      await updateSubtask(id, { order: newOrder });
    } else if (
      (oldOrder < newOrder && sibling.order > oldOrder && sibling.order <= newOrder) ||
      (oldOrder > newOrder && sibling.order >= newOrder && sibling.order < oldOrder)
    ) {
      // 更新受影响的其他子任务顺序
      const newSiblingOrder = oldOrder < newOrder
        ? sibling.order - 1 // 向上移动时，中间的子任务顺序减1
        : sibling.order + 1; // 向下移动时，中间的子任务顺序加1
      await updateSubtask(sibling.id!, { order: newSiblingOrder });
    }
  }
}

/**
 * 更新父任务进度
 * @param parentTaskId 父任务ID
 */
export async function updateParentTaskProgress(parentTaskId: number): Promise<void> {
  const subtasks = await getSubtasks(parentTaskId);
  if (subtasks.length === 0) {
    return;
  }

  // 计算完成的子任务数量
  const completedCount = subtasks.filter(
    subtask => subtask.status === TaskStatus.COMPLETED
  ).length;

  // 计算进度百分比
  const progressPercentage = Math.round((completedCount / subtasks.length) * 100);

  // 如果所有子任务都完成，将父任务标记为已完成
  if (completedCount === subtasks.length) {
    await updateTask(parentTaskId, {
      status: TaskStatus.COMPLETED,
      completedAt: new Date()
    });
  } else if (completedCount > 0) {
    // 如果有部分子任务完成，将父任务标记为进行中
    await updateTask(parentTaskId, {
      status: TaskStatus.IN_PROGRESS
    });
  }
}

/**
 * 将任务转换为带有子任务的任务
 * @param taskId 任务ID
 * @param subtaskTitles 子任务标题列表
 */
export async function convertTaskToParentTask(
  taskId: number,
  subtaskTitles: string[]
): Promise<SubtaskRecord[]> {
  const task = await db.table('tasks').get(taskId);
  if (!task) {
    throw new Error(`Task with id ${taskId} not found`);
  }

  const createdSubtasks: SubtaskRecord[] = [];

  // 创建子任务
  for (let i = 0; i < subtaskTitles.length; i++) {
    const subtask = await createSubtask({
      parentTaskId: taskId,
      title: subtaskTitles[i]
    });
    createdSubtasks.push(subtask);
  }

  // 将父任务状态更新为进行中
  await updateTask(taskId, {
    status: TaskStatus.IN_PROGRESS
  });

  return createdSubtasks;
}

/**
 * 检查任务是否有子任务
 * @param taskId 任务ID
 */
export async function hasSubtasks(taskId: number): Promise<boolean> {
  const count = await db.table('subtasks')
    .where('parentTaskId')
    .equals(taskId)
    .count();
  return count > 0;
}
</file>

<file path="src/utils/sound.ts">
// src/utils/sound.ts
/**
 * 声音工具类
 * 用于播放游戏中的各种音效
 */

// 音效类型枚举
export enum SoundType {
  // 奖励音效
  REWARD_COMMON = 'reward_common',
  REWARD_UNCOMMON = 'reward_uncommon',
  REWARD_RARE = 'reward_rare',
  REWARD_EPIC = 'reward_epic',
  REWARD_LEGENDARY = 'reward_legendary',

  // 任务相关音效
  TASK_COMPLETE = 'task_complete',
  TASK_COMPLETE_HIGH = 'task_complete_high',
  TASK_COMPLETE_MAIN = 'task_complete_main',
  TASK_FAILED = 'task_failed',
  TASK_CREATED = 'task_created',

  // 挑战相关音效
  CHALLENGE_COMPLETE = 'challenge_complete',
  CHALLENGE_COMPLETE_EPIC = 'challenge_complete_epic',
  CHALLENGE_COMPLETE_LEGENDARY = 'challenge_complete_legendary',
  CHALLENGE_FAILED = 'challenge_failed',
  CHALLENGE_UNLOCKED = 'challenge_unlocked',

  // 系统音效
  LEVEL_UP = 'level_up',
  ABILITY_UNLOCKED = 'ability_unlocked',
  ABILITY_ACTIVATED = 'ability_activated',
  BUTTON_CLICK = 'button_click',
  ERROR = 'error',
  SUCCESS = 'success',
  NOTIFICATION = 'notification'
}

// 音效文件路径映射
const soundPaths: Record<SoundType, string> = {
  // 奖励音效
  [SoundType.REWARD_COMMON]: '/assets/sounds/reward_common.mp3',
  [SoundType.REWARD_UNCOMMON]: '/assets/sounds/reward_uncommon.mp3',
  [SoundType.REWARD_RARE]: '/assets/sounds/reward_rare.mp3',
  [SoundType.REWARD_EPIC]: '/assets/sounds/reward_epic.mp3',
  [SoundType.REWARD_LEGENDARY]: '/assets/sounds/reward_legendary.mp3',

  // 任务相关音效
  [SoundType.TASK_COMPLETE]: '/assets/sounds/task_complete.mp3',
  [SoundType.TASK_COMPLETE_HIGH]: '/assets/sounds/task_complete_high.mp3',
  [SoundType.TASK_COMPLETE_MAIN]: '/assets/sounds/task_complete_main.mp3',
  [SoundType.TASK_FAILED]: '/assets/sounds/task_failed.mp3',
  [SoundType.TASK_CREATED]: '/assets/sounds/task_created.mp3',

  // 挑战相关音效
  [SoundType.CHALLENGE_COMPLETE]: '/assets/sounds/challenge_complete.mp3',
  [SoundType.CHALLENGE_COMPLETE_EPIC]: '/assets/sounds/challenge_complete_epic.mp3',
  [SoundType.CHALLENGE_COMPLETE_LEGENDARY]: '/assets/sounds/challenge_complete_legendary.mp3',
  [SoundType.CHALLENGE_FAILED]: '/assets/sounds/challenge_failed.mp3',
  [SoundType.CHALLENGE_UNLOCKED]: '/assets/sounds/challenge_unlocked.mp3',

  // 系统音效
  [SoundType.LEVEL_UP]: '/assets/sounds/level_up.mp3',
  [SoundType.ABILITY_UNLOCKED]: '/assets/sounds/ability_unlocked.mp3',
  [SoundType.ABILITY_ACTIVATED]: '/assets/sounds/ability_activated.mp3',
  [SoundType.BUTTON_CLICK]: '/assets/sounds/button_click.mp3',
  [SoundType.ERROR]: '/assets/sounds/error.mp3',
  [SoundType.SUCCESS]: '/assets/sounds/success.mp3',
  [SoundType.NOTIFICATION]: '/assets/sounds/notification.mp3'
};

// 音频对象缓存
const audioCache: Record<string, HTMLAudioElement> = {};

/**
 * 播放音效
 * @param type 音效类型
 * @param volume 音量（0-1）
 * @returns 是否成功播放
 */
export function playSound(type: SoundType, volume: number = 0.5): boolean {
  try {
    const soundPath = soundPaths[type];

    // 检查音频是否已缓存
    if (!audioCache[soundPath]) {
      audioCache[soundPath] = new Audio(soundPath);
    }

    const audio = audioCache[soundPath];

    // 设置音量
    audio.volume = Math.max(0, Math.min(1, volume));

    // 重置播放位置
    audio.currentTime = 0;

    // 播放音效
    audio.play().catch(error => {
      console.warn(`Failed to play sound: ${error.message}`);
      return false;
    });

    return true;
  } catch (error) {
    console.error('Error playing sound:', error);
    return false;
  }
}

/**
 * 根据奖励稀有度播放对应音效
 * @param rarity 奖励稀有度
 * @param volume 音量（0-1）
 * @returns 是否成功播放
 */
export function playRewardSound(rarity: string, volume: number = 0.5): boolean {
  switch (rarity) {
    case 'common':
      return playSound(SoundType.REWARD_COMMON, volume);
    case 'uncommon':
      return playSound(SoundType.REWARD_UNCOMMON, volume);
    case 'rare':
      return playSound(SoundType.REWARD_RARE, volume);
    case 'epic':
      return playSound(SoundType.REWARD_EPIC, volume);
    case 'legendary':
      return playSound(SoundType.REWARD_LEGENDARY, volume);
    default:
      return playSound(SoundType.REWARD_COMMON, volume);
  }
}

/**
 * 根据任务类型和优先级播放对应音效
 * @param taskType 任务类型
 * @param taskPriority 任务优先级
 * @param volume 音量（0-1）
 * @returns 是否成功播放
 */
export function playTaskCompletionSound(taskType: string, taskPriority: string, volume: number = 0.5): boolean {
  // 主线任务
  if (taskType === 'main') {
    return playSound(SoundType.TASK_COMPLETE_MAIN, volume);
  }

  // 高优先级任务
  if (taskPriority === 'high') {
    return playSound(SoundType.TASK_COMPLETE_HIGH, volume);
  }

  // 默认任务完成音效
  return playSound(SoundType.TASK_COMPLETE, volume);
}

/**
 * 根据挑战难度播放对应音效
 * @param difficulty 挑战难度
 * @param volume 音量（0-1）
 * @returns 是否成功播放
 */
export function playChallengeCompletionSound(difficulty: string, volume: number = 0.5): boolean {
  switch (difficulty) {
    case 'expert':
    case 'legendary':
      return playSound(SoundType.CHALLENGE_COMPLETE_LEGENDARY, volume);
    case 'hard':
    case 'epic':
      return playSound(SoundType.CHALLENGE_COMPLETE_EPIC, volume);
    default:
      return playSound(SoundType.CHALLENGE_COMPLETE, volume);
  }
}

/**
 * 预加载所有音效
 * 在游戏启动时调用，提前加载所有音效文件
 */
export function preloadAllSounds(): void {
  Object.values(SoundType).forEach(type => {
    const soundPath = soundPaths[type as SoundType];
    if (!audioCache[soundPath]) {
      audioCache[soundPath] = new Audio(soundPath);
      // 只加载元数据，不播放
      audioCache[soundPath].preload = 'metadata';
      audioCache[soundPath].load();
    }
  });
}

/**
 * 设置全局音量
 * @param volume 音量（0-1）
 */
export function setGlobalVolume(volume: number): void {
  const normalizedVolume = Math.max(0, Math.min(1, volume));
  Object.values(audioCache).forEach(audio => {
    audio.volume = normalizedVolume;
  });
}
</file>

<file path=".gitignore">
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage
/.nyc_output

# next.js
/.next/
/out/
/dist/

# production
/build

# misc
.DS_Store
*.pem
# .env
# .env.local
.env.development.local
.env.test.local
.env.production.local
# .env.mock

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
# .env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# IDE
.idea/
.vscode/
*.swp
*.swo

# Capacitor
/android/
/ios/
/capacitor/

# Database
/data/
*.db
*.sqlite
*.sqlite3

# Logs
/logs/
*.log

# Cache
.cache/
.temp/

# Build
/dist/
/build/
/out/

# Test
/coverage/
/.nyc_output/

# Misc
.DS_Store
Thumbs.db
*.bak
*.tmp
*.temp
</file>

<file path="app-design-brief.md">
# PandaHabit App Design Brief: 华丽游戏风格

## 1. Introduction

### 1.1 Overview
PandaHabit是一款移动应用，通过引人入胜且支持性的虚拟宠物体验，帮助用户建立积极的习惯，改善自我护理，提升心理健康。用户通过完成现实生活中的任务和习惯来培养虚拟熊猫，创造一种共生关系，照顾自己直接有益于宠物，而宠物则提供陪伴、动力和温和的指导。

### 1.2 华丽游戏风格设计理念
PandaHabit的设计理念围绕创造一种**华丽奢华的游戏体验**，给人以高级感、沉浸感和情感满足感。应用旨在通过利用精美绚丽的视觉效果、精心设计的交互和令人惊叹的动画效果，将自我护理从一项琐事转变为一段愉悦的旅程。我们采用了东方美学与现代游戏设计相结合的方式，打造出一个既华丽壮观又温馨舒适的数字空间。

### 1.3 目标用户
- 寻求习惯养成和自我护理工具的个人
- 喜欢游戏化和虚拟宠物体验的用户
- 渴望获得支持性、温和方式进行个人发展的人群
- 年龄范围：18-45岁，重点关注年轻专业人士和学生
- 欣赏高品质数字体验并愿意投资优质应用的用户
- 对东方美学和华丽视觉风格有偏好的玩家

## 2. 华丽游戏风格分析

### 2.1 华丽游戏风格定义
对于PandaHabit，"华丽游戏风格"的定义包括：
- **绚丽华美的视觉效果**，包含精细的插画和动画，灵感来源于东方美学和传统中国艺术
- **金碧辉煌的色彩搭配**，融合深沉的宝石色调、金色点缀、精致的渐变和传统中国色彩
- **精雕细琢的UI元素**，注重阴影、高光和纹理细节，采用传统中国装饰元素（如云纹、如意纹）
- **流畅华丽的动画效果**，提供视觉反馈和愉悦感，动画风格融合现代游戏与传统水墨画动态美感
- **沉浸式音效设计**，结合平静的自然声音、传统中国乐器和温柔的音乐元素
- **精心设计的字体排版**，平衡可读性与美学吸引力，中文使用优雅的书法风格字体

### 2.2 视觉参考与灵感来源
- **高品质移动游戏**：《原神》(整体UI风格与动效)、《天涯明月刀》(中国风元素)、《阴阳师》(华丽特效)
- **中国传统艺术**：水墨画、竹子图案、山水画、传统纹饰、剪纸艺术、京剧脸谱元素
- **奢侈品牌应用**：上海滩、故宫文创、Louis Vuitton中国版
- **自然启发设计**：国家地理、高端度假村网站、中国园林设计
- **古典游戏美学**：《轩辕剑》系列、《仙剑奇侠传》系列的视觉风格
- **现代中国风设计**：当代中国插画师作品、新中式设计元素

### 2.3 华丽色彩方案
- **主要色彩**:
  - 皇家翡翠绿 (#1A5F4A)：代表成长、宁静与自然，灵感来自传统中国玉器
  - 富贵竹绿 (#88B04B)：象征熊猫的食物和活力，传递生机与希望
  - 瑞雪白 (#F7F9F9)：提供视觉呼吸空间和清晰度，象征纯净与和谐
  - 朱砂红 (#D73E35)：传统中国红，象征喜庆、活力与好运

- **点缀色彩**:
  - 华贵金 (#D4AF37)：突出成就和高级元素，灵感来自古代中国金饰
  - 青花蓝 (#1A6DB0)：代表水分和流动，灵感来自青花瓷
  - 牡丹粉 (#F8C8DC)：增添温暖和情感连接，灵感来自中国传统花卉
  - 紫檀紫 (#5D3954)：增添神秘感和高贵感，灵感来自传统家具

- **功能色彩**:
  - 如意绿 (#2E8B57)：表示完成和积极成果，灵感来自如意玉器
  - 琥珀黄 (#FFA500)：引起注意但不刺眼，灵感来自古代琥珀饰品
  - 墨灰 (#8A8D91)：用于次要文本和非活动元素，灵感来自水墨画

### 2.4 字体设计
- **主标题字体**:
  - 中文：**"方正清刻本悦宋"**，传递典雅与永恒感
  - 英文：**"Playfair Display"**，与中文字体风格相协调
  - 用于页面标题、成就名称和重要标签，配以金色描边增强华丽感

- **正文字体**:
  - 中文：**"思源宋体"**，高可读性，带有友好、平易近人的感觉
  - 英文：**"Nunito Sans"**，与中文字体搭配和谐
  - 用于任务描述、说明和一般内容，保持清晰易读

- **装饰字体**:
  - 中文：**"庞门正道行书"**，增添个人、亲密的触感，模仿传统书法
  - 英文：**"Caveat"**，手写风格元素
  - 谨慎使用于引言、反思和来自熊猫的特殊信息，增添情感连接

### 2.5 UI组件设计指南
- **按钮**：传统中国风格元素（如云纹、如意纹）装饰的软圆角矩形，配以精致渐变和金色点缀，点击时有华丽粒子效果
- **卡片**：层叠设计，带有精致阴影和纹理背景，边框采用传统中国纹饰，重要卡片有金色或红色描边
- **图标**：水墨画风格，笔触一致，圆润边角，融入传统中国元素（如竹、山水、花鸟）
- **进度指示器**：优雅的环形或线性设计，动画填充效果模仿水墨晕染，重要进度条采用卷轴或竹简形式
- **输入框**：简约设计，带有微妙边框和焦点状态，边框采用传统纹饰，激活时有水墨扩散效果
- **弹窗**：居中设计，装饰性框架采用传统窗棂样式，半透明背景模仿宣纸质感，重要弹窗有红色或金色装饰

## 3. 信息架构

### 3.1 导航结构
基于PRD，PandaHabit将使用底部标签导航，具有以下主要部分，每个导航图标都采用华丽的中国风设计：

1. **主页（竹林家园）**：主仪表盘，展示熊猫、及时奖励进度条和快速操作，背景为动态竹林场景
2. **任务（修行之路）**：日常任务列表和管理，设计为古代卷轴样式
3. **挑战（江湖历练）**：长期目标和特别活动，设计为地图探险风格
4. **旅程（成长之道）**：熊猫成长路径和里程碑，设计为传统山水画卷
5. **商店（珍宝阁）**：装饰物品、资源和VIP订阅，设计为古代商铺风格

次要导航包括：
- **熊猫互动（心灵相通）**：通过点击主页上的熊猫访问，设计为精美的互动场景
- **幸运抽奖（福缘抽签）**：通过顶部导航中的专用图标访问，设计为传统抽签与宝箱相结合的形式
- **设置（玉简设定）**：通过右上角的齿轮图标访问，图标设计为古代玉简
- **反思模块（静心茶室）**：根据用户行为情境触发，设计为宁静的传统茶室环境

### 3.2 用户流程图
关键用户流程包括，每个流程都配有华丽的过渡动画和视觉引导：

1. **新用户引导（初入仙境）**：
   - 应用介绍（古卷展开动画）→ 熊猫定制（水墨渲染效果）→ 首个任务设置（卷轴书写动画）→ 任务完成（金光特效）→ 奖励（宝箱开启动画）→ 主页（竹林展开效果）

2. **日常习惯打卡（每日修行）**：
   - 通知（熊猫信使动画）→ 任务页面（卷轴展开）→ 任务完成（墨迹渲染动画）→ 及时奖励（金币飞舞效果）→ 熊猫互动（熊猫欢喜动画）

3. **挑战参与（江湖探索）**：
   - 挑战页面（地图展开动画）→ 挑战选择（地点点亮效果）→ 日常子任务（小卷轴展开）→ 进度跟踪（地图路径点亮）→ 完成奖励（宝箱华丽开启）

4. **反思过程（茶道静心）**：
   - 触发事件（茶杯图标出现）→ 温和提示（熊猫邀请动画）→ 反思问题（水墨扩散效果）→ 支持性反馈（熊猫安慰动画）→ 行动建议（竹简展开效果）

5. **VIP转化（飞升之路）**：
   - 功能互动（金色光芒提示）→ VIP提示（华丽卷轴展开）→ 福利展示（金光特效展示）→ 订阅选择（玉璧选择界面）→ 购买确认（祥云环绕动画）

### 3.3 屏幕层次结构
屏幕层次结构遵循从一般到特定的逻辑进展，每一层都有独特的视觉风格：

- **第一层**：主标签屏幕（竹林家园、修行之路、江湖历练、成长之道、珍宝阁），设计为完整的场景画面
- **第二层**：特定功能屏幕（心灵相通、福缘抽签、玉简设定），设计为主场景的特写或变体
- **第三层**：详情屏幕（任务详情、挑战详情、物品详情），设计为精美的卷轴或玉简展开
- **第四层**：流程屏幕（静心茶室、VIP购买、任务创建），设计为特殊互动场景

## 4. Detailed UI/UX Design

### 4.1 Home Page
The Home Page serves as the main dashboard and emotional center of the app, featuring:

- **Top Section**:
  - User profile icon/avatar (top-left)
  - Currency display (Coins, Diamonds, Luck Points) with luxurious icons
  - Settings gear icon with ornate design (top-right)
  - Lucky Draw access with animated sparkle effect

- **Center Section**:
  - Large, beautifully illustrated Panda in a premium environment
  - Panda animations that respond to touch and app events
  - Ambient nature elements (butterflies, leaves, light effects)
  - Timeliness Bar displayed as an elegant scroll or bamboo-themed progress indicator
  - Visual reward preview with subtle animation

- **Bottom Section**:
  - Quick access to active tasks with ornate card design
  - Recent rewards log with delicate animations
  - Luxurious bottom navigation bar with custom icons and selection effects

### 4.2 Task Page
The Task Page presents daily tasks in a visually appealing manner:

- **Top Section**:
  - Date display with elegant typography and decorative elements
  - Daily progress indicator with animated fill and particle effects
  - Filter/sort options with custom dropdown design

- **Task List**:
  - Scrollable list with premium card design for each task
  - Task cards feature:
    - Custom icons representing habit types
    - Elegant typography for task names
    - Visual reward previews with subtle animations
    - Timeliness indicators with clock and sparkle effects
    - Time window display with countdown animation
    - Challenge/Custom Goal indicators with special visual treatment
    - Luxurious completion animation with particle effects

- **Add Task Button**:
  - Floating action button with gold accent and plus icon
  - Subtle pulse animation to draw attention

### 4.3 Challenge Page
The Challenge Page showcases long-term goals with a premium presentation:

- **Top Section**:
  - Elegant tab design for challenge categories
  - Animated transitions between tabs
  - Decorative header elements that reflect the challenge theme

- **Challenge Cards**:
  - Rich, detailed card design with visual hierarchy
  - Challenge title with feature typography
  - Key reward visualization with subtle highlight effects
  - Progress bar with luxurious fill animation
  - Time limit display with elegant countdown
  - Sub-task preview with expandable design
  - Accept/Claim buttons with premium styling

### 4.4 Journey Page
The Journey Page visualizes the Panda's growth path with an immersive design:

- **Growth Path Visualization**:
  - Elegant timeline or tree visualization with ornate connecting elements
  - Node design featuring miniature Panda evolution stages
  - Completed nodes with golden highlights and particle effects
  - Current node with pulsing animation
  - Locked nodes with subtle, mysterious styling
  - Reward previews with premium presentation

- **Milestone Log**:
  - Scrollable timeline with rich visual treatment
  - Achievement cards with decorative frames
  - Date stamps with elegant typography
  - Reward recap with animated icons

### 4.5 Shop Page
The Shop Page offers a premium shopping experience:

- **Top Section**:
  - Elegant search bar with decorative elements
  - Category filters with custom icons and selection effects
  - Featured items carousel with premium presentation

- **Item Grid**:
  - Luxurious card design for each item
  - High-quality item illustrations with subtle animations
  - Price display with elegant typography and currency icons
  - VIP items with special visual treatment (gold frame, sparkle effects)

- **Item Detail View**:
  - Large item preview with 3D rotation capability
  - Rich description text with premium typography
  - Before/after visualization for Panda customizations
  - Purchase button with satisfying animation
  - Related items section with elegant scrolling

### 4.6 Pet Interaction Page
The Pet Interaction Page creates an intimate connection with the Panda:

- **Environment Design**:
  - Rich, detailed background with ambient animations
  - Dynamic lighting effects based on time of day
  - Responsive environmental elements (plants, water, clouds)

- **Panda Visualization**:
  - Large, expressive Panda with detailed animations
  - Emotional states visualized through posture, facial expressions, and effects
  - Customization items rendered with high-quality details

- **Interaction Controls**:
  - Elegant button design for different interactions
  - Feeding animation with satisfying visual feedback
  - Play interactions with mini-game elements
  - Training visualizations with progress indicators
  - Reflection prompt with gentle visual treatment

### 4.7 Lucky Draw Page
The Lucky Draw Page delivers an exciting yet elegant experience:

- **Top Section**:
  - Luck Point balance with premium counter design
  - Animated sparkle effects around the balance

- **Draw Mechanism**:
  - Visually rich draw animation (ornate wheel, decorated chest, or elegant gacha)
  - Particle effects and sound design for anticipation
  - Draw buttons with luxurious styling and clear point costs
  - Result reveal with dramatic animation and celebratory effects

- **Prize Pool Display**:
  - Elegant gallery of potential prizes
  - Rarity indicators with premium visual treatment
  - Probability display with sophisticated data visualization
  - Recent wins log with animated timeline

### 4.8 Reflection Module
The Reflection Module provides a calming, supportive space:

- **Visual Design**:
  - Serene background with subtle animations (gentle clouds, soft light)
  - Reduced UI elements to minimize distraction
  - Warm color palette to create a safe atmosphere

- **Interaction Design**:
  - Panda avatar with empathetic expressions
  - Elegant text animations for dialogue appearance
  - Thoughtful input methods (custom buttons, gentle text fields)
  - Supportive visual feedback for user inputs
  - Smooth transitions between reflection stages

## 5. Core Gameplay Elements

### 5.1 Panda Companion Visualization
The Panda companion is the emotional heart of the app and features:

- **Growth Stages**:
  - Infant: Small, extra fluffy with large eyes and playful movements
  - Youth: More active, curious expressions, developing unique personality
  - Adult: Graceful, wise appearance with confident posture
  - Perfect Form: Majestic presence with subtle glow effects and special animations

- **Emotional States**:
  - Happy: Bright eyes, smiling expression, energetic movements
  - Neutral: Calm demeanor, regular breathing animation
  - Concerned: Gentle head tilt, softer movements, attentive gaze

- **Customization Visualization**:
  - Seamless integration of accessories and clothing
  - Environment decorations that the Panda interacts with
  - Special effects for rare or VIP items

### 5.2 Resource System Visualization
Resources are presented with premium visual treatment:

- **Resource Icons**:
  - Bamboo: Detailed, realistic bamboo stalks with subtle shine
  - Water: Crystal-clear droplets with light refraction effects
  - Coins: Ornate gold coins with embossed panda design
  - Diamonds: Multi-faceted gems with light reflection and sparkle

- **Resource Animations**:
  - Collection: Satisfying gather animation with particle effects
  - Spending: Elegant transfer animation from inventory to use
  - Low resources: Subtle visual indicator without being punitive
  - Resource milestone: Special celebration animation

### 5.3 Timely Reward System Visualization
The Timely Reward System features premium visual elements:

- **Timeliness Bar**:
  - Elegant scroll or bamboo-themed progress indicator
  - Rich fill animation with particle effects
  - Reward preview with subtle highlight animation
  - Completion celebration with luxurious visual effects

- **Luck Points**:
  - Premium counter with sparkle animation
  - Earning visualization with floating point animation
  - Accumulation milestone effects with special visual treatment

- **On-Time Completion**:
  - Satisfying visual feedback for timely task completion
  - Special animation for "Early Bird" bonus
  - Elegant visual connection between task completion and rewards

### 5.4 Challenge System Visualization
Challenges are presented with immersive visual elements:

- **Challenge Categories**:
  - Visual theming for different challenge types
  - Custom illustrations for challenge backgrounds
  - Animated transitions between categories

- **Progress Tracking**:
  - Rich progress bar design with milestone markers
  - Sub-task completion visualization with elegant checkmarks
  - Time remaining indicator with premium countdown design

- **Reward Presentation**:
  - Treasure chest or gift box animation for claiming rewards
  - Particle effects and sound design for celebration
  - Reward showcase with detailed item presentation

## 6. Monetization Design

### 6.1 VIP Subscription UI/UX
The VIP subscription is presented with a premium, value-focused approach:

- **VIP Badge Design**:
  - Elegant, non-intrusive badge with subtle animation
  - Tiered designs for different subscription levels
  - Special visual effects for VIP users' avatars

- **VIP Benefits Visualization**:
  - Clear, visually rich comparison between free and VIP
  - Animated demonstrations of enhanced features
  - Before/after visualizations of rewards and progression

- **Subscription Flow**:
  - Elegant, distraction-free purchase screen
  - Tiered options with visual hierarchy based on value
  - Secure payment visualization with premium styling
  - Thank you/confirmation screen with celebratory animation

### 6.2 Shop Design
The Shop provides a luxurious shopping experience:

- **Item Categories**:
  - Visual theming for different item types
  - Elegant category icons with selection effects
  - Featured items carousel with premium presentation

- **Item Presentation**:
  - High-quality item illustrations with subtle animations
  - 3D preview capability for certain items
  - Try-before-buy visualization for Panda customizations
  - Limited-time items with special visual treatment

- **Purchase Experience**:
  - Smooth, satisfying purchase animation
  - Elegant confirmation screen with item showcase
  - Gift wrapping animation for new acquisitions
  - Inventory update visualization

### 6.3 Conversion Optimization
Conversion points are designed to be compelling yet non-intrusive:

- **Feature Discovery**:
  - Elegant "VIP Feature" indicators on locked content
  - Subtle glow or highlight effects to draw attention
  - Preview capabilities with "Upgrade to Access" messaging

- **Value Demonstration**:
  - Visual comparisons showing enhanced rewards
  - Progress acceleration visualizations
  - Exclusive item showcases with premium presentation

- **Contextual Prompts**:
  - Thoughtfully timed upgrade suggestions
  - Elegant modal design for upgrade prompts
  - Clear value proposition with visual support

## 7. Technical Implementation Guidelines

### 7.1 Integration with Existing Codebase
The implementation will build upon the existing React/TypeScript architecture:

- Leverage the current component structure while enhancing visual elements
- Maintain the existing data flow patterns while adding new features
- Extend the current state management approach to include new game elements

### 7.2 Internationalization Approach
Building on the existing i18n infrastructure:

- Extend the current language system to include game-specific terminology
- Ensure all new UI elements support multiple languages
- Implement culturally appropriate visual elements for different regions

### 7.3 Component Structure
The component architecture will follow a modular approach:

- **Atomic Design Methodology**:
  - Atoms: Basic UI elements (buttons, inputs, icons)
  - Molecules: Compound components (task cards, reward displays)
  - Organisms: Feature sections (task list, panda interaction area)
  - Templates: Page layouts with placeholder content
  - Pages: Complete screens with real content

- **Game-Specific Components**:
  - PandaAvatar: Handles rendering and animating the Panda
  - ResourceDisplay: Manages resource visualization
  - RewardAnimation: Controls reward presentation effects
  - ChallengeTracker: Visualizes challenge progress

### 7.4 State Management
The state management approach will handle game-specific requirements:

- User progress and achievements stored in persistent state
- Real-time interactions managed with local state
- Animation states controlled with dedicated hooks
- Game mechanics (timers, random events) managed with specialized services

## 8. Appendices

### 8.1 Asset Requirements
- High-resolution Panda illustrations in various poses and growth stages
- Premium UI element designs (buttons, cards, icons)
- Environmental elements and backgrounds
- Resource and reward visualizations
- Animation sequences for key interactions

### 8.2 Animation Specifications
- Micro-interactions for UI elements (button presses, switches, sliders)
- Character animations for the Panda (idle, happy, concerned, interactions)
- Reward and achievement celebrations
- Transition effects between screens and states

### 8.3 Accessibility Considerations
- Color contrast compliance for all UI elements
- Alternative text for decorative elements
- Keyboard navigation support
- Screen reader compatibility
- Motion reduction options for animations
</file>

<file path="docs/data-sync-architecture.md">
# 熊猫习惯 - 数据同步与局部刷新架构

## 1. 概述

本文档描述了熊猫习惯应用中的数据同步和局部刷新架构，包括数据流、同步机制和UI更新策略。这种架构旨在提供高效的数据管理和响应式用户界面，同时保持良好的离线功能。

## 2. 核心组件

### 2.1 数据同步服务 (dataSyncService)

数据同步服务负责管理应用数据与后端服务器之间的同步。它提供以下功能：

- **同步队列管理**：跟踪需要同步的数据项
- **自动同步**：定期尝试同步待处理项目
- **手动同步**：允许用户手动触发同步
- **错误处理和重试**：处理同步失败并实现重试机制
- **网络状态监控**：在网络恢复时自动同步

关键函数：
- `initializeDataSync`: 初始化同步服务
- `addSyncItem`: 将项目添加到同步队列
- `syncPendingItems`: 同步待处理项目
- `getPendingSyncCount`: 获取待同步项目数量
- `getCurrentSyncStatus`: 获取当前同步状态

### 2.2 数据刷新钩子 (useDataRefresh)

`useDataRefresh` 是一个自定义 React Hook，用于监听数据变化并触发组件更新。它提供以下功能：

- **表特定监听**：监听特定数据表的变化
- **回调函数**：在数据变化时执行自定义逻辑
- **局部更新**：支持精确更新而非全页面刷新

变体：
- `useDataRefresh`: 监听多个表的变化
- `useTableRefresh`: 监听单个表的变化
- `triggerDataRefresh`: 手动触发数据刷新事件

## 3. 数据流程

### 3.1 数据创建/更新流程

1. 用户在UI中创建或更新数据（如任务）
2. 数据首先保存到本地数据库（Dexie.js）
3. 数据变更添加到同步队列（通过 `addSyncItem`）
4. 触发 `syncItemAdded` 事件，通知UI更新
5. 如果在线，立即尝试同步；否则等待网络恢复
6. 同步成功后，触发 `dataRefresh` 事件，通知相关组件更新

### 3.2 数据同步状态流程

1. 同步状态变化时，触发 `syncStatusChanged` 事件
2. SyncStatusIndicator 组件监听事件并更新显示
3. 同步完成后，触发 `dataRefresh` 事件
4. 使用 `useDataRefresh` 或 `useTableRefresh` 的组件接收更新并刷新UI

## 4. 组件集成

以下组件已集成数据同步和局部刷新机制：

### 4.1 任务管理相关组件

- **TaskManager**: 使用 `useDataRefresh` 监听任务数据变化
- **AnimatedTaskList**: 使用 `useTableRefresh` 监听任务表变化，实现任务列表的局部更新

### 4.2 熊猫状态相关组件

- **PandaStateProvider**: 使用 `useTableRefresh` 监听熊猫状态和能力变化
- **AbilityList**: 使用 `useTableRefresh` 监听能力表变化

### 4.3 奖励相关组件

- **RewardModal**: 使用 `useTableRefresh` 监听奖励表变化

### 4.4 UI反馈组件

- **SyncStatusIndicator**: 显示同步状态和待同步项目数量，监听 `syncItemAdded` 和 `syncStatusChanged` 事件

## 5. 错误处理

数据同步架构包含多层错误处理机制：

1. **同步错误处理**：
   - 记录失败的同步尝试
   - 实现指数退避重试策略
   - 在网络恢复时自动重试

2. **UI错误处理**：
   - 显示同步错误状态
   - 提供手动重试选项
   - 在错误状态下保持应用可用

3. **数据一致性**：
   - 使用乐观更新策略（先更新UI，后同步数据）
   - 在同步失败时回滚到服务器状态

## 6. 最佳实践

### 6.1 组件集成指南

要将新组件集成到数据同步架构中：

1. 导入适当的 Hook：
   ```typescript
   import { useDataRefresh } from '@/hooks/useDataRefresh';
   // 或
   import { useTableRefresh } from '@/hooks/useDataRefresh';
   ```

2. 在组件中使用 Hook：
   ```typescript
   // 监听多个表
   useDataRefresh(['table1', 'table2'], (event) => {
     // 处理数据刷新
   });
   
   // 或监听单个表
   useTableRefresh('tableName', (data) => {
     // 处理表数据刷新
   });
   ```

3. 实现数据变更时的局部更新逻辑

### 6.2 数据操作指南

在修改数据时：

1. 首先更新本地数据库
2. 使用 `addSyncItem` 将变更添加到同步队列
3. 依赖数据同步服务和 `useDataRefresh` 机制自动更新UI

## 7. 性能考虑

- **选择性更新**：只更新变更的数据，而不是整个列表
- **防抖动和节流**：限制短时间内的多次更新
- **懒加载**：仅在需要时加载数据
- **缓存**：缓存频繁访问的数据以减少数据库查询

## 8. 未来改进

- **冲突解决**：实现更复杂的冲突解决策略
- **批量同步优化**：改进批量同步性能
- **同步优先级**：实现基于优先级的同步队列
- **数据压缩**：减少同步数据的大小
- **增量同步**：只同步变更的字段而非整个记录
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- You can add a link to an icon file here if you have one -->
    <!-- <link rel="icon" type="image/svg+xml" href="/vite.svg" /> -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minimal Dexie I18n Demo V3</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="page-design-document.md">
# PandaHabit 页面设计文档

## 1. 概述

PandaHabit 是一款华丽游戏风格的习惯养成应用，采用中国风视觉元素，以熊猫伙伴为核心角色。本文档描述了应用程序的页面结构、设计原则和主要组件。

本应用采用多语言支持，所有页面的静态文本都通过 useLocalizedView 钩子从本地化服务获取，支持中文和英文界面。

## 2. 设计原则

### 2.1 视觉风格

- **华丽游戏风格**：采用精美的游戏界面设计，包括装饰性边框、精致图标和动画效果
- **中国风元素**：融入水墨、竹叶、金光等中国传统视觉元素
- **熊猫主题**：以熊猫为核心角色，贯穿整个应用程序

### 2.2 用户体验原则

- **直观易用**：界面简洁明了，操作流程直观
- **即时反馈**：用户操作后提供即时视觉和音效反馈
- **渐进式引导**：逐步引导用户了解功能，避免信息过载
- **奖励机制**：完成任务后提供丰富的奖励和成就系统

### 2.3 响应式设计

- **移动优先**：以移动设备为主要目标平台
- **自适应布局**：适应不同屏幕尺寸和方向
- **触摸友好**：按钮和交互元素设计适合触摸操作

## 3. 页面结构

### 3.1 主页 (HomePage)

**功能**：应用程序的入口点，展示用户概览和熊猫伙伴状态

**主要组件**：
- WelcomeSection：欢迎用户，显示当前日期和时间
- PandaSection：展示熊猫伙伴及其状态
- MoodsSection：显示用户心情记录和统计

**设计特点**：
- 竹叶装饰边框
- 水墨风格背景
- 熊猫动画效果

### 3.2 任务页面 (TasksPage)

**功能**：管理用户的任务和习惯

**主要组件**：
- TaskManager：任务管理器，包含任务列表和过滤器
- AnimatedTaskList：动画任务列表，显示任务卡片
- TaskForm：创建和编辑任务的表单

**设计特点**：
- 任务卡片采用卷轴设计
- 完成任务时的金光特效
- 任务优先级视觉区分

### 3.3 能力页面 (AbilitiesPage)

**功能**：展示和管理熊猫伙伴的能力

**主要组件**：
- AbilityTree：能力树，展示能力之间的关系
- AbilityCard：能力卡片，显示能力详情
- AbilityUnlockModal：解锁能力的模态框

**设计特点**：
- 树状结构展示能力关系
- 已解锁和未解锁能力的视觉区分
- 解锁动画效果

### 3.4 挑战页面 (ChallengesPage)

**功能**：展示和管理用户挑战

**主要组件**：
- ChallengeList：挑战列表，显示挑战卡片
- ChallengeFilter：挑战过滤器，按状态、类型和难度过滤
- ChallengeCard：挑战卡片，显示挑战详情和进度

**设计特点**：
- 挑战卡片采用华丽边框设计
- 进度条采用中国风元素
- 挑战完成时的庆祝动画

### 3.5 及时奖励页面 (TimelyRewardsPage)

**功能**：展示和管理及时奖励和幸运抽奖

**主要组件**：
- TimelyRewardList：及时奖励列表，显示奖励卡片
- TimelyRewardCard：及时奖励卡片，显示奖励详情和进度
- LuckyDraw：幸运抽奖组件，使用幸运点进行抽奖

**设计特点**：
- 奖励卡片采用金色边框设计
- 幸运抽奖采用转盘动画
- 奖励获取时的特效动画

### 3.6 设置页面 (SettingsPage)

**功能**：管理应用程序设置和用户偏好

**主要组件**：
- LanguageSelector：语言选择器
- ThemeSelector：主题选择器
- NotificationSettings：通知设置
- AccountSettings：账户设置

**设计特点**：
- 简洁的设置界面
- 分类组织设置项
- 即时应用设置变更

## 4. 共享组件

### 4.1 导航组件 (Navigation)

**功能**：在不同页面之间导航

**设计特点**：
- 底部导航栏，适合移动设备
- 图标和文字结合
- 当前页面高亮显示

### 4.2 模态框组件 (Modal)

**功能**：显示弹出内容

**设计特点**：
- 半透明背景遮罩
- 动画进入和退出效果
- 支持点击外部区域关闭

### 4.3 卷轴对话框 (ScrollDialog)

**功能**：以卷轴形式显示重要信息

**设计特点**：
- 古代卷轴设计
- 装饰性边框和纹理
- 展开和收起动画

### 4.4 奖励模态框 (RewardModal)

**功能**：展示获得的奖励

**设计特点**：
- 华丽的金色边框
- 奖励展示动画
- 粒子特效

### 4.5 熊猫头像 (PandaAvatar)

**功能**：显示熊猫伙伴

**设计特点**：
- 根据状态变化表情和动作
- 互动动画效果
- 装饰性边框

## 5. 动画系统

### 5.1 页面过渡动画

- 页面进入：淡入和上移
- 页面退出：淡出和下移
- 页面切换：交叉淡入淡出

### 5.2 元素动画

- 按钮：悬停放大，点击缩小
- 卡片：悬停轻微上浮，添加阴影
- 列表项：进入时序列动画

### 5.3 特效动画

- 完成任务：金光特效
- 解锁能力：水墨扩散效果
- 获得奖励：粒子爆炸效果

## 6. 响应式设计策略

### 6.1 移动设备 (< 768px)

- 单列布局
- 底部导航栏
- 简化的卡片设计

### 6.2 平板设备 (768px - 1024px)

- 双列布局
- 侧边导航栏
- 更详细的卡片设计

### 6.3 桌面设备 (> 1024px)

- 多列布局
- 顶部导航栏
- 完整的卡片设计，包含更多信息

## 7. 主题系统

### 7.1 颜色主题

- **默认主题**：竹青绿为主色调，金色为强调色
- **夜间主题**：深蓝为主色调，银色为强调色
- **节日主题**：红色为主色调，金色为强调色

### 7.2 字体系统

- 标题：华丽的中文书法字体
- 正文：清晰易读的无衬线字体
- 强调：装饰性中文字体

### 7.3 间距系统

- 采用 8px 基础网格系统
- 移动设备使用更紧凑的间距
- 桌面设备使用更宽松的间距

## 8. 国际化支持

### 8.1 多语言实现

- 支持中文和英文界面
- 使用 useLocalizedView 钩子加载本地化内容
- 根据语言调整布局和字体大小

### 8.2 本地化内容服务

- 使用 localizedContentService 提供本地化内容
- 每个页面都有对应的 fetch 函数，如 fetchHomePageView、fetchSettingsPageView 等
- 本地化内容包括标签（labels）和数据（data）两部分

### 8.3 页面本地化实现

每个页面都遵循相同的本地化模式：

1. 导入 useLocalizedView 钩子和对应的 fetch 函数
2. 在组件中使用 useLocalizedView 获取本地化内容
3. 处理加载状态和错误状态
4. 使用获取到的标签渲染页面内容

示例代码：

```typescript
const {
  labels: pageLabels,
  isPending,
  isError,
  error,
  refetch
} = useLocalizedView<null, PageViewLabelsBundle>(
  'pageViewContent',
  fetchPageView
);

// 处理加载状态
if (isPending && !pageLabels) {
  return <LoadingSpinner variant="jade" text="加载页面内容..." />;
}

// 处理错误状态
if (isError && !pageLabels) {
  return (
    <div className="page-content">
      <ErrorDisplay error={error} title="页面错误" onRetry={refetch} />
    </div>
  );
}

// 使用标签渲染页面内容
return (
  <div>
    <h1>{pageLabels?.pageTitle || '默认标题'}</h1>
    {/* 其他页面内容 */}
  </div>
);
```

## 9. 总结

PandaHabit 的页面设计融合了华丽游戏风格和中国传统视觉元素，以熊猫伙伴为核心角色，通过精美的界面设计、流畅的动画效果和丰富的奖励机制，为用户提供愉悦的习惯养成体验。
</file>

<file path="prd.md">
Okay, here is the comprehensive, standalone Product Requirements Document (PRD) for **PandaHabit**, incorporating all the previously discussed elements, including competitor analysis solutions, the Timely Reward System (Scheme C), User Journeys, API Structure Analysis, and detailed Page Descriptions.

---

**Product Requirements Document: PandaHabit**

**Version:** 1.0
**Date:** May 15, 2025
**Status:** Draft

**1. Introduction**

*   **1.1. Overview:** PandaHabit is a mobile application designed to help users build positive habits, improve self-care routines, and enhance mental well-being through an engaging and supportive virtual pet experience. Users nurture a virtual Panda by completing real-life tasks and habits, creating a symbiotic relationship where taking care of oneself directly benefits the pet, and the pet, in turn, offers companionship, motivation, and gentle guidance.
*   **1.2. Vision:** To be the most supportive and engaging habit-building companion, transforming self-care from a chore into a rewarding journey. We aim to foster genuine, long-term positive change by providing proactive support, gentle accountability, meaningful emotional connection, and sustained engagement, overcoming the known shortcomings of existing apps in the market.
*   **1.3. Goals:**
    *   Increase user consistency in desired habits (e.g., hydration, mindfulness, exercise).
    *   Improve user self-reported mood and well-being.
    *   Achieve high user retention and engagement through a rewarding core loop and meaningful progression.
    *   Provide a genuinely supportive and non-judgmental environment, especially when users face challenges.
    *   Establish PandaHabit as a leader in the gamified self-care app market by directly addressing competitor weaknesses (lack of active support, becoming boring, punitive mechanics, negative reinforcement).
    *   Successfully monetize through a valuable VIP subscription model.
*   **1.4. Target Audience:** Individuals seeking tools for habit formation, self-care, mood tracking, motivation, and stress management. Particularly relevant for those who enjoy gamification, virtual pets, and desire a supportive, gentle approach. Also targets users dissatisfied with existing apps due to lack of active help, waning engagement, or negative experiences.

**2. User Journeys**

*   **2.1. New User Onboarding & First Task:**
    1.  User downloads and opens PandaHabit.
    2.  Welcomed with a brief intro to the concept (Panda companion for habits).
    3.  User customizes their initial Panda appearance (basic options).
    4.  User is guided to set their first simple habit/task (e.g., "Drink a glass of water").
    5.  Panda companion provides encouragement.
    6.  User completes the task in real life.
    7.  User opens the app and marks the task complete on the **Task Page**.
    8.  User receives base resource rewards (e.g., Bamboo, Water).
    9.  **Timely Reward:** User also sees the **Timeliness Bar** fill slightly and receives **Luck Points** (with visual feedback).
    10. User is guided to feed the Panda with the earned resources on the **Home Page** or **Pet Interaction Page**.
    11. Panda reacts positively to being fed.
    12. User is introduced to the main **Home Page** interface.
*   **2.2. Daily Habit Check-in & Timely Reward:**
    1.  User receives a gentle reminder notification (optional, Panda-themed).
    2.  User opens the app, landing on the **Home Page**.
    3.  User navigates to the **Task Page**.
    4.  User reviews their daily tasks (some marked with ⏰ for Timely Rewards).
    5.  User completes several tasks within their time windows.
    6.  User marks tasks complete in the app.
    7.  User receives base resources for each task.
    8.  **Timely Reward:** For each on-time task, the **Timeliness Bar** progresses, and **Luck Points** are awarded with visual feedback.
    9.  User sees their total Luck Points increase on the HUD.
    10. User might navigate to the **Lucky Draw Page** to spend points or check the Timeliness Bar reward progress on the Home Page.
*   **2.3. Engaging with a Challenge:**
    1.  User navigates to the **Challenge Page**.
    2.  User browses active Challenges (Daily, Weekly, Event, Continuous).
    3.  User selects a Challenge (e.g., "7-Day Meditation Streak").
    4.  Challenge details show the overall goal, final reward, and component sub-tasks (e.g., "Meditate 5 mins today").
    5.  User accepts the Challenge.
    6.  The relevant daily sub-task appears in the user's **Task Page**, marked as a Challenge Task (🔥).
    7.  User completes the sub-task daily and marks it off in the Task Page, earning daily rewards and Timely Rewards if applicable.
    8.  User checks progress on the **Challenge Page**.
    9.  Upon completing the final sub-task, the Challenge is marked complete, and the user claims the main Challenge reward.
*   **2.4. Using the Reflection Module:**
    1.  User consistently skips a core habit task for several days OR reports a low mood during check-in.
    2.  Panda **gently** offers the option to reflect ("Things seem tough with [Task Name] lately. Want to explore that?").
    3.  User accepts and enters the Reflection Module.
    4.  Panda asks simple, non-judgmental questions ("What felt like the biggest barrier today?").
    5.  User provides input (optional text or multiple choice).
    6.  Panda offers empathetic validation ("It's okay to find things difficult sometimes.") and suggests **small, actionable positive steps** ("Maybe tomorrow we try just 2 minutes of it? Or try [alternative simple task] instead?").
    7.  User feels supported and less discouraged.
*   **2.5. Upgrading to VIP:**
    1.  User interacts with a feature locked behind VIP (e.g., creating a Custom Goal, trying to claim extra reward bonus).
    2.  A prompt appears explaining the benefits of VIP related to that feature and others.
    3.  User navigates to the **Shop Page** or a dedicated VIP section.
    4.  User reviews VIP tiers, benefits (increased rewards, custom goals, exclusive items), and pricing.
    5.  User selects a subscription plan and completes the purchase via the App Store.
    6.  App UI updates immediately to reflect VIP status (e.g., VIP badge, unlocked features).
*   **2.6. Using the Lucky Draw:**
    1.  User accumulates sufficient **Luck Points** by completing tasks on time.
    2.  User navigates to the **Lucky Draw Page** (accessible from Home HUD or Rewards page).
    3.  User sees their current Luck Point balance and the "Draw x1" / "Draw x10" buttons with costs.
    4.  User views the potential prize pool highlights.
    5.  User taps a Draw button.
    6.  An engaging animation plays (e.g., spinning wheel, opening bamboo chest).
    7.  The awarded prize is revealed (e.g., "+50 Coins", "Rare Panda Hat").
    8.  The prize is automatically added to the user's inventory/balance.

**3. Functional Requirements**

*   **3.1. Core Gameplay Loop: "Panda Nurturing Lifestyle System"**
    *   **3.1.1. Panda Companion:**
        *   Visual representation of a Panda that grows and evolves.
        *   Displays emotional states (happy, neutral, concerned) based on user actions and inputs.
        *   Reacts to user interactions (feeding, petting).
        *   Possesses unlockable abilities tied to growth stages (see 3.2.2).
    *   **3.1.2. Resource System:**
        *   Core resources (e.g., Bamboo, Water, Coins) earned primarily through Task completion.
        *   Resources used for feeding the Panda and facilitating Panda Growth/Upgrades.
        *   Premium currency (e.g., Diamonds) potentially used for cosmetics, speeding up timers (if any), or specific VIP features.
    *   **3.1.3. Interconnected Loop:** User completes Tasks -> Earns Resources & Timely Rewards -> Feeds/Grows Panda -> Panda Unlocks Abilities/Provides Support -> User is Motivated to Complete More Tasks.
*   **3.2. Panda Growth & Customization**
    *   **3.2.1. Growth Stages:** Defined stages (e.g., Infant, Youth, Adult, Perfect Form) reached by spending resources and meeting level requirements. Each stage unlocks new visual appearances.
    *   **3.2.2. Capability Unlock (Meaningful Progression):** Panda growth unlocks functional benefits:
        *   New supportive dialogue options and emotional responses.
        *   Enhanced ability to help break down User-Defined Goals (VIP).
        *   Access to advanced guided exercises (meditation, breathing).
        *   Potentially offer small passive bonuses (e.g., slightly increased Luck Point gain).
    *   **3.2.3. Customization:** Users can personalize Panda appearance (skins, hats, accessories) and its environment (decorations) using items earned or purchased.
*   **3.3. Tasks System**
    *   **3.3.1. Task Types:**
        *   **Daily Tasks:** Simple, repeatable tasks for daily engagement and basic resource generation (e.g., Login, Feed Panda, Quick Mood Check). Contribute to Timely Rewards.
        *   **Mainline Tasks:** Core habit-building tasks related to user's goals (e.g., Drink Water, Meditate, Exercise, Journal, Health Record). Contribute to Timely Rewards. Can be broken down into smaller steps.
        *   **Side Tasks:** Varied tasks including Positive Psychology prompts (Affirmation, Gratitude), Guided Practices, Event Tasks, and potentially social tasks. Time-sensitive ones contribute to Timely Rewards.
    *   **3.3.2. Task Management:**
        *   Users can select from predefined task suggestions or create basic custom tasks (advanced custom goals are VIP).
        *   Tasks appear on a daily Task List.
        *   Users mark tasks as complete.
        *   Ability to set task recurrence (daily, specific days, weekly).
    *   **3.3.3. Task Decomposition:** System/Panda offers assistance in breaking down larger Mainline tasks or User-Defined Goals into smaller, manageable daily actions.
    *   **3.3.4. Gentle Reminders:** Optional, customizable, Panda-themed push notifications for specific tasks.
*   **3.4. Challenge System**
    *   **3.4.1. Challenge Definition:** Longer-term objectives composed of multiple steps or requiring sustained effort over time (See Section 4.1 for definition).
    *   **3.4.2. Challenge Types:** Daily Login Streaks, Task Completion Streaks, Resource Collection Goals, Event-Specific Challenges, Cooperative Social Challenges. Categorized by duration (Daily, 7-Day, 30-Day, etc.) and source (System, Event).
    *   **3.4.3. Challenge Lifecycle Tagging:** Challenges tagged for user lifecycle stages (Newbie, Growing, Mature) for appropriate presentation.
    *   **3.4.4. Sub-Task Integration:** Challenge sub-tasks appear in the daily Task List, clearly marked. Completing sub-tasks (on time) contributes to the Timely Reward System. Challenge completion grants a separate, larger reward.
*   **3.5. Progression Systems**
    *   **3.5.1. Achievements:** Awarded for specific, one-off accomplishments across all game areas (Pet Growth, Tasks, Challenges, Resources, Social, Timeliness). Provide small-medium rewards (Coins, basic items). (See Appendix A for detailed list).
    *   **3.5.2. Milestones:** Mark major user journey progression points, often tied to account age or significant achievements. Provide substantial rewards (Large Coins, Rare Cosmetics, Materials). Tailored to user lifecycle stages. (See Appendix B for detailed list).
*   **3.6. Timely Reward System (Scheme C)**
    *   **3.6.1. Eligibility:** Clearly marked Tasks (Daily, Mainline, applicable Side/Challenge sub-tasks) are eligible.
    *   **3.6.2. Time Windows:** Defined windows for "on-time" completion (daily cutoff, specific times, task deadlines). "Early Bird" bonus potential.
    *   **3.6.3. Rewards:**
        *   **Timeliness Bar:** Fills progressively with each on-time completion. Visible on Home HUD. Reaching the end grants a **guaranteed significant reward** (e.g., rare seasonal cosmetic, large resource bundle). Bar resets upon claiming. Reward preview visible.
        *   **Luck Points:** Awarded for each on-time completion. Amount varies by task type/difficulty and VIP status. Displayed on HUD.
    *   **3.6.4. Lucky Draw:** Dedicated feature where users spend Luck Points for a chance to win random rewards from a tiered pool (Common to Legendary). Clear UI for drawing and viewing potential prizes.
*   **3.7. Deep Reflection & Psychological Support**
    *   **3.7.1. Reflection Module ("Take a Break"):** Non-intrusive module offered when user struggles (skipping tasks, low mood). Uses gentle, non-judgmental dialogue (Panda-led) to explore barriers and suggest small, positive, actionable steps. Focuses on self-compassion.
    *   **3.7.2. Proactive Support:** Panda provides context-aware, actionable, positive tips based on mood check-ins or detected patterns (e.g., suggesting hydration if mood is low and water task incomplete).
    *   **3.7.3. Avoidance of Negative Reinforcement:** No punitive mechanics for skipping tasks. Mood tracking focuses on providing support, not reinforcing negative feelings. No potentially inaccurate diagnostic quizzes.
*   **3.8. Social & Community Features**
    *   **3.8.1. Friends System:** Add friends, send encouragement messages, small resource gifts.
    *   **3.8.2. Sharing (Optional):** Share Panda growth, Milestone achievements, rare Lucky Draw wins.
    *   **3.8.3. Cooperative Challenges:** Team-based challenges encouraging collaboration.
    *   **3.8.4. Community Forum/Space:** Moderated area for sharing positive stories, tips, and encouragement.
*   **3.9. Monetization (VIP Subscription & Shop)**
    *   **3.9.1. VIP Subscription:** Tiered subscription offering benefits:
        *   Increased Luck Point earnings.
        *   Faster Timeliness Bar progression.
        *   Free daily/weekly Lucky Draws.
        *   Access to create User-Defined Goals (with Panda assistance).
        *   Higher reward caps/better potential rewards for Custom Goals.
        *   Exclusive cosmetic items (accessible only via VIP or VIP shop).
        *   VIP badge/identifier.
        *   Potential ad removal (if ads exist for free tier).
    *   **3.9.2. Shop:** In-app store selling:
        *   Cosmetic items (Panda skins, accessories, environment decorations) for Coins or potentially Diamonds.
        *   Potentially resource bundles or enhancement materials (use with caution to avoid pay-to-win feel).
        *   VIP-exclusive items.

**4. UI/UX Design (Page Descriptions)**

*   **4.1. Home Page**
    *   **Purpose:** Main dashboard, quick overview, access to core interactions.
    *   **Layout:**
        *   *Top:* User info (profile, name), Currency (Coins, Diamonds, **Luck Points** ✨), quick access icons (Pet, Achievements, Events, Tasks, VIP, Settings).
        *   *Center:* Large interactive Panda visual, reflecting current state/growth. **Timeliness Bar** 进度条 prominently displayed below or near Panda, showing progress and target reward icon.
        *   *Bottom:* Key active Task display/button area. Recent reward notifications/log.
    *   **Navigation:** Fixed bottom navigation bar (Home, Rewards/Draw, Journey, Shop, Task List).
    *   **Key Interactions:** Tapping Panda (petting), feeding shortcut, claiming task rewards, accessing other sections via icons/nav bar, checking Timeliness Bar.
*   **4.2. Task Page**
    *   **Purpose:** View and manage daily/current tasks.
    *   **Layout:**
        *   *Top:* Date, overall daily progress ("X/Y tasks complete"). Filter/Sort options.
        *   *Main:* Vertical scrollable list of tasks. Each task item shows:
            *   Name/Description.
            *   Associated icon (habit type).
            *   Reward preview (base resources).
            *   **Timeliness Icon (⏰/✨)** if eligible.
            *   **Time Window/Deadline** clearly stated.
            *   **Challenge/Custom Goal Indicator (🔥/👤)** if applicable.
            *   Checkbox/button/swipe to complete.
    *   **Key Interactions:** Marking tasks complete (triggers reward/timeliness feedback), filtering list, potentially adding new tasks (VIP).
*   **4.3. Challenge Page**
    *   **Purpose:** Track progress on long-term goals and special events.
    *   **Layout:**
        *   *Top:* Tabs or filters for challenge categories (Active, Continuous, Event, Completed).
        *   *Main:* Card-based view of Challenges. Each card shows Title, Key Reward, Progress Bar, Time Limit, potentially list of sub-tasks.
    *   **Key Interactions:** Viewing challenge details, accepting new challenges, tracking progress, claiming final challenge rewards.
*   **4.4. Journey Page (Panda Growth & Milestones)**
    *   **Purpose:** Visualize Panda's growth path and user's major achievements.
    *   **Layout:**
        *   *Top/Main:* Visual representation of Panda's evolution path (timeline, tree, etc.). Nodes mark key levels and Milestones. Each node shows requirement and reward. Clear indication of completed/current/locked status.
        *   *Bottom/Tab:* Log of achieved Milestones and potentially significant past accomplishments.
    *   **Key Interactions:** Exploring the growth path, seeing future rewards, reviewing past achievements.
*   **4.5. Shop Page**
    *   **Purpose:** Browse and purchase cosmetic items, resources, or VIP subscription.
    *   **Layout:**
        *   *Top:* Search bar, scrollable category filters (Decorations, Skins, Resources, VIP).
        *   *Main:* Grid/list of items with image, name, price. Highlighted section for Sales/Featured/VIP items.
        *   *Item Detail View:* Larger image/preview, description, purchase button.
    *   **Key Interactions:** Browsing categories, searching, viewing item details, making purchases.
*   **4.6. Pet Interaction Page**
    *   **Purpose:** Direct interaction with the Panda, feeding, accessing skills.
    *   **Layout:**
        *   *Top:* Panda status indicators (Mood, Health, Energy).
        *   *Center:* Large interactive Panda view.
        *   *Bottom:* Interaction buttons (Feed, Play, Train, Reflect). Section showing unlocked skills/abilities.
    *   **Key Interactions:** Feeding Panda (uses resources), playing mini-games (if any), triggering reflection, viewing/upgrading skills.
*   **4.7. Lucky Draw Page**
    *   **Purpose:** Spend Luck Points for random rewards.
    *   **Layout:**
        *   *Top:* Current Luck Point balance (⭐).
        *   *Center:* Visually engaging draw mechanism (wheel, chest, gacha machine). "Draw x1" and "Draw x10" buttons showing point costs.
        *   *Bottom/Side:* Display of potential prize pool highlights (especially rare items). Link to view probabilities/full pool. History log of recent wins.
    *   **Key Interactions:** Spending points to initiate draws, viewing results, checking prize pool.
*   **4.8. Reflection Module (Modal/Separate Screen)**
    *   **Purpose:** Guided self-reflection when struggling.
    *   **Layout:** Calm, simple interface. Text-based dialogue with Panda avatar. Options for user input (buttons, simple text entry). Clear display of Panda's questions and supportive statements.
    *   **Key Interactions:** Reading prompts, selecting responses or typing brief reflections, receiving actionable suggestions.

**5. API Endpoint Structure Analysis (High-Level)**

*(Assuming a standard RESTful API structure for communication between the mobile app and backend server)*

*   **User:**
    *   `POST /auth/register`
    *   `POST /auth/login`
    *   `GET /user/profile`
    *   `PUT /user/profile`
    *   `GET /user/vip_status`
*   **Panda:**
    *   `GET /panda/status` (Level, evolution, mood, health)
    *   `POST /panda/feed` (Body: {resource_type, amount})
    *   `POST /panda/interact` (Body: {interaction_type})
    *   `GET /panda/customization`
    *   `PUT /panda/customization`
*   **Tasks:**
    *   `GET /tasks?date={YYYY-MM-DD}` (Fetch tasks for a specific day)
    *   `POST /tasks` (Create custom task - basic)
    *   `PUT /tasks/{taskId}` (Update task - e.g., recurrence)
    *   `POST /tasks/{taskId}/complete` (Crucially includes timestamp for timely check)
    *   `DELETE /tasks/{taskId}`
*   **Challenges:**
    *   `GET /challenges?status=active|completed`
    *   `GET /challenges/{challengeId}`
    *   `POST /challenges/{challengeId}/accept`
    *   `POST /challenges/{challengeId}/claim_reward`
*   **User-Defined Goals (VIP):**
    *   `POST /goals` (VIP only - create Goal and sub-tasks)
    *   `GET /goals` (VIP only - list user's custom goals)
    *   `GET /goals/{goalId}`
    *   `PUT /goals/{goalId}`
    *   `DELETE /goals/{goalId}`
*   **Timely Rewards:**
    *   `GET /timely_rewards/status` (Current Luck Points, Timeliness Bar progress & target reward)
    *   `POST /lucky_draw/draw` (Body: {draw_count}) -> Returns awarded items
    *   `GET /lucky_draw/pool` (Info about potential prizes)
    *   `POST /timely_rewards/claim_bar_reward`
*   **Progression:**
    *   `GET /achievements`
    *   `GET /milestones`
*   **Shop & Monetization:**
    *   `GET /shop/items?category={category}`
    *   `POST /shop/purchase/{itemId}`
    *   `POST /vip/subscribe` (Handles App Store receipt validation)
*   **Social:**
    *   `GET /friends`
    *   `POST /friends/add`
    *   `POST /friends/{friendId}/send_encouragement`
    *   `GET /community/feed` (For shared stories)

**6. Non-Functional Requirements**

*   **6.1. Performance:** Smooth animations, fast load times, responsive UI. Backend API responses should be quick (<500ms target).
*   **6.2. Reliability:** Stable app with minimal crashes. Accurate tracking of tasks, resources, and progression. No loss of rewards due to technical issues (addressing Finch complaint). Robust data synchronization.
*   **6.3. Scalability:** Backend infrastructure capable of handling a growing user base.
*   **6.4. Security:** Secure handling of user authentication and personal data (including mood/reflection data if stored). Compliance with privacy regulations (GDPR, CCPA, etc.). Secure payment processing integration.
*   **6.5. Usability:** Intuitive navigation, clear visual hierarchy. Features should be discoverable. Onboarding should effectively teach core mechanics.
*   **6.6. Accessibility:** Adherence to platform accessibility guidelines (e.g., font sizes, color contrast, screen reader support) where feasible.

**7. Future Considerations / Roadmap Ideas**

*   Advanced Panda interactions and mini-games.
*   More sophisticated habit analytics and insights for users.
*   Deeper social features (e.g., forming accountability groups).
*   Integration with wearable devices (e.g., step tracking).
*   Expanded range of guided exercises (mindfulness, fitness).
*   Themed seasonal events with unique mechanics and rewards.

**8. Appendix**

*(Note: This section assumes the detailed tables provided in earlier prompts are available as appendices.)*

*   **Appendix A:** Detailed Task Lists (Daily, Mainline, Side - including 0-7 Day User Behavior Expectation Table)
*   **Appendix B:** Detailed Achievement List & Descriptions (Including Timeliness Achievements)
*   **Appendix C:** Detailed Milestone List & Descriptions (Lifecycle-based, including Timeliness Milestones)
*   **Appendix D:** Detailed Challenge List & Descriptions (Categorized by duration/type)
*   **Appendix E:** Reward Coefficient Tables (Task Type vs. VIP Level, Timely Reward Coefficients)
*   **Appendix F:** Data Models (JSON examples for Goal, Task, Achievement, Milestone, etc.)
*   **Appendix G:** Lucky Draw Pool Itemization (Example list of items and tiers)

---

This PRD provides a comprehensive guide for the development of PandaHabit, focusing on creating a supportive, engaging, and effective self-care and habit-building application that learns from and improves upon existing market offerings.
</file>

<file path="prompt.md">
好的，这是一个独立的、简明扼要且不失细节的 Prompt 版本，用于生成游戏化 App 原型及其设计文档。

**(Start of Independent & Concise Gamified App Prototype Prompt)**

**Prompt: 游戏化 App 原型与设计文档生成 (用户聚焦与功能实现)**

**任务：** AI 作为首席策划与设计师，需构思并创建一个功能丰富、用户体验卓越的游戏化 App 原型 (`app.html`) 及其详尽的设计文档 (`app-design-brief.md`)。核心目标是最大化用户参与度，驱动订阅转化，并体现产品价值。

**核心交付物：**

1.  **`app** 可交互的 App 原型，采用统一的游戏 UI 风格，包含下述核心功能。
2.  **`app-design-brief.md`:** 详细的设计文档，阐述所有研究、策略、设计决策及技术建议。

**关键要求与 AI 职责：**

*   **AI 自主性：** 即使产品需求 (`prd.md`) 不完整，AI 也需主动进行市场调研、用户分析 (聚焦游戏玩家)、竞品分析 (游戏 App UI/UX)，补充信息并自主优化/拓展功能。
*   **核心功能 (原型必备)：**
    1.  **语言选择：** 在设置内提供，JSON驱动，`data-i18n` 属性支持。
    2.  **排行榜：** 若 PRD 未提及，AI 需判断是否添加以增强游戏性。
    3.  **订阅引导优化：** 实现有效的订阅 UI/UX 策略 (如下文详述)。
*   **游戏 UI 风格：** AI 将根据用户输入或自主选择并论证一种特定游戏 UI 风格 (例如：魔幻、科技、二次元、休闲、复古等，具体风格列表可参考之前的详细版本)，并确保其在 App 原型中的一致性与沉浸感。
*   **清晰导航：** 基于用户提供的“App 结构与导航”或 AI 的最佳实践研究，构建直观易用的导航系统。

**用户需提供：**

1.  **`prd.md` (产品需求文档)：** 即使不完整。
2.  **游戏 App 核心信息：** 名称、主要卖点、目标用户特征、品牌调性等。
3.  **App 结构与导航蓝图 (强烈建议)：**
    *   **主要导航页面列表：** (例如：首页、游戏中心、任务、个人资料、设置、商店)。
    *   **次要页面列表及其入口：** (例如：从游戏中心 -> 游戏详情页；从设置 -> 语言选择页)。
    *   **关键流程页面：** (例如：新手引导、付费墙、分享流程)。
    *   *若用户未提供，AI 将基于研究进行假设并说明。*

**AI 研究与规划 (`app-design-brief.md` 中体现)：**

*   **市场与用户洞察：** 分析市场趋势、用户需求与痛点、游戏习惯、UI/导航偏好。
*   **竞品分析：** 学习成功竞品的 UI/UX、功能、导航架构。
*   **最佳实践应用：** 融入移动端 UX、游戏化设计、多语言支持、排行榜设计、导航设计及订阅转化策略。
*   **设计决策论证：** 详细说明各项设计选择 (颜色、布局、交互、功能等) 的理由，并与研究结果和最佳实践关联。

**`app.html` 原型构建要点：**

*   **用户体验优先：** 界面直观，操作流畅，核心流程清晰。
*   **响应式设计：** 适配主流移动设备屏幕。
*   **交互反馈：** 包含按钮点击、页面切换等基本交互。
*   **订阅 UI/UX 实现：**
    *   **分层提示：** 在不同用户阶段提供订阅入口。
    *   **“PRO”专区：** 集中展示高级功能价值。
    *   **视觉强化：** 突出订阅按钮和核心价值。
    *   **情境触发：** 在用户最需要高级功能时提示。
    *   **挽留机制：** 用户尝试取消订阅时提供优惠或重申价值。
    *   **社交证明：** (可选) 展示用户评价。
*   **导航实现：** 根据规划的结构和导航模式 (如底部Tab、抽屉式等) 实现，确保所有页面可达且流程顺畅。

**`app-design-brief.md` 文档结构：**

1.  **引言与研究总结：** PRD分析、AI自主研究发现 (市场、用户、竞品)。
2.  **App 整体设计策略：** 功能拓展理由、核心设计原则。
3.  **详细设计规划：**
    *   **信息架构与导航设计：** 架构图、导航模式选择及理由、页面跳转流程、关键页面设计分析 (含截图/线框图)。
    *   **游戏 UI 风格选择与应用：** 理由、具体视觉元素规划。
    *   **核心功能设计详解：** 语言选择、排行榜 (若添加)、订阅引导 UI/UX (各策略点实现方案、A/B测试建议)。
    *   **其他设计要素：** 文案风格、视觉素材、颜色方案、CTA、响应式策略。
4.  **技术与合规性建议：** 性能优化、技术选型参考、合规性提示。

**评估重点：**

*   **用户体验与导航：** 是否直观易用？流程是否顺畅？
*   **核心功能完整性：** 语言选择、排行榜、订阅引导是否按要求实现并有效？
*   **游戏 UI 沉浸感：** UI 风格是否统一且吸引人？
*   **设计文档质量：** AI 的研究、决策和规划是否清晰、详尽且合理？

**指示 AI：** 严格遵循上述要求，特别是核心功能的实现、清晰导航的构建、指定或选定游戏 UI 风格的深度融合，以及详尽设计文档的产出。

**(End of Independent & Concise Gamified App Prototype Prompt)**
</file>

<file path="public/assets/abilities/bamboo-focus.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Bamboo Focus</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="focusGradient">
            <stop stop-color="#4A90E2" offset="0%"></stop>
            <stop stop-color="#1A5F4A" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Target/Focus symbol -->
        <circle cx="50" cy="50" r="30" stroke="url(#focusGradient)" stroke-width="3" fill="none"></circle>
        <circle cx="50" cy="50" r="20" stroke="url(#focusGradient)" stroke-width="2" fill="none"></circle>
        <circle cx="50" cy="50" r="10" stroke="url(#focusGradient)" stroke-width="1" fill="url(#focusGradient)"></circle>
        
        <!-- Crosshair lines -->
        <path d="M50,10 L50,30" stroke="url(#focusGradient)" stroke-width="2"></path>
        <path d="M50,70 L50,90" stroke="url(#focusGradient)" stroke-width="2"></path>
        <path d="M10,50 L30,50" stroke="url(#focusGradient)" stroke-width="2"></path>
        <path d="M70,50 L90,50" stroke="url(#focusGradient)" stroke-width="2"></path>
        
        <!-- Bamboo elements -->
        <path d="M20,20 L25,25" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M75,75 L80,80" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M20,80 L25,75" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M75,25 L80,20" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#4A90E2" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/bamboo-heart.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Bamboo Heart</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="bambooGradient">
            <stop stop-color="#88B04B" offset="0%"></stop>
            <stop stop-color="#1A5F4A" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Heart shape made of bamboo -->
        <path d="M50,75 C50,75 25,55 25,40 C25,30 35,25 45,30 C48,32 50,35 50,35 C50,35 52,32 55,30 C65,25 75,30 75,40 C75,55 50,75 50,75 Z" fill="url(#bambooGradient)" stroke="#1A5F4A" stroke-width="2"></path>
        
        <!-- Bamboo details -->
        <path d="M40,35 L40,65" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        <path d="M50,35 L50,65" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        <path d="M60,35 L60,65" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        
        <path d="M35,45 L65,45" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        <path d="M30,55 L70,55" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#88B04B" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/bamboo-master.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Bamboo Master</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="masterGradient">
            <stop stop-color="#FFD700" offset="0%"></stop>
            <stop stop-color="#D4AF37" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="4" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Golden bamboo stalks -->
        <path d="M30,20 L30,80" stroke="url(#masterGradient)" stroke-width="4" stroke-linecap="round"></path>
        <path d="M50,20 L50,80" stroke="url(#masterGradient)" stroke-width="4" stroke-linecap="round"></path>
        <path d="M70,20 L70,80" stroke="url(#masterGradient)" stroke-width="4" stroke-linecap="round"></path>
        
        <!-- Bamboo nodes -->
        <path d="M25,30 L35,30" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M25,50 L35,50" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M25,70 L35,70" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M45,40 L55,40" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M45,60 L55,60" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M65,30 L75,30" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M65,50 L75,50" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M65,70 L75,70" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Bamboo leaves -->
        <path d="M30,25 C25,20 20,25 25,30" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M30,75 C25,80 20,75 25,70" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M50,35 C45,30 40,35 45,40" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M50,65 C45,70 40,65 45,60" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M70,25 C75,20 80,25 75,30" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M70,75 C75,80 80,75 75,70" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Master symbol -->
        <circle cx="50" cy="50" r="35" stroke="url(#masterGradient)" stroke-width="2" stroke-dasharray="3,2"></circle>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#D4AF37" stroke-width="3" stroke-opacity="0.9"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/default-ability.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Default Ability</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="defaultGradient">
            <stop stop-color="#9E9E9E" offset="0%"></stop>
            <stop stop-color="#616161" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Question mark -->
        <circle cx="50" cy="50" r="30" fill="url(#defaultGradient)"></circle>
        <text x="50" y="62" font-family="Arial" font-size="40" fill="#FFFFFF" text-anchor="middle">?</text>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#9E9E9E" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/panda-vitality.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Panda Vitality</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="energyGradient">
            <stop stop-color="#FFD700" offset="0%"></stop>
            <stop stop-color="#FFA500" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Panda face -->
        <circle cx="50" cy="50" r="30" fill="white" stroke="black" stroke-width="2"></circle>
        
        <!-- Panda ears -->
        <circle cx="30" cy="30" r="10" fill="black"></circle>
        <circle cx="70" cy="30" r="10" fill="black"></circle>
        
        <!-- Panda eyes -->
        <ellipse cx="40" cy="45" rx="8" ry="7" fill="black"></ellipse>
        <ellipse cx="60" cy="45" rx="8" ry="7" fill="black"></ellipse>
        
        <!-- Panda nose -->
        <ellipse cx="50" cy="55" rx="5" ry="4" fill="black"></ellipse>
        
        <!-- Energy aura -->
        <circle cx="50" cy="50" r="38" stroke="url(#energyGradient)" stroke-width="3" stroke-dasharray="5,3"></circle>
        
        <!-- Energy rays -->
        <path d="M50,12 L50,20" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M50,80 L50,88" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M12,50 L20,50" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M80,50 L88,50" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M25,25 L31,31" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M69,69 L75,75" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M25,75 L31,69" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M69,31 L75,25" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#FFA500" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/panda-wisdom.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Panda Wisdom</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="wisdomGradient">
            <stop stop-color="#9C27B0" offset="0%"></stop>
            <stop stop-color="#673AB7" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Panda face -->
        <circle cx="50" cy="45" r="25" fill="white" stroke="black" stroke-width="2"></circle>
        
        <!-- Panda ears -->
        <circle cx="35" cy="30" r="8" fill="black"></circle>
        <circle cx="65" cy="30" r="8" fill="black"></circle>
        
        <!-- Panda eyes -->
        <ellipse cx="42" cy="42" rx="6" ry="5" fill="black"></ellipse>
        <ellipse cx="58" cy="42" rx="6" ry="5" fill="black"></ellipse>
        
        <!-- Panda nose -->
        <ellipse cx="50" cy="50" rx="4" ry="3" fill="black"></ellipse>
        
        <!-- Wisdom scroll -->
        <path d="M30,65 L70,65 L70,80 C65,75 60,78 55,80 C50,82 45,82 40,80 C35,78 30,75 30,80 L30,65 Z" fill="#F8F0D8" stroke="#9C27B0" stroke-width="2"></path>
        
        <!-- Scroll lines -->
        <path d="M35,70 L65,70" stroke="#9C27B0" stroke-width="1" stroke-opacity="0.5"></path>
        <path d="M35,75 L65,75" stroke="#9C27B0" stroke-width="1" stroke-opacity="0.5"></path>
        
        <!-- Wisdom aura -->
        <path d="M30,20 L35,15 L40,20 L45,15 L50,20 L55,15 L60,20 L65,15 L70,20" stroke="url(#wisdomGradient)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"></path>
        
        <!-- Stars -->
        <path d="M25,35 L27,30 L29,35 L34,35 L30,38 L32,43 L27,40 L22,43 L24,38 L20,35 Z" fill="url(#wisdomGradient)" opacity="0.7"></path>
        <path d="M75,35 L77,30 L79,35 L84,35 L80,38 L82,43 L77,40 L72,43 L74,38 L70,35 Z" fill="url(#wisdomGradient)" opacity="0.7"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#9C27B0" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/bamboo-bg-pattern.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- Bamboo pattern background -->
  <defs>
    <pattern id="bamboo-pattern" x="0" y="0" width="50" height="50" patternUnits="userSpaceOnUse">
      <!-- Bamboo stalk -->
      <path d="M25,0 L25,50" stroke="#88B04B" stroke-width="3" opacity="0.1"/>
      <!-- Bamboo joints -->
      <path d="M20,10 L30,10" stroke="#88B04B" stroke-width="2" opacity="0.1"/>
      <path d="M20,25 L30,25" stroke="#88B04B" stroke-width="2" opacity="0.1"/>
      <path d="M20,40 L30,40" stroke="#88B04B" stroke-width="2" opacity="0.1"/>
      <!-- Bamboo leaves -->
      <path d="M25,10 C30,5 35,8 38,12" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,25 C30,20 35,23 38,27" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,40 C30,35 35,38 38,42" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,10 C20,5 15,8 12,12" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,25 C20,20 15,23 12,27" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,40 C20,35 15,38 12,42" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
    </pattern>
  </defs>
  <rect width="100%" height="100%" fill="url(#bamboo-pattern)" />
</svg>
</file>

<file path="public/assets/bamboo-leaves.svg">
<svg width="250" height="250" viewBox="0 0 250 250" xmlns="http://www.w3.org/2000/svg">
  <!-- Bamboo stalk -->
  <path d="M50,250 L50,100" stroke="#88B04B" stroke-width="8" stroke-linecap="round"/>
  <path d="M50,100 L50,50" stroke="#88B04B" stroke-width="6" stroke-linecap="round"/>
  
  <!-- Bamboo joints -->
  <path d="M40,220 L60,220" stroke="#1A5F4A" stroke-width="3"/>
  <path d="M40,180 L60,180" stroke="#1A5F4A" stroke-width="3"/>
  <path d="M40,140 L60,140" stroke="#1A5F4A" stroke-width="3"/>
  <path d="M40,100 L60,100" stroke="#1A5F4A" stroke-width="3"/>
  <path d="M40,60 L60,60" stroke="#1A5F4A" stroke-width="3"/>
  
  <!-- Bamboo leaves -->
  <path d="M50,60 C80,30 120,40 140,20" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,60 C90,50 110,70 130,60" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,100 C70,80 100,90 120,70" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,100 C80,110 100,90 120,100" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,140 C30,120 20,100 10,90" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,140 C30,150 20,130 10,140" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,180 C70,160 90,170 110,150" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,180 C70,190 90,170 110,180" stroke="#88B04B" stroke-width="3" fill="none"/>
  
  <!-- Leaf details -->
  <path d="M140,20 C150,15 160,25 140,30" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M130,60 C140,55 150,65 130,70" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M120,70 C130,65 140,75 120,80" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M120,100 C130,95 140,105 120,110" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M10,90 C0,85 -5,95 15,100" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M10,140 C0,135 -5,145 15,150" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M110,150 C120,145 130,155 110,160" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M110,180 C120,175 130,185 110,190" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
</svg>
</file>

<file path="public/assets/chinese-cloud.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="200px" height="100px" viewBox="0 0 200 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Chinese Cloud</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="cloudGradient">
            <stop stop-color="#F7F9F9" offset="0%"></stop>
            <stop stop-color="#E0E0E0" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M20,60 C10,60 5,50 10,40 C15,30 30,30 35,40 C40,20 60,10 80,20 C100,30 110,20 130,20 C150,20 170,40 160,60 C180,60 190,80 170,90 C150,100 130,90 120,80 C110,90 90,100 70,90 C50,80 40,90 30,80 C20,70 10,60 20,60 Z" 
              fill="url(#cloudGradient)" 
              stroke="#CCCCCC" 
              stroke-width="1">
        </path>
    </g>
</svg>
</file>

<file path="public/assets/chinese-knot.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="150px" viewBox="0 0 100 150" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Chinese Knot</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="knotGradient">
            <stop stop-color="#D73E35" offset="0%"></stop>
            <stop stop-color="#9E1A1A" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Main knot structure -->
        <path d="M50,10 C60,10 70,20 70,30 C70,40 60,45 50,45 C40,45 30,40 30,30 C30,20 40,10 50,10 Z" 
              fill="url(#knotGradient)" 
              stroke="#7A0000" 
              stroke-width="2">
        </path>
        
        <path d="M50,45 C60,45 70,50 70,60 C70,70 60,75 50,75 C40,75 30,70 30,60 C30,50 40,45 50,45 Z" 
              fill="url(#knotGradient)" 
              stroke="#7A0000" 
              stroke-width="2">
        </path>
        
        <path d="M50,75 C60,75 70,80 70,90 C70,100 60,105 50,105 C40,105 30,100 30,90 C30,80 40,75 50,75 Z" 
              fill="url(#knotGradient)" 
              stroke="#7A0000" 
              stroke-width="2">
        </path>
        
        <!-- Decorative elements -->
        <circle cx="50" cy="30" r="5" fill="#FFD700" stroke="#7A0000" stroke-width="1"></circle>
        <circle cx="50" cy="60" r="5" fill="#FFD700" stroke="#7A0000" stroke-width="1"></circle>
        <circle cx="50" cy="90" r="5" fill="#FFD700" stroke="#7A0000" stroke-width="1"></circle>
        
        <!-- Tassels -->
        <path d="M45,105 L40,140" stroke="#7A0000" stroke-width="2" stroke-linecap="round"></path>
        <path d="M55,105 L60,140" stroke="#7A0000" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M40,120 L35,130" stroke="#7A0000" stroke-width="1" stroke-linecap="round"></path>
        <path d="M40,130 L35,140" stroke="#7A0000" stroke-width="1" stroke-linecap="round"></path>
        
        <path d="M60,120 L65,130" stroke="#7A0000" stroke-width="1" stroke-linecap="round"></path>
        <path d="M60,130 L65,140" stroke="#7A0000" stroke-width="1" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/chinese-lantern.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="150px" viewBox="0 0 100 150" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Chinese Lantern</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="lanternGradient">
            <stop stop-color="#D73E35" offset="0%"></stop>
            <stop stop-color="#9E1A1A" offset="100%"></stop>
        </linearGradient>
        <filter id="lanternGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Lantern top -->
        <path d="M40,20 L60,20 L55,30 L45,30 Z" 
              fill="#D4AF37" 
              stroke="#7A0000" 
              stroke-width="1">
        </path>
        
        <!-- Lantern body -->
        <path d="M45,30 C25,40 25,90 45,100 L55,100 C75,90 75,40 55,30 Z" 
              fill="url(#lanternGradient)" 
              stroke="#7A0000" 
              stroke-width="2"
              filter="url(#lanternGlow)">
        </path>
        
        <!-- Lantern bottom -->
        <path d="M45,100 L55,100 L60,110 L40,110 Z" 
              fill="#D4AF37" 
              stroke="#7A0000" 
              stroke-width="1">
        </path>
        
        <!-- Decorative lines -->
        <path d="M45,30 L45,100" stroke="#7A0000" stroke-width="1" stroke-dasharray="5,5"></path>
        <path d="M55,30 L55,100" stroke="#7A0000" stroke-width="1" stroke-dasharray="5,5"></path>
        <path d="M35,50 L65,50" stroke="#7A0000" stroke-width="1" stroke-dasharray="5,5"></path>
        <path d="M35,70 L65,70" stroke="#7A0000" stroke-width="1" stroke-dasharray="5,5"></path>
        
        <!-- Chinese character for "福" (Fortune) -->
        <text x="50" y="65" font-family="Ma Shan Zheng, cursive" font-size="24" fill="#FFD700" text-anchor="middle">福</text>
        
        <!-- Tassel -->
        <path d="M50,110 L50,130" stroke="#D4AF37" stroke-width="2" stroke-linecap="round"></path>
        <path d="M45,130 L55,130" stroke="#D4AF37" stroke-width="2" stroke-linecap="round"></path>
        <path d="M45,130 L40,140" stroke="#D4AF37" stroke-width="1" stroke-linecap="round"></path>
        <path d="M50,130 L50,140" stroke="#D4AF37" stroke-width="1" stroke-linecap="round"></path>
        <path d="M55,130 L60,140" stroke="#D4AF37" stroke-width="1" stroke-linecap="round"></path>
        
        <!-- String -->
        <path d="M50,10 L50,20" stroke="#7A0000" stroke-width="1"></path>
    </g>
</svg>
</file>

<file path="public/assets/chinese-pattern.svg">
<svg width="100" height="8" viewBox="0 0 100 8" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <pattern id="chinese-border" x="0" y="0" width="20" height="8" patternUnits="userSpaceOnUse">
      <!-- Traditional Chinese border pattern -->
      <path d="M0,4 L5,4 L5,0 L10,0 L10,4 L15,4 L15,0 L20,0 L20,4" 
            stroke="#D4AF37" stroke-width="1" fill="none"/>
      <path d="M0,8 L5,8 L5,4 L10,4 L10,8 L15,8 L15,4 L20,4 L20,8" 
            stroke="#D4AF37" stroke-width="1" fill="none"/>
      <!-- Decorative elements -->
      <circle cx="5" cy="2" r="0.8" fill="#D73E35"/>
      <circle cx="15" cy="2" r="0.8" fill="#D73E35"/>
      <circle cx="5" cy="6" r="0.8" fill="#D73E35"/>
      <circle cx="15" cy="6" r="0.8" fill="#D73E35"/>
    </pattern>
  </defs>
  <rect width="100" height="8" fill="url(#chinese-border)"/>
</svg>
</file>

<file path="public/assets/ink-splash.svg">
<svg width="300" height="300" viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
  <!-- Ink splash effect -->
  <path d="M150,50 
           C180,30 220,40 240,70 
           C260,100 250,140 230,160 
           C210,180 190,200 170,220 
           C150,240 130,250 110,230 
           C90,210 70,190 60,160 
           C50,130 60,100 80,80 
           C100,60 130,60 150,50 Z" 
        fill="#1A5F4A" opacity="0.8"/>
  <!-- Additional ink splatters -->
  <circle cx="200" cy="100" r="15" fill="#1A5F4A" opacity="0.6"/>
  <circle cx="80" cy="150" r="20" fill="#1A5F4A" opacity="0.5"/>
  <circle cx="180" cy="220" r="12" fill="#1A5F4A" opacity="0.7"/>
  <circle cx="120" cy="80" r="10" fill="#1A5F4A" opacity="0.6"/>
</svg>
</file>

<file path="public/assets/lattice-pattern.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Lattice Pattern</title>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Horizontal lines -->
        <line x1="0" y1="0" x2="100" y2="0" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="0" y1="25" x2="100" y2="25" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="0" y1="50" x2="100" y2="50" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="0" y1="75" x2="100" y2="75" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="0" y1="100" x2="100" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        
        <!-- Vertical lines -->
        <line x1="0" y1="0" x2="0" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="25" y1="0" x2="25" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="50" y1="0" x2="50" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="75" y1="0" x2="75" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="100" y1="0" x2="100" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        
        <!-- Decorative elements at intersections -->
        <circle cx="0" cy="0" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="0" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="0" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="0" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="0" r="3" fill="#D4AF37"></circle>
        
        <circle cx="0" cy="25" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="25" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="25" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="25" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="25" r="3" fill="#D4AF37"></circle>
        
        <circle cx="0" cy="50" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="50" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="50" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="50" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="50" r="3" fill="#D4AF37"></circle>
        
        <circle cx="0" cy="75" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="75" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="75" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="75" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="75" r="3" fill="#D4AF37"></circle>
        
        <circle cx="0" cy="100" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="100" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="100" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="100" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="100" r="3" fill="#D4AF37"></circle>
        
        <!-- Decorative elements in cells -->
        <path d="M12.5,12.5 L18.75,6.25 L12.5,6.25 L12.5,12.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M37.5,12.5 L43.75,6.25 L37.5,6.25 L37.5,12.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M62.5,12.5 L68.75,6.25 L62.5,6.25 L62.5,12.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M87.5,12.5 L93.75,6.25 L87.5,6.25 L87.5,12.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        
        <path d="M12.5,37.5 L18.75,31.25 L12.5,31.25 L12.5,37.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M37.5,37.5 L43.75,31.25 L37.5,31.25 L37.5,37.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M62.5,37.5 L68.75,31.25 L62.5,31.25 L62.5,37.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M87.5,37.5 L93.75,31.25 L87.5,31.25 L87.5,37.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        
        <path d="M12.5,62.5 L18.75,56.25 L12.5,56.25 L12.5,62.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M37.5,62.5 L43.75,56.25 L37.5,56.25 L37.5,62.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M62.5,62.5 L68.75,56.25 L62.5,56.25 L62.5,62.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M87.5,62.5 L93.75,56.25 L87.5,56.25 L87.5,62.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        
        <path d="M12.5,87.5 L18.75,81.25 L12.5,81.25 L12.5,87.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M37.5,87.5 L43.75,81.25 L37.5,81.25 L37.5,87.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M62.5,87.5 L68.75,81.25 L62.5,81.25 L62.5,87.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M87.5,87.5 L93.75,81.25 L87.5,81.25 L87.5,87.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
    </g>
</svg>
</file>

<file path="public/assets/lotus-flower.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="150px" height="150px" viewBox="0 0 150 150" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Lotus Flower</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="petalGradient">
            <stop stop-color="#F8C8DC" offset="0%"></stop>
            <stop stop-color="#E57373" offset="100%"></stop>
        </linearGradient>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="centerGradient">
            <stop stop-color="#FFD700" offset="0%"></stop>
            <stop stop-color="#FFA000" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Outer petals -->
        <path d="M75,20 C85,30 95,50 75,70 C55,50 65,30 75,20 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M75,20 C65,30 55,50 75,70 C95,50 85,30 75,20 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M40,40 C50,50 60,70 75,70 C60,50 50,30 40,40 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M110,40 C100,50 90,70 75,70 C90,50 100,30 110,40 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M30,75 C50,65 70,65 75,70 C60,80 40,85 30,75 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M120,75 C100,65 80,65 75,70 C90,80 110,85 120,75 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M40,110 C50,90 70,80 75,70 C60,90 50,110 40,110 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M110,110 C100,90 80,80 75,70 C90,90 100,110 110,110 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <!-- Inner petals -->
        <path d="M75,40 C80,45 85,55 75,65 C65,55 70,45 75,40 Z" 
              fill="#F8C8DC" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M75,40 C70,45 65,55 75,65 C85,55 80,45 75,40 Z" 
              fill="#F8C8DC" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M55,50 C60,55 65,65 75,65 C65,55 60,45 55,50 Z" 
              fill="#F8C8DC" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M95,50 C90,55 85,65 75,65 C85,55 90,45 95,50 Z" 
              fill="#F8C8DC" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <!-- Center -->
        <circle cx="75" cy="65" r="10" fill="url(#centerGradient)" stroke="#FFA000" stroke-width="1"></circle>
        
        <!-- Stem -->
        <path d="M75,70 L75,130" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        
        <!-- Leaves -->
        <path d="M75,100 C60,90 40,100 30,120" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M75,100 C90,90 110,100 120,120" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/mountain-landscape.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="300px" height="150px" viewBox="0 0 300 150" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Mountain Landscape</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="mountainGradient1">
            <stop stop-color="#1A5F4A" offset="0%"></stop>
            <stop stop-color="#0D2F25" offset="100%"></stop>
        </linearGradient>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="mountainGradient2">
            <stop stop-color="#88B04B" offset="0%"></stop>
            <stop stop-color="#1A5F4A" offset="100%"></stop>
        </linearGradient>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="waterGradient">
            <stop stop-color="#1A6DB0" offset="0%"></stop>
            <stop stop-color="#0D3658" offset="100%"></stop>
        </linearGradient>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="0%" id="skyGradient">
            <stop stop-color="#F7F9F9" offset="0%"></stop>
            <stop stop-color="#E0E0E0" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Sky -->
        <rect x="0" y="0" width="300" height="150" fill="url(#skyGradient)"></rect>
        
        <!-- Far mountains -->
        <path d="M0,70 L50,40 L100,60 L150,30 L200,50 L250,35 L300,60 L300,150 L0,150 Z" 
              fill="url(#mountainGradient1)" 
              opacity="0.7">
        </path>
        
        <!-- Near mountains -->
        <path d="M0,90 L30,70 L60,85 L90,60 L120,80 L150,50 L180,75 L210,55 L240,70 L270,60 L300,80 L300,150 L0,150 Z" 
              fill="url(#mountainGradient2)" 
              opacity="0.9">
        </path>
        
        <!-- Water -->
        <path d="M0,120 C30,115 60,125 90,120 C120,115 150,125 180,120 C210,115 240,125 270,120 C300,115 300,150 300,150 L0,150 Z" 
              fill="url(#waterGradient)" 
              opacity="0.6">
        </path>
        
        <!-- Sun -->
        <circle cx="250" cy="30" r="15" fill="#FFD700" opacity="0.8"></circle>
        
        <!-- Clouds -->
        <path d="M50,40 C40,40 35,35 40,30 C45,25 55,25 60,30 C65,20 75,15 85,20 C95,25 100,20 110,20 C120,20 130,30 125,40 C135,40 140,50 130,55 C120,60 110,55 105,50 C100,55 90,60 80,55 C70,50 65,55 60,50 C55,45 50,40 50,40 Z" 
              fill="#FFFFFF" 
              opacity="0.7">
        </path>
        
        <path d="M180,50 C170,50 165,45 170,40 C175,35 185,35 190,40 C195,30 205,25 215,30 C225,35 230,30 240,30 C250,30 260,40 255,50 C265,50 270,60 260,65 C250,70 240,65 235,60 C230,65 220,70 210,65 C200,60 195,65 190,60 C185,55 180,50 180,50 Z" 
              fill="#FFFFFF" 
              opacity="0.5">
        </path>
        
        <!-- Trees -->
        <path d="M60,100 L60,120 L55,120 L65,130 L75,120 L70,120 L70,100 Z" 
              fill="#88B04B">
        </path>
        
        <path d="M240,100 L240,120 L235,120 L245,130 L255,120 L250,120 L250,100 Z" 
              fill="#88B04B">
        </path>
        
        <!-- Bamboo -->
        <path d="M100,90 L100,130" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M110,95 L110,130" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M120,100 L120,130" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        
        <path d="M95,100 L105,100" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M95,110 L105,110" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M95,120 L105,120" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        
        <path d="M105,105 L115,105" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M105,115 L115,115" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M105,125 L115,125" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        
        <path d="M115,110 L125,110" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M115,120 L125,120" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        
        <!-- Birds -->
        <path d="M160,40 C165,35 170,40 175,35" stroke="#333333" stroke-width="1" stroke-linecap="round"></path>
        <path d="M180,30 C185,25 190,30 195,25" stroke="#333333" stroke-width="1" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/panda-focused.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 熊猫头部 - 专注状态 -->
  
  <!-- 头部轮廓 -->
  <circle cx="100" cy="100" r="90" fill="white" stroke="black" stroke-width="2"/>
  
  <!-- 左耳朵 -->
  <ellipse cx="40" cy="40" rx="25" ry="25" fill="black" transform="rotate(-15 40 40)"/>
  
  <!-- 右耳朵 -->
  <ellipse cx="160" cy="40" rx="25" ry="25" fill="black" transform="rotate(15 160 40)"/>
  
  <!-- 左眼眶 -->
  <ellipse cx="70" cy="85" rx="25" ry="23" fill="black" transform="rotate(-10 70 85)"/>
  
  <!-- 右眼眶 -->
  <ellipse cx="130" cy="85" rx="25" ry="23" fill="black" transform="rotate(10 130 85)"/>
  
  <!-- 左眼 - 专注 -->
  <ellipse cx="70" cy="85" rx="8" ry="10" fill="white" transform="rotate(-10 70 85)"/>
  <circle cx="70" cy="85" r="5" fill="black"/>
  <circle cx="68" cy="83" r="2" fill="white"/>
  
  <!-- 右眼 - 专注 -->
  <ellipse cx="130" cy="85" rx="8" ry="10" fill="white" transform="rotate(10 130 85)"/>
  <circle cx="130" cy="85" r="5" fill="black"/>
  <circle cx="128" cy="83" r="2" fill="white"/>
  
  <!-- 眉毛 - 专注 -->
  <path d="M55,65 L85,70" stroke="black" stroke-width="3" fill="none"/>
  <path d="M145,65 L115,70" stroke="black" stroke-width="3" fill="none"/>
  
  <!-- 鼻子 -->
  <ellipse cx="100" cy="110" rx="15" ry="10" fill="black"/>
  
  <!-- 嘴巴 - 抿嘴 -->
  <path d="M85,125 L115,125" stroke="black" stroke-width="2" fill="none"/>
  
  <!-- 装饰 - 竹叶 -->
  <path d="M30,160 C20,150 25,140 35,145" stroke="#88B04B" stroke-width="2" fill="none"/>
  <path d="M30,160 C40,150 45,140 35,135" stroke="#88B04B" stroke-width="2" fill="none"/>
</svg>
</file>

<file path="public/assets/panda-happy.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 熊猫头部 - 开心状态 -->
  
  <!-- 头部轮廓 -->
  <circle cx="100" cy="100" r="90" fill="white" stroke="black" stroke-width="2"/>
  
  <!-- 左耳朵 -->
  <ellipse cx="40" cy="40" rx="25" ry="25" fill="black" transform="rotate(-15 40 40)"/>
  
  <!-- 右耳朵 -->
  <ellipse cx="160" cy="40" rx="25" ry="25" fill="black" transform="rotate(15 160 40)"/>
  
  <!-- 左眼眶 -->
  <ellipse cx="70" cy="85" rx="25" ry="23" fill="black" transform="rotate(-10 70 85)"/>
  
  <!-- 右眼眶 -->
  <ellipse cx="130" cy="85" rx="25" ry="23" fill="black" transform="rotate(10 130 85)"/>
  
  <!-- 左眼 - 眯眼笑 -->
  <path d="M60,85 Q70,75 80,85" stroke="white" stroke-width="3" fill="none"/>
  <circle cx="70" cy="82" r="2" fill="white"/>
  
  <!-- 右眼 - 眯眼笑 -->
  <path d="M120,85 Q130,75 140,85" stroke="white" stroke-width="3" fill="none"/>
  <circle cx="130" cy="82" r="2" fill="white"/>
  
  <!-- 鼻子 -->
  <ellipse cx="100" cy="110" rx="15" ry="10" fill="black"/>
  
  <!-- 嘴巴 - 笑容 -->
  <path d="M75,125 Q100,145 125,125" stroke="black" stroke-width="3" fill="none"/>
  
  <!-- 脸颊 - 更红 -->
  <circle cx="60" cy="115" r="15" fill="#ff9999" opacity="0.6"/>
  <circle cx="140" cy="115" r="15" fill="#ff9999" opacity="0.6"/>
  
  <!-- 装饰 - 竹子 -->
  <path d="M180,160 L190,140" stroke="#88B04B" stroke-width="4" stroke-linecap="round"/>
  <path d="M180,160 L185,150" stroke="#88B04B" stroke-width="2" stroke-linecap="round"/>
  <path d="M185,150 L190,145" stroke="#88B04B" stroke-width="2" stroke-linecap="round"/>
  <ellipse cx="180" cy="160" rx="5" ry="3" fill="#1A5F4A" transform="rotate(-30 180 160)"/>
</svg>
</file>

<file path="public/assets/panda-normal.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 熊猫头部 - 基本状态 -->
  
  <!-- 头部轮廓 -->
  <circle cx="100" cy="100" r="90" fill="white" stroke="black" stroke-width="2"/>
  
  <!-- 左耳朵 -->
  <ellipse cx="40" cy="40" rx="25" ry="25" fill="black" transform="rotate(-15 40 40)"/>
  
  <!-- 右耳朵 -->
  <ellipse cx="160" cy="40" rx="25" ry="25" fill="black" transform="rotate(15 160 40)"/>
  
  <!-- 左眼眶 -->
  <ellipse cx="70" cy="85" rx="25" ry="23" fill="black" transform="rotate(-10 70 85)"/>
  
  <!-- 右眼眶 -->
  <ellipse cx="130" cy="85" rx="25" ry="23" fill="black" transform="rotate(10 130 85)"/>
  
  <!-- 左眼 -->
  <ellipse cx="70" cy="85" rx="8" ry="10" fill="white" transform="rotate(-10 70 85)"/>
  <circle cx="70" cy="85" r="4" fill="black"/>
  <circle cx="68" cy="83" r="2" fill="white"/>
  
  <!-- 右眼 -->
  <ellipse cx="130" cy="85" rx="8" ry="10" fill="white" transform="rotate(10 130 85)"/>
  <circle cx="130" cy="85" r="4" fill="black"/>
  <circle cx="128" cy="83" r="2" fill="white"/>
  
  <!-- 鼻子 -->
  <ellipse cx="100" cy="110" rx="15" ry="10" fill="black"/>
  
  <!-- 嘴巴 -->
  <path d="M85,120 Q100,130 115,120" stroke="black" stroke-width="2" fill="none"/>
  
  <!-- 脸颊 -->
  <circle cx="60" cy="115" r="10" fill="#ffcccc" opacity="0.5"/>
  <circle cx="140" cy="115" r="10" fill="#ffcccc" opacity="0.5"/>
</svg>
</file>

<file path="public/assets/panda-tired.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 熊猫头部 - 疲惫状态 -->
  
  <!-- 头部轮廓 -->
  <circle cx="100" cy="100" r="90" fill="white" stroke="black" stroke-width="2"/>
  
  <!-- 左耳朵 -->
  <ellipse cx="40" cy="40" rx="25" ry="25" fill="black" transform="rotate(-15 40 40)"/>
  
  <!-- 右耳朵 -->
  <ellipse cx="160" cy="40" rx="25" ry="25" fill="black" transform="rotate(15 160 40)"/>
  
  <!-- 左眼眶 -->
  <ellipse cx="70" cy="85" rx="25" ry="23" fill="black" transform="rotate(-10 70 85)"/>
  
  <!-- 右眼眶 -->
  <ellipse cx="130" cy="85" rx="25" ry="23" fill="black" transform="rotate(10 130 85)"/>
  
  <!-- 左眼 - 疲惫 -->
  <ellipse cx="70" cy="85" rx="8" ry="5" fill="white" transform="rotate(-10 70 85)"/>
  <path d="M62,85 L78,85" stroke="black" stroke-width="1.5" fill="none"/>
  
  <!-- 右眼 - 疲惫 -->
  <ellipse cx="130" cy="85" rx="8" ry="5" fill="white" transform="rotate(10 130 85)"/>
  <path d="M122,85 L138,85" stroke="black" stroke-width="1.5" fill="none"/>
  
  <!-- 黑眼圈 -->
  <path d="M50,95 Q70,105 90,95" stroke="#666" stroke-width="2" fill="none" opacity="0.5"/>
  <path d="M110,95 Q130,105 150,95" stroke="#666" stroke-width="2" fill="none" opacity="0.5"/>
  
  <!-- 鼻子 -->
  <ellipse cx="100" cy="110" rx="15" ry="10" fill="black"/>
  
  <!-- 嘴巴 - 疲惫 -->
  <path d="M85,125 Q100,115 115,125" stroke="black" stroke-width="2" fill="none"/>
  
  <!-- 汗滴 -->
  <path d="M40,60 L35,70" stroke="#89CFF0" stroke-width="2" fill="none"/>
  <circle cx="33" cy="73" r="3" fill="#89CFF0"/>
</svg>
</file>

<file path="public/assets/paper-texture.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="200px" height="200px" viewBox="0 0 200 200" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Paper Texture</title>
    <defs>
        <filter id="noise" x="0%" y="0%" width="100%" height="100%">
            <feTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" stitchTiles="stitch" result="noise"/>
            <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.05 0" in="noise" result="coloredNoise"/>
            <feComposite operator="in" in="coloredNoise" in2="SourceGraphic" result="monoNoise"/>
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <rect id="background" fill="#f8f0d8" x="0" y="0" width="200" height="200" filter="url(#noise)"></rect>
        
        <!-- Subtle lines -->
        <line x1="0" y1="20" x2="200" y2="20" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        <line x1="0" y1="60" x2="200" y2="60" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        <line x1="0" y1="100" x2="200" y2="100" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        <line x1="0" y1="140" x2="200" y2="140" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        <line x1="0" y1="180" x2="200" y2="180" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        
        <!-- Subtle spots -->
        <circle cx="30" cy="30" r="2" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="70" cy="90" r="1.5" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="150" cy="50" r="2" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="120" cy="120" r="1.5" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="40" cy="170" r="2" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="180" cy="140" r="1.5" fill="#d0c0a0" fill-opacity="0.1"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/coin.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Coin</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="coinGradient">
            <stop stop-color="#FFD700" offset="0%"></stop>
            <stop stop-color="#D4AF37" offset="100%"></stop>
        </linearGradient>
        <filter id="coinGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Coin base -->
        <circle cx="50" cy="50" r="40" fill="url(#coinGradient)" filter="url(#coinGlow)"></circle>
        
        <!-- Bamboo symbol -->
        <path d="M45,30 C45,30 40,35 40,40 C40,45 45,50 45,50 C45,50 50,45 50,40 C50,35 45,30 45,30 Z" fill="#1A5F4A" fill-opacity="0.8"></path>
        <path d="M55,30 C55,30 50,35 50,40 C50,45 55,50 55,50 C55,50 60,45 60,40 C60,35 55,30 55,30 Z" fill="#1A5F4A" fill-opacity="0.8"></path>
        <path d="M50,40 C50,40 45,45 45,50 C45,55 50,60 50,60 C50,60 55,55 55,50 C55,45 50,40 50,40 Z" fill="#1A5F4A" fill-opacity="0.8"></path>
        
        <!-- Coin edge -->
        <circle cx="50" cy="50" r="40" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7"></circle>
        
        <!-- Coin shine -->
        <path d="M30,40 Q40,30 50,35 Q60,40 70,35" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.8" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/rewards/decoration_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Decoration - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="decorationGradient">
            <stop stop-color="#A0D468" offset="0%"></stop>
            <stop stop-color="#88B04B" offset="100%"></stop>
        </linearGradient>
        <filter id="decorationGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#decorationGlow)"></circle>
        
        <!-- Bamboo hat -->
        <path d="M30,50 C30,35 50,25 70,50" stroke="url(#decorationGradient)" stroke-width="4" stroke-linecap="round"></path>
        <path d="M35,45 L65,45" stroke="url(#decorationGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M40,40 L60,40" stroke="url(#decorationGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M45,35 L55,35" stroke="url(#decorationGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Decorative strings -->
        <path d="M40,50 L40,65" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M60,50 L60,65" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#88B04B" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/experience.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Experience</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="experienceGradient">
            <stop stop-color="#88B04B" offset="0%"></stop>
            <stop stop-color="#1A5F4A" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <circle cx="50" cy="50" r="45" fill="url(#experienceGradient)" filter="url(#glow)"></circle>
        <path d="M50,20 L55,35 L70,35 L60,45 L65,60 L50,50 L35,60 L40,45 L30,35 L45,35 Z" fill="#FFFFFF" fill-opacity="0.9"></path>
        <circle cx="50" cy="50" r="45" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.5"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/food_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Food - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="bambooGradient">
            <stop stop-color="#A0D468" offset="0%"></stop>
            <stop stop-color="#88B04B" offset="100%"></stop>
        </linearGradient>
        <filter id="foodGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#foodGlow)"></circle>
        
        <!-- Bamboo shoots -->
        <path d="M30,30 L40,70 L50,30 L60,70 L70,30" stroke="url(#bambooGradient)" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"></path>
        
        <!-- Bamboo leaves -->
        <path d="M30,35 C20,30 25,20 35,25" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M50,35 C40,30 45,20 55,25" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M70,35 C60,30 65,20 75,25" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#88B04B" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/food_uncommon.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Food - Uncommon</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="bambooGradient">
            <stop stop-color="#4CAF50" offset="0%"></stop>
            <stop stop-color="#2E7D32" offset="100%"></stop>
        </linearGradient>
        <filter id="foodGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#foodGlow)"></circle>
        
        <!-- Bamboo shoots -->
        <path d="M30,30 L40,70 L50,30 L60,70 L70,30" stroke="url(#bambooGradient)" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"></path>
        
        <!-- Bamboo leaves -->
        <path d="M30,35 C20,30 25,20 35,25" stroke="#2E7D32" stroke-width="2" stroke-linecap="round"></path>
        <path d="M50,35 C40,30 45,20 55,25" stroke="#2E7D32" stroke-width="2" stroke-linecap="round"></path>
        <path d="M70,35 C60,30 65,20 75,25" stroke="#2E7D32" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Sparkles -->
        <circle cx="35" cy="40" r="2" fill="#FFFFFF"></circle>
        <circle cx="55" cy="35" r="2" fill="#FFFFFF"></circle>
        <circle cx="65" cy="45" r="2" fill="#FFFFFF"></circle>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#4CAF50" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/item_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Item - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="itemGradient">
            <stop stop-color="#FFC107" offset="0%"></stop>
            <stop stop-color="#FF9800" offset="100%"></stop>
        </linearGradient>
        <filter id="itemGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#itemGlow)"></circle>
        
        <!-- Item box -->
        <rect x="30" y="30" width="40" height="40" rx="5" fill="#FFFFFF" stroke="#FF9800" stroke-width="2"></rect>
        
        <!-- Box decoration -->
        <rect x="35" y="35" width="30" height="30" rx="3" fill="url(#itemGradient)" fill-opacity="0.3"></rect>
        
        <!-- Question mark -->
        <text x="50" y="60" font-family="Arial" font-size="30" fill="#FF9800" text-anchor="middle">?</text>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#FF9800" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/potion_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Potion - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="potionGradient">
            <stop stop-color="#42A5F5" offset="0%"></stop>
            <stop stop-color="#1976D2" offset="100%"></stop>
        </linearGradient>
        <filter id="potionGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#potionGlow)"></circle>
        
        <!-- Potion bottle -->
        <path d="M45,30 L55,30 L55,40 C60,45 65,55 60,65 C55,70 45,70 40,65 C35,55 40,45 45,40 L45,30 Z" fill="#FFFFFF" stroke="#1976D2" stroke-width="2"></path>
        
        <!-- Potion liquid -->
        <path d="M45,45 C40,50 35,60 40,65 C45,70 55,70 60,65 C65,60 60,50 55,45 L45,45 Z" fill="url(#potionGradient)"></path>
        
        <!-- Bottle cap -->
        <rect x="45" y="27" width="10" height="5" rx="2" fill="#1976D2"></rect>
        
        <!-- Bubbles -->
        <circle cx="45" cy="55" r="2" fill="#FFFFFF" fill-opacity="0.7"></circle>
        <circle cx="55" cy="60" r="1.5" fill="#FFFFFF" fill-opacity="0.7"></circle>
        <circle cx="50" cy="50" r="1" fill="#FFFFFF" fill-opacity="0.7"></circle>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#1976D2" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/scroll_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Scroll - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="scrollGradient">
            <stop stop-color="#D4AF37" offset="0%"></stop>
            <stop stop-color="#FFA000" offset="100%"></stop>
        </linearGradient>
        <filter id="scrollGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#scrollGlow)"></circle>
        
        <!-- Scroll -->
        <rect x="30" y="35" width="40" height="30" rx="2" fill="#F8F0D8"></rect>
        <path d="M30,35 C25,35 25,40 25,45 C25,50 25,55 30,55" stroke="#D4AF37" stroke-width="2" stroke-linecap="round"></path>
        <path d="M70,35 C75,35 75,40 75,45 C75,50 75,55 70,55" stroke="#D4AF37" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Scroll lines -->
        <path d="M35,42 L65,42" stroke="#D4AF37" stroke-width="1" stroke-opacity="0.5"></path>
        <path d="M35,47 L65,47" stroke="#D4AF37" stroke-width="1" stroke-opacity="0.5"></path>
        <path d="M35,52 L65,52" stroke="#D4AF37" stroke-width="1" stroke-opacity="0.5"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#D4AF37" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/toy_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Toy - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="toyGradient">
            <stop stop-color="#8CC152" offset="0%"></stop>
            <stop stop-color="#A0D468" offset="100%"></stop>
        </linearGradient>
        <filter id="toyGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#toyGlow)"></circle>
        
        <!-- Bamboo ball -->
        <circle cx="50" cy="50" r="25" fill="url(#toyGradient)"></circle>
        <circle cx="50" cy="50" r="25" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7"></circle>
        
        <!-- Decorative patterns -->
        <path d="M35,40 L65,40" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        <path d="M35,50 L65,50" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        <path d="M35,60 L65,60" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#8CC152" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/toy_uncommon.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Toy - Uncommon</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="toyGradient">
            <stop stop-color="#4CAF50" offset="0%"></stop>
            <stop stop-color="#2E7D32" offset="100%"></stop>
        </linearGradient>
        <filter id="toyGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#toyGlow)"></circle>
        
        <!-- Bamboo ball -->
        <circle cx="50" cy="50" r="25" fill="url(#toyGradient)"></circle>
        <circle cx="50" cy="50" r="25" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7"></circle>
        
        <!-- Decorative patterns -->
        <path d="M35,40 L65,40" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        <path d="M35,50 L65,50" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        <path d="M35,60 L65,60" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Sparkles -->
        <circle cx="35" cy="35" r="2" fill="#FFFFFF"></circle>
        <circle cx="65" cy="35" r="2" fill="#FFFFFF"></circle>
        <circle cx="65" cy="65" r="2" fill="#FFFFFF"></circle>
        <circle cx="35" cy="65" r="2" fill="#FFFFFF"></circle>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#4CAF50" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/scroll-edge.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="800px" height="30px" viewBox="0 0 800 30" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Scroll Edge</title>
    <defs>
        <linearGradient x1="0%" y1="50%" x2="100%" y2="50%" id="scrollGradient">
            <stop stop-color="#D4AF37" offset="0%"></stop>
            <stop stop-color="#FFA000" offset="50%"></stop>
            <stop stop-color="#D4AF37" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M0,0 L800,0 L800,5 C750,8 700,15 650,20 C600,25 550,28 500,29 C450,30 400,30 350,29 C300,28 250,25 200,20 C150,15 100,8 50,5 L0,5 L0,0 Z" fill="#f8f0d8"></path>
        <path d="M0,5 C50,8 100,15 150,20 C200,25 250,28 300,29 C350,30 400,30 450,29 C500,28 550,25 600,20 C650,15 700,8 750,5 L800,5 L800,30 L0,30 L0,5 Z" fill="#e8d8b8"></path>
        <path d="M0,5 C50,8 100,15 150,20 C200,25 250,28 300,29 C350,30 400,30 450,29 C500,28 550,25 600,20 C650,15 700,8 750,5" stroke="url(#scrollGradient)" stroke-width="1.5" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="README.md">
好的，这是 Minimal Demo V3 Final 的独立完整代码。我已经将所有部分整合在一起，并确保了命名和结构的一致性。

**项目结构 (回顾):**

```
minimal-dexie-i18n-v3-final/
├── README.md
├── index.html
├── package.json
├── tsconfig.json
├── tsconfig.node.json
├── vite.config.ts
└── src/
    ├── App.tsx
    ├── main.tsx
    ├── index.css
    ├── vite-env.d.ts
    ├── types/
    │   └── index.ts
    ├── context/
    │   └── LanguageProvider.tsx
    ├── db.ts
    ├── services/
    │   └── index.ts
    │   └── localizedContentService.ts
    ├── hooks/
    │   └── useInternationalizedQuery.ts
    │   └── useLocalizedView.ts
    ├── components/
    │   ├── common/
    │   │   ├── Button.tsx
    │   │   ├── LoadingSpinner.tsx
    │   │   └── ErrorDisplay.tsx
    │   └── layout/
    │       ├── AppShell.tsx
    │       ├── Header.tsx
    │       └── Navigation.tsx
    ├── features/
    │   ├── home/
    │   │   ├── WelcomeSection.tsx
    │   │   └── MoodsSection.tsx
    │   └── settings/
    │       └── LanguageSettingsSection.tsx
    ├── pages/
    │   ├── HomePage.tsx
    │   └── SettingsPage.tsx
    └── router.tsx
```

---

**1. `README.md`**

```markdown
# Minimal Dexie I18n Demo (V3 - Finalized Structure)

This project demonstrates a type-safe, API-driven (simulated with Dexie.js) internationalization architecture for React applications, emphasizing clear naming, page-level content fetching, and component-based design for optimal team collaboration.

## Core Architecture & Data Flow:

1.  **Language Management (`LanguageProvider`):**
    *   Manages and persists the global `language` state (`en` | `zh`).
    *   Provides `language` and `setLanguage` via `useLanguage` hook.
    *   Does **not** handle translations directly.

2.  **Dexie.js as Mock Backend (`db.ts`):**
    *   Simulates an API data source using IndexedDB.
    *   The `uiLabels` store holds all translatable text records.
    *   `UILabelRecord` includes `scopeKey`, `labelKey`, `languageCode`, `translatedText`.
    *   **Scope Keys:** Organize labels hierarchically:
        *   `globalLayout`: For app shell (header, footer, nav).
        *   `[viewName]View`: For page-level titles and direct content (e.g., `homeView`, `settingsView`).
        *   `[viewName]View.[sectionName]`: For labels specific to a section within a view.

3.  **Services (`localizedContentService.ts`):**
    *   Functions like `fetchHomePageView`, `fetchSettingsPageView`, `fetchGlobalLayoutView`.
    *   Interact with Dexie to retrieve `labels` and `data` for a given `language` and `scopeKey`.
    *   Return a `Promise<LocalizedContent<TDataPayload, TLabelsBundle>>`.
    *   `buildLabelsObject` helper reconstructs nested label objects from flat Dexie records.

4.  **Custom Hook (`useLocalizedView.ts`):**
    *   Built on `useInternationalizedQuery` (generic React Query wrapper).
    *   Simplifies fetching localized content for a view.
    *   Takes a `viewQueryKey` (e.g., "homeViewContent") and the corresponding `fetchViewFn`.
    *   Automatically manages `language` in the React Query `queryKey`.
    *   Returns typed `{ labels, data, isPending, isError, ... }`.

5.  **Type Definitions (`types/index.ts`):**
    *   Centralized, clearly named types.
    *   `LocalizedContent<TData, TLabels>`: Standard service response.
    *   `[PageName]ViewLabelsBundle`, `[PageName]ViewDataPayload`: For view-specific content.
    *   `[FeatureName][SectionName]Labels`: For section-specific labels.

6.  **Page-Level Data Ownership & Props Delegation:**
    *   **Page/View Components (`src/pages/`):**
        *   Act as containers. Use `useLocalizedView` to fetch all content for their view.
    *   **Data Downflow:** Pages pass relevant slices of `labels` and `data` as props to child "Section" components (`src/features/`) and common components.
    *   **Presentational Children:** Section and common components receive all text and data via props.

7.  **Componentization:**
    *   **Layout (`AppShell`, `Header`, `Navigation`):** `AppShell` fetches `GlobalLayoutLabelsBundle`.
    *   **Features/Sections:** Encapsulate distinct UI parts.
    *   **Common:** Reusable, prop-driven components.

## Running the Demo:

1.  `npm install`
    *   Note: If `vite.config.ts` shows type errors for `path` or `__dirname`, you may need to install Node.js types: `npm install --save-dev @types/node`.
    *   The `package.json` includes necessary type definitions like `@types/react`, but ensure your TypeScript server has recognized them after installation. Sometimes a reload of your editor or TS server might be needed if "Cannot find module" errors persist initially for installed packages.
2.  `npm run dev`
3.  Open in browser (usually `http://localhost:5173`).

**Important Notes for Development:**

*   **`index.html`:** This project uses Vite, which requires an `index.html` file in the project root as the entry point.
*   **Dexie DB Population:** The `src/db.ts` includes a mechanism to populate the IndexedDB with sample data. In development, React's `StrictMode` might cause the population function to be called twice. The provided code has a safeguard to prevent duplicate data errors (`ConstraintError`) in this scenario. If you modify this, be mindful of potential re-entrancy.
*   **Favicon:** You might see a 404 error for `favicon.ico` in the browser console. This is harmless and can be resolved by adding a favicon to your project and linking it in `index.html`.
```

---

**2. `package.json`**

```json
{
  "name": "minimal-dexie-i18n-v3-final",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.32.0",
    "dexie": "^3.2.7",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.23.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@types/react-router-dom": "^5.3.3",
    "@typescript-eslint/eslint-plugin": "^7.2.0",
    "@typescript-eslint/parser": "^7.2.0",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "typescript": "^5.2.2",
    "vite": "^5.2.0"
  }
}
```

---

**3. `vite.config.ts`**

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})
```

---

**4. `tsconfig.json`**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src", "vite.config.ts"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

---

**5. `tsconfig.node.json`**

```json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts"]
}
```

---

**6. `src/vite-env.d.ts`**

```typescript
/// <reference types="vite/client" />
```

---

**7. `src/index.css`**

```css
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
    Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f0f2f5;
  color: #333;
  line-height: 1.6;
}

#root {
  max-width: 960px;
  margin: 20px auto;
  padding: 15px;
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

header {
  padding-bottom: 15px;
  border-bottom: 1px solid #e8e8e8;
  margin-bottom: 20px;
}

h1, h2, h3, h4 {
  color: #2c3e50;
  margin-top: 0;
}
h1 { font-size: 1.8em; }
h2 { font-size: 1.5em; margin-bottom: 0.8em; }
h3 { font-size: 1.3em; margin-bottom: 0.6em; color: #34495e; }
h4 { font-size: 1.1em; margin-bottom: 0.5em; color: #7f8c8d; }


nav {
  margin-bottom: 20px;
  display: flex;
  gap: 10px;
}

nav a {
  padding: 8px 15px;
  text-decoration: none;
  color: #3498db;
  border-radius: 4px;
  transition: background-color 0.2s, color 0.2s;
}

nav a:hover {
  background-color: #ecf0f1;
  color: #2980b9;
}

nav a.active {
  background-color: #3498db;
  color: white;
  font-weight: bold;
}

.page-content, section.page-content { /* Allow section to also use page-content style */
  background-color: #fff;
  padding: 15px;
  border-radius: 5px;
  margin-bottom: 20px;
  /* box-shadow: 0 1px 3px rgba(0,0,0,0.05); */
}
section + section { margin-top: 25px; }


hr {
  border: 0;
  height: 1px;
  background-color: #e8e8e8;
  margin: 25px 0;
}

footer {
  text-align: center;
  margin-top: 30px;
  padding-top: 15px;
  border-top: 1px solid #e8e8e8;
  font-size: 0.9em;
  color: #7f8c8d;
}

ul {
  list-style-type: disc;
  padding-left: 20px;
}
li { margin-bottom: 5px; }


/* Common Components */
.button-common {
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1em;
  font-weight: 500;
  transition: background-color 0.2s, opacity 0.2s;
  margin-right: 10px; /* Default spacing for buttons */
}
.button-common:last-child { margin-right: 0; }

.button-common:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.button-primary {
  background-color: #3498db;
  color: white;
}
.button-primary:hover:not(:disabled) {
  background-color: #2980b9;
}
.button-secondary {
  background-color: #95a5a6;
  color: white;
}
.button-secondary:hover:not(:disabled) {
  background-color: #7f8c8d;
}


select {
  padding: 10px;
  border-radius: 4px;
  border: 1px solid #bdc3c7;
  margin-right: 10px;
  font-size: 1em;
  background-color: white;
}

.loading-spinner-overlay {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  min-height: 100px;
}
.loading-spinner {
  border: 4px solid #ecf0f1; /* Light grey */
  border-top: 4px solid #3498db; /* Blue */
  border-radius: 50%;
  width: 30px;
  height: 30px;
  animation: spin 0.8s linear infinite;
}
.loading-spinner-text { margin-top: 10px; font-style: italic; color: #555; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.error-container {
  border: 1px solid #e74c3c; /* Red */
  padding: 15px;
  border-radius: 5px;
  background-color: #fdedec; /* Light red */
  margin-bottom: 15px;
}
.error-container h3 { color: #c0392b; margin-bottom: 8px;}
.error-text { color: #c0392b; }
.error-code-text { font-size: 0.85em; color: #7f8c8d; margin-top: 5px; }
```

---

**8. `src/types/index.ts`**

```typescript
// src/types/index.ts
export type Language = "en" | "zh";

export interface LanguageContextType {
  language: Language;
  setLanguage: (lang: Language) => void;
}

export interface ApiError extends Error { errorCode?: string; statusCode?: number; }

// Structure for Dexie uiLabels store
export interface UILabelRecord {
  id?: number;
  scopeKey: string; // e.g., "globalLayout", "homeView", "homeView.welcomeSection", "components.button"
  labelKey: string; // e.g., "appTitle", "welcomeMessage", "confirmText"
  languageCode: Language;
  translatedText: string;
}

// --- Generic Localized Content Structure (from services) ---
export interface LocalizedContent<TDataPayload, TLabelsBundle> {
  labels: TLabelsBundle;
  data: TDataPayload | null;
}

// --- Global / Layout Content Types ---
export interface GlobalLayoutLabelsBundle {
  appTitle: string;
  navHome: string;
  navSettings: string;
  footerText: string;
  loadingGeneric: string;
  errorGeneric: string;
}
export type FetchGlobalLayoutViewResult = LocalizedContent<null, GlobalLayoutLabelsBundle>;

// --- Home Page/View Specific Types ---
export interface HomeWelcomeSectionLabels {
  welcomeMessage: string;
}
export interface MoodItem { readonly id: number; readonly name: string; readonly feeling: string; }
export interface HomeMoodsSectionLabels {
  sectionTitle: string;
  noMoodsMessage: string;
  refreshButtonText: string;
}
export interface HomePageViewLabelsBundle {
  pageTitle: string;
  welcomeSection: HomeWelcomeSectionLabels;
  moodsSection: HomeMoodsSectionLabels;
  someActionText: string; // Example of a page-level label for a generic action
}
export interface HomePageViewDataPayload {
  username: string;
  moods: readonly MoodItem[];
}
export type FetchHomePageViewResult = LocalizedContent<HomePageViewDataPayload, HomePageViewLabelsBundle>;

// --- Settings Page/View Specific Types ---
export interface SettingsLanguageSectionLabels {
  sectionTitle: string;
  selectLanguagePrompt: string;
  currentLanguageIs: string;
  langNameEn: string;
  langNameZh: string;
  saveButtonText: string;
  successMessage: string;
}
export interface SettingsPageViewLabelsBundle {
  pageTitle: string;
  languageSection: SettingsLanguageSectionLabels;
}
export type FetchSettingsPageViewResult = LocalizedContent<null, SettingsPageViewLabelsBundle>;
```

---

**9. `src/context/LanguageProvider.tsx`**

```tsx
// src/context/LanguageProvider.tsx
import React, { createContext, useState, useContext, useEffect, ReactNode, useCallback } from "react";
import type { Language, LanguageContextType } from "@/types";

const DEFAULT_LANGUAGE: Language = "en";
const LOCAL_STORAGE_KEY = "app_lang_v3_final";

const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

export const LanguageProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [language, setLanguageState] = useState<Language>(() => {
    try {
      const saved = localStorage.getItem(LOCAL_STORAGE_KEY) as Language | null;
      return (saved === "en" || saved === "zh") ? saved : DEFAULT_LANGUAGE;
    } catch (e) { console.warn("localStorage access error for language", e); return DEFAULT_LANGUAGE; }
  });

  useEffect(() => {
    try {
      localStorage.setItem(LOCAL_STORAGE_KEY, language);
      document.documentElement.lang = language;
    } catch (e) { console.warn("localStorage write error for language", e); }
  }, [language]);

  const setLanguage = useCallback((lang: Language) => setLanguageState(lang), []);
  const value = { language, setLanguage };

  return <LanguageContext.Provider value={value}>{children}</LanguageContext.Provider>;
};

export const useLanguage = (): LanguageContextType => {
  const context = useContext(LanguageContext);
  if (!context) throw new Error("useLanguage must be used within LanguageProvider");
  return context;
};
```

---

**10. `src/db.ts`**

```typescript
// src/db.ts
import Dexie, { Table } from 'dexie';
import type { UILabelRecord } from '@/types';

export class AppDB extends Dexie {
  uiLabels!: Table<UILabelRecord, number>;
  constructor() {
    super('FinalMinimalI18nDB_V3'); // Unique DB name for this version
    this.version(1).stores({
      uiLabels: '++id, scopeKey, labelKey, languageCode, &[scopeKey+labelKey+languageCode]',
    });
  }
}
export const db = new AppDB();

export async function populateDB() {
  const count = await db.uiLabels.count();
  if (count > 0) { /* console.log("DB V3 already populated."); */ return; }
  console.log("Populating Final V3 Dexie DB...");

  const labels: UILabelRecord[] = [
    // GlobalLayout scope
    { scopeKey: 'globalLayout', labelKey: 'appTitle', languageCode: 'en', translatedText: 'App V3 - Consistent' },
    { scopeKey: 'globalLayout', labelKey: 'appTitle', languageCode: 'zh', translatedText: '应用 V3 - 一致性' },
    { scopeKey: 'globalLayout', labelKey: 'navHome', languageCode: 'en', translatedText: 'Home' },
    { scopeKey: 'globalLayout', labelKey: 'navHome', languageCode: 'zh', translatedText: '主页' },
    { scopeKey: 'globalLayout', labelKey: 'navSettings', languageCode: 'en', translatedText: 'Settings' },
    { scopeKey: 'globalLayout', labelKey: 'navSettings', languageCode: 'zh', translatedText: '设定' },
    { scopeKey: 'globalLayout', labelKey: 'footerText', languageCode: 'en', translatedText: '© 2024 Final Demo App' },
    { scopeKey: 'globalLayout', labelKey: 'footerText', languageCode: 'zh', translatedText: '© 2024 最终演示应用' },
    { scopeKey: 'globalLayout', labelKey: 'loadingGeneric', languageCode: 'en', translatedText: 'Loading, one moment...' },
    { scopeKey: 'globalLayout', labelKey: 'loadingGeneric', languageCode: 'zh', translatedText: '加载中，请稍候...' },
    { scopeKey: 'globalLayout', labelKey: 'errorGeneric', languageCode: 'en', translatedText: 'An unexpected error occurred.' },
    { scopeKey: 'globalLayout', labelKey: 'errorGeneric', languageCode: 'zh', translatedText: '发生了一个意外错误。' },

    // homeView scope
    { scopeKey: 'homeView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'My Dashboard' },
    { scopeKey: 'homeView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '我的仪表板' },
    { scopeKey: 'homeView.welcomeSection', labelKey: 'welcomeMessage', languageCode: 'en', translatedText: 'Greetings, {user}! Have a productive day.' },
    { scopeKey: 'homeView.welcomeSection', labelKey: 'welcomeMessage', languageCode: 'zh', translatedText: '你好 {user}，祝你拥有高效的一天！' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Recent Mood Entries' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: '近期心情记录' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'noMoodsMessage', languageCode: 'en', translatedText: 'No moods logged. Why not add one?' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'noMoodsMessage', languageCode: 'zh', translatedText: '暂无心情记录。要不要添加一条？' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'refreshButtonText', languageCode: 'en', translatedText: 'Refresh Moods' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'refreshButtonText', languageCode: 'zh', translatedText: '刷新心情' },
    { scopeKey: 'homeView', labelKey: 'someActionText', languageCode: 'en', translatedText: 'Perform Action' },
    { scopeKey: 'homeView', labelKey: 'someActionText', languageCode: 'zh', translatedText: '执行操作' },

    // settingsView scope
    { scopeKey: 'settingsView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Configuration Panel' },
    { scopeKey: 'settingsView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '配置面板' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Display Language' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: '显示语言' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'selectLanguagePrompt', languageCode: 'en', translatedText: 'Select your preferred language:' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'selectLanguagePrompt', languageCode: 'zh', translatedText: '请选择您的偏好语言：' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'currentLanguageIs', languageCode: 'en', translatedText: 'Currently using: {lang}' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'currentLanguageIs', languageCode: 'zh', translatedText: '当前使用：{lang}' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameEn', languageCode: 'en', translatedText: 'English (US)' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameEn', languageCode: 'zh', translatedText: '美式英语' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameZh', languageCode: 'en', translatedText: 'Chinese (Simplified)' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameZh', languageCode: 'zh', translatedText: '简体中文' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'saveButtonText', languageCode: 'en', translatedText: 'Save Preferences' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'saveButtonText', languageCode: 'zh', translatedText: '保存偏好' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'successMessage', languageCode: 'en', translatedText: 'Preferences have been updated!' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'successMessage', languageCode: 'zh', translatedText: '偏好设置已更新！' },
  ];
  await db.uiLabels.bulkAdd(labels);
  console.log("Final V3 DB populated.");
}
```

---

**11. `src/services/index.ts`**

```typescript
// src/services/index.ts
export * from './localizedContentService';
```

---

**12. `src/services/localizedContentService.ts`**

```typescript
// src/services/localizedContentService.ts
import { db } from '@/db';
import type {
  Language, LocalizedContent,
  HomePageViewLabelsBundle, HomePageViewDataPayload, MoodItem,
  SettingsPageViewLabelsBundle,
  GlobalLayoutLabelsBundle,
  UILabelRecord, ApiError,
  FetchHomePageViewResult, FetchSettingsPageViewResult, FetchGlobalLayoutViewResult
} from '@/types';

const SIMULATED_DELAY_MS = 150;

function buildLabelsObject<TLabelsBundle>(records: UILabelRecord[], baseScope: string): TLabelsBundle {
  const labels = {} as any;
  records.forEach(record => {
    let keyPath = record.labelKey;
    if (record.scopeKey.startsWith(baseScope + '.') && record.scopeKey.length > baseScope.length) {
        const sectionPath = record.scopeKey.substring(baseScope.length + 1);
        keyPath = `${sectionPath}.${record.labelKey}`;
    } else if (record.scopeKey !== baseScope) {
        // This label is not directly under baseScope or a direct sub-scope path, might be an issue or intended for a different structure.
        // For this demo, we'll assume labels fetched by getScopedLabels are correctly targeted.
        // console.warn(`Label with key ${record.labelKey} has scope ${record.scopeKey} which is not directly under or part of ${baseScope}`);
    }

    const keys = keyPath.split('.');
    let current = labels;
    keys.forEach((key, index) => {
      if (index === keys.length - 1) {
        current[key] = record.translatedText;
      } else {
        current[key] = current[key] || {};
        current = current[key];
      }
    });
  });
  return labels as TLabelsBundle;
}

async function getScopedLabels<TLabelsBundle>(baseScopeKey: string, lang: Language): Promise<TLabelsBundle> {
  let labelRecords = await db.uiLabels
    .where('languageCode').equals(lang)
    .and(record => record.scopeKey.startsWith(baseScopeKey))
    .toArray();

  if (!labelRecords.length && lang !== 'en') {
    console.warn(`No '${lang}' labels for scope ${baseScopeKey}, falling back to 'en'`);
    labelRecords = await db.uiLabels
      .where('languageCode').equals('en')
      .and(record => record.scopeKey.startsWith(baseScopeKey))
      .toArray();
  }

  if (!labelRecords.length) {
    const errorMessage = `CRITICAL: No labels found for essential scope ${baseScopeKey} (lang: ${lang} or fallback 'en').`;
    console.error(errorMessage);
    // In a real app, you might throw an error or have a more robust fallback
    return {} as TLabelsBundle;
  }
  return buildLabelsObject<TLabelsBundle>(labelRecords, baseScopeKey);
}

export async function fetchGlobalLayoutView(lang: Language): Promise<FetchGlobalLayoutViewResult> {
  console.log(`SVC_DEXIE: Fetching GLOBAL LAYOUT VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<GlobalLayoutLabelsBundle>('globalLayout', lang);
  return { labels, data: null };
}

export async function fetchHomePageView(lang: Language): Promise<FetchHomePageViewResult> {
  console.log(`SVC_DEXIE: Fetching HOME PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS));
  const labels = await getScopedLabels<HomePageViewLabelsBundle>('homeView', lang);

  const moods: MoodItem[] = [
    { id: 1, name: labels.moodsSection?.sectionTitle || (lang === 'zh' ? '心情' : 'Moods'), feeling: lang === 'zh' ? '专注的' : 'Focused' },
    { id: 2, name: lang === 'zh' ? '锻炼会议' : 'Workout Session', feeling: lang === 'zh' ? '精力充沛的' : 'Energized' },
  ];
  const data: HomePageViewDataPayload = { username: "DevUser", moods };
  return { labels, data };
}

export async function fetchSettingsPageView(lang: Language): Promise<FetchSettingsPageViewResult> {
  console.log(`SVC_DEXIE: Fetching SETTINGS PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<SettingsPageViewLabelsBundle>('settingsView', lang);
  return { labels, data: null };
}
```

---

**13. `src/hooks/useInternationalizedQuery.ts`**

```typescript
// src/hooks/useInternationalizedQuery.ts
import {
  useQuery,
  type UseQueryOptions,
  type QueryKey,
  type UseQueryResult,
} from '@tanstack/react-query';
import type { ApiError, LocalizedContent } from '@/types';

interface UseInternationalizedQueryResult<TDataPayload, TLabelsBundle, TErrorResponse> {
  data: TDataPayload | undefined | null; // Data can be TDataPayload OR null
  labels: TLabelsBundle | undefined;
  isPending: boolean;
  isLoading: boolean;
  isFetching: boolean;
  isError: boolean;
  error: TErrorResponse | null;
  refetch: UseQueryResult<LocalizedContent<TDataPayload, TLabelsBundle>, TErrorResponse>['refetch'];
  status: UseQueryResult<LocalizedContent<TDataPayload, TLabelsBundle>, TErrorResponse>['status'];
  isSuccess: boolean;
}

export function useInternationalizedQuery<
  TLocalizedContent extends LocalizedContent<TDataPayload, TLabelsBundle>,
  TErrorResponse extends Error = ApiError,
  TDataPayload = TLocalizedContent['data'],
  TLabelsBundle = TLocalizedContent['labels'],
  TQueryKey extends QueryKey = QueryKey
>(
  options: UseQueryOptions<TLocalizedContent, TErrorResponse, TLocalizedContent, TQueryKey>
): UseInternationalizedQueryResult<TDataPayload, TLabelsBundle, TErrorResponse> {
  const {
    data: queryResult,
    isPending,
    isLoading,
    isFetching,
    isError,
    error,
    refetch,
    status,
    isSuccess,
  } = useQuery<TLocalizedContent, TErrorResponse, TLocalizedContent, TQueryKey>(options);

  return {
    data: queryResult?.data, // queryResult can be undefined during initial fetch
    labels: queryResult?.labels,
    isPending,
    isLoading,
    isFetching,
    isError,
    error,
    refetch,
    status,
    isSuccess,
  };
}
```

---

**14. `src/hooks/useLocalizedView.ts`**

```typescript
// src/hooks/useLocalizedView.ts
import { useLanguage } from '@/context/LanguageProvider';
import { useInternationalizedQuery } from './useInternationalizedQuery';
import type { ApiError, Language, LocalizedContent } from '@/types';
import { QueryKey, UseQueryOptions } from '@tanstack/react-query';

export function useLocalizedView<
  TDataPayload,
  TLabelsBundle
>(
  viewQueryKey: QueryKey,
  fetchViewFn: (lang: Language) => Promise<LocalizedContent<TDataPayload, TLabelsBundle>>,
  options?: Omit<UseQueryOptions<LocalizedContent<TDataPayload, TLabelsBundle>, ApiError, LocalizedContent<TDataPayload, TLabelsBundle>, QueryKey>, 'queryKey' | 'queryFn'>
) {
  const { language } = useLanguage();
  const fullQueryKeyWithLang: QueryKey = Array.isArray(viewQueryKey)
    ? [...viewQueryKey, language]
    : [viewQueryKey, language];

  return useInternationalizedQuery<
    LocalizedContent<TDataPayload, TLabelsBundle>,
    ApiError,
    TDataPayload,
    TLabelsBundle
  >({
    queryKey: fullQueryKeyWithLang,
    queryFn: () => fetchViewFn(language),
    enabled: !!language && (options?.enabled === undefined || options.enabled),
    ...options,
  });
}
```

---

**15. `src/components/common/Button.tsx`**

```tsx
// src/components/common/Button.tsx
import React from 'react';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary';
  isLoading?: boolean;
  loadingText?: string;
}

const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'primary',
  isLoading = false,
  loadingText = "Loading...",
  ...props
}) => {
  const baseStyle = "button-common";
  const variantStyle = variant === 'primary' ? "button-primary" : "button-secondary";
  return (
    <button className={`${baseStyle} ${variantStyle}`} disabled={isLoading || props.disabled} {...props}>
      {isLoading ? loadingText : children}
    </button>
  );
};
export default Button;
```

---

**16. `src/components/common/LoadingSpinner.tsx`**

```tsx
// src/components/common/LoadingSpinner.tsx
import React from 'react';
// CSS for this will be in src/index.css

const LoadingSpinner: React.FC<{ text?: string }> = ({ text }) => {
  return (
    <div className="loading-spinner-overlay">
      <div className="loading-spinner"></div>
      {text && <p className="loading-spinner-text">{text}</p>}
    </div>
  );
};
export default LoadingSpinner;
```

---

**17. `src/components/common/ErrorDisplay.tsx`**

```tsx
// src/components/common/ErrorDisplay.tsx
import React from 'react';
import type { ApiError } from '@/types';
import Button from './Button'; // Use our common Button

interface ErrorDisplayProps {
  error: ApiError | Error | null;
  title?: string;
  messageTemplate?: string;
  onRetry?: () => void;
  retryButtonText?: string;
}

const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  title = "Error", // Fallback title
  messageTemplate = "Details: {message}",
  onRetry,
  retryButtonText = "Try Again",
}) => {
  if (!error) return null;

  const errorMessage = error.message || "An unknown error occurred.";
  const finalMessage = messageTemplate.replace('{message}', errorMessage);
  const errorCode = (error as ApiError)?.errorCode;
  const statusCode = (error as ApiError)?.statusCode;

  return (
    <div className="error-container" role="alert">
      <h3>{title}</h3>
      <p className="error-text">{finalMessage}</p>
      {errorCode && <p className="error-code-text">Error Code: {errorCode}</p>}
      {statusCode && <p className="error-code-text">Status Code: {statusCode}</p>}
      {onRetry && (
        <Button onClick={onRetry} variant="secondary" style={{ marginTop: '10px' }}>
          {retryButtonText}
        </Button>
      )}
    </div>
  );
};
export default ErrorDisplay;
```

---

**18. `src/components/layout/Header.tsx`**

```tsx
// src/components/layout/Header.tsx
import React from 'react';
import type { GlobalLayoutLabelsBundle } from '@/types';

interface HeaderProps {
  labels: GlobalLayoutLabelsBundle | undefined;
  isFetching?: boolean;
}

const Header: React.FC<HeaderProps> = ({ labels, isFetching }) => {
  // Provide a minimal fallback if labels are still undefined during initial render pass
  const title = labels?.appTitle || "App Loading...";

  return (
    <header style={{ opacity: isFetching ? 0.7 : 1 }}>
      <h1>
        {title}
        {isFetching && labels && <small style={{ marginLeft: '10px', fontStyle: 'italic', color: '#555' }}>(syncing layout...)</small>}
      </h1>
    </header>
  );
};
export default Header;
```

---

**19. `src/components/layout/Navigation.tsx`**

```tsx
// src/components/layout/Navigation.tsx
import React from 'react';
import { NavLink } from 'react-router-dom';
import type { GlobalLayoutLabelsBundle } from '@/types';

interface NavigationProps {
  labels: GlobalLayoutLabelsBundle | undefined;
}

const Navigation: React.FC<NavigationProps> = ({ labels }) => {
  // Provide fallbacks for label properties
  const navHomeText = labels?.navHome || "Home";
  const navSettingsText = labels?.navSettings || "Settings";

  if (!labels) { // Can show a minimal loading state or just render with fallbacks
    return <nav>Loading navigation...</nav>;
  }

  return (
    <nav>
      <NavLink to="/" className={({isActive}) => isActive ? 'active' : ''}>{navHomeText}</NavLink>
      <NavLink to="/settings" className={({isActive}) => isActive ? 'active' : ''}>{navSettingsText}</NavLink>
    </nav>
  );
};
export default Navigation;
```

---

**20. `src/components/layout/AppShell.tsx`**

```tsx
// src/components/layout/AppShell.tsx
import React, { ReactNode } from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchGlobalLayoutView } from '@/services';
import Header from './Header';
import Navigation from './Navigation';
import LoadingSpinner from '../common/LoadingSpinner';
import ErrorDisplay from '../common/ErrorDisplay';
import type { GlobalLayoutLabelsBundle, ApiError } from '@/types';

interface AppShellProps { children: ReactNode; }

const AppShell: React.FC<AppShellProps> = ({ children }) => {
  const {
    labels: globalLabels, isPending, isError, error, isFetching, refetch
  } = useLocalizedView<null, GlobalLayoutLabelsBundle>(
    'globalLayoutViewContent', // Unique query key for this "view"
    fetchGlobalLayoutView
  );

  if (isPending && !globalLabels) {
    // Use a very generic loading text if global labels themselves are not available
    return <LoadingSpinner text={globalLabels?.loadingGeneric || "Initializing Application..."} />;
  }

  if (isError || !globalLabels) { // Critical error if global labels fail
    return (
      <div style={{ padding: '20px' }}>
        <ErrorDisplay
          error={error} // Error from the hook
          title={globalLabels?.appErrorHeading || "Application Shell Error"}
          messageTemplate={globalLabels?.appErrorGeneralMessage || "Core UI failed. Details: {message}"}
          onRetry={refetch}
          retryButtonText="Retry Loading Shell"
        />
      </div>
    );
  }

  return (
    <div className="app-shell">
      <Header labels={globalLabels} isFetching={isFetching && !!globalLabels}/> {/* Pass fetching only if labels are loaded */}
      <Navigation labels={globalLabels} />
      <hr />
      <main>{children}</main>
      <hr />
      <footer style={{ textAlign: 'center', marginTop: '20px', fontSize: '0.9em', color: '#7f8c8d' }}>
        <p>{globalLabels.footerText || "App Footer"}</p>
      </footer>
    </div>
  );
};
export default AppShell;
```

---

**21. `src/features/home/WelcomeSection.tsx`**

```tsx
// src/features/home/WelcomeSection.tsx
import React from 'react';
import type { HomeWelcomeSectionLabels } from '@/types';

interface WelcomeSectionProps {
  labels: HomeWelcomeSectionLabels | undefined;
  username: string | undefined;
}

const WelcomeSection: React.FC<WelcomeSectionProps> = ({ labels, username }) => {
  if (!labels || username === undefined) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Initializing welcome message...</p>;
  }
  const welcomeText = labels.welcomeMessage.replace('{user}', username);
  return <p>{welcomeText}</p>;
};
export default WelcomeSection;
```

---

**22. `src/features/home/MoodsSection.tsx`**

```tsx
// src/features/home/MoodsSection.tsx
import React from 'react';
import type { HomeMoodsSectionLabels, MoodItem } from '@/types';
import Button from '@/components/common/Button';

interface MoodsSectionProps {
  labels: HomeMoodsSectionLabels | undefined;
  moods: readonly MoodItem[] | undefined; // Made readonly in type
  onRefresh: () => void;
  isFetching?: boolean;
}

const MoodsSection: React.FC<MoodsSectionProps> = ({ labels, moods, onRefresh, isFetching }) => {
  if (!labels) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Loading moods section...</p>;
  }

  return (
    <section className="page-content" style={{marginTop: '20px'}}> {/* Use class for styling */}
      <h4>{labels.sectionTitle}</h4> {/* Use h4 for sections within a page normally */}
      {moods && moods.length > 0 ? (
        <ul>
          {moods.map(mood => (
            <li key={mood.id}>{mood.name}: <strong>{mood.feeling}</strong></li>
          ))}
        </ul>
      ) : (
        <p>{labels.noMoodsMessage}</p>
      )}
      <Button onClick={onRefresh} isLoading={isFetching} loadingText="Refreshing...">
        {labels.refreshButtonText}
      </Button>
    </section>
  );
};
export default MoodsSection;
```

---

**23. `src/features/settings/LanguageSettingsSection.tsx`**

```tsx
// src/features/settings/LanguageSettingsSection.tsx
import React, { useState, useEffect } from 'react';
import { useLanguage } from '@/context/LanguageProvider';
import type { Language, SettingsLanguageSectionLabels } from '@/types';
import Button from '@/components/common/Button';

interface LanguageSettingsSectionProps {
  labels: SettingsLanguageSectionLabels | undefined;
  isUpdatingPage?: boolean; // Indicates if the parent page is fetching new labels
}

const LanguageSettingsSection: React.FC<LanguageSettingsSectionProps> = ({ labels, isUpdatingPage }) => {
  const { language, setLanguage } = useLanguage();
  const [selectedLocalLang, setSelectedLocalLang] = useState<Language>(language);
  const [showSuccess, setShowSuccess] = useState(false);

  useEffect(() => {
    setSelectedLocalLang(language); // Sync with global changes
    if (showSuccess) setShowSuccess(false); // Hide success if global lang changes elsewhere
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [language]); // Only re-sync local if global language changes

  if (!labels) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Loading language settings...</p>;
  }

  const handleSave = () => {
    if (selectedLocalLang !== language) {
      setLanguage(selectedLocalLang); // This will trigger page label refetch
      setShowSuccess(true);
      setTimeout(() => setShowSuccess(false), 2500);
    }
  };

  const currentLangDisplay = labels.currentLanguageIs.replace('{lang}', language.toUpperCase());

  return (
    <section> {/* Sections could also use page-content class if desired */}
      <h4>{labels.sectionTitle}</h4>
      <p>{currentLangDisplay}</p>
      <div>
        <label htmlFor="lang-select-component" style={{ marginRight: '8px' }}>{labels.selectLanguagePrompt}</label>
        <select
          id="lang-select-component"
          value={selectedLocalLang}
          onChange={e => {
            setSelectedLocalLang(e.target.value as Language);
            if (showSuccess) setShowSuccess(false);
          }}
          disabled={isUpdatingPage}
        >
          <option value="en">{labels.langNameEn}</option>
          <option value="zh">{labels.langNameZh}</option>
        </select>
      </div>
      <Button
        onClick={handleSave}
        disabled={isUpdatingPage || selectedLocalLang === language}
        style={{marginTop: '15px'}}
        variant="primary"
      >
        {labels.saveButtonText}
      </Button>
      {showSuccess && <p style={{ color: 'green', marginTop: '10px', fontStyle:'italic' }}>{labels.successMessage}</p>}
    </section>
  );
};
export default LanguageSettingsSection;
```

---

**24. `src/pages/HomePage.tsx`**

```tsx
// src/pages/HomePage.tsx
import React from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchHomePageView } from '@/services';
import WelcomeSection from '@/features/home/WelcomeSection';
import MoodsSection from '@/features/home/MoodsSection';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import Button from '@/components/common/Button'; // Example of using common button
import type { HomePageViewDataPayload, HomePageViewLabelsBundle, ApiError } from '@/types';

const HomePage: React.FC = () => {
  const {
    data: pageData, labels: pageLabels, isPending, isError, error, refetch, isFetching
  } = useLocalizedView<HomePageViewDataPayload, HomePageViewLabelsBundle>(
    'homePageViewContent',
    fetchHomePageView
  );

  if (isPending && !pageLabels) { // Full page initial load
    return <LoadingSpinner text="Loading Home Page Content..." />;
  }

  if (isError && !pageLabels) { // Critical: Page labels failed
    return (
      <div className="page-content">
        <ErrorDisplay error={error} title="Home Page Error" onRetry={refetch} />
      </div>
    );
  }

  // If labels are partially/fully loaded, but an error occurred or still pending data
  // We can render the page shell with what we have.
  const isLoadingData = isPending || (isFetching && !pageData); // True if data is still being fetched/refetched

  return (
    <div className="page-container"> {/* Optional container for page styling */}
      <h2>{pageLabels?.pageTitle || "Dashboard"}</h2>

      <WelcomeSection labels={pageLabels?.welcomeSection} username={pageData?.username} />

      <MoodsSection
        labels={pageLabels?.moodsSection}
        moods={pageData?.moods}
        onRefresh={refetch}
        isFetching={isFetching}
      />

      {/* Example of a page-level button using a page-level label */}
      {pageLabels?.someActionText && (
        <Button onClick={() => alert('Action Confirmed!')} style={{marginTop: '20px'}}>
          {pageLabels.someActionText}
        </Button>
      )}

      {/* Show specific data error if labels loaded but data part failed */}
      {isError && pageData === undefined && pageLabels && (
         <ErrorDisplay
            error={error}
            title={pageLabels.moodsSection?.sectionTitle || "Data Fetch Error"}
            messageTemplate="Could not load mood data. Details: {message}"
            onRetry={refetch}
         />
       )}
       {isLoadingData && pageLabels && ( // Show spinner for data if labels are present
           <LoadingSpinner text="Fetching latest data..." />
       )}
    </div>
  );
};
export default HomePage;
```

---

**25. `src/pages/SettingsPage.tsx`**

```tsx
// src/pages/SettingsPage.tsx
import React from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchSettingsPageView } from '@/services';
import LanguageSettingsSection from '@/features/settings/LanguageSettingsSection';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import type { SettingsPageViewLabelsBundle, ApiError } from '@/types';

const SettingsPage: React.FC = () => {
  const {
    labels: pageLabels, isPending, isError, error, refetch, isFetching
  } = useLocalizedView<null, SettingsPageViewLabelsBundle>(
    'settingsPageViewContent',
    fetchSettingsPageView
  );

  if (isPending && !pageLabels) { // Full page initial load
    return <LoadingSpinner text="Loading Settings Page Content..." />;
  }

  if (isError || !pageLabels) { // Critical: Page labels failed
     return (
      <div className="page-content">
        <ErrorDisplay
          error={error}
          title={pageLabels?.pageTitle || "Settings Load Error"}
          messageTemplate="Could not load settings. Details: {message}"
          onRetry={refetch}
        />
      </div>
    );
  }

  return (
    <div className="page-content"> {/* Using class for consistent page styling */}
      <h2>{pageLabels.pageTitle || "Settings"}</h2>
      <LanguageSettingsSection
        labels={pageLabels.languageSection}
        isUpdatingPage={isFetching && !!pageLabels} // Page is fetching if labels are present but still fetching
      />
      {/* Other settings sections would be added here */}
    </div>
  );
};
export default SettingsPage;
```

---

**26. `src/router.tsx`**

```tsx
// src/router.tsx
import React, { Suspense, lazy } from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// Lazy load page components
const HomePage = lazy(() => import('@/pages/HomePage'));
const SettingsPage = lazy(() => import('@/pages/SettingsPage'));

const AppRouter: React.FC = () => {
  return (
    <Suspense fallback={<LoadingSpinner text="Loading view..." />}>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/settings" element={<SettingsPage />} />
        <Route path="*" element={<Navigate to="/" replace />} /> {/* Fallback route */}
      </Routes>
    </Suspense>
  );
};
export default AppRouter;
```

---

**27. `src/App.tsx`**

```tsx
// src/App.tsx
import React, { useEffect } from 'react';
import { BrowserRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
// import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { LanguageProvider } from '@/context/LanguageProvider';
import { populateDB } from '@/db';
import AppShell from '@/components/layout/AppShell';
import AppRouter from '@/router';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 2, // 2 minutes
      refetchOnWindowFocus: false, // Personal preference for demos
      retry: 1, // Retry failed queries once
    },
  },
});

const App: React.FC = () => {
  useEffect(() => {
    // Populate Dexie DB on app start for development
    if (import.meta.env.DEV) { // Vite specific dev check
      populateDB().catch(err => {
        console.error("Failed to populate Dexie DB:", err);
      });
    }
  }, []);

  return (
    <QueryClientProvider client={queryClient}>
      <LanguageProvider>
        <BrowserRouter>
          <AppShell> {/* AppShell fetches global layout labels and provides overall structure */}
            <AppRouter /> {/* AppRouter handles page-specific content and routing */}
          </AppShell>
        </BrowserRouter>
      </LanguageProvider>
      {/* <ReactQueryDevtools initialIsOpen={false} /> */}
    </QueryClientProvider>
  );
};
export default App;
```

---

**28. `src/main.tsx`**

```tsx
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';
import './index.css'; // Global styles

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
```

---

This V3 Final version provides a clean, well-structured, and type-safe foundation. The README clearly outlines the architecture, making it suitable for team collaboration. Key improvements include refined naming, a dedicated `useLocalizedView` hook, and clearer separation of concerns with page components fetching all necessary content and delegating rendering to feature-specific sections.
</file>

<file path="src/components/animation/AnimatedButton.tsx">
// src/components/animation/AnimatedButton.tsx
import React from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import Button from '@/components/common/Button';

interface AnimatedButtonProps extends HTMLMotionProps<'button'> {
  variant?: 'primary' | 'secondary' | 'jade' | 'gold';
  isLoading?: boolean;
  loadingText?: string;
  children: React.ReactNode;
  whileHover?: object;
  whileTap?: object;
  className?: string;
  onClick?: () => void;
}

/**
 * 动画按钮组件，为Button组件添加动画效果
 * 
 * @param variant - 按钮变体
 * @param isLoading - 是否显示加载状态
 * @param loadingText - 加载状态文本
 * @param children - 子元素
 * @param whileHover - 悬停动画
 * @param whileTap - 点击动画
 * @param className - CSS类名
 * @param onClick - 点击事件处理函数
 */
const AnimatedButton: React.FC<AnimatedButtonProps> = ({
  variant = 'primary',
  isLoading = false,
  loadingText,
  children,
  whileHover = { scale: 1.05 },
  whileTap = { scale: 0.95 },
  className = '',
  onClick,
  ...props
}) => {
  // 根据变体设置不同的动画效果
  const getAnimationProps = () => {
    switch (variant) {
      case 'jade':
        return {
          whileHover: { 
            scale: 1.05, 
            boxShadow: '0 0 15px rgba(136, 176, 75, 0.5)' 
          },
          whileTap: { 
            scale: 0.95 
          }
        };
      case 'gold':
        return {
          whileHover: { 
            scale: 1.05, 
            boxShadow: '0 0 15px rgba(212, 175, 55, 0.5)' 
          },
          whileTap: { 
            scale: 0.95 
          }
        };
      default:
        return {
          whileHover,
          whileTap
        };
    }
  };

  const animationProps = getAnimationProps();

  return (
    <motion.div
      className={`animated-button-container ${className}`}
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: 10 }}
      {...animationProps}
      {...props}
    >
      <Button
        variant={variant}
        isLoading={isLoading}
        loadingText={loadingText}
        onClick={onClick}
        style={{ width: '100%', height: '100%' }}
      >
        {children}
      </Button>
    </motion.div>
  );
};

export default AnimatedButton;
</file>

<file path="src/components/animation/AnimatedContainer.tsx">
// src/components/animation/AnimatedContainer.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { createContainerVariants } from '@/utils/animation';

interface AnimatedContainerProps extends HTMLMotionProps<'div'> {
  children: ReactNode;
  variants?: Variants;
  staggerChildren?: number;
  delayChildren?: number;
  className?: string;
  initial?: string | object;
  animate?: string | object;
  exit?: string | object;
}

/**
 * 动画容器组件，用于为子元素添加交错动画效果
 * 
 * @param children - 子元素
 * @param variants - 动画变体
 * @param staggerChildren - 子元素之间的延迟时间
 * @param delayChildren - 所有子元素的初始延迟
 * @param className - CSS类名
 * @param initial - 初始动画状态
 * @param animate - 动画状态
 * @param exit - 退出动画状态
 */
const AnimatedContainer: React.FC<AnimatedContainerProps> = ({
  children,
  variants,
  staggerChildren = 0.1,
  delayChildren = 0,
  className = '',
  initial = 'hidden',
  animate = 'visible',
  exit = 'exit',
  ...props
}) => {
  // 如果没有提供变体，则使用默认的容器变体
  const containerVariants = variants || createContainerVariants(staggerChildren, delayChildren);

  return (
    <motion.div
      className={className}
      variants={containerVariants}
      initial={initial}
      animate={animate}
      exit={exit}
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default AnimatedContainer;
</file>

<file path="src/components/animation/AnimatedItem.tsx">
// src/components/animation/AnimatedItem.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { listItem } from '@/utils/animation';

interface AnimatedItemProps extends HTMLMotionProps<'div'> {
  children: ReactNode;
  variants?: Variants;
  index?: number;
  className?: string;
  initial?: string | object;
  animate?: string | object;
  exit?: string | object;
}

/**
 * 动画项组件，用于为列表项添加动画效果
 * 
 * @param children - 子元素
 * @param variants - 动画变体
 * @param index - 项目索引，用于计算延迟
 * @param className - CSS类名
 * @param initial - 初始动画状态
 * @param animate - 动画状态
 * @param exit - 退出动画状态
 */
const AnimatedItem: React.FC<AnimatedItemProps> = ({
  children,
  variants = listItem,
  index = 0,
  className = '',
  initial = 'hidden',
  animate = 'visible',
  exit = 'exit',
  ...props
}) => {
  return (
    <motion.div
      className={className}
      variants={variants}
      initial={initial}
      animate={animate}
      exit={exit}
      custom={index}
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default AnimatedItem;
</file>

<file path="src/components/animation/AnimatedTaskCard.tsx">
// src/components/animation/AnimatedTaskCard.tsx
import React, { forwardRef } from 'react';
import { motion } from 'framer-motion';
import TaskCard from '@/components/game/TaskCard';
import { TaskRecord } from '@/services/taskService';
import { listItem } from '@/utils/animation';

interface AnimatedTaskCardProps {
  task: TaskRecord;
  onComplete?: (taskId: number) => void;
  onEdit?: (taskId: number) => void;
  onDelete?: (taskId: number) => void;
  index?: number;
  className?: string;
}

/**
 * 动画任务卡片组件，为TaskCard组件添加动画效果
 * 
 * @param task - 任务数据
 * @param onComplete - 完成任务回调
 * @param onEdit - 编辑任务回调
 * @param onDelete - 删除任务回调
 * @param index - 索引，用于计算动画延迟
 * @param className - CSS类名
 */
const AnimatedTaskCard = forwardRef<HTMLDivElement, AnimatedTaskCardProps>(({
  task,
  onComplete,
  onEdit,
  onDelete,
  index = 0,
  className = ''
}, ref) => {
  return (
    <motion.div
      ref={ref}
      variants={listItem}
      initial="hidden"
      animate="visible"
      exit="exit"
      custom={index}
      layout
      layoutId={`task-${task.id}`}
      whileHover={{ 
        y: -5, 
        boxShadow: '0 10px 20px rgba(0, 0, 0, 0.1)',
        transition: { duration: 0.2 }
      }}
    >
      <TaskCard
        task={task}
        onComplete={onComplete}
        onEdit={onEdit}
        onDelete={onDelete}
        className={className}
      />
    </motion.div>
  );
});

export default AnimatedTaskCard;
</file>

<file path="src/components/animation/AnimatedTaskList.tsx">
// src/components/animation/AnimatedTaskList.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { AnimatePresence } from 'framer-motion';
import {
  TaskRecord,
  TaskStatus,
  TaskPriority,
  TaskType,
  getAllTasks,
  completeTask,
  deleteTask
} from '@/services/taskService';

// 扩展Window接口，添加全局回调函数
declare global {
  interface Window {
    handleCompletionAnimationEnd?: () => void;
  }
}
import { RewardRecord } from '@/services/rewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import { TimelyRewardRecord } from '@/services/timelyRewardService';
import AnimatedContainer from './AnimatedContainer';
import AnimatedTaskCard from './AnimatedTaskCard';
import AnimatedButton from './AnimatedButton';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import RewardModal from '@/components/game/RewardModal';
import TimelyRewardCard from '@/components/game/TimelyRewardCard';
import TaskCompletionAnimation from './TaskCompletionAnimation';
import { createContainerVariants } from '@/utils/animation';

interface AnimatedTaskListProps {
  onEditTask: (taskId: number) => void;
  filter?: {
    status?: TaskStatus;
    categoryId?: number;
    type?: TaskType;
    priority?: TaskPriority;
  };
  refreshTrigger?: number;
}

/**
 * 动画任务列表组件，为任务列表添加动画效果
 *
 * @param onEditTask - 编辑任务回调
 * @param filter - 过滤条件
 * @param refreshTrigger - 刷新触发器
 */
const AnimatedTaskList: React.FC<AnimatedTaskListProps> = ({
  onEditTask,
  filter,
  refreshTrigger = 0
}) => {
  const [tasks, setTasks] = useState<TaskRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [showRewardModal, setShowRewardModal] = useState(false);
  const [timelyReward, setTimelyReward] = useState<TimelyRewardRecord | null>(null);
  const [showTimelyReward, setShowTimelyReward] = useState(false);
  const [completedTask, setCompletedTask] = useState<TaskRecord | null>(null);
  const [showCompletionAnimation, setShowCompletionAnimation] = useState(false);

  // 加载任务
  const loadTasks = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const taskList = await getAllTasks(filter);
      setTasks(taskList);
    } catch (err) {
      console.error('Failed to load tasks:', err);
      setError('加载任务失败，请重试');
    } finally {
      setIsLoading(false);
    }
  }, [filter]);

  // 初始加载和刷新触发器变化时加载任务
  useEffect(() => {
    loadTasks();
  }, [loadTasks, refreshTrigger]);

  // 定义任务数据更新处理函数 - 使用 useRef 来避免依赖变化
  const filterRef = React.useRef(filter);
  const loadTasksRef = React.useRef(loadTasks);

  // 更新 refs 当依赖变化时
  React.useEffect(() => {
    filterRef.current = filter;
    loadTasksRef.current = loadTasks;
  }, [filter, loadTasks]);

  // 使用稳定的回调函数，不依赖于 filter 或 loadTasks
  const handleTaskDataUpdate = useCallback((taskData: any) => {
    // 使用 ref 值而不是直接依赖
    const currentFilter = filterRef.current;
    const currentLoadTasks = loadTasksRef.current;

    // 如果有特定任务数据，则更新该任务
    if (taskData && taskData.id) {
      setTasks(prevTasks => {
        // 检查任务是否已存在
        const taskExists = prevTasks.some(task => task.id === taskData.id);

        if (taskExists) {
          // 更新现有任务
          return prevTasks.map(task =>
            task.id === taskData.id ? { ...task, ...taskData } : task
          );
        } else {
          // 添加新任务（如果符合过滤条件）
          if (!currentFilter ||
              ((!currentFilter.status || taskData.status === currentFilter.status) &&
               (!currentFilter.categoryId || taskData.categoryId === currentFilter.categoryId) &&
               (!currentFilter.type || taskData.type === currentFilter.type) &&
               (!currentFilter.priority || taskData.priority === currentFilter.priority))) {
            return [...prevTasks, taskData];
          }
          return prevTasks;
        }
      });
    } else {
      // 如果没有特定任务数据，则重新加载所有任务
      currentLoadTasks();
    }
  }, [/* 没有依赖项，使用 ref 来获取最新值 */]);

  // 使用 useRegisterTableRefresh hook 监听任务表的变化
  React.useEffect(() => {
    useRegisterTableRefresh('tasks', handleTaskDataUpdate);
    // Debug: log when registered
    console.log('Registered table refresh for tasks');
    // No cleanup needed as hook likely handles it
  }, []);

  // 处理完成任务
  const handleCompleteTask = async (taskId: number) => {
    try {
      setIsLoading(true);

      // 获取要完成的任务
      const taskToComplete = tasks.find(task => task.id === taskId);
      if (!taskToComplete) {
        throw new Error('任务不存在');
      }

      // 先显示任务完成动画
      setCompletedTask(taskToComplete);
      setShowCompletionAnimation(true);

      // 完成任务并获取奖励
      const result = await completeTask(taskId);

      // 不需要手动更新任务列表，数据同步服务会自动触发更新
      // 但为了UI立即响应，我们仍然更新本地状态
      setTasks(prevTasks =>
        prevTasks.map(task =>
          task.id === taskId
            ? { ...task, status: TaskStatus.COMPLETED, completedAt: new Date() }
            : task
        )
      );

      // 动画完成后显示奖励
      const handleCompletionAnimationEnd = () => {
        setShowCompletionAnimation(false);

        // 显示奖励
        if (result.rewards && result.rewards.length > 0) {
          setTimeout(() => {
            setRewards(result.rewards);
            setShowRewardModal(true);
          }, 300);
        }

        // 如果有及时奖励，显示及时奖励
        if (result.timelyReward) {
          setTimelyReward(result.timelyReward);

          // 延迟显示及时奖励，先显示任务奖励
          if (result.rewards && result.rewards.length > 0) {
            setTimeout(() => {
              setShowTimelyReward(true);
            }, 1000);
          } else {
            setTimeout(() => {
              setShowTimelyReward(true);
            }, 500);
          }
        }
      };

      // 如果动画已经完成，直接显示奖励
      if (!showCompletionAnimation) {
        handleCompletionAnimationEnd();
      } else {
        // 否则等待动画完成
        window.handleCompletionAnimationEnd = handleCompletionAnimationEnd;
      }
    } catch (err) {
      console.error('Failed to complete task:', err);
      setError('完成任务失败，请重试');
      setShowCompletionAnimation(false);
    } finally {
      setIsLoading(false);
    }
  };

  // 处理删除任务
  const handleDeleteTask = async (taskId: number) => {
    if (!window.confirm('确定要删除这个任务吗？')) {
      return;
    }

    try {
      setIsLoading(true);
      await deleteTask(taskId);

      // 不需要手动更新任务列表，数据同步服务会自动触发更新
      // 但为了UI立即响应，我们仍然更新本地状态
      setTasks(prevTasks => prevTasks.filter(task => task.id !== taskId));
    } catch (err) {
      console.error('Failed to delete task:', err);
      setError('删除任务失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 按优先级排序任务
  const sortedTasks = [...tasks].sort((a, b) => {
    // 首先按状态排序（未完成的在前）
    if (a.status !== b.status) {
      if (a.status === TaskStatus.COMPLETED) return 1;
      if (b.status === TaskStatus.COMPLETED) return -1;
    }

    // 然后按优先级排序
    const priorityOrder = {
      [TaskPriority.HIGH]: 0,
      [TaskPriority.MEDIUM]: 1,
      [TaskPriority.LOW]: 2
    };

    return priorityOrder[a.priority] - priorityOrder[b.priority];
  });

  if (isLoading && tasks.length === 0) {
    return <LoadingSpinner variant="jade" text="加载任务中..." />;
  }

  if (error) {
    return (
      <div className="task-list-error">
        <p>{error}</p>
        <AnimatedButton variant="jade" onClick={() => window.location.reload()}>
          重试
        </AnimatedButton>
      </div>
    );
  }

  if (tasks.length === 0) {
    return (
      <AnimatedContainer
        variants={createContainerVariants(0.1, 0.2)}
        className="task-list-empty"
      >
        <p>暂无任务</p>
      </AnimatedContainer>
    );
  }

  // 关闭奖励模态框
  const handleCloseRewardModal = () => {
    setShowRewardModal(false);
    setRewards([]);

    // 如果有及时奖励，显示及时奖励
    if (timelyReward && !showTimelyReward) {
      setTimeout(() => {
        setShowTimelyReward(true);
      }, 500);
    }
  };

  // 关闭及时奖励
  const handleCloseTimelyReward = () => {
    setShowTimelyReward(false);
    setTimelyReward(null);
  };

  return (
    <div className="task-list">
      {isLoading && (
        <div className="task-list-loading-overlay">
          <LoadingSpinner variant="jade" />
        </div>
      )}

      <AnimatedContainer
        variants={createContainerVariants(0.05, 0)}
      >
        <AnimatePresence mode="popLayout">
          {sortedTasks.map((task, index) => (
            <AnimatedTaskCard
              key={task.id}
              task={task}
              index={index}
              onComplete={handleCompleteTask}
              onEdit={onEditTask}
              onDelete={handleDeleteTask}
            />
          ))}
        </AnimatePresence>
      </AnimatedContainer>

      {/* 奖励模态框 */}
      {showRewardModal && (
        <RewardModal
          isOpen={showRewardModal}
          onClose={handleCloseRewardModal}
          rewards={rewards}
        />
      )}

      {/* 及时奖励模态框 */}
      {showTimelyReward && timelyReward && (
        <div className="timely-reward-modal">
          <div className="timely-reward-modal-backdrop" onClick={handleCloseTimelyReward}></div>
          <div className="timely-reward-modal-content">
            <h3 className="timely-reward-modal-title">及时奖励</h3>
            <p className="timely-reward-modal-description">
              恭喜！你在规定时间内完成了任务，获得了及时奖励！
            </p>
            <TimelyRewardCard
              reward={timelyReward}
              onComplete={() => {}}
            />
            <div className="timely-reward-modal-actions">
              <AnimatedButton onClick={handleCloseTimelyReward}>
                关闭
              </AnimatedButton>
            </div>
          </div>
        </div>
      )}

      {/* 任务完成动画 */}
      {showCompletionAnimation && completedTask && (
        <TaskCompletionAnimation
          task={completedTask}
          style={completedTask.priority === TaskPriority.HIGH ? 'fireworks' :
                 completedTask.type === TaskType.MAIN ? 'stars' : 'confetti'}
          onAnimationComplete={() => {
            setShowCompletionAnimation(false);
            // 调用全局回调函数（如果存在）
            if (window.handleCompletionAnimationEnd) {
              window.handleCompletionAnimationEnd();
              delete window.handleCompletionAnimationEnd;
            }
          }}
        />
      )}
    </div>
  );
};

export default AnimatedTaskList;
</file>

<file path="src/components/animation/GoldenGlow.tsx">
// src/components/animation/GoldenGlow.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { goldenGlow } from '@/utils/animation';

interface GoldenGlowProps extends HTMLMotionProps<'div'> {
  children: ReactNode;
  variants?: Variants;
  className?: string;
  intensity?: 'low' | 'medium' | 'high';
  onClick?: () => void;
}

/**
 * 金光效果动画组件，用于创建中国风金光动画效果
 * 
 * @param children - 子元素
 * @param variants - 动画变体
 * @param className - CSS类名
 * @param intensity - 强度
 * @param onClick - 点击事件处理函数
 */
const GoldenGlow: React.FC<GoldenGlowProps> = ({
  children,
  variants = goldenGlow,
  className = '',
  intensity = 'medium',
  onClick,
  ...props
}) => {
  // 根据强度设置样式
  const intensityStyles = {
    low: { 
      boxShadow: '0 0 10px 2px rgba(212, 175, 55, 0.3)',
      filter: 'brightness(1.1) saturate(1.1)'
    },
    medium: { 
      boxShadow: '0 0 15px 5px rgba(212, 175, 55, 0.5)',
      filter: 'brightness(1.2) saturate(1.2)'
    },
    high: { 
      boxShadow: '0 0 20px 10px rgba(212, 175, 55, 0.7)',
      filter: 'brightness(1.3) saturate(1.3)'
    }
  };

  return (
    <motion.div
      className={`golden-glow ${className}`}
      variants={variants}
      initial="hidden"
      animate="visible"
      exit="exit"
      style={{
        position: 'relative',
        ...intensityStyles[intensity],
        ...props.style
      }}
      onClick={onClick}
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default GoldenGlow;
</file>

<file path="src/components/animation/InkSplash.tsx">
// src/components/animation/InkSplash.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { inkSplash } from '@/utils/animation';

interface InkSplashProps extends HTMLMotionProps<'div'> {
  children?: ReactNode;
  variants?: Variants;
  className?: string;
  size?: 'small' | 'medium' | 'large';
  color?: string;
  onClick?: () => void;
}

/**
 * 水墨效果动画组件，用于创建中国风水墨动画效果
 * 
 * @param children - 子元素
 * @param variants - 动画变体
 * @param className - CSS类名
 * @param size - 大小
 * @param color - 颜色
 * @param onClick - 点击事件处理函数
 */
const InkSplash: React.FC<InkSplashProps> = ({
  children,
  variants = inkSplash,
  className = '',
  size = 'medium',
  color = 'var(--royal-jade)',
  onClick,
  ...props
}) => {
  // 根据大小设置样式
  const sizeStyles = {
    small: { width: '50px', height: '50px' },
    medium: { width: '100px', height: '100px' },
    large: { width: '150px', height: '150px' }
  };

  return (
    <motion.div
      className={`ink-splash ${className}`}
      variants={variants}
      initial="hidden"
      animate="visible"
      exit="exit"
      style={{
        ...sizeStyles[size],
        backgroundColor: color,
        borderRadius: '50%',
        filter: 'blur(5px)',
        position: 'relative',
        overflow: 'hidden',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        ...props.style
      }}
      onClick={onClick}
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default InkSplash;
</file>

<file path="src/components/animation/PageTransition.tsx">
// src/components/animation/PageTransition.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { pageTransition } from '@/utils/animation';

interface PageTransitionProps extends HTMLMotionProps<'div'> {
  children: ReactNode;
  variants?: Variants;
  className?: string;
}

/**
 * 页面过渡组件，用于为页面添加进入和退出动画
 * 
 * @param children - 子元素
 * @param variants - 动画变体
 * @param className - CSS类名
 */
const PageTransition: React.FC<PageTransitionProps> = ({
  children,
  variants = pageTransition,
  className = '',
  ...props
}) => {
  return (
    <motion.div
      className={className}
      variants={variants}
      initial="hidden"
      animate="visible"
      exit="exit"
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default PageTransition;
</file>

<file path="src/components/animation/RewardAnimation.tsx">
// src/components/animation/RewardAnimation.tsx
import React, { useEffect, useState } from 'react';
import { motion, Variants, AnimatePresence } from 'framer-motion';
import { RewardType, RewardRarity } from '@/services/rewardService';
import { playRewardSound } from '@/utils/sound';

interface RewardAnimationProps {
  type: RewardType;
  rarity: RewardRarity;
  iconPath: string;
  amount?: number;
  size?: number;
  onAnimationComplete?: () => void;
  animationStyle?: 'default' | 'burst' | 'float' | 'spin' | 'pulse';
  playSound?: boolean;
  soundVolume?: number;
}

/**
 * 奖励动画组件
 * 显示奖励获取的动画效果
 *
 * @param type - 奖励类型
 * @param rarity - 奖励稀有度
 * @param iconPath - 图标路径
 * @param amount - 奖励数量
 * @param size - 图标大小
 * @param onAnimationComplete - 动画完成回调
 */
const RewardAnimation: React.FC<RewardAnimationProps> = ({
  type,
  rarity,
  iconPath,
  amount = 1,
  size = 100,
  onAnimationComplete,
  animationStyle = 'default',
  playSound = true,
  soundVolume = 0.5
}) => {
  // 动画完成状态
  const [isAnimationComplete, setIsAnimationComplete] = useState(false);

  // 播放音效
  useEffect(() => {
    if (playSound) {
      playRewardSound(rarity, soundVolume);
    }
  }, [playSound, rarity, soundVolume]);
  // 根据稀有度获取光晕颜色
  const getGlowColor = (rarity: RewardRarity): string => {
    switch (rarity) {
      case RewardRarity.COMMON:
        return 'rgba(255, 255, 255, 0.7)';
      case RewardRarity.UNCOMMON:
        return 'rgba(75, 175, 80, 0.7)';
      case RewardRarity.RARE:
        return 'rgba(33, 150, 243, 0.7)';
      case RewardRarity.EPIC:
        return 'rgba(156, 39, 176, 0.7)';
      case RewardRarity.LEGENDARY:
        return 'rgba(255, 193, 7, 0.7)';
      default:
        return 'rgba(255, 255, 255, 0.7)';
    }
  };

  // 根据稀有度获取粒子数量
  const getParticleCount = (rarity: RewardRarity): number => {
    switch (rarity) {
      case RewardRarity.COMMON:
        return 5;
      case RewardRarity.UNCOMMON:
        return 10;
      case RewardRarity.RARE:
        return 15;
      case RewardRarity.EPIC:
        return 20;
      case RewardRarity.LEGENDARY:
        return 25;
      default:
        return 5;
    }
  };

  // 获取图标动画变体
  const getIconVariants = (): Variants => {
    // 默认动画
    const defaultVariants: Variants = {
      hidden: {
        scale: 0,
        opacity: 0,
        rotate: -180
      },
      visible: {
        scale: 1,
        opacity: 1,
        rotate: 0,
        transition: {
          type: 'spring',
          damping: 10,
          stiffness: 100,
          duration: 0.8
        }
      },
      exit: {
        scale: 0,
        opacity: 0,
        transition: {
          duration: 0.3
        }
      }
    };

    // 爆发动画
    const burstVariants: Variants = {
      hidden: {
        scale: 0,
        opacity: 0,
      },
      visible: {
        scale: [0, 1.5, 1],
        opacity: [0, 1, 1],
        transition: {
          times: [0, 0.6, 1],
          duration: 1,
          ease: "easeOut"
        }
      },
      exit: {
        scale: [1, 1.2, 0],
        opacity: [1, 1, 0],
        transition: {
          duration: 0.5
        }
      }
    };

    // 浮动动画
    const floatVariants: Variants = {
      hidden: {
        y: 50,
        opacity: 0,
      },
      visible: {
        y: [50, -10, 0],
        opacity: [0, 1, 1],
        transition: {
          times: [0, 0.6, 1],
          duration: 1.2,
          ease: "easeOut"
        }
      },
      exit: {
        y: -50,
        opacity: 0,
        transition: {
          duration: 0.5
        }
      }
    };

    // 旋转动画
    const spinVariants: Variants = {
      hidden: {
        scale: 0,
        opacity: 0,
        rotate: 0
      },
      visible: {
        scale: 1,
        opacity: 1,
        rotate: 360 * 2,
        transition: {
          duration: 1.2,
          ease: "easeOut"
        }
      },
      exit: {
        scale: 0,
        opacity: 0,
        rotate: 180,
        transition: {
          duration: 0.5
        }
      }
    };

    // 脉冲动画
    const pulseVariants: Variants = {
      hidden: {
        scale: 0.8,
        opacity: 0,
      },
      visible: {
        scale: [0.8, 1.1, 1, 1.05, 1],
        opacity: 1,
        transition: {
          times: [0, 0.3, 0.5, 0.8, 1],
          duration: 1,
          ease: "easeInOut",
          repeat: 0
        }
      },
      exit: {
        scale: 0.8,
        opacity: 0,
        transition: {
          duration: 0.3
        }
      }
    };

    // 根据动画样式返回对应的变体
    switch (animationStyle) {
      case 'burst':
        return burstVariants;
      case 'float':
        return floatVariants;
      case 'spin':
        return spinVariants;
      case 'pulse':
        return pulseVariants;
      default:
        return defaultVariants;
    }
  };

  // 获取当前动画变体
  const iconVariants = getIconVariants();

  // 数量动画变体
  const amountVariants: Variants = {
    hidden: {
      opacity: 0,
      y: 20
    },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        delay: 0.3,
        duration: 0.5
      }
    },
    exit: {
      opacity: 0,
      y: -20,
      transition: {
        duration: 0.2
      }
    }
  };

  // 光晕动画变体
  const getGlowVariants = (): Variants => {
    // 默认光晕动画
    const defaultGlowVariants: Variants = {
      hidden: {
        scale: 0.5,
        opacity: 0
      },
      visible: {
        scale: [0.5, 1.2, 1],
        opacity: [0, 0.8, 0.5],
        transition: {
          times: [0, 0.5, 1],
          duration: 1
        }
      }
    };

    // 稀有和史诗光晕动画（更强烈的脉冲）
    const rareGlowVariants: Variants = {
      hidden: {
        scale: 0.5,
        opacity: 0
      },
      visible: {
        scale: [0.5, 1.3, 0.9, 1.1, 1],
        opacity: [0, 0.9, 0.7, 0.8, 0.6],
        transition: {
          times: [0, 0.3, 0.5, 0.7, 1],
          duration: 1.5,
          repeat: Infinity,
          repeatType: "reverse"
        }
      }
    };

    // 传说光晕动画（彩虹色变化）
    const legendaryGlowVariants: Variants = {
      hidden: {
        scale: 0.5,
        opacity: 0
      },
      visible: {
        scale: [0.8, 1.2, 1, 1.1, 0.9, 1],
        opacity: [0.3, 0.8, 0.6, 0.7, 0.5, 0.6],
        transition: {
          times: [0, 0.2, 0.4, 0.6, 0.8, 1],
          duration: 3,
          repeat: Infinity,
          repeatType: "loop"
        }
      }
    };

    // 根据稀有度返回对应的光晕动画
    if (rarity === RewardRarity.LEGENDARY) {
      return legendaryGlowVariants;
    } else if (rarity === RewardRarity.EPIC || rarity === RewardRarity.RARE) {
      return rareGlowVariants;
    } else {
      return defaultGlowVariants;
    }
  };

  const glowVariants = getGlowVariants();

  // 生成随机粒子
  const renderParticles = () => {
    const particleCount = getParticleCount(rarity);
    const particles = [];

    // 根据稀有度和动画样式调整粒子效果
    const getParticleStyle = () => {
      // 默认粒子样式
      if (animationStyle === 'default' || animationStyle === 'pulse') {
        // 标准放射状粒子
        for (let i = 0; i < particleCount; i++) {
          const angle = (i / particleCount) * 360;
          const distance = Math.random() * 50 + 50;
          const delay = Math.random() * 0.3;
          const duration = Math.random() * 0.5 + 0.5;
          const size = Math.random() * 6 + 4;

          particles.push(
            <motion.div
              key={`standard-${i}`}
              style={{
                position: 'absolute',
                width: size,
                height: size,
                borderRadius: '50%',
                backgroundColor: getGlowColor(rarity),
                top: '50%',
                left: '50%',
                margin: `-${size / 2}px 0 0 -${size / 2}px`
              }}
              initial={{
                x: 0,
                y: 0,
                opacity: 0
              }}
              animate={{
                x: Math.cos(angle * Math.PI / 180) * distance,
                y: Math.sin(angle * Math.PI / 180) * distance,
                opacity: [0, 1, 0],
                scale: [1, 1.5, 0.5]
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'easeOut'
              }}
            />
          );
        }
      }

      // 爆发式粒子 - 更多、更快的粒子
      if (animationStyle === 'burst') {
        for (let i = 0; i < particleCount * 1.5; i++) {
          const angle = Math.random() * 360;
          const distance = Math.random() * 80 + 40;
          const delay = Math.random() * 0.2;
          const duration = Math.random() * 0.4 + 0.3;
          const size = Math.random() * 5 + 3;

          particles.push(
            <motion.div
              key={`burst-${i}`}
              style={{
                position: 'absolute',
                width: size,
                height: size,
                borderRadius: '50%',
                backgroundColor: getGlowColor(rarity),
                top: '50%',
                left: '50%',
                margin: `-${size / 2}px 0 0 -${size / 2}px`
              }}
              initial={{
                x: 0,
                y: 0,
                opacity: 0
              }}
              animate={{
                x: Math.cos(angle * Math.PI / 180) * distance,
                y: Math.sin(angle * Math.PI / 180) * distance,
                opacity: [0, 1, 0],
                scale: [1, 2, 0]
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'easeOut'
              }}
            />
          );
        }
      }

      // 浮动粒子 - 上升的粒子
      if (animationStyle === 'float') {
        for (let i = 0; i < particleCount; i++) {
          const xOffset = (Math.random() - 0.5) * 80;
          const yDistance = -1 * (Math.random() * 60 + 40);
          const delay = Math.random() * 0.5;
          const duration = Math.random() * 1 + 1;
          const size = Math.random() * 6 + 3;

          particles.push(
            <motion.div
              key={`float-${i}`}
              style={{
                position: 'absolute',
                width: size,
                height: size,
                borderRadius: '50%',
                backgroundColor: getGlowColor(rarity),
                top: '50%',
                left: '50%',
                margin: `-${size / 2}px 0 0 -${size / 2}px`
              }}
              initial={{
                x: xOffset / 3,
                y: 10,
                opacity: 0
              }}
              animate={{
                x: xOffset,
                y: yDistance,
                opacity: [0, 0.8, 0],
                scale: [0.8, 1.2, 0.5]
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'easeOut'
              }}
            />
          );
        }
      }

      // 旋转粒子 - 围绕中心旋转
      if (animationStyle === 'spin') {
        for (let i = 0; i < particleCount; i++) {
          const radius = Math.random() * 30 + 30;
          const startAngle = Math.random() * 360;
          const duration = Math.random() * 2 + 2;
          const delay = Math.random() * 0.3;
          const size = Math.random() * 5 + 3;

          particles.push(
            <motion.div
              key={`spin-${i}`}
              style={{
                position: 'absolute',
                width: size,
                height: size,
                borderRadius: '50%',
                backgroundColor: getGlowColor(rarity),
                top: '50%',
                left: '50%',
                margin: `-${size / 2}px 0 0 -${size / 2}px`
              }}
              initial={{
                opacity: 0,
                x: Math.cos(startAngle * Math.PI / 180) * radius,
                y: Math.sin(startAngle * Math.PI / 180) * radius,
              }}
              animate={{
                opacity: [0, 0.8, 0.8, 0],
                x: [
                  Math.cos(startAngle * Math.PI / 180) * radius,
                  Math.cos((startAngle + 120) * Math.PI / 180) * radius,
                  Math.cos((startAngle + 240) * Math.PI / 180) * radius,
                  Math.cos((startAngle + 360) * Math.PI / 180) * radius
                ],
                y: [
                  Math.sin(startAngle * Math.PI / 180) * radius,
                  Math.sin((startAngle + 120) * Math.PI / 180) * radius,
                  Math.sin((startAngle + 240) * Math.PI / 180) * radius,
                  Math.sin((startAngle + 360) * Math.PI / 180) * radius
                ]
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'linear',
                times: [0, 0.33, 0.66, 1]
              }}
            />
          );
        }
      }

      // 传说级特效 - 额外的星星粒子
      if (rarity === RewardRarity.LEGENDARY) {
        // 添加星形粒子
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * 360;
          const distance = Math.random() * 30 + 60;
          const delay = Math.random() * 0.5 + 0.5;
          const duration = Math.random() * 1.5 + 1.5;

          particles.push(
            <motion.div
              key={`star-${i}`}
              style={{
                position: 'absolute',
                width: 10,
                height: 10,
                top: '50%',
                left: '50%',
                margin: '-5px 0 0 -5px',
                clipPath: 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
                backgroundColor: '#FFD700',
                boxShadow: '0 0 10px #FFD700'
              }}
              initial={{
                x: 0,
                y: 0,
                scale: 0,
                opacity: 0,
                rotate: 0
              }}
              animate={{
                x: Math.cos(angle * Math.PI / 180) * distance,
                y: Math.sin(angle * Math.PI / 180) * distance,
                scale: [0, 1.5, 1, 1.2, 0],
                opacity: [0, 1, 1, 0.8, 0],
                rotate: 360
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'easeInOut',
                times: [0, 0.2, 0.4, 0.8, 1]
              }}
            />
          );
        }
      }
    };

    // 生成粒子
    getParticleStyle();

    return particles;
  };

  // 处理动画完成
  const handleAnimationComplete = () => {
    setIsAnimationComplete(true);
    if (onAnimationComplete) {
      onAnimationComplete();
    }
  };

  // 获取传说级奖励的彩虹边框
  const getLegendaryBorder = () => {
    if (rarity === RewardRarity.LEGENDARY) {
      return (
        <motion.div
          style={{
            position: 'absolute',
            width: '110%',
            height: '110%',
            borderRadius: '50%',
            border: '3px solid transparent',
            backgroundImage: 'linear-gradient(white, white), linear-gradient(to right, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff)',
            backgroundOrigin: 'border-box',
            backgroundClip: 'content-box, border-box',
            top: '-5%',
            left: '-5%'
          }}
          animate={{
            rotate: [0, 360],
          }}
          transition={{
            duration: 8,
            repeat: Infinity,
            ease: 'linear'
          }}
        />
      );
    }
    return null;
  };

  // 获取稀有级奖励的特殊边框
  const getRareBorder = () => {
    if (rarity === RewardRarity.RARE || rarity === RewardRarity.EPIC) {
      return (
        <motion.div
          style={{
            position: 'absolute',
            width: '110%',
            height: '110%',
            borderRadius: '50%',
            border: '2px solid',
            borderColor: rarity === RewardRarity.RARE ? '#0088ff' : '#a335ee',
            top: '-5%',
            left: '-5%'
          }}
          animate={{
            boxShadow: [
              `0 0 5px ${rarity === RewardRarity.RARE ? '#0088ff' : '#a335ee'}`,
              `0 0 15px ${rarity === RewardRarity.RARE ? '#0088ff' : '#a335ee'}`,
              `0 0 5px ${rarity === RewardRarity.RARE ? '#0088ff' : '#a335ee'}`
            ]
          }}
          transition={{
            duration: 2,
            repeat: Infinity,
            ease: 'easeInOut'
          }}
        />
      );
    }
    return null;
  };

  return (
    <div
      style={{
        position: 'relative',
        width: size,
        height: size,
        margin: '0 auto'
      }}
    >
      {/* 特殊边框效果 */}
      {getLegendaryBorder()}
      {getRareBorder()}

      {/* 光晕效果 */}
      <motion.div
        style={{
          position: 'absolute',
          width: '100%',
          height: '100%',
          borderRadius: '50%',
          backgroundColor: getGlowColor(rarity),
          top: 0,
          left: 0
        }}
        variants={glowVariants}
        initial="hidden"
        animate="visible"
      />

      {/* 粒子效果 */}
      <AnimatePresence>
        {!isAnimationComplete && renderParticles()}
      </AnimatePresence>

      {/* 奖励图标 */}
      <motion.div
        style={{
          position: 'relative',
          width: '100%',
          height: '100%',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          zIndex: 2
        }}
        variants={iconVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
        onAnimationComplete={handleAnimationComplete}
      >
        <img
          src={iconPath}
          alt={`${type} reward`}
          style={{
            width: '80%',
            height: '80%',
            objectFit: 'contain',
            filter: rarity === RewardRarity.LEGENDARY
              ? 'drop-shadow(0 0 5px gold)'
              : rarity === RewardRarity.EPIC
                ? 'drop-shadow(0 0 3px purple)'
                : rarity === RewardRarity.RARE
                  ? 'drop-shadow(0 0 3px blue)'
                  : 'none'
          }}
          onError={(e) => {
            // 图标加载失败时使用默认图标
            const target = e.target as HTMLImageElement;
            target.onerror = null; // 防止无限循环
            target.src = type === RewardType.EXPERIENCE
              ? '/assets/rewards/experience.svg'
              : type === RewardType.COIN
                ? '/assets/rewards/coin.svg'
                : '/assets/rewards/item_common.svg';
          }}
        />
      </motion.div>

      {/* 数量显示 */}
      {amount > 1 && (
        <motion.div
          style={{
            position: 'absolute',
            bottom: -10,
            right: -10,
            backgroundColor: 'var(--imperial-gold)',
            color: 'white',
            borderRadius: '50%',
            width: 30,
            height: 30,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            fontWeight: 'bold',
            fontSize: '0.9rem',
            boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)',
            zIndex: 3
          }}
          variants={amountVariants}
          initial="hidden"
          animate="visible"
          exit="exit"
        >
          {amount}
        </motion.div>
      )}

      {/* 稀有度指示器 - 只对稀有及以上显示 */}
      {(rarity === RewardRarity.RARE || rarity === RewardRarity.EPIC || rarity === RewardRarity.LEGENDARY) && (
        <motion.div
          style={{
            position: 'absolute',
            top: -15,
            left: '50%',
            transform: 'translateX(-50%)',
            backgroundColor: rarity === RewardRarity.LEGENDARY
              ? '#FFD700'
              : rarity === RewardRarity.EPIC
                ? '#a335ee'
                : '#0088ff',
            color: 'white',
            borderRadius: '4px',
            padding: '2px 6px',
            fontSize: '0.7rem',
            fontWeight: 'bold',
            boxShadow: `0 0 5px ${
              rarity === RewardRarity.LEGENDARY
                ? '#FFD700'
                : rarity === RewardRarity.EPIC
                  ? '#a335ee'
                  : '#0088ff'
            }`,
            zIndex: 3
          }}
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.5, duration: 0.3 }}
        >
          {rarity === RewardRarity.LEGENDARY
            ? '传说'
            : rarity === RewardRarity.EPIC
              ? '史诗'
              : '稀有'}
        </motion.div>
      )}
    </div>
  );
};

export default RewardAnimation;
</file>

<file path="src/components/common/Button.tsx">
// src/components/common/Button.tsx
import React from 'react';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'jade' | 'gold';
  isLoading?: boolean;
  loadingText?: string;
}

/**
 * Button component with support for different styles including game-themed variants
 *
 * @param variant - 'primary' (default), 'secondary', 'jade' (game-themed green), 'gold' (premium)
 * @param isLoading - Whether to show loading state
 * @param loadingText - Text to display when loading
 */
const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'primary',
  isLoading = false,
  loadingText = "Loading...",
  ...props
}) => {
  // Determine the appropriate CSS class based on variant
  let variantStyle = '';

  switch (variant) {
    case 'jade':
      variantStyle = 'jade-button';
      break;
    case 'gold':
      variantStyle = 'gold-button';
      break;
    case 'secondary':
      variantStyle = 'button-secondary';
      break;
    case 'primary':
    default:
      variantStyle = 'button-primary';
  }

  // Only add button-common class for non-game-themed buttons
  const baseStyle = !['jade', 'gold'].includes(variant) ? 'button-common' : '';

  return (
    <button
      className={`${baseStyle} ${variantStyle}`.trim()}
      disabled={isLoading || props.disabled}
      {...props}
    >
      {isLoading ? loadingText : children}
    </button>
  );
};

export default Button;
</file>

<file path="src/components/common/DataLoader.tsx">
// src/components/common/DataLoader.tsx
import React, { ReactNode } from 'react';
import { motion } from 'framer-motion';
import LoadingSpinner from './LoadingSpinner';
import ErrorDisplay from './ErrorDisplay';

interface DataLoaderProps<T> {
  isLoading: boolean;
  isError: boolean;
  error: Error | null;
  data: T | undefined | null;
  loadingText?: string;
  errorTitle?: string;
  onRetry?: () => void;
  emptyState?: ReactNode;
  children: (data: T) => ReactNode;
  loadingComponent?: ReactNode;
  errorComponent?: ReactNode;
}

/**
 * 通用数据加载组件
 * 处理加载状态、错误状态和空数据状态
 * 
 * @param isLoading - 是否正在加载
 * @param isError - 是否出错
 * @param error - 错误对象
 * @param data - 数据
 * @param loadingText - 加载文本
 * @param errorTitle - 错误标题
 * @param onRetry - 重试回调
 * @param emptyState - 空数据状态组件
 * @param children - 渲染数据的函数
 * @param loadingComponent - 自定义加载组件
 * @param errorComponent - 自定义错误组件
 */
function DataLoader<T>({
  isLoading,
  isError,
  error,
  data,
  loadingText = '加载数据中...',
  errorTitle = '加载错误',
  onRetry,
  emptyState,
  children,
  loadingComponent,
  errorComponent
}: DataLoaderProps<T>) {
  // 加载状态
  if (isLoading && !data) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="data-loader-container"
      >
        {loadingComponent || <LoadingSpinner variant="jade" text={loadingText} />}
      </motion.div>
    );
  }

  // 错误状态
  if (isError && !data) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="data-loader-container"
      >
        {errorComponent || (
          <ErrorDisplay
            error={error}
            title={errorTitle}
            onRetry={onRetry}
          />
        )}
      </motion.div>
    );
  }

  // 空数据状态
  if (!data) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="data-loader-container"
      >
        {emptyState || (
          <div className="empty-state">
            <p>暂无数据</p>
          </div>
        )}
      </motion.div>
    );
  }

  // 渲染数据
  return <>{children(data)}</>;
}

export default DataLoader;
</file>

<file path="src/components/common/ErrorDisplay.tsx">
// src/components/common/ErrorDisplay.tsx
import React from 'react';
import type { ApiError } from '@/types';
import Button from './Button'; // Use our common Button

interface ErrorDisplayProps {
  error: ApiError | Error | null;
  title?: string;
  messageTemplate?: string;
  onRetry?: () => void;
  retryButtonText?: string;
}

const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  title = "Error", // Fallback title
  messageTemplate = "Details: {message}",
  onRetry,
  retryButtonText = "Try Again",
}) => {
  if (!error) return null;

  const errorMessage = error.message || "An unknown error occurred.";
  const finalMessage = messageTemplate.replace('{message}', errorMessage);
  const errorCode = (error as ApiError)?.errorCode;
  const statusCode = (error as ApiError)?.statusCode;

  return (
    <div className="error-container" role="alert">
      <h3>{title}</h3>
      <p className="error-text">{finalMessage}</p>
      {errorCode && <p className="error-code-text">Error Code: {errorCode}</p>}
      {statusCode && <p className="error-code-text">Status Code: {statusCode}</p>}
      {onRetry && (
        <Button onClick={onRetry} variant="secondary" style={{ marginTop: '10px' }}>
          {retryButtonText}
        </Button>
      )}
    </div>
  );
};
export default ErrorDisplay;
</file>

<file path="src/components/common/LoadingSpinner.tsx">
// src/components/common/LoadingSpinner.tsx
import React from 'react';

interface LoadingSpinnerProps {
  text?: string;
  variant?: 'default' | 'jade';
}

/**
 * Loading spinner component with support for game-themed style
 *
 * @param text - Optional text to display below the spinner
 * @param variant - 'default' or 'jade' (game-themed)
 */
const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  text,
  variant = 'default'
}) => {
  const spinnerClass = variant === 'jade' ? 'jade-spinner' : 'loading-spinner';

  return (
    <div className="loading-spinner-overlay">
      <div className={spinnerClass}></div>
      {text && <p className="loading-spinner-text">{text}</p>}
    </div>
  );
};

export default LoadingSpinner;
</file>

<file path="src/components/common/Modal.tsx">
// src/components/common/Modal.tsx
import React, { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import { motion, AnimatePresence } from 'framer-motion';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
  closeOnOutsideClick?: boolean;
  closeOnEsc?: boolean;
  className?: string;
  overlayClassName?: string;
  contentClassName?: string;
}

/**
 * 基础模态框组件
 * 提供可重用的模态框功能，支持动画和自定义样式
 * 
 * @param isOpen - 控制模态框是否显示
 * @param onClose - 关闭模态框的回调函数
 * @param children - 模态框内容
 * @param closeOnOutsideClick - 是否在点击外部区域时关闭模态框，默认为true
 * @param closeOnEsc - 是否在按下ESC键时关闭模态框，默认为true
 * @param className - 自定义模态框容器类名
 * @param overlayClassName - 自定义遮罩层类名
 * @param contentClassName - 自定义内容区域类名
 */
const Modal: React.FC<ModalProps> = ({
  isOpen,
  onClose,
  children,
  closeOnOutsideClick = true,
  closeOnEsc = true,
  className = '',
  overlayClassName = '',
  contentClassName = '',
}) => {
  const contentRef = useRef<HTMLDivElement>(null);

  // 处理ESC键关闭
  useEffect(() => {
    const handleEscKey = (event: KeyboardEvent) => {
      if (closeOnEsc && event.key === 'Escape' && isOpen) {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscKey);
      // 禁止背景滚动
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscKey);
      // 恢复背景滚动
      document.body.style.overflow = '';
    };
  }, [isOpen, onClose, closeOnEsc]);

  // 处理点击外部区域关闭
  const handleOverlayClick = (e: React.MouseEvent) => {
    if (closeOnOutsideClick && e.target === e.currentTarget) {
      onClose();
    }
  };

  // 动画变体
  const overlayVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { duration: 0.3 } },
    exit: { opacity: 0, transition: { duration: 0.2 } }
  };

  const contentVariants = {
    hidden: { opacity: 0, scale: 0.9, y: -20 },
    visible: { 
      opacity: 1, 
      scale: 1, 
      y: 0, 
      transition: { 
        type: 'spring', 
        damping: 25, 
        stiffness: 300,
        delay: 0.1
      } 
    },
    exit: { 
      opacity: 0, 
      scale: 0.95, 
      y: 10, 
      transition: { 
        duration: 0.2 
      } 
    }
  };

  // 使用Portal将模态框渲染到body下
  return createPortal(
    <AnimatePresence>
      {isOpen && (
        <motion.div
          className={`modal-overlay ${overlayClassName}`}
          variants={overlayVariants}
          initial="hidden"
          animate="visible"
          exit="exit"
          onClick={handleOverlayClick}
        >
          <motion.div
            ref={contentRef}
            className={`modal-content ${contentClassName}`}
            variants={contentVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
            onClick={(e) => e.stopPropagation()}
          >
            <div className={`modal-container ${className}`}>
              {children}
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>,
    document.body
  );
};

export default Modal;
</file>

<file path="src/components/common/ProgressBar.tsx">
// src/components/common/ProgressBar.tsx
import React from 'react';
import { motion } from 'framer-motion';

interface ProgressBarProps {
  progress: number;
  total?: number;
  showPercentage?: boolean;
  className?: string;
  height?: number;
  color?: string;
  backgroundColor?: string;
  radius?: number;
  animate?: boolean;
}

/**
 * 进度条组件
 * 显示任务或奖励的完成进度
 * 
 * @param progress 当前进度值
 * @param total 总进度值，默认为100
 * @param showPercentage 是否显示百分比文本
 * @param className 自定义CSS类名
 * @param height 进度条高度，默认为10px
 * @param color 进度条颜色，默认为主题色
 * @param backgroundColor 进度条背景色，默认为半透明灰色
 * @param radius 进度条圆角半径，默认为4px
 * @param animate 是否启用动画效果，默认为true
 */
const ProgressBar: React.FC<ProgressBarProps> = ({
  progress,
  total = 100,
  showPercentage = false,
  className = '',
  height = 10,
  color,
  backgroundColor,
  radius = 4,
  animate = true
}) => {
  // 计算百分比
  const percentage = Math.min(Math.max(0, Math.round((progress / total) * 100)), 100);
  
  // 动画变体
  const variants = {
    initial: { width: '0%' },
    animate: { width: `${percentage}%` }
  };

  return (
    <div 
      className={`progress-bar-container ${className}`}
      style={{
        height: `${height}px`,
        backgroundColor: backgroundColor || 'rgba(0, 0, 0, 0.1)',
        borderRadius: `${radius}px`,
        overflow: 'hidden',
        position: 'relative'
      }}
    >
      <motion.div
        className="progress-bar-fill"
        style={{
          height: '100%',
          backgroundColor: color || 'var(--primary-color, #4caf50)',
          borderRadius: `${radius}px`
        }}
        initial={animate ? "initial" : false}
        animate={animate ? "animate" : false}
        variants={variants}
        transition={{ duration: 0.5, ease: "easeOut" }}
      />
      
      {showPercentage && (
        <div 
          className="progress-bar-text"
          style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: percentage > 50 ? '#fff' : '#000',
            fontSize: `${height < 20 ? 10 : 14}px`,
            fontWeight: 'bold',
            textShadow: percentage > 50 ? '0 0 2px rgba(0,0,0,0.5)' : 'none'
          }}
        >
          {percentage}%
        </div>
      )}
    </div>
  );
};

export default ProgressBar;
</file>

<file path="src/components/common/SyncStatusIndicator.tsx">
// src/components/common/SyncStatusIndicator.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { SyncStatus, getCurrentSyncStatus, getPendingSyncCount, manualSync } from '@/services/dataSyncService';

interface SyncStatusIndicatorProps {
  showCount?: boolean;
  showLabel?: boolean;
  variant?: 'minimal' | 'standard' | 'detailed';
}

/**
 * 数据同步状态指示器组件
 * 显示当前同步状态和待同步项目数量
 *
 * @param showCount - 是否显示待同步项目数量
 * @param showLabel - 是否显示状态标签
 * @param variant - 显示变体
 */
const SyncStatusIndicator: React.FC<SyncStatusIndicatorProps> = ({
  showCount = true,
  showLabel = true,
  variant = 'standard'
}) => {
  const [syncStatus, setSyncStatus] = useState<SyncStatus>(SyncStatus.IDLE);
  const [pendingCount, setPendingCount] = useState<number>(0);
  const [isVisible, setIsVisible] = useState<boolean>(false);

  // 更新同步状态和待同步项目数量
  useEffect(() => {
    const updateStatus = async () => {
      try {
        const status = getCurrentSyncStatus();
        let count = 0;

        try {
          count = await getPendingSyncCount();
        } catch (countErr) {
          console.error('Failed to get pending sync count:', countErr);
        }

        setSyncStatus(status);
        setPendingCount(count);

        // 如果有待同步项目或正在同步，则显示指示器
        setIsVisible(count > 0 || status === SyncStatus.SYNCING);
      } catch (err) {
        console.error('Failed to update sync status:', err);
      }
    };

    // 初始更新
    updateStatus();

    // 定期更新，更频繁地检查
    const interval = setInterval(updateStatus, 1000);

    // 添加事件监听器，在网络状态变化时更新
    window.addEventListener('online', updateStatus);
    window.addEventListener('offline', updateStatus);

    // 添加自定义事件监听器，在添加同步项目时更新
    const handleSyncItemAdded = () => updateStatus();
    window.addEventListener('syncItemAdded', handleSyncItemAdded);

    // 添加自定义事件监听器，在同步状态变化时更新
    const handleSyncStatusChanged = (event: Event) => {
      const customEvent = event as CustomEvent<SyncStatus>;
      setSyncStatus(customEvent.detail);
      updateStatus();
    };
    window.addEventListener('syncStatusChanged', handleSyncStatusChanged);

    return () => {
      clearInterval(interval);
      window.removeEventListener('online', updateStatus);
      window.removeEventListener('offline', updateStatus);
      window.removeEventListener('syncItemAdded', handleSyncItemAdded);
      window.removeEventListener('syncStatusChanged', handleSyncStatusChanged);
    };
  }, []);

  // 手动触发同步
  const handleManualSync = async () => {
    try {
      await manualSync();
    } catch (err) {
      console.error('Manual sync failed:', err);
    }
  };

  // 获取状态图标
  const getStatusIcon = () => {
    switch (syncStatus) {
      case SyncStatus.SYNCING:
        return (
          <motion.div
            animate={{ rotate: 360 }}
            transition={{ repeat: Infinity, duration: 1, ease: 'linear' }}
            className="sync-icon syncing"
          >
            ↻
          </motion.div>
        );
      case SyncStatus.SUCCESS:
        return <div className="sync-icon success">✓</div>;
      case SyncStatus.ERROR:
        return <div className="sync-icon error">✗</div>;
      default:
        return <div className="sync-icon idle">⟳</div>;
    }
  };

  // 获取状态标签
  const getStatusLabel = () => {
    switch (syncStatus) {
      case SyncStatus.SYNCING:
        return '同步中...';
      case SyncStatus.SUCCESS:
        return '同步成功';
      case SyncStatus.ERROR:
        return '同步失败';
      default:
        return '待同步';
    }
  };

  // 始终显示同步状态指示器，除非是最小变体且没有待同步项目
  if (!isVisible && variant === 'minimal') {
    return null;
  }

  // 最小变体
  if (variant === 'minimal') {
    return (
      <motion.div
        className="sync-status-indicator minimal"
        initial={{ opacity: 0, scale: 0.8 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.8 }}
        onClick={handleManualSync}
      >
        {getStatusIcon()}
      </motion.div>
    );
  }

  // 获取状态类名
  const getStatusClassName = () => {
    switch (syncStatus) {
      case SyncStatus.SYNCING:
        return 'syncing';
      case SyncStatus.SUCCESS:
        return 'success';
      case SyncStatus.ERROR:
        return 'error';
      default:
        return 'idle';
    }
  };

  // 标准变体
  return (
    <AnimatePresence>
      <motion.div
        className={`sync-status-indicator ${variant} ${getStatusClassName()}`}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: 20 }}
        onClick={handleManualSync}
      >
        {getStatusIcon()}

        {showLabel && (
          <span className="sync-label">{getStatusLabel()}</span>
        )}

        {showCount && pendingCount > 0 && (
          <span className="sync-count">{pendingCount}</span>
        )}
      </motion.div>
    </AnimatePresence>
  );
};

export default SyncStatusIndicator;
</file>

<file path="src/components/decoration/ChineseDecoration.tsx">
// src/components/decoration/ChineseDecoration.tsx
import React from 'react';

/**
 * 中国风装饰组件
 * 添加各种中国风装饰元素到应用程序中
 */
const ChineseDecoration: React.FC = () => {
  return (
    <>
      {/* 云朵装饰 */}
      <div className="chinese-cloud top-right" />
      <div className="chinese-cloud top-left" />
      
      {/* 中国结装饰 */}
      <div className="chinese-knot top-right" />
      
      {/* 荷花装饰 */}
      <div className="lotus-flower bottom-left" />
      
      {/* 山水画装饰 */}
      <div className="mountain-landscape bottom" />
    </>
  );
};

export default ChineseDecoration;
</file>

<file path="src/components/decoration/InkAnimation.tsx">
// src/components/decoration/InkAnimation.tsx
import React, { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

interface InkAnimationProps {
  text: string;
  duration?: number;
  fontSize?: number;
  color?: string;
  onComplete?: () => void;
}

/**
 * 中国风水墨动画组件
 * 用于文字的水墨渲染效果
 * 
 * @param text - 要显示的文字
 * @param duration - 动画持续时间（毫秒）
 * @param fontSize - 字体大小
 * @param color - 文字颜色
 * @param onComplete - 动画完成回调
 */
const InkAnimation: React.FC<InkAnimationProps> = ({
  text,
  duration = 2000,
  fontSize = 36,
  color = 'var(--royal-jade)',
  onComplete
}) => {
  const [isVisible, setIsVisible] = useState(true);
  const characters = text.split('');
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsVisible(false);
      if (onComplete) {
        onComplete();
      }
    }, duration + characters.length * 200);
    
    return () => clearTimeout(timer);
  }, [duration, characters.length, onComplete]);
  
  // 字符动画变体
  const characterVariants = {
    hidden: { 
      opacity: 0,
      scale: 0.5,
      filter: 'blur(10px)'
    },
    visible: (i: number) => ({
      opacity: 1,
      scale: 1,
      filter: 'blur(0px)',
      transition: {
        delay: i * 0.1,
        duration: 0.5,
        ease: [0.17, 0.67, 0.83, 0.67] // 模拟水墨扩散效果
      }
    }),
    exit: (i: number) => ({
      opacity: 0,
      scale: 1.2,
      filter: 'blur(5px)',
      transition: {
        delay: i * 0.05,
        duration: 0.3,
        ease: 'easeOut'
      }
    })
  };
  
  // 墨滴动画变体
  const inkDropVariants = {
    hidden: { 
      opacity: 0,
      scale: 0
    },
    visible: (i: number) => ({
      opacity: [0, 0.7, 0.3],
      scale: [0, 1.5, 1],
      transition: {
        delay: i * 0.1,
        duration: 0.8,
        ease: 'easeOut'
      }
    }),
    exit: (i: number) => ({
      opacity: 0,
      scale: 1.5,
      transition: {
        delay: i * 0.05,
        duration: 0.3,
        ease: 'easeOut'
      }
    })
  };
  
  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          style={{
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            position: 'relative',
            padding: '20px'
          }}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          {characters.map((char, index) => (
            <motion.div
              key={`${char}-${index}`}
              style={{
                position: 'relative',
                margin: '0 2px'
              }}
              custom={index}
              variants={characterVariants}
              initial="hidden"
              animate="visible"
              exit="exit"
            >
              {/* 墨滴效果 */}
              <motion.div
                style={{
                  position: 'absolute',
                  top: '50%',
                  left: '50%',
                  width: `${fontSize * 1.5}px`,
                  height: `${fontSize * 1.5}px`,
                  borderRadius: '50%',
                  backgroundColor: color,
                  transform: 'translate(-50%, -50%)',
                  zIndex: -1,
                  opacity: 0.2
                }}
                custom={index}
                variants={inkDropVariants}
                initial="hidden"
                animate="visible"
                exit="exit"
              />
              
              {/* 文字 */}
              <motion.span
                style={{
                  fontFamily: 'var(--font-title)',
                  fontSize: `${fontSize}px`,
                  color: color,
                  position: 'relative',
                  zIndex: 1
                }}
              >
                {char}
              </motion.span>
            </motion.div>
          ))}
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default InkAnimation;
</file>

<file path="src/components/decoration/LanternDecoration.tsx">
// src/components/decoration/LanternDecoration.tsx
import React from 'react';
import { motion } from 'framer-motion';

interface LanternDecorationProps {
  count?: number;
  character?: string;
  position?: 'top' | 'left' | 'right' | 'bottom';
}

/**
 * 中国风灯笼装饰组件
 * 用于特殊场合的装饰，如节日、成就解锁等
 * 
 * @param count - 灯笼数量
 * @param character - 灯笼上的汉字
 * @param position - 灯笼位置
 */
const LanternDecoration: React.FC<LanternDecorationProps> = ({
  count = 2,
  character = '福',
  position = 'top'
}) => {
  // 根据位置确定灯笼的样式
  const getPositionStyle = (index: number) => {
    const baseStyle = {
      position: 'fixed' as const,
      zIndex: 10,
      pointerEvents: 'none' as const
    };
    
    const totalWidth = count * 60; // 每个灯笼宽度约60px
    const startPosition = `calc(50% - ${totalWidth / 2}px)`;
    
    switch (position) {
      case 'top':
        return {
          ...baseStyle,
          top: '10px',
          left: `calc(${startPosition} + ${index * 60}px)`
        };
      case 'bottom':
        return {
          ...baseStyle,
          bottom: '80px', // 为底部导航留出空间
          left: `calc(${startPosition} + ${index * 60}px)`
        };
      case 'left':
        return {
          ...baseStyle,
          left: '10px',
          top: `calc(50% - ${totalWidth / 2}px + ${index * 60}px)`
        };
      case 'right':
        return {
          ...baseStyle,
          right: '10px',
          top: `calc(50% - ${totalWidth / 2}px + ${index * 60}px)`
        };
      default:
        return baseStyle;
    }
  };
  
  // 灯笼动画变体
  const lanternVariants = {
    initial: { y: -10, opacity: 0 },
    animate: (i: number) => ({
      y: 0,
      opacity: 1,
      transition: {
        delay: i * 0.2,
        duration: 0.5,
        ease: 'easeOut'
      }
    }),
    swing: (i: number) => ({
      rotate: [0, 3, 0, -3, 0],
      transition: {
        delay: i * 0.1,
        duration: 2,
        ease: 'easeInOut',
        repeat: Infinity,
        repeatType: 'reverse'
      }
    })
  };
  
  return (
    <>
      {Array.from({ length: count }).map((_, index) => (
        <motion.div
          key={index}
          style={{
            ...getPositionStyle(index),
            width: '50px',
            height: '75px',
            backgroundImage: "url('/assets/chinese-lantern.svg')",
            backgroundSize: 'contain',
            backgroundRepeat: 'no-repeat',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center'
          }}
          custom={index}
          variants={lanternVariants}
          initial="initial"
          animate={['animate', 'swing']}
        >
          <motion.span
            style={{
              fontFamily: 'var(--font-title)',
              color: '#FFD700',
              fontSize: '18px',
              marginTop: '-5px'
            }}
            animate={{
              scale: [1, 1.1, 1],
              transition: {
                duration: 2,
                ease: 'easeInOut',
                repeat: Infinity,
                repeatType: 'reverse'
              }
            }}
          >
            {character}
          </motion.span>
        </motion.div>
      ))}
    </>
  );
};

export default LanternDecoration;
</file>

<file path="src/components/game/AbilityCard.tsx">
// src/components/game/AbilityCard.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { PandaAbilityRecord, AbilityType } from '@/services/pandaAbilityService';
import { RewardRarity } from '@/services/rewardService';

interface AbilityCardProps {
  ability: PandaAbilityRecord;
  isUnlocked: boolean;
  onActivate?: () => void;
  className?: string;
}

/**
 * 熊猫能力卡片组件
 * 显示熊猫能力的详细信息
 * 
 * @param ability - 能力数据
 * @param isUnlocked - 是否已解锁
 * @param onActivate - 激活能力的回调函数
 * @param className - 自定义类名
 */
const AbilityCard: React.FC<AbilityCardProps> = ({
  ability,
  isUnlocked,
  onActivate,
  className = ''
}) => {
  // 获取能力类型的中文名称
  const getAbilityTypeName = (type: AbilityType): string => {
    switch (type) {
      case AbilityType.PASSIVE:
        return '被动';
      case AbilityType.ACTIVE:
        return '主动';
      case AbilityType.ULTIMATE:
        return '终极';
      default:
        return '未知';
    }
  };

  // 获取稀有度的中文名称
  const getRarityName = (rarity: RewardRarity): string => {
    switch (rarity) {
      case RewardRarity.COMMON:
        return '普通';
      case RewardRarity.UNCOMMON:
        return '不常见';
      case RewardRarity.RARE:
        return '稀有';
      case RewardRarity.EPIC:
        return '史诗';
      case RewardRarity.LEGENDARY:
        return '传说';
      default:
        return '普通';
    }
  };

  // 获取稀有度的颜色
  const getRarityColor = (rarity: RewardRarity): string => {
    switch (rarity) {
      case RewardRarity.COMMON:
        return 'var(--text-primary)';
      case RewardRarity.UNCOMMON:
        return 'var(--jade-green)';
      case RewardRarity.RARE:
        return 'var(--imperial-blue)';
      case RewardRarity.EPIC:
        return 'var(--imperial-purple)';
      case RewardRarity.LEGENDARY:
        return 'var(--imperial-gold)';
      default:
        return 'var(--text-primary)';
    }
  };

  // 检查能力是否可用（已解锁且不在冷却中）
  const isAvailable = (): boolean => {
    if (!isUnlocked) {
      return false;
    }

    // 被动能力总是可用
    if (ability.type === AbilityType.PASSIVE) {
      return true;
    }

    // 检查冷却时间
    if (ability.lastUsedAt && ability.cooldownMinutes) {
      const now = new Date();
      const cooldownEndTime = new Date(ability.lastUsedAt);
      cooldownEndTime.setMinutes(cooldownEndTime.getMinutes() + ability.cooldownMinutes);
      
      return now >= cooldownEndTime;
    }

    return true;
  };

  // 获取冷却剩余时间
  const getCooldownRemaining = (): string => {
    if (!ability.lastUsedAt || !ability.cooldownMinutes) {
      return '';
    }

    const now = new Date();
    const cooldownEndTime = new Date(ability.lastUsedAt);
    cooldownEndTime.setMinutes(cooldownEndTime.getMinutes() + ability.cooldownMinutes);

    if (now >= cooldownEndTime) {
      return '';
    }

    const remainingMs = cooldownEndTime.getTime() - now.getTime();
    const remainingMinutes = Math.ceil(remainingMs / (1000 * 60));

    if (remainingMinutes < 60) {
      return `${remainingMinutes}分钟`;
    } else {
      const hours = Math.floor(remainingMinutes / 60);
      const minutes = remainingMinutes % 60;
      return `${hours}小时${minutes > 0 ? ` ${minutes}分钟` : ''}`;
    }
  };

  return (
    <motion.div
      className={`ability-card ${className} ${isUnlocked ? 'unlocked' : 'locked'} ${ability.type.toLowerCase()}-ability`}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
    >
      <div className="ability-card-header">
        <div className="ability-icon">
          <img 
            src={ability.iconPath} 
            alt={ability.name}
            onError={(e) => {
              const target = e.target as HTMLImageElement;
              target.onerror = null;
              target.src = '/assets/abilities/default-ability.svg';
            }}
          />
        </div>
        <div className="ability-info">
          <h3 className="ability-name" style={{ color: getRarityColor(ability.rarity) }}>
            {ability.name}
          </h3>
          <div className="ability-meta">
            <span className="ability-type">{getAbilityTypeName(ability.type)}</span>
            <span className="ability-rarity">{getRarityName(ability.rarity)}</span>
          </div>
        </div>
      </div>

      <div className="ability-card-body">
        <p className="ability-description">{ability.description}</p>
        
        {!isUnlocked && (
          <div className="ability-unlock-info">
            <span className="ability-lock-icon">🔒</span>
            <span>需要等级 {ability.requiredLevel} 解锁</span>
          </div>
        )}
        
        {isUnlocked && ability.type !== AbilityType.PASSIVE && (
          <div className="ability-cooldown">
            {getCooldownRemaining() ? (
              <span className="cooldown-remaining">冷却中: {getCooldownRemaining()}</span>
            ) : (
              <span className="cooldown-info">冷却时间: {ability.cooldownMinutes} 分钟</span>
            )}
          </div>
        )}
      </div>

      {isUnlocked && ability.type !== AbilityType.PASSIVE && (
        <div className="ability-card-footer">
          <button
            className={`activate-button ${isAvailable() ? 'available' : 'unavailable'}`}
            onClick={onActivate}
            disabled={!isAvailable()}
          >
            {ability.isActive ? '已激活' : '激活能力'}
          </button>
        </div>
      )}
    </motion.div>
  );
};

export default AbilityCard;
</file>

<file path="src/components/game/AbilityList.tsx">
// src/components/game/AbilityList.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import AbilityCard from './AbilityCard';
import { PandaAbilityRecord, AbilityType } from '@/services/pandaAbilityService';
import ScrollDialog from './ScrollDialog';

interface AbilityListProps {
  abilities: PandaAbilityRecord[];
  unlockedAbilities: PandaAbilityRecord[];
  onActivateAbility: (abilityId: number) => Promise<void>;
  pandaLevel: number;
}

/**
 * 熊猫能力列表组件
 * 显示所有熊猫能力，并允许激活已解锁的能力
 *
 * @param abilities - 所有能力列表
 * @param unlockedAbilities - 已解锁的能力列表
 * @param onActivateAbility - 激活能力的回调函数
 * @param pandaLevel - 当前熊猫等级
 */
const AbilityList: React.FC<AbilityListProps> = ({
  abilities,
  unlockedAbilities,
  onActivateAbility,
  pandaLevel
}) => {
  const [activeFilter, setActiveFilter] = useState<string>('all');
  const [selectedAbility, setSelectedAbility] = useState<PandaAbilityRecord | null>(null);
  const [isDetailModalOpen, setIsDetailModalOpen] = useState(false);

  // 过滤能力
  const filteredAbilities = abilities.filter(ability => {
    if (activeFilter === 'all') {
      return true;
    }
    if (activeFilter === 'unlocked') {
      return unlockedAbilities.some(unlocked => unlocked.id === ability.id);
    }
    if (activeFilter === 'locked') {
      return !unlockedAbilities.some(unlocked => unlocked.id === ability.id);
    }
    if (activeFilter === 'passive') {
      return ability.type === AbilityType.PASSIVE;
    }
    if (activeFilter === 'active') {
      return ability.type === AbilityType.ACTIVE;
    }
    if (activeFilter === 'ultimate') {
      return ability.type === AbilityType.ULTIMATE;
    }
    return true;
  });

  // 检查能力是否已解锁
  const isAbilityUnlocked = (ability: PandaAbilityRecord): boolean => {
    return unlockedAbilities.some(unlocked => unlocked.id === ability.id);
  };

  // 处理能力激活
  const handleActivateAbility = async (abilityId: number) => {
    await onActivateAbility(abilityId);
  };

  // 打开能力详情模态框
  const openAbilityDetail = (ability: PandaAbilityRecord) => {
    setSelectedAbility(ability);
    setIsDetailModalOpen(true);
  };

  // 关闭能力详情模态框
  const closeAbilityDetail = () => {
    setIsDetailModalOpen(false);
    setSelectedAbility(null);
  };

  return (
    <div className="ability-list-container">
      <div className="ability-filters">
        <button
          className={`filter-button ${activeFilter === 'all' ? 'active' : ''}`}
          onClick={() => setActiveFilter('all')}
        >
          全部
        </button>
        <button
          className={`filter-button ${activeFilter === 'unlocked' ? 'active' : ''}`}
          onClick={() => setActiveFilter('unlocked')}
        >
          已解锁
        </button>
        <button
          className={`filter-button ${activeFilter === 'locked' ? 'active' : ''}`}
          onClick={() => setActiveFilter('locked')}
        >
          未解锁
        </button>
        <button
          className={`filter-button ${activeFilter === 'passive' ? 'active' : ''}`}
          onClick={() => setActiveFilter('passive')}
        >
          被动
        </button>
        <button
          className={`filter-button ${activeFilter === 'active' ? 'active' : ''}`}
          onClick={() => setActiveFilter('active')}
        >
          主动
        </button>
        <button
          className={`filter-button ${activeFilter === 'ultimate' ? 'active' : ''}`}
          onClick={() => setActiveFilter('ultimate')}
        >
          终极
        </button>
      </div>

      <div className="abilities-grid">
        <AnimatePresence>
          {filteredAbilities.map(ability => (
            <motion.div
              key={ability.id}
              layout
              initial={{ opacity: 0, scale: 0.8 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.8 }}
              transition={{ duration: 0.3 }}
              onClick={() => openAbilityDetail(ability)}
            >
              <AbilityCard
                ability={ability}
                isUnlocked={isAbilityUnlocked(ability)}
                onActivate={() => ability.id && handleActivateAbility(ability.id)}
              />
            </motion.div>
          ))}
        </AnimatePresence>
      </div>

      {filteredAbilities.length === 0 && (
        <div className="no-abilities">
          <p>没有符合条件的能力</p>
        </div>
      )}

      {/* 能力详情模态框 */}
      <ScrollDialog
        isOpen={isDetailModalOpen}
        onClose={closeAbilityDetail}
        title={selectedAbility?.name || '能力详情'}
      >
        {selectedAbility && (
          <div className="ability-detail">
            <div className="ability-detail-icon">
              <img
                src={selectedAbility.iconPath}
                alt={selectedAbility.name}
                onError={(e) => {
                  const target = e.target as HTMLImageElement;
                  target.onerror = null;
                  target.src = '/assets/abilities/default-ability.svg';
                }}
              />
            </div>

            <div className="ability-detail-info">
              <p className="ability-detail-description">
                {selectedAbility.description}
              </p>

              <div className="ability-detail-meta">
                <div className="meta-item">
                  <span className="meta-label">类型:</span>
                  <span className="meta-value">
                    {selectedAbility.type === AbilityType.PASSIVE ? '被动' :
                     selectedAbility.type === AbilityType.ACTIVE ? '主动' : '终极'}
                  </span>
                </div>

                <div className="meta-item">
                  <span className="meta-label">效果值:</span>
                  <span className="meta-value">{selectedAbility.effectValue * 100}%</span>
                </div>

                {selectedAbility.cooldownMinutes && (
                  <div className="meta-item">
                    <span className="meta-label">冷却时间:</span>
                    <span className="meta-value">{selectedAbility.cooldownMinutes} 分钟</span>
                  </div>
                )}

                <div className="meta-item">
                  <span className="meta-label">解锁等级:</span>
                  <span className="meta-value">
                    {selectedAbility.requiredLevel}
                    {pandaLevel < selectedAbility.requiredLevel &&
                      ` (还需 ${selectedAbility.requiredLevel - pandaLevel} 级)`}
                  </span>
                </div>
              </div>

              {isAbilityUnlocked(selectedAbility) && selectedAbility.type !== AbilityType.PASSIVE && (
                <div className="ability-detail-actions">
                  <button
                    className="activate-detail-button"
                    onClick={() => {
                      selectedAbility.id && handleActivateAbility(selectedAbility.id);
                      closeAbilityDetail();
                    }}
                    disabled={selectedAbility.isActive}
                  >
                    {selectedAbility.isActive ? '已激活' : '激活能力'}
                  </button>
                </div>
              )}
            </div>
          </div>
        )}
      </ScrollDialog>
    </div>
  );
};

export default AbilityList;
</file>

<file path="src/components/game/AbilityUnlockNotification.tsx">
// src/components/game/AbilityUnlockNotification.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { PandaAbilityRecord } from '@/services/pandaAbilityService';
import ScrollDialog from './ScrollDialog';
import Button from '@/components/common/Button';

interface AbilityUnlockNotificationProps {
  newlyUnlockedAbilities: PandaAbilityRecord[];
  onClose: () => void;
}

/**
 * 熊猫能力解锁通知组件
 * 当新能力解锁时显示通知
 * 
 * @param newlyUnlockedAbilities - 新解锁的能力列表
 * @param onClose - 关闭通知的回调函数
 */
const AbilityUnlockNotification: React.FC<AbilityUnlockNotificationProps> = ({
  newlyUnlockedAbilities,
  onClose
}) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [showAll, setShowAll] = useState(false);
  
  // 当前显示的能力
  const currentAbility = newlyUnlockedAbilities[currentIndex];
  
  // 是否有能力可以显示
  const hasAbilities = newlyUnlockedAbilities.length > 0;
  
  // 是否有下一个能力
  const hasNextAbility = currentIndex < newlyUnlockedAbilities.length - 1;
  
  // 显示下一个能力
  const showNextAbility = () => {
    if (hasNextAbility) {
      setCurrentIndex(prev => prev + 1);
    } else {
      setShowAll(true);
    }
  };
  
  // 动画变体
  const containerVariants = {
    hidden: { opacity: 0, scale: 0.9 },
    visible: { 
      opacity: 1, 
      scale: 1,
      transition: { 
        duration: 0.5,
        delayChildren: 0.3,
        staggerChildren: 0.2
      }
    },
    exit: { 
      opacity: 0, 
      scale: 0.9,
      transition: { duration: 0.3 }
    }
  };
  
  const itemVariants = {
    hidden: { y: 20, opacity: 0 },
    visible: { 
      y: 0, 
      opacity: 1,
      transition: { duration: 0.5 }
    }
  };
  
  // 渲染单个能力解锁通知
  const renderSingleAbility = () => {
    if (!currentAbility) return null;
    
    return (
      <motion.div
        className="ability-unlock-single"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <motion.div className="ability-unlock-icon" variants={itemVariants}>
          <img 
            src={currentAbility.iconPath} 
            alt={currentAbility.name}
            onError={(e) => {
              const target = e.target as HTMLImageElement;
              target.onerror = null;
              target.src = '/assets/abilities/default-ability.svg';
            }}
          />
        </motion.div>
        
        <motion.h3 className="ability-unlock-title" variants={itemVariants}>
          解锁新能力！
        </motion.h3>
        
        <motion.h4 className="ability-unlock-name" variants={itemVariants}>
          {currentAbility.name}
        </motion.h4>
        
        <motion.p className="ability-unlock-description" variants={itemVariants}>
          {currentAbility.description}
        </motion.p>
        
        <motion.div className="ability-unlock-actions" variants={itemVariants}>
          {hasNextAbility ? (
            <Button variant="jade" onClick={showNextAbility}>
              下一个能力
            </Button>
          ) : (
            <Button variant="jade" onClick={() => setShowAll(true)}>
              查看所有能力
            </Button>
          )}
        </motion.div>
      </motion.div>
    );
  };
  
  // 渲染所有解锁的能力列表
  const renderAllAbilities = () => {
    return (
      <motion.div
        className="ability-unlock-all"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <motion.h3 className="ability-unlock-title" variants={itemVariants}>
          新解锁的能力
        </motion.h3>
        
        <motion.div className="ability-unlock-list" variants={itemVariants}>
          {newlyUnlockedAbilities.map((ability, index) => (
            <div key={index} className="ability-unlock-item">
              <div className="ability-unlock-item-icon">
                <img 
                  src={ability.iconPath} 
                  alt={ability.name}
                  onError={(e) => {
                    const target = e.target as HTMLImageElement;
                    target.onerror = null;
                    target.src = '/assets/abilities/default-ability.svg';
                  }}
                />
              </div>
              <div className="ability-unlock-item-info">
                <h4 className="ability-unlock-item-name">{ability.name}</h4>
                <p className="ability-unlock-item-description">{ability.description}</p>
              </div>
            </div>
          ))}
        </motion.div>
        
        <motion.div className="ability-unlock-actions" variants={itemVariants}>
          <Button variant="gold" onClick={onClose}>
            关闭
          </Button>
        </motion.div>
      </motion.div>
    );
  };
  
  // 如果没有能力，不显示通知
  if (!hasAbilities) {
    return null;
  }
  
  return (
    <ScrollDialog
      isOpen={true}
      onClose={onClose}
      title="能力解锁"
      closeOnOutsideClick={false}
      closeOnEsc={false}
      showCloseButton={showAll}
      footer={null}
    >
      <div className="ability-unlock-content">
        <AnimatePresence mode="wait">
          {!showAll ? (
            <motion.div key="single" className="ability-unlock-view">
              {renderSingleAbility()}
            </motion.div>
          ) : (
            <motion.div key="all" className="ability-unlock-view">
              {renderAllAbilities()}
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </ScrollDialog>
  );
};

export default AbilityUnlockNotification;
</file>

<file path="src/components/game/ChallengeCard.tsx">
// src/components/game/ChallengeCard.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { ChallengeRecord, ChallengeStatus, ChallengeDifficulty } from '@/services/challengeService';
import ProgressBar from '@/components/common/ProgressBar';
import { formatTime } from '@/utils/dateUtils';

interface ChallengeCardProps {
  challenge: ChallengeRecord;
  onClick?: (challenge: ChallengeRecord) => void;
  onComplete?: (challengeId: number) => void;
}

/**
 * 挑战卡片组件
 * 显示挑战的基本信息和进度
 */
const ChallengeCard: React.FC<ChallengeCardProps> = ({ challenge, onClick, onComplete }) => {
  // 获取挑战状态对应的样式类
  const getStatusClass = () => {
    switch (challenge.status) {
      case ChallengeStatus.ACTIVE:
        return 'challenge-active';
      case ChallengeStatus.COMPLETED:
        return 'challenge-completed';
      case ChallengeStatus.EXPIRED:
        return 'challenge-expired';
      case ChallengeStatus.UPCOMING:
        return 'challenge-upcoming';
      default:
        return '';
    }
  };

  // 获取挑战难度对应的样式类
  const getDifficultyClass = () => {
    switch (challenge.difficulty) {
      case ChallengeDifficulty.EASY:
        return 'difficulty-easy';
      case ChallengeDifficulty.MEDIUM:
        return 'difficulty-medium';
      case ChallengeDifficulty.HARD:
        return 'difficulty-hard';
      case ChallengeDifficulty.EXPERT:
        return 'difficulty-expert';
      default:
        return '';
    }
  };

  // 获取挑战难度对应的文本
  const getDifficultyText = () => {
    switch (challenge.difficulty) {
      case ChallengeDifficulty.EASY:
        return '简单';
      case ChallengeDifficulty.MEDIUM:
        return '中等';
      case ChallengeDifficulty.HARD:
        return '困难';
      case ChallengeDifficulty.EXPERT:
        return '专家';
      default:
        return '';
    }
  };

  // 获取挑战状态对应的文本
  const getStatusText = () => {
    switch (challenge.status) {
      case ChallengeStatus.ACTIVE:
        return '进行中';
      case ChallengeStatus.COMPLETED:
        return '已完成';
      case ChallengeStatus.EXPIRED:
        return '已过期';
      case ChallengeStatus.UPCOMING:
        return '即将开始';
      default:
        return '';
    }
  };

  // 处理点击事件
  const handleClick = () => {
    if (onClick) {
      onClick(challenge);
    }
  };

  // 处理完成挑战事件
  const handleComplete = (e: React.MouseEvent) => {
    e.stopPropagation(); // 阻止事件冒泡
    if (onComplete && challenge.status === ChallengeStatus.ACTIVE) {
      onComplete(challenge.id!);
    }
  };

  return (
    <motion.div
      className={`challenge-card ${getStatusClass()} ${getDifficultyClass()}`}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={handleClick}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      transition={{ duration: 0.3 }}
    >
      <div className="challenge-card-header">
        <div className="challenge-icon">
          <img src={challenge.iconPath} alt={challenge.title} />
        </div>
        <div className="challenge-title-section">
          <h3 className="challenge-title">{challenge.title}</h3>
          <div className="challenge-meta">
            <span className={`challenge-difficulty ${getDifficultyClass()}`}>
              {getDifficultyText()}
            </span>
            <span className={`challenge-status ${getStatusClass()}`}>
              {getStatusText()}
            </span>
          </div>
        </div>
      </div>

      <div className="challenge-card-body">
        <p className="challenge-description">{challenge.description}</p>

        <div className="challenge-progress-section">
          <ProgressBar
            progress={challenge.progress}
            total={100}
            showPercentage
            className={getStatusClass()}
          />
          <div className="challenge-dates">
            <span>开始: {formatTime(challenge.startDate, false)}</span>
            {challenge.endDate && (
              <span>结束: {formatTime(challenge.endDate, false)}</span>
            )}
          </div>
        </div>
      </div>

      <div className="challenge-card-footer">
        {challenge.status === ChallengeStatus.ACTIVE && (
          <button
            className="complete-challenge-button"
            onClick={handleComplete}
            disabled={challenge.progress < 100}
          >
            {challenge.progress >= 100 ? '完成挑战' : '进行中...'}
          </button>
        )}
        {challenge.status === ChallengeStatus.COMPLETED && (
          <div className="challenge-completed-info">
            <span className="completion-date">
              完成于: {formatTime(challenge.completedDate!, false)}
            </span>
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default ChallengeCard;
</file>

<file path="src/components/game/ChallengeList.tsx">
// src/components/game/ChallengeList.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  ChallengeRecord,
  ChallengeStatus,
  ChallengeType,
  ChallengeDifficulty,
  getAllChallenges,
  completeChallenge
} from '@/services/challengeService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import ChallengeCard from './ChallengeCard';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import RewardModal from '@/components/game/RewardModal';
import { RewardRecord } from '@/services/rewardService';
import ScrollDialog from './ScrollDialog';

interface ChallengeListProps {
  filter?: {
    status?: ChallengeStatus;
    type?: ChallengeType;
    difficulty?: ChallengeDifficulty;
  };
  onSelectChallenge?: (challenge: ChallengeRecord) => void;
}

/**
 * 挑战列表组件
 * 显示挑战列表，支持过滤和选择
 */
const ChallengeList: React.FC<ChallengeListProps> = ({ filter, onSelectChallenge }) => {
  const [challenges, setChallenges] = useState<ChallengeRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [showRewardModal, setShowRewardModal] = useState(false);
  const [selectedChallenge, setSelectedChallenge] = useState<ChallengeRecord | null>(null);
  const [showChallengeDetails, setShowChallengeDetails] = useState(false);

  // 加载挑战
  const loadChallenges = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const challengeList = await getAllChallenges(filter);
      setChallenges(challengeList);
    } catch (err) {
      console.error('Failed to load challenges:', err);
      setError('加载挑战失败，请重试');
    } finally {
      setIsLoading(false);
    }
  }, [filter]);

  // 初始加载
  useEffect(() => {
    loadChallenges();
  }, [loadChallenges]);

  // 定义挑战数据更新处理函数
  const handleChallengeDataUpdate = useCallback((challengeData: any) => {
    // 如果有特定挑战数据，则更新该挑战
    if (challengeData && challengeData.id) {
      setChallenges(prevChallenges => {
        // 检查挑战是否已存在
        const challengeExists = prevChallenges.some(challenge => challenge.id === challengeData.id);

        if (challengeExists) {
          // 更新现有挑战
          return prevChallenges.map(challenge =>
            challenge.id === challengeData.id ? { ...challenge, ...challengeData } : challenge
          );
        } else {
          // 添加新挑战（如果符合过滤条件）
          if (!filter ||
              ((!filter.status || challengeData.status === filter.status) &&
               (!filter.type || challengeData.type === filter.type) &&
               (!filter.difficulty || challengeData.difficulty === filter.difficulty))) {
            return [...prevChallenges, challengeData];
          }
          return prevChallenges;
        }
      });
    } else {
      // 如果没有特定挑战数据，则重新加载所有挑战
      loadChallenges();
    }
  }, [loadChallenges, filter]);

  // 使用 useRegisterTableRefresh hook 监听挑战表的变化
  useRegisterTableRefresh('challenges', handleChallengeDataUpdate);

  // 处理选择挑战
  const handleSelectChallenge = (challenge: ChallengeRecord) => {
    setSelectedChallenge(challenge);
    setShowChallengeDetails(true);

    if (onSelectChallenge) {
      onSelectChallenge(challenge);
    }
  };

  // 处理完成挑战
  const handleCompleteChallenge = async (challengeId: number) => {
    try {
      setIsLoading(true);

      // 完成挑战并获取奖励
      const challengeRewards = await completeChallenge(challengeId);

      // 更新挑战列表
      setChallenges(prevChallenges =>
        prevChallenges.map(challenge =>
          challenge.id === challengeId
            ? {
                ...challenge,
                status: ChallengeStatus.COMPLETED,
                progress: 100,
                completedDate: new Date()
              }
            : challenge
        )
      );

      // 显示奖励
      if (challengeRewards && challengeRewards.length > 0) {
        setRewards(challengeRewards);
        setShowRewardModal(true);
      }
    } catch (err) {
      console.error('Failed to complete challenge:', err);
      setError('完成挑战失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 关闭奖励模态框
  const handleCloseRewardModal = () => {
    setShowRewardModal(false);
  };

  // 关闭挑战详情
  const handleCloseChallengeDetails = () => {
    setShowChallengeDetails(false);
    setSelectedChallenge(null);
  };

  // 如果正在加载，显示加载动画
  if (isLoading && challenges.length === 0) {
    return <LoadingSpinner />;
  }

  // 如果有错误，显示错误信息
  if (error && challenges.length === 0) {
    return <div className="error-message">{error}</div>;
  }

  // 如果没有挑战，显示提示信息
  if (challenges.length === 0) {
    return <div className="no-challenges-message">暂无挑战</div>;
  }

  return (
    <div className="challenge-list">
      <AnimatePresence>
        {challenges.map(challenge => (
          <ChallengeCard
            key={challenge.id}
            challenge={challenge}
            onClick={handleSelectChallenge}
            onComplete={handleCompleteChallenge}
          />
        ))}
      </AnimatePresence>

      {/* 奖励模态框 */}
      {showRewardModal && (
        <RewardModal
          rewards={rewards}
          onClose={handleCloseRewardModal}
        />
      )}

      {/* 挑战详情 */}
      {showChallengeDetails && selectedChallenge && (
        <ScrollDialog
          title={selectedChallenge.title}
          onClose={handleCloseChallengeDetails}
        >
          <div className="challenge-details">
            <div className="challenge-header">
              <img
                src={selectedChallenge.iconPath}
                alt={selectedChallenge.title}
                className="challenge-icon-large"
              />
              <div className="challenge-meta-details">
                <div className="challenge-difficulty">
                  难度: {selectedChallenge.difficulty}
                </div>
                <div className="challenge-type">
                  类型: {selectedChallenge.type}
                </div>
                <div className="challenge-status">
                  状态: {selectedChallenge.status}
                </div>
              </div>
            </div>

            <div className="challenge-description-full">
              {selectedChallenge.description}
            </div>

            <div className="challenge-progress-details">
              <h4>进度: {selectedChallenge.progress}%</h4>
              <div className="progress-bar-container">
                <div
                  className="progress-bar-fill"
                  style={{ width: `${selectedChallenge.progress}%` }}
                ></div>
              </div>
            </div>

            <div className="challenge-dates-details">
              <div>开始日期: {selectedChallenge.startDate.toLocaleDateString()}</div>
              {selectedChallenge.endDate && (
                <div>结束日期: {selectedChallenge.endDate.toLocaleDateString()}</div>
              )}
              {selectedChallenge.completedDate && (
                <div>完成日期: {selectedChallenge.completedDate.toLocaleDateString()}</div>
              )}
            </div>

            {selectedChallenge.status === ChallengeStatus.ACTIVE && (
              <button
                className="complete-challenge-button-large"
                onClick={() => handleCompleteChallenge(selectedChallenge.id!)}
                disabled={selectedChallenge.progress < 100}
              >
                {selectedChallenge.progress >= 100 ? '完成挑战' : '继续努力'}
              </button>
            )}
          </div>
        </ScrollDialog>
      )}
    </div>
  );
};

export default ChallengeList;
</file>

<file path="src/components/game/DialogDemo.tsx">
// src/components/game/DialogDemo.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import ScrollDialog from './ScrollDialog';
import LatticeDialog from './LatticeDialog';
import Button from '@/components/common/Button';

/**
 * 对话框演示组件
 * 用于展示不同风格的对话框组件
 */
const DialogDemo: React.FC = () => {
  const [isScrollDialogOpen, setIsScrollDialogOpen] = useState(false);
  const [isLatticeDialogOpen, setIsLatticeDialogOpen] = useState(false);
  const [isConfirmDialogOpen, setIsConfirmDialogOpen] = useState(false);

  // 打开卷轴对话框
  const openScrollDialog = () => {
    setIsScrollDialogOpen(true);
  };

  // 关闭卷轴对话框
  const closeScrollDialog = () => {
    setIsScrollDialogOpen(false);
  };

  // 打开窗棂对话框
  const openLatticeDialog = () => {
    setIsLatticeDialogOpen(true);
  };

  // 关闭窗棂对话框
  const closeLatticeDialog = () => {
    setIsLatticeDialogOpen(false);
  };

  // 打开确认对话框
  const openConfirmDialog = () => {
    setIsConfirmDialogOpen(true);
  };

  // 关闭确认对话框
  const closeConfirmDialog = () => {
    setIsConfirmDialogOpen(false);
  };

  // 确认操作
  const handleConfirm = () => {
    alert('操作已确认！');
    closeConfirmDialog();
  };

  // 确认对话框的底部按钮
  const confirmDialogFooter = (
    <>
      <Button variant="secondary" onClick={closeConfirmDialog}>
        取消
      </Button>
      <Button variant="jade" onClick={handleConfirm}>
        确认
      </Button>
    </>
  );

  return (
    <div className="dialog-demo">
      <h2>对话框演示</h2>
      
      <div style={{ display: 'flex', gap: '16px', marginBottom: '24px' }}>
        <Button variant="jade" onClick={openScrollDialog}>
          打开卷轴对话框
        </Button>
        
        <Button variant="gold" onClick={openLatticeDialog}>
          打开窗棂对话框
        </Button>
        
        <Button variant="primary" onClick={openConfirmDialog}>
          打开确认对话框
        </Button>
      </div>

      {/* 卷轴风格对话框 */}
      <ScrollDialog
        isOpen={isScrollDialogOpen}
        onClose={closeScrollDialog}
        title="熊猫传说"
      >
        <div style={{ padding: '0 16px' }}>
          <p>
            很久很久以前，在一个被竹林环绕的山谷里，生活着一群神奇的熊猫。它们不仅会说人类的语言，还掌握着古老的智慧。
          </p>
          <p>
            传说中，这些熊猫是天上的星辰化身，它们来到人间是为了指引人们找到内心的平静与坚持。每当有人迷失方向或放弃自己的目标时，熊猫就会出现，用它们的智慧和耐心帮助人们重新找回前进的道路。
          </p>
          <p>
            这些熊猫会教导人们如何像竹子一样坚韧不拔，在风雨中依然挺立；如何像流水一样灵活应变，绕过生活中的障碍；如何像山石一样沉稳坚定，不被外界的喧嚣所动摇。
          </p>
          <p>
            据说，只要你真心相信并坚持不懈地追求自己的目标，熊猫的智慧就会在你的心中显现，指引你走向成功和幸福。
          </p>
        </div>
      </ScrollDialog>

      {/* 窗棂风格对话框 */}
      <LatticeDialog
        isOpen={isLatticeDialogOpen}
        onClose={closeLatticeDialog}
        title="熊猫伙伴设置"
      >
        <div>
          <div className="form-group">
            <label htmlFor="panda-name">熊猫名称</label>
            <input
              id="panda-name"
              type="text"
              placeholder="给你的熊猫伙伴起个名字"
              defaultValue="竹竹"
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="panda-color">熊猫颜色主题</label>
            <select id="panda-color" defaultValue="classic">
              <option value="classic">经典黑白</option>
              <option value="golden">金色传说</option>
              <option value="jade">翡翠绿</option>
              <option value="blue">青花蓝</option>
            </select>
          </div>
          
          <div className="form-group">
            <label>熊猫互动提醒</label>
            <div style={{ display: 'flex', gap: '16px' }}>
              <label>
                <input type="checkbox" defaultChecked /> 喂食提醒
              </label>
              <label>
                <input type="checkbox" defaultChecked /> 玩耍提醒
              </label>
              <label>
                <input type="checkbox" defaultChecked /> 训练提醒
              </label>
            </div>
          </div>
        </div>
      </LatticeDialog>

      {/* 确认对话框 */}
      <LatticeDialog
        isOpen={isConfirmDialogOpen}
        onClose={closeConfirmDialog}
        title="操作确认"
        footer={confirmDialogFooter}
      >
        <div style={{ textAlign: 'center', padding: '16px 0' }}>
          <p>您确定要执行此操作吗？</p>
          <p style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>
            此操作无法撤销，请谨慎确认。
          </p>
        </div>
      </LatticeDialog>
    </div>
  );
};

export default DialogDemo;
</file>

<file path="src/components/game/LatticeDialog.tsx">
// src/components/game/LatticeDialog.tsx
import React from 'react';
import { motion } from 'framer-motion';
import Modal from '@/components/common/Modal';
import Button from '@/components/common/Button';

interface LatticeDialogProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
  footer?: React.ReactNode;
  closeOnOutsideClick?: boolean;
  closeOnEsc?: boolean;
  showCloseButton?: boolean;
}

/**
 * 窗棂风格对话框组件
 * 设计为中国传统窗棂样式，适合展示操作确认、设置或表单
 * 
 * @param isOpen - 控制对话框是否显示
 * @param onClose - 关闭对话框的回调函数
 * @param title - 对话框标题
 * @param children - 对话框内容
 * @param footer - 对话框底部内容，通常是按钮
 * @param closeOnOutsideClick - 是否在点击外部区域时关闭，默认为true
 * @param closeOnEsc - 是否在按下ESC键时关闭，默认为true
 * @param showCloseButton - 是否显示关闭按钮，默认为true
 */
const LatticeDialog: React.FC<LatticeDialogProps> = ({
  isOpen,
  onClose,
  title,
  children,
  footer,
  closeOnOutsideClick = true,
  closeOnEsc = true,
  showCloseButton = true,
}) => {
  // 默认底部内容
  const defaultFooter = (
    <Button variant="jade" onClick={onClose}>
      确认
    </Button>
  );

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      closeOnOutsideClick={closeOnOutsideClick}
      closeOnEsc={closeOnEsc}
      className="lattice-modal"
    >
      <div className="lattice-modal-header">
        <h3 className="lattice-modal-title">{title}</h3>
        {showCloseButton && (
          <motion.button
            className="lattice-modal-close"
            onClick={onClose}
            whileHover={{ scale: 1.1 }}
            whileTap={{ scale: 0.9 }}
            aria-label="关闭"
          >
            ×
          </motion.button>
        )}
      </div>

      <div className="lattice-modal-content">
        {children}
      </div>

      {(footer || defaultFooter) && (
        <div className="lattice-modal-footer">
          {footer || defaultFooter}
        </div>
      )}
    </Modal>
  );
};

export default LatticeDialog;
</file>

<file path="src/components/game/LuckyDraw.tsx">
// src/components/game/LuckyDraw.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  getLuckyPointsTotal,
  performLuckyDraw,
  PrizeLevel
} from '@/services/timelyRewardService';
import { RewardRecord } from '@/services/rewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import LuckyPointsDisplay from './LuckyPointsDisplay';
import RewardAnimation from '@/components/animation/RewardAnimation';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';

interface LuckyDrawProps {
  onClose?: () => void;
  onRewardEarned?: (rewards: RewardRecord[]) => void;
}

/**
 * 幸运抽奖组件
 * 允许用户使用幸运点进行抽奖
 */
const LuckyDraw: React.FC<LuckyDrawProps> = ({ onClose, onRewardEarned }) => {
  const [points, setPoints] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [isDrawing, setIsDrawing] = useState(false);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [showRewards, setShowRewards] = useState(false);
  const [selectedPoints, setSelectedPoints] = useState(10); // 默认使用10点
  const [error, setError] = useState<string | null>(null);

  // 抽奖选项
  const drawOptions = [
    { points: 10, label: '基础抽奖', description: '获得普通奖励的机会' },
    { points: 30, label: '高级抽奖', description: '获得稀有奖励的更高机会' },
    { points: 50, label: '豪华抽奖', description: '获得史诗和传说奖励的最高机会' }
  ];

  // 加载幸运点数量
  const loadPoints = async () => {
    try {
      setIsLoading(true);
      const total = await getLuckyPointsTotal();
      setPoints(total);
    } catch (err) {
      console.error('Failed to load lucky points:', err);
      setError('加载幸运点失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadPoints();
  }, []);

  // 定义幸运点数据更新处理函数
  const handleLuckyPointsUpdate = useCallback(() => {
    loadPoints();
  }, [loadPoints]);

  // 使用 useRegisterTableRefresh hook 监听幸运点表的变化
  useRegisterTableRefresh('luckyPoints', handleLuckyPointsUpdate);

  // 处理抽奖
  const handleDraw = async () => {
    if (points < selectedPoints) {
      setError('幸运点不足');
      return;
    }

    try {
      setIsDrawing(true);
      setError(null);

      // 执行抽奖
      const result = await performLuckyDraw(selectedPoints);

      // 更新幸运点
      setPoints(prev => prev - selectedPoints);

      // 设置奖励
      setRewards(result.rewards);

      // 显示奖励动画
      setTimeout(() => {
        setShowRewards(true);
      }, 1000);

      // 通知父组件
      if (onRewardEarned) {
        onRewardEarned(result.rewards);
      }
    } catch (err) {
      console.error('Failed to perform lucky draw:', err);
      setError('抽奖失败，请重试');
    } finally {
      setIsDrawing(false);
    }
  };

  // 处理关闭
  const handleClose = () => {
    if (onClose) {
      onClose();
    }
  };

  // 处理选择抽奖选项
  const handleSelectOption = (points: number) => {
    setSelectedPoints(points);
  };

  // 处理继续抽奖
  const handleContinue = () => {
    setShowRewards(false);
    setRewards([]);
  };

  return (
    <div className="lucky-draw-container">
      <div className="lucky-draw-header">
        <h2 className="lucky-draw-title">幸运抽奖</h2>
        <LuckyPointsDisplay variant="large" />
      </div>

      {isLoading ? (
        <LoadingSpinner />
      ) : showRewards ? (
        <div className="lucky-draw-results">
          <RewardAnimation rewards={rewards} />
          <div className="lucky-draw-actions">
            <Button onClick={handleContinue}>继续抽奖</Button>
            <Button onClick={handleClose}>关闭</Button>
          </div>
        </div>
      ) : (
        <>
          <div className="lucky-draw-options">
            <AnimatePresence>
              {drawOptions.map(option => (
                <motion.div
                  key={option.points}
                  className={`draw-option ${selectedPoints === option.points ? 'selected' : ''} ${points < option.points ? 'disabled' : ''}`}
                  onClick={() => handleSelectOption(option.points)}
                  whileHover={{ scale: points >= option.points ? 1.05 : 1 }}
                  whileTap={{ scale: points >= option.points ? 0.95 : 1 }}
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -20 }}
                  transition={{ duration: 0.3 }}
                >
                  <div className="draw-option-header">
                    <div className="draw-option-points">
                      <span className="lucky-points-icon">🍀</span>
                      <span>{option.points}</span>
                    </div>
                    <h3 className="draw-option-label">{option.label}</h3>
                  </div>
                  <p className="draw-option-description">{option.description}</p>
                  {points < option.points && (
                    <div className="draw-option-insufficient">幸运点不足</div>
                  )}
                </motion.div>
              ))}
            </AnimatePresence>
          </div>

          {error && (
            <div className="error-message">{error}</div>
          )}

          <div className="lucky-draw-actions">
            <Button
              onClick={handleDraw}
              disabled={isDrawing || points < selectedPoints}
              className="draw-button"
            >
              {isDrawing ? '抽奖中...' : '抽奖'}
            </Button>
            <Button onClick={handleClose}>关闭</Button>
          </div>
        </>
      )}
    </div>
  );
};

export default LuckyDraw;
</file>

<file path="src/components/game/LuckyPointsDisplay.tsx">
// src/components/game/LuckyPointsDisplay.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { getLuckyPointsTotal } from '@/services/timelyRewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface LuckyPointsDisplayProps {
  onClick?: () => void;
  variant?: 'default' | 'compact' | 'large';
}

/**
 * 幸运点显示组件
 * 显示用户当前的幸运点数量
 */
const LuckyPointsDisplay: React.FC<LuckyPointsDisplayProps> = ({
  onClick,
  variant = 'default'
}) => {
  const [points, setPoints] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [isAnimating, setIsAnimating] = useState(false);

  // 加载幸运点数量
  const loadPoints = async () => {
    try {
      setIsLoading(true);
      const total = await getLuckyPointsTotal();
      setPoints(total);
    } catch (err) {
      console.error('Failed to load lucky points:', err);
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadPoints();
  }, []);

  // 定义幸运点数据更新处理函数
  const handleLuckyPointsUpdate = useCallback(() => {
    loadPoints();
    setIsAnimating(true);

    // 动画结束后重置状态
    setTimeout(() => {
      setIsAnimating(false);
    }, 1000);
  }, [loadPoints]);

  // 使用 useRegisterTableRefresh hook 监听幸运点表的变化
  useRegisterTableRefresh('luckyPoints', handleLuckyPointsUpdate);

  // 处理点击事件
  const handleClick = () => {
    if (onClick) {
      onClick();
    }
  };

  // 获取变体类名
  const getVariantClass = () => {
    switch (variant) {
      case 'compact':
        return 'lucky-points-compact';
      case 'large':
        return 'lucky-points-large';
      default:
        return 'lucky-points-default';
    }
  };

  return (
    <motion.div
      className={`lucky-points-display ${getVariantClass()} ${isAnimating ? 'animating' : ''}`}
      onClick={handleClick}
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
    >
      <div className="lucky-points-icon">🍀</div>
      <AnimatePresence mode="wait">
        <motion.div
          key={points}
          className="lucky-points-value"
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: 10 }}
          transition={{ duration: 0.3 }}
        >
          {isLoading ? (
            <span className="loading-dots">...</span>
          ) : (
            <span>{points}</span>
          )}
        </motion.div>
      </AnimatePresence>
      <div className="lucky-points-label">幸运点</div>
    </motion.div>
  );
};

export default LuckyPointsDisplay;
</file>

<file path="src/components/game/PandaAvatar.tsx">
// src/components/game/PandaAvatar.tsx
import React, { useState, useEffect } from 'react';
import { useTableRefresh } from '@/hooks/useDataRefresh';

// 熊猫状态类型
export type PandaMood = 'normal' | 'happy' | 'focused' | 'tired';

// 熊猫能量级别
export type EnergyLevel = 'high' | 'medium' | 'low';

interface PandaAvatarProps {
  mood?: PandaMood;
  energy?: EnergyLevel;
  size?: number;
  onClick?: () => void;
  className?: string;
  animate?: boolean;
}

/**
 * 熊猫头像组件，显示不同情绪和能量状态的熊猫
 *
 * @param mood - 熊猫的情绪状态：normal(正常), happy(开心), focused(专注), tired(疲惫)
 * @param energy - 熊猫的能量级别：high(高), medium(中), low(低)
 * @param size - 头像大小，默认为120px
 * @param onClick - 点击头像时的回调函数
 * @param className - 额外的CSS类名
 * @param animate - 是否启用动画效果
 */
const PandaAvatar: React.FC<PandaAvatarProps> = ({
  mood = 'normal',
  energy = 'medium',
  size = 120,
  onClick,
  className = '',
  animate = true
}) => {
  const [isAnimating, setIsAnimating] = useState(false);

  // 根据情绪状态获取对应的SVG图像路径
  const getPandaImage = (pandaMood: PandaMood) => {
    switch (pandaMood) {
      case 'happy':
        return '/assets/panda-happy.svg';
      case 'focused':
        return '/assets/panda-focused.svg';
      case 'tired':
        return '/assets/panda-tired.svg';
      case 'normal':
      default:
        return '/assets/panda-normal.svg';
    }
  };

  // 根据能量级别获取对应的样式
  const getEnergyStyle = (level: EnergyLevel) => {
    switch (level) {
      case 'high':
        return { filter: 'brightness(1.2) saturate(1.2)', transform: 'scale(1.05)' };
      case 'low':
        return { filter: 'brightness(0.9) saturate(0.8)', transform: 'scale(0.95)' };
      case 'medium':
      default:
        return { filter: 'brightness(1) saturate(1)', transform: 'scale(1)' };
    }
  };

  // 处理点击事件
  const handleClick = () => {
    if (onClick) {
      onClick();
    }

    if (animate) {
      setIsAnimating(true);
      setTimeout(() => setIsAnimating(false), 500);
    }
  };

  // 动画效果
  useEffect(() => {
    if (animate && isAnimating) {
      // 动画逻辑可以在这里添加
    }
  }, [animate, isAnimating]);

  // 组合样式
  const energyStyle = getEnergyStyle(energy);
  const animationStyle = isAnimating ? { animation: 'panda-bounce 0.5s ease' } : {};
  const combinedStyle = {
    width: `${size}px`,
    height: `${size}px`,
    cursor: onClick ? 'pointer' : 'default',
    transition: 'all 0.3s ease',
    ...energyStyle,
    ...animationStyle
  };

  return (
    <div
      className={`panda-avatar ${className}`}
      style={combinedStyle}
      onClick={handleClick}
    >
      <img
        src={getPandaImage(mood)}
        alt={`Panda in ${mood} mood`}
        style={{ width: '100%', height: '100%' }}
      />
    </div>
  );
};

export default PandaAvatar;
</file>

<file path="src/components/game/RewardModal.tsx">
// src/components/game/RewardModal.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ScrollDialog from './ScrollDialog';
import Button from '@/components/common/Button';
import RewardAnimation from '@/components/animation/RewardAnimation';
import { RewardRecord, markRewardsAsViewed } from '@/services/rewardService';
import { useTableRefresh } from '@/hooks/useDataRefresh';

interface RewardModalProps {
  isOpen: boolean;
  onClose: () => void;
  rewards: RewardRecord[];
}

/**
 * 奖励展示模态框
 * 以卷轴风格展示任务完成后获得的奖励
 *
 * @param isOpen - 控制模态框是否显示
 * @param onClose - 关闭模态框的回调函数
 * @param rewards - 要展示的奖励列表
 */
const RewardModal: React.FC<RewardModalProps> = ({
  isOpen,
  onClose,
  rewards
}) => {
  const [currentRewardIndex, setCurrentRewardIndex] = useState(0);
  const [showAll, setShowAll] = useState(false);
  const [animationComplete, setAnimationComplete] = useState(false);

  // 当前展示的奖励
  const currentReward = rewards[currentRewardIndex];

  // 重置状态
  useEffect(() => {
    if (isOpen) {
      setCurrentRewardIndex(0);
      setShowAll(false);
      setAnimationComplete(false);
    }
  }, [isOpen]);

  // 标记奖励为已查看
  useEffect(() => {
    if (!isOpen) return;

    const rewardIds = rewards
      .filter(reward => reward.id !== undefined)
      .map(reward => reward.id as number);

    if (rewardIds.length > 0) {
      markRewardsAsViewed(rewardIds);
    }
  }, [isOpen, rewards]);

  // 处理动画完成
  const handleAnimationComplete = () => {
    setAnimationComplete(true);
  };

  // 显示下一个奖励
  const handleNextReward = () => {
    if (currentRewardIndex < rewards.length - 1) {
      setCurrentRewardIndex(prev => prev + 1);
      setAnimationComplete(false);
    } else {
      setShowAll(true);
    }
  };

  // 获取奖励稀有度的中文名称
  const getRarityName = (rarity: string): string => {
    switch (rarity) {
      case 'common': return '普通';
      case 'uncommon': return '不常见';
      case 'rare': return '稀有';
      case 'epic': return '史诗';
      case 'legendary': return '传说';
      default: return '普通';
    }
  };

  // 获取奖励类型的中文名称
  const getTypeName = (type: string): string => {
    switch (type) {
      case 'experience': return '经验值';
      case 'coin': return '竹币';
      case 'item': return '物品';
      case 'badge': return '徽章';
      case 'ability': return '能力';
      default: return '奖励';
    }
  };

  // 根据稀有度获取动画样式
  const getAnimationStyleForRarity = (rarity: string): 'default' | 'burst' | 'float' | 'spin' | 'pulse' => {
    switch (rarity) {
      case 'legendary': return 'burst';
      case 'epic': return 'spin';
      case 'rare': return 'pulse';
      case 'uncommon': return 'float';
      default: return 'default';
    }
  };

  // 渲染单个奖励展示
  const renderSingleReward = () => {
    // 确保有奖励可以显示
    if (!rewards.length || !currentReward) {
      return (
        <div className="reward-showcase">
          <h3 className="reward-title">暂无奖励</h3>
          <div className="reward-navigation">
            <Button variant="gold" onClick={onClose}>
              关闭
            </Button>
          </div>
        </div>
      );
    }

    return (
      <div className="reward-showcase">
        <h3 className="reward-title">
          获得{getTypeName(currentReward.type)}奖励！
        </h3>

        <div className="reward-animation-container">
          <RewardAnimation
            type={currentReward.type}
            rarity={currentReward.rarity}
            iconPath={currentReward.iconPath}
            amount={currentReward.amount}
            size={120}
            onAnimationComplete={handleAnimationComplete}
            animationStyle={getAnimationStyleForRarity(currentReward.rarity)}
            playSound={true}
            soundVolume={0.6}
          />
        </div>

        <div className="reward-details">
          <h4>{currentReward.name}</h4>
          <p className="reward-rarity">
            {getRarityName(currentReward.rarity)}
          </p>
          <p className="reward-description">
            {currentReward.description}
          </p>
          {currentReward.amount > 1 && (
            <p className="reward-amount">
              数量: {currentReward.amount}
            </p>
          )}
        </div>

        <div className="reward-navigation">
          <AnimatePresence>
            {animationComplete && (
              <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                transition={{ duration: 0.3 }}
              >
                {currentRewardIndex < rewards.length - 1 ? (
                  <Button variant="jade" onClick={handleNextReward}>
                    下一个奖励
                  </Button>
                ) : (
                  <Button variant="jade" onClick={() => setShowAll(true)}>
                    查看全部奖励
                  </Button>
                )}
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      </div>
    );
  };

  // 渲染所有奖励列表
  const renderAllRewards = () => {
    // 确保有奖励可以显示
    if (!rewards.length) {
      return (
        <div className="rewards-summary">
          <h3 className="rewards-summary-title">暂无奖励</h3>
          <div className="rewards-summary-footer">
            <Button variant="gold" onClick={onClose}>
              关闭
            </Button>
          </div>
        </div>
      );
    }

    return (
      <div className="rewards-summary">
        <h3 className="rewards-summary-title">
          任务奖励总览
        </h3>

        <div className="rewards-list">
          {rewards.map((reward, index) => (
            <div key={index} className="reward-item">
              <div className="reward-item-icon">
                <img
                  src={reward.iconPath}
                  alt={reward.name}
                  style={{ width: 40, height: 40 }}
                />
              </div>
              <div className="reward-item-details">
                <h4>{reward.name}</h4>
                <p className="reward-item-description">
                  {reward.description}
                </p>
              </div>
              <div className="reward-item-amount">
                {reward.amount > 0 && `x${reward.amount}`}
              </div>
            </div>
          ))}
        </div>

        <div className="rewards-summary-footer">
          <Button variant="gold" onClick={onClose}>
            关闭
          </Button>
        </div>
      </div>
    );
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="任务奖励"
      closeOnOutsideClick={false}
      closeOnEsc={false}
      showCloseButton={showAll}
      footer={null}
    >
      <div className="reward-modal-content">
        {!showAll ? renderSingleReward() : renderAllRewards()}
      </div>
    </ScrollDialog>
  );
};

export default RewardModal;
</file>

<file path="src/components/game/ScrollDialog.tsx">
// src/components/game/ScrollDialog.tsx
import React from 'react';
import { motion } from 'framer-motion';
import Modal from '@/components/common/Modal';
import Button from '@/components/common/Button';

interface ScrollDialogProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
  footer?: React.ReactNode;
  closeOnOutsideClick?: boolean;
  closeOnEsc?: boolean;
  showCloseButton?: boolean;
}

/**
 * 卷轴风格对话框组件
 * 设计为古代卷轴样式，适合展示重要信息、成就或故事内容
 * 
 * @param isOpen - 控制对话框是否显示
 * @param onClose - 关闭对话框的回调函数
 * @param title - 对话框标题
 * @param children - 对话框内容
 * @param footer - 对话框底部内容，通常是按钮
 * @param closeOnOutsideClick - 是否在点击外部区域时关闭，默认为true
 * @param closeOnEsc - 是否在按下ESC键时关闭，默认为true
 * @param showCloseButton - 是否显示关闭按钮，默认为true
 */
const ScrollDialog: React.FC<ScrollDialogProps> = ({
  isOpen,
  onClose,
  title,
  children,
  footer,
  closeOnOutsideClick = true,
  closeOnEsc = true,
  showCloseButton = true,
}) => {
  // 默认底部内容
  const defaultFooter = (
    <Button variant="gold" onClick={onClose}>
      关闭
    </Button>
  );

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      closeOnOutsideClick={closeOnOutsideClick}
      closeOnEsc={closeOnEsc}
      className="scroll-modal"
    >
      <div className="scroll-modal-header">
        <h3 className="scroll-modal-title">{title}</h3>
        {showCloseButton && (
          <motion.button
            className="scroll-modal-close"
            onClick={onClose}
            whileHover={{ scale: 1.1 }}
            whileTap={{ scale: 0.9 }}
            aria-label="关闭"
          >
            ×
          </motion.button>
        )}
      </div>

      <div className="scroll-modal-content">
        {children}
      </div>

      {(footer || defaultFooter) && (
        <div className="scroll-modal-footer">
          {footer || defaultFooter}
        </div>
      )}
    </Modal>
  );
};

export default ScrollDialog;
</file>

<file path="src/components/game/TaskCard.tsx">
// src/components/game/TaskCard.tsx
import React from 'react';
import { TaskRecord, TaskPriority, TaskStatus, TaskType } from '@/services/taskService';

interface TaskCardProps {
  task: TaskRecord;
  onComplete?: (taskId: number) => void;
  onEdit?: (taskId: number) => void;
  onDelete?: (taskId: number) => void;
  className?: string;
}

/**
 * 任务卡片组件，显示任务信息和操作按钮
 */
const TaskCard: React.FC<TaskCardProps> = ({
  task,
  onComplete,
  onEdit,
  onDelete,
  className = ''
}) => {
  // 获取任务优先级对应的样式
  const getPriorityStyle = (priority: TaskPriority) => {
    switch (priority) {
      case TaskPriority.HIGH:
        return 'task-priority-high';
      case TaskPriority.MEDIUM:
        return 'task-priority-medium';
      case TaskPriority.LOW:
        return 'task-priority-low';
      default:
        return '';
    }
  };
  
  // 获取任务类型对应的样式
  const getTypeStyle = (type: TaskType) => {
    switch (type) {
      case TaskType.MAIN:
        return 'task-type-main';
      case TaskType.DAILY:
        return 'task-type-daily';
      case TaskType.SIDE:
        return 'task-type-side';
      default:
        return '';
    }
  };
  
  // 获取任务状态对应的样式
  const getStatusStyle = (status: TaskStatus) => {
    switch (status) {
      case TaskStatus.COMPLETED:
        return 'task-status-completed';
      case TaskStatus.IN_PROGRESS:
        return 'task-status-in-progress';
      case TaskStatus.TODO:
        return 'task-status-todo';
      case TaskStatus.ARCHIVED:
        return 'task-status-archived';
      default:
        return '';
    }
  };
  
  // 格式化日期显示
  const formatDate = (date: Date | undefined) => {
    if (!date) return '';
    return new Date(date).toLocaleDateString();
  };
  
  // 处理完成任务
  const handleComplete = () => {
    if (onComplete && task.id) {
      onComplete(task.id);
    }
  };
  
  // 处理编辑任务
  const handleEdit = () => {
    if (onEdit && task.id) {
      onEdit(task.id);
    }
  };
  
  // 处理删除任务
  const handleDelete = () => {
    if (onDelete && task.id) {
      onDelete(task.id);
    }
  };
  
  return (
    <div className={`task-card ${getPriorityStyle(task.priority)} ${getStatusStyle(task.status)} ${className}`}>
      <div className="task-card-header">
        <div className={`task-type-badge ${getTypeStyle(task.type)}`}>
          {task.type.toUpperCase()}
        </div>
        <h3 className="task-title">{task.title}</h3>
      </div>
      
      {task.description && (
        <div className="task-description">
          {task.description}
        </div>
      )}
      
      <div className="task-meta">
        {task.dueDate && (
          <div className="task-due-date">
            <span>Due: {formatDate(task.dueDate)}</span>
          </div>
        )}
        
        {task.estimatedMinutes && (
          <div className="task-estimated-time">
            <span>Est: {task.estimatedMinutes} min</span>
          </div>
        )}
      </div>
      
      <div className="task-actions">
        {task.status !== TaskStatus.COMPLETED && (
          <button 
            className="task-action-complete jade-button-small"
            onClick={handleComplete}
            aria-label="Complete task"
          >
            完成
          </button>
        )}
        
        <button 
          className="task-action-edit"
          onClick={handleEdit}
          aria-label="Edit task"
        >
          编辑
        </button>
        
        <button 
          className="task-action-delete"
          onClick={handleDelete}
          aria-label="Delete task"
        >
          删除
        </button>
      </div>
    </div>
  );
};

export default TaskCard;
</file>

<file path="src/components/game/TaskForm.tsx">
// src/components/game/TaskForm.tsx
import React, { useState, useEffect } from 'react';
import { 
  TaskRecord, 
  TaskPriority, 
  TaskType, 
  TaskCategoryRecord,
  getAllTaskCategories
} from '@/services/taskService';
import Button from '@/components/common/Button';

interface TaskFormProps {
  initialTask?: Partial<TaskRecord>;
  onSubmit: (task: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'>) => void;
  onCancel: () => void;
}

/**
 * 任务表单组件，用于创建和编辑任务
 */
const TaskForm: React.FC<TaskFormProps> = ({
  initialTask = {},
  onSubmit,
  onCancel
}) => {
  // 表单状态
  const [title, setTitle] = useState(initialTask.title || '');
  const [description, setDescription] = useState(initialTask.description || '');
  const [categoryId, setCategoryId] = useState<number | undefined>(initialTask.categoryId);
  const [type, setType] = useState<TaskType>(initialTask.type || TaskType.DAILY);
  const [priority, setPriority] = useState<TaskPriority>(initialTask.priority || TaskPriority.MEDIUM);
  const [dueDate, setDueDate] = useState<string>(
    initialTask.dueDate 
      ? new Date(initialTask.dueDate).toISOString().split('T')[0] 
      : ''
  );
  const [estimatedMinutes, setEstimatedMinutes] = useState<number | undefined>(
    initialTask.estimatedMinutes
  );
  const [categories, setCategories] = useState<TaskCategoryRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});

  // 加载任务类别
  useEffect(() => {
    const loadCategories = async () => {
      try {
        setIsLoading(true);
        const allCategories = await getAllTaskCategories();
        setCategories(allCategories);
        
        // 如果没有选择类别，默认选择第一个
        if (!categoryId && allCategories.length > 0) {
          setCategoryId(allCategories[0].id);
        }
      } catch (error) {
        console.error('Failed to load task categories:', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    loadCategories();
  }, [categoryId]);

  // 验证表单
  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    if (!title.trim()) {
      newErrors.title = '请输入任务标题';
    }
    
    if (!categoryId) {
      newErrors.categoryId = '请选择任务类别';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // 处理表单提交
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }
    
    const taskData: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'> = {
      title,
      description: description || undefined,
      categoryId: categoryId!,
      type,
      priority,
      dueDate: dueDate ? new Date(dueDate) : undefined,
      estimatedMinutes: estimatedMinutes || undefined
    };
    
    onSubmit(taskData);
  };

  return (
    <form className="task-form bamboo-frame" onSubmit={handleSubmit}>
      <h2>{initialTask.id ? '编辑任务' : '创建新任务'}</h2>
      
      <div className="form-group">
        <label htmlFor="task-title">标题 *</label>
        <input
          id="task-title"
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          className={errors.title ? 'error' : ''}
          placeholder="输入任务标题"
        />
        {errors.title && <div className="error-message">{errors.title}</div>}
      </div>
      
      <div className="form-group">
        <label htmlFor="task-description">描述</label>
        <textarea
          id="task-description"
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          placeholder="输入任务描述（可选）"
          rows={3}
        />
      </div>
      
      <div className="form-group">
        <label htmlFor="task-category">类别 *</label>
        <select
          id="task-category"
          value={categoryId}
          onChange={(e) => setCategoryId(Number(e.target.value))}
          className={errors.categoryId ? 'error' : ''}
          disabled={isLoading}
        >
          <option value="">选择类别</option>
          {categories.map((category) => (
            <option key={category.id} value={category.id}>
              {category.name}
            </option>
          ))}
        </select>
        {errors.categoryId && <div className="error-message">{errors.categoryId}</div>}
      </div>
      
      <div className="form-group">
        <label htmlFor="task-type">任务类型</label>
        <select
          id="task-type"
          value={type}
          onChange={(e) => setType(e.target.value as TaskType)}
        >
          <option value={TaskType.DAILY}>日常任务</option>
          <option value={TaskType.MAIN}>主线任务</option>
          <option value={TaskType.SIDE}>支线任务</option>
        </select>
      </div>
      
      <div className="form-group">
        <label htmlFor="task-priority">优先级</label>
        <select
          id="task-priority"
          value={priority}
          onChange={(e) => setPriority(e.target.value as TaskPriority)}
        >
          <option value={TaskPriority.LOW}>低</option>
          <option value={TaskPriority.MEDIUM}>中</option>
          <option value={TaskPriority.HIGH}>高</option>
        </select>
      </div>
      
      <div className="form-group">
        <label htmlFor="task-due-date">截止日期</label>
        <input
          id="task-due-date"
          type="date"
          value={dueDate}
          onChange={(e) => setDueDate(e.target.value)}
        />
      </div>
      
      <div className="form-group">
        <label htmlFor="task-estimated-time">预计时间（分钟）</label>
        <input
          id="task-estimated-time"
          type="number"
          min="1"
          value={estimatedMinutes || ''}
          onChange={(e) => setEstimatedMinutes(e.target.value ? Number(e.target.value) : undefined)}
          placeholder="预计完成时间（可选）"
        />
      </div>
      
      <div className="form-actions">
        <Button variant="jade" type="submit">
          {initialTask.id ? '保存修改' : '创建任务'}
        </Button>
        <Button variant="secondary" type="button" onClick={onCancel}>
          取消
        </Button>
      </div>
    </form>
  );
};

export default TaskForm;
</file>

<file path="src/components/game/TaskList.tsx">
// src/components/game/TaskList.tsx
import React, { useState, useEffect } from 'react';
import { 
  TaskRecord, 
  TaskStatus, 
  TaskPriority, 
  TaskType,
  TaskCategoryRecord,
  getAllTasks,
  getAllTaskCategories,
  completeTask,
  deleteTask
} from '@/services/taskService';
import TaskCard from './TaskCard';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';

interface TaskListProps {
  onEditTask: (taskId: number) => void;
  filter?: {
    status?: TaskStatus;
    categoryId?: number;
    type?: TaskType;
    priority?: TaskPriority;
  };
  refreshTrigger?: number; // 用于触发刷新的值
}

/**
 * 任务列表组件，显示任务卡片列表
 */
const TaskList: React.FC<TaskListProps> = ({
  onEditTask,
  filter,
  refreshTrigger = 0
}) => {
  const [tasks, setTasks] = useState<TaskRecord[]>([]);
  const [categories, setCategories] = useState<Record<number, TaskCategoryRecord>>({});
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // 加载任务和类别
  useEffect(() => {
    const loadData = async () => {
      try {
        setIsLoading(true);
        setError(null);
        
        // 加载任务
        const taskList = await getAllTasks(filter);
        setTasks(taskList);
        
        // 加载类别
        const categoryList = await getAllTaskCategories();
        const categoryMap: Record<number, TaskCategoryRecord> = {};
        categoryList.forEach(category => {
          if (category.id) {
            categoryMap[category.id] = category;
          }
        });
        setCategories(categoryMap);
      } catch (err) {
        console.error('Failed to load tasks:', err);
        setError('加载任务失败，请重试');
      } finally {
        setIsLoading(false);
      }
    };
    
    loadData();
  }, [filter, refreshTrigger]);
  
  // 处理完成任务
  const handleCompleteTask = async (taskId: number) => {
    try {
      setIsLoading(true);
      await completeTask(taskId);
      
      // 更新任务列表
      setTasks(prevTasks => 
        prevTasks.map(task => 
          task.id === taskId 
            ? { ...task, status: TaskStatus.COMPLETED, completedAt: new Date() } 
            : task
        )
      );
    } catch (err) {
      console.error('Failed to complete task:', err);
      setError('完成任务失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };
  
  // 处理删除任务
  const handleDeleteTask = async (taskId: number) => {
    if (!window.confirm('确定要删除这个任务吗？')) {
      return;
    }
    
    try {
      setIsLoading(true);
      await deleteTask(taskId);
      
      // 更新任务列表
      setTasks(prevTasks => prevTasks.filter(task => task.id !== taskId));
    } catch (err) {
      console.error('Failed to delete task:', err);
      setError('删除任务失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };
  
  // 获取任务类别名称
  const getCategoryName = (categoryId: number) => {
    return categories[categoryId]?.name || '未分类';
  };
  
  // 按优先级排序任务
  const sortedTasks = [...tasks].sort((a, b) => {
    // 首先按状态排序（未完成的在前）
    if (a.status !== b.status) {
      if (a.status === TaskStatus.COMPLETED) return 1;
      if (b.status === TaskStatus.COMPLETED) return -1;
    }
    
    // 然后按优先级排序
    const priorityOrder = {
      [TaskPriority.HIGH]: 0,
      [TaskPriority.MEDIUM]: 1,
      [TaskPriority.LOW]: 2
    };
    
    return priorityOrder[a.priority] - priorityOrder[b.priority];
  });
  
  if (isLoading && tasks.length === 0) {
    return <LoadingSpinner variant="jade" text="加载任务中..." />;
  }
  
  if (error) {
    return (
      <div className="task-list-error">
        <p>{error}</p>
        <Button variant="jade" onClick={() => window.location.reload()}>
          重试
        </Button>
      </div>
    );
  }
  
  if (tasks.length === 0) {
    return (
      <div className="task-list-empty">
        <p>暂无任务</p>
      </div>
    );
  }
  
  return (
    <div className="task-list">
      {isLoading && (
        <div className="task-list-loading-overlay">
          <LoadingSpinner variant="jade" />
        </div>
      )}
      
      {sortedTasks.map(task => (
        <TaskCard
          key={task.id}
          task={task}
          onComplete={handleCompleteTask}
          onEdit={onEditTask}
          onDelete={handleDeleteTask}
        />
      ))}
    </div>
  );
};

export default TaskList;
</file>

<file path="src/components/game/TimelyRewardCard.tsx">
// src/components/game/TimelyRewardCard.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { TimelyRewardRecord, TimelyRewardStatus, TimelyRewardType } from '@/services/timelyRewardService';
import ProgressBar from '@/components/common/ProgressBar';
import { formatTime } from '@/utils/dateUtils';

interface TimelyRewardCardProps {
  reward: TimelyRewardRecord;
  onClick?: (reward: TimelyRewardRecord) => void;
  onComplete?: (rewardId: number) => void;
}

/**
 * 及时奖励卡片组件
 * 显示及时奖励的基本信息和进度
 */
const TimelyRewardCard: React.FC<TimelyRewardCardProps> = ({ reward, onClick, onComplete }) => {
  // 获取奖励状态对应的样式类
  const getStatusClass = () => {
    switch (reward.status) {
      case TimelyRewardStatus.ACTIVE:
        return 'reward-active';
      case TimelyRewardStatus.COMPLETED:
        return 'reward-completed';
      case TimelyRewardStatus.EXPIRED:
        return 'reward-expired';
      case TimelyRewardStatus.UPCOMING:
        return 'reward-upcoming';
      default:
        return '';
    }
  };

  // 获取奖励类型对应的文本
  const getTypeText = () => {
    switch (reward.type) {
      case TimelyRewardType.DAILY:
        return '每日奖励';
      case TimelyRewardType.MORNING:
        return '早起鸟奖励';
      case TimelyRewardType.STREAK:
        return '连续完成奖励';
      case TimelyRewardType.SPECIAL:
        return '特殊奖励';
      default:
        return '';
    }
  };

  // 获取奖励状态对应的文本
  const getStatusText = () => {
    switch (reward.status) {
      case TimelyRewardStatus.ACTIVE:
        return '进行中';
      case TimelyRewardStatus.COMPLETED:
        return '已完成';
      case TimelyRewardStatus.EXPIRED:
        return '已过期';
      case TimelyRewardStatus.UPCOMING:
        return '即将开始';
      default:
        return '';
    }
  };

  // 计算剩余时间
  const getRemainingTime = () => {
    const now = new Date();
    const endTime = new Date(reward.endTime);
    
    if (now > endTime) {
      return '已结束';
    }
    
    const diffMs = endTime.getTime() - now.getTime();
    const diffHrs = Math.floor(diffMs / (1000 * 60 * 60));
    const diffMins = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
    
    return `${diffHrs}小时${diffMins}分钟`;
  };

  // 处理点击事件
  const handleClick = () => {
    if (onClick) {
      onClick(reward);
    }
  };

  // 处理完成奖励事件
  const handleComplete = (e: React.MouseEvent) => {
    e.stopPropagation(); // 阻止事件冒泡
    if (onComplete && reward.status === TimelyRewardStatus.ACTIVE && reward.progress >= 100) {
      onComplete(reward.id!);
    }
  };

  return (
    <motion.div
      className={`timely-reward-card ${getStatusClass()}`}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={handleClick}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      transition={{ duration: 0.3 }}
    >
      <div className="reward-card-header">
        <div className="reward-icon">
          <img src={reward.iconPath} alt={reward.title} />
        </div>
        <div className="reward-title-section">
          <h3 className="reward-title">{reward.title}</h3>
          <div className="reward-meta">
            <span className="reward-type">{getTypeText()}</span>
            <span className={`reward-status ${getStatusClass()}`}>
              {getStatusText()}
            </span>
          </div>
        </div>
      </div>

      <div className="reward-card-body">
        <p className="reward-description">{reward.description}</p>
        
        <div className="reward-progress-section">
          <ProgressBar 
            progress={reward.progress} 
            total={100} 
            showPercentage 
            className={getStatusClass()}
          />
          <div className="reward-time-info">
            <div className="reward-time-range">
              {formatTime(reward.startTime)} - {formatTime(reward.endTime)}
            </div>
            {reward.status === TimelyRewardStatus.ACTIVE && (
              <div className="reward-remaining-time">
                剩余时间: {getRemainingTime()}
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="reward-card-footer">
        <div className="reward-points">
          <span className="lucky-points-icon">🍀</span>
          <span className="lucky-points-value">{reward.luckyPoints} 幸运点</span>
        </div>
        
        {reward.status === TimelyRewardStatus.ACTIVE && (
          <button 
            className="complete-reward-button"
            onClick={handleComplete}
            disabled={reward.progress < 100}
          >
            {reward.progress >= 100 ? '领取奖励' : '进行中...'}
          </button>
        )}
        {reward.status === TimelyRewardStatus.COMPLETED && (
          <div className="reward-completed-info">
            <span className="completion-date">
              完成于: {formatTime(reward.completedTime!)}
            </span>
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default TimelyRewardCard;
</file>

<file path="src/components/game/TimelyRewardList.tsx">
// src/components/game/TimelyRewardList.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  TimelyRewardRecord,
  TimelyRewardStatus,
  TimelyRewardType,
  getAllTimelyRewards,
  completeTimelyReward,
  updateTimelyRewardsStatus
} from '@/services/timelyRewardService';
import { useTableRefresh } from '@/hooks/useDataRefresh';
import TimelyRewardCard from './TimelyRewardCard';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import RewardModal from '@/components/game/RewardModal';
import { RewardRecord } from '@/services/rewardService';
import ScrollDialog from './ScrollDialog';
import LuckyPointsDisplay from './LuckyPointsDisplay';

interface TimelyRewardListProps {
  filter?: {
    status?: TimelyRewardStatus;
    type?: TimelyRewardType;
  };
  onSelectReward?: (reward: TimelyRewardRecord) => void;
}

/**
 * 及时奖励列表组件
 * 显示及时奖励列表，支持过滤和选择
 */
const TimelyRewardList: React.FC<TimelyRewardListProps> = ({ filter, onSelectReward }) => {
  const [rewards, setRewards] = useState<TimelyRewardRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [earnedRewards, setEarnedRewards] = useState<RewardRecord[]>([]);
  const [showRewardModal, setShowRewardModal] = useState(false);
  const [selectedReward, setSelectedReward] = useState<TimelyRewardRecord | null>(null);
  const [showRewardDetails, setShowRewardDetails] = useState(false);

  // 加载及时奖励
  const loadTimelyRewards = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      // 更新及时奖励状态
      await updateTimelyRewardsStatus();

      // 获取及时奖励列表
      const rewardList = await getAllTimelyRewards(filter);
      setRewards(rewardList);
    } catch (err) {
      console.error('Failed to load timely rewards:', err);
      setError('加载及时奖励失败，请重试');
    } finally {
      setIsLoading(false);
    }
  }, [filter]);

  // 初始加载
  useEffect(() => {
    loadTimelyRewards();
  }, [loadTimelyRewards]);

  // 定义奖励数据更新处理函数
  const handleRewardDataUpdate = useCallback((rewardData: any) => {
    // 如果有特定奖励数据，则更新该奖励
    if (rewardData && rewardData.id) {
      setRewards(prevRewards => {
        // 检查奖励是否已存在
        const rewardExists = prevRewards.some(reward => reward.id === rewardData.id);

        if (rewardExists) {
          // 更新现有奖励
          return prevRewards.map(reward =>
            reward.id === rewardData.id ? { ...reward, ...rewardData } : reward
          );
        } else {
          // 添加新奖励（如果符合过滤条件）
          if (!filter ||
              ((!filter.status || rewardData.status === filter.status) &&
               (!filter.type || rewardData.type === filter.type))) {
            return [...prevRewards, rewardData];
          }
          return prevRewards;
        }
      });
    } else {
      // 如果没有特定奖励数据，则重新加载所有奖励
      loadTimelyRewards();
    }
  }, [loadTimelyRewards, filter]);

  // 使用 useRegisterTableRefresh hook 监听及时奖励表的变化
  useRegisterTableRefresh('timelyRewards', handleRewardDataUpdate);

  // 处理选择奖励
  const handleSelectReward = (reward: TimelyRewardRecord) => {
    setSelectedReward(reward);
    setShowRewardDetails(true);

    if (onSelectReward) {
      onSelectReward(reward);
    }
  };

  // 处理完成奖励
  const handleCompleteReward = async (rewardId: number) => {
    try {
      setIsLoading(true);

      // 完成奖励并获取奖励
      const rewards = await completeTimelyReward(rewardId);

      // 更新奖励列表
      setRewards(prevRewards =>
        prevRewards.map(reward =>
          reward.id === rewardId
            ? {
                ...reward,
                status: TimelyRewardStatus.COMPLETED,
                progress: 100,
                completedTime: new Date()
              }
            : reward
        )
      );

      // 显示奖励
      if (rewards && rewards.length > 0) {
        setEarnedRewards(rewards);
        setShowRewardModal(true);
      }
    } catch (err) {
      console.error('Failed to complete timely reward:', err);
      setError('完成及时奖励失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 关闭奖励模态框
  const handleCloseRewardModal = () => {
    setShowRewardModal(false);
  };

  // 关闭奖励详情
  const handleCloseRewardDetails = () => {
    setShowRewardDetails(false);
    setSelectedReward(null);
  };

  // 如果正在加载，显示加载动画
  if (isLoading && rewards.length === 0) {
    return <LoadingSpinner />;
  }

  // 如果有错误，显示错误信息
  if (error && rewards.length === 0) {
    return <div className="error-message">{error}</div>;
  }

  // 如果没有奖励，显示提示信息
  if (rewards.length === 0) {
    return <div className="no-rewards-message">暂无及时奖励</div>;
  }

  return (
    <div className="timely-reward-list">
      <div className="lucky-points-container">
        <LuckyPointsDisplay />
      </div>

      <AnimatePresence>
        {rewards.map(reward => (
          <TimelyRewardCard
            key={reward.id}
            reward={reward}
            onClick={handleSelectReward}
            onComplete={handleCompleteReward}
          />
        ))}
      </AnimatePresence>

      {/* 奖励模态框 */}
      {showRewardModal && (
        <RewardModal
          rewards={earnedRewards}
          onClose={handleCloseRewardModal}
        />
      )}

      {/* 奖励详情 */}
      {showRewardDetails && selectedReward && (
        <ScrollDialog
          title={selectedReward.title}
          onClose={handleCloseRewardDetails}
        >
          <div className="reward-details">
            <div className="reward-header">
              <img
                src={selectedReward.iconPath}
                alt={selectedReward.title}
                className="reward-icon-large"
              />
              <div className="reward-meta-details">
                <div className="reward-type">
                  类型: {selectedReward.type}
                </div>
                <div className="reward-status">
                  状态: {selectedReward.status}
                </div>
                <div className="reward-lucky-points">
                  幸运点: {selectedReward.luckyPoints}
                </div>
              </div>
            </div>

            <div className="reward-description-full">
              {selectedReward.description}
            </div>

            <div className="reward-progress-details">
              <h4>进度: {selectedReward.progress}%</h4>
              <div className="progress-bar-container">
                <div
                  className="progress-bar-fill"
                  style={{ width: `${selectedReward.progress}%` }}
                ></div>
              </div>
            </div>

            <div className="reward-time-details">
              <div>开始时间: {new Date(selectedReward.startTime).toLocaleString()}</div>
              <div>结束时间: {new Date(selectedReward.endTime).toLocaleString()}</div>
              {selectedReward.completedTime && (
                <div>完成时间: {new Date(selectedReward.completedTime).toLocaleString()}</div>
              )}
            </div>

            {selectedReward.status === TimelyRewardStatus.ACTIVE && (
              <button
                className="complete-reward-button-large"
                onClick={() => handleCompleteReward(selectedReward.id!)}
                disabled={selectedReward.progress < 100}
              >
                {selectedReward.progress >= 100 ? '领取奖励' : '继续努力'}
              </button>
            )}
          </div>
        </ScrollDialog>
      )}
    </div>
  );
};

export default TimelyRewardList;
</file>

<file path="src/components/layout/Header.tsx">
// src/components/layout/Header.tsx
import React from 'react';
import type { GlobalLayoutLabelsBundle } from '@/types';

interface HeaderProps {
  labels: GlobalLayoutLabelsBundle | undefined;
  isFetching?: boolean;
}

const Header: React.FC<HeaderProps> = ({ labels, isFetching }) => {
  return (
    <header style={{
      opacity: isFetching ? 0.7 : 1,
      display: 'flex',
      justifyContent: 'center',
      padding: '10px 0'
    }}>
      {/* 移动应用通常不需要显示应用标题 */}
      {isFetching && labels &&
        <small style={{ fontStyle: 'italic', color: '#555' }}>(syncing...)</small>
      }
    </header>
  );
};
export default Header;
</file>

<file path="src/context/DataRefreshProvider.tsx">
// src/context/DataRefreshProvider.tsx
import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';
import { DataRefreshEvent } from '@/types/dataRefresh';

// 数据刷新上下文类型
interface DataRefreshContextType {
  lastRefresh: Record<string, DataRefreshEvent | null>;
  refreshTable: (table: string, data?: any) => void;
  registerRefreshListener: (table: string, callback: (data?: any) => void) => () => void;
}

// 创建上下文
const DataRefreshContext = createContext<DataRefreshContextType | undefined>(undefined);

// Provider组件属性
interface DataRefreshProviderProps {
  children: ReactNode;
}

/**
 * 数据刷新Provider组件
 * 提供全局数据刷新管理功能
 */
export const DataRefreshProvider: React.FC<DataRefreshProviderProps> = ({ children }) => {
  const [lastRefresh, setLastRefresh] = useState<Record<string, DataRefreshEvent | null>>({});
  const [listeners, setListeners] = useState<Record<string, Set<(data?: any) => void>>>({});

  // 监听数据刷新事件
  useEffect(() => {
    const handleDataRefresh = (event: Event) => {
      const customEvent = event as CustomEvent<DataRefreshEvent>;
      const { table, data } = customEvent.detail;

      // 更新最近一次刷新的数据
      setLastRefresh(prev => ({
        ...prev,
        [table]: { table, data }
      }));

      // 通知该表的所有监听器
      if (listeners[table]) {
        listeners[table].forEach(callback => {
          try {
            callback(data);
          } catch (err) {
            console.error(`Error in refresh listener for table ${table}:`, err);
          }
        });
      }
    };

    // 添加事件监听器
    window.addEventListener('dataRefresh', handleDataRefresh);

    // 清理函数
    return () => {
      window.removeEventListener('dataRefresh', handleDataRefresh);
    };
  }, [listeners]);

  // 刷新表数据
  const refreshTable = useCallback((table: string, data?: any) => {
    const refreshEvent = new CustomEvent('dataRefresh', {
      detail: { table, data }
    });
    window.dispatchEvent(refreshEvent);
  }, []);

  // 注册刷新监听器
  const registerRefreshListener = useCallback((table: string, callback: (data?: any) => void) => {
    setListeners(prev => {
      const tableListeners = prev[table] || new Set();
      tableListeners.add(callback);

      return {
        ...prev,
        [table]: tableListeners
      };
    });

    // 返回取消注册的函数
    return () => {
      setListeners(prev => {
        const tableListeners = prev[table];
        if (tableListeners) {
          tableListeners.delete(callback);

          return {
            ...prev,
            [table]: tableListeners
          };
        }
        return prev;
      });
    };
  }, []);

  // 提供上下文值
  const contextValue: DataRefreshContextType = {
    lastRefresh,
    refreshTable,
    registerRefreshListener
  };

  return (
    <DataRefreshContext.Provider value={contextValue}>
      {children}
    </DataRefreshContext.Provider>
  );
};

/**
 * 使用数据刷新的Hook
 * @returns 数据刷新上下文
 */
export const useDataRefreshContext = (): DataRefreshContextType => {
  const context = useContext(DataRefreshContext);
  if (context === undefined) {
    throw new Error('useDataRefreshContext must be used within a DataRefreshProvider');
  }
  return context;
};
</file>

<file path="src/context/LanguageProvider.tsx">
// src/context/LanguageProvider.tsx
import React, { createContext, useState, useContext, useEffect, ReactNode, useCallback } from "react";
import type { Language, LanguageContextType } from "@/types";

const DEFAULT_LANGUAGE: Language = "en";
const LOCAL_STORAGE_KEY = "app_lang_v3_final";

const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

export const LanguageProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [language, setLanguageState] = useState<Language>(() => {
    try {
      const saved = localStorage.getItem(LOCAL_STORAGE_KEY) as Language | null;
      return (saved === "en" || saved === "zh") ? saved : DEFAULT_LANGUAGE;
    } catch (e) { console.warn("localStorage access error for language", e); return DEFAULT_LANGUAGE; }
  });

  useEffect(() => {
    try {
      localStorage.setItem(LOCAL_STORAGE_KEY, language);
      document.documentElement.lang = language;
    } catch (e) { console.warn("localStorage write error for language", e); }
  }, [language]);

  const setLanguage = useCallback((lang: Language) => setLanguageState(lang), []);
  const value = { language, setLanguage };

  return <LanguageContext.Provider value={value}>{children}</LanguageContext.Provider>;
};

export const useLanguage = (): LanguageContextType => {
  const context = useContext(LanguageContext);
  if (!context) throw new Error("useLanguage must be used within LanguageProvider");
  return context;
};
</file>

<file path="src/context/PandaStateProvider.tsx">
// src/context/PandaStateProvider.tsx
import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';
import {
  getPandaState,
  updatePandaMood,
  updatePandaEnergy,
  addPandaExperience,
  resetPandaState,
  type PandaStateRecord
} from '@/services/pandaStateService';
import {
  initializePandaAbilities,
  checkAndUnlockAbilities,
  getAllPandaAbilities,
  getUnlockedPandaAbilities,
  activateAbility,
  type PandaAbilityRecord
} from '@/services/pandaAbilityService';
import { useDataRefreshContext } from '@/context/DataRefreshProvider';
import type { PandaMood, EnergyLevel } from '@/components/game/PandaAvatar';

// 熊猫状态上下文类型
interface PandaStateContextType {
  pandaState: PandaStateRecord | null;
  abilities: PandaAbilityRecord[];
  unlockedAbilities: PandaAbilityRecord[];
  isLoading: boolean;
  error: Error | null;
  setMood: (mood: PandaMood) => Promise<void>;
  setEnergy: (energy: EnergyLevel) => Promise<void>;
  addExperience: (amount: number) => Promise<void>;
  resetState: () => Promise<void>;
  refreshState: () => Promise<void>;
  activateAbility: (abilityId: number) => Promise<void>;
  checkNewAbilities: () => Promise<PandaAbilityRecord[]>;
}

// 创建上下文
const PandaStateContext = createContext<PandaStateContextType | undefined>(undefined);

// Provider组件属性
interface PandaStateProviderProps {
  children: ReactNode;
}

/**
 * 熊猫状态Provider组件
 * 提供熊猫状态管理功能
 */
export const PandaStateProvider: React.FC<PandaStateProviderProps> = ({ children }) => {
  const [pandaState, setPandaState] = useState<PandaStateRecord | null>(null);
  const [abilities, setAbilities] = useState<PandaAbilityRecord[]>([]);
  const [unlockedAbilities, setUnlockedAbilities] = useState<PandaAbilityRecord[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);
  const { registerRefreshListener } = useDataRefreshContext();

  // 初始加载熊猫状态和能力
  useEffect(() => {
    initializeSystem();
  }, []);

  // 初始化系统
  const initializeSystem = async () => {
    try {
      setIsLoading(true);

      // 加载熊猫状态
      try {
        await loadPandaState();
      } catch (stateErr) {
        console.error('Failed to load panda state:', stateErr);
      }

      // 加载熊猫能力
      try {
        await loadPandaAbilities();
      } catch (abilitiesErr) {
        console.error('Failed to load panda abilities:', abilitiesErr);
      }

      setError(null);
    } catch (err) {
      console.error('Failed to initialize panda system:', err);
      setError(err instanceof Error ? err : new Error('Failed to initialize panda system'));
    } finally {
      setIsLoading(false);
    }
  };

  // 定义状态更新处理函数
  const handleStateUpdate = useCallback((stateData: any) => {
    if (stateData) {
      setPandaState(prevState => {
        if (!prevState) return stateData;
        return {
          ...prevState,
          ...stateData
        };
      });
    }
  }, []);

  // 定义能力更新处理函数
  const handleAbilityUpdate = useCallback(async (abilityData: any) => {
    // 只有当有特定的能力数据时才更新，避免无限循环
    if (abilityData && abilityData.id) {
      try {
        // 更新单个能力而不是重新加载所有能力
        setAbilities(prevAbilities => {
          const index = prevAbilities.findIndex(a => a.id === abilityData.id);
          if (index >= 0) {
            const newAbilities = [...prevAbilities];
            newAbilities[index] = { ...newAbilities[index], ...abilityData };
            return newAbilities;
          }
          return [...prevAbilities, abilityData];
        });

        // 更新已解锁能力列表
        if (abilityData.isUnlocked) {
          setUnlockedAbilities(prevUnlocked => {
            const index = prevUnlocked.findIndex(a => a.id === abilityData.id);
            if (index >= 0) {
              const newUnlocked = [...prevUnlocked];
              newUnlocked[index] = { ...newUnlocked[index], ...abilityData };
              return newUnlocked;
            }
            return [...prevUnlocked, abilityData];
          });
        } else {
          // 如果能力被锁定，从已解锁列表中移除
          setUnlockedAbilities(prevUnlocked =>
            prevUnlocked.filter(a => a.id !== abilityData.id)
          );
        }
      } catch (err) {
        console.error('Failed to update ability:', err);
      }
    }
  }, []);

  // 使用 useEffect 注册监听器
  useEffect(() => {
    // 注册监听器
    const unregisterState = registerRefreshListener('pandaState', handleStateUpdate);
    const unregisterAbility = registerRefreshListener('abilities', handleAbilityUpdate);

    return () => {
      unregisterState();
      unregisterAbility();
    };
  }, [registerRefreshListener, handleStateUpdate, handleAbilityUpdate]);

  // 加载熊猫状态
  const loadPandaState = async () => {
    try {
      const state = await getPandaState();
      setPandaState(state);

      // 检查是否有新解锁的能力
      if (state) {
        await checkAndUnlockAbilities(state.level);
      }

      setError(null);
    } catch (err) {
      console.error('Failed to load panda state:', err);
      setError(err instanceof Error ? err : new Error('Failed to load panda state'));
    }
  };

  // 加载熊猫能力
  const loadPandaAbilities = async () => {
    try {
      // 初始化熊猫能力系统（只在第一次加载时初始化）
      await initializePandaAbilities();

      // 获取所有能力
      let allAbilities: PandaAbilityRecord[] = [];
      try {
        allAbilities = await getAllPandaAbilities();
      } catch (allErr) {
        console.error('Failed to get all abilities:', allErr);
        allAbilities = [];
      }

      // 安全地更新能力列表
      if (Array.isArray(allAbilities)) {
        // 只有当能力列表为空或长度不同时才更新状态
        if (abilities.length === 0 || abilities.length !== allAbilities.length) {
          setAbilities(allAbilities);
        }
      } else {
        console.error('getAllPandaAbilities did not return an array:', allAbilities);
        if (abilities.length === 0) {
          setAbilities([]);
        }
      }

      // 获取已解锁的能力
      let unlocked: PandaAbilityRecord[] = [];
      try {
        unlocked = await getUnlockedPandaAbilities();
      } catch (unlockErr) {
        console.error('Failed to load unlocked abilities:', unlockErr);
        unlocked = [];
      }

      // 安全地更新已解锁能力列表
      if (Array.isArray(unlocked)) {
        // 只有当解锁能力列表为空或长度不同时才更新状态
        if (unlockedAbilities.length === 0 || unlockedAbilities.length !== unlocked.length) {
          setUnlockedAbilities(unlocked);
        }
      } else {
        console.error('getUnlockedPandaAbilities did not return an array:', unlocked);
        if (unlockedAbilities.length === 0) {
          setUnlockedAbilities([]);
        }
      }

      setError(null);
    } catch (err) {
      console.error('Failed to load panda abilities:', err);
      setError(err instanceof Error ? err : new Error('Failed to load panda abilities'));
      // 设置默认空数组，防止UI错误
      if (abilities.length === 0) {
        setAbilities([]);
      }
      if (unlockedAbilities.length === 0) {
        setUnlockedAbilities([]);
      }
    }
  };

  // 设置熊猫情绪
  const setMood = async (mood: PandaMood) => {
    try {
      setIsLoading(true);
      const updatedState = await updatePandaMood(mood);
      setPandaState(updatedState);
    } catch (err) {
      console.error('Failed to update panda mood:', err);
      setError(err instanceof Error ? err : new Error('Failed to update panda mood'));
    } finally {
      setIsLoading(false);
    }
  };

  // 设置熊猫能量
  const setEnergy = async (energy: EnergyLevel) => {
    try {
      setIsLoading(true);
      const updatedState = await updatePandaEnergy(energy);
      setPandaState(updatedState);
    } catch (err) {
      console.error('Failed to update panda energy:', err);
      setError(err instanceof Error ? err : new Error('Failed to update panda energy'));
    } finally {
      setIsLoading(false);
    }
  };

  // 增加熊猫经验
  const addExperience = async (amount: number) => {
    try {
      setIsLoading(true);
      const updatedState = await addPandaExperience(amount);
      setPandaState(updatedState);

      // 检查是否有新解锁的能力
      if (updatedState) {
        await checkAndUnlockAbilities(updatedState.level);
        await loadPandaAbilities(); // 重新加载能力以更新状态
      }
    } catch (err) {
      console.error('Failed to add panda experience:', err);
      setError(err instanceof Error ? err : new Error('Failed to add panda experience'));
    } finally {
      setIsLoading(false);
    }
  };

  // 激活熊猫能力
  const handleActivateAbility = async (abilityId: number) => {
    try {
      setIsLoading(true);
      await activateAbility(abilityId);
      await loadPandaAbilities(); // 重新加载能力以更新状态
      setError(null);
    } catch (err) {
      console.error('Failed to activate ability:', err);
      setError(err instanceof Error ? err : new Error('Failed to activate ability'));
    } finally {
      setIsLoading(false);
    }
  };

  // 检查新解锁的能力
  const checkNewAbilities = async (): Promise<PandaAbilityRecord[]> => {
    try {
      if (!pandaState) {
        return [];
      }

      const newlyUnlocked = await checkAndUnlockAbilities(pandaState.level);
      await loadPandaAbilities(); // 重新加载能力以更新状态

      return newlyUnlocked;
    } catch (err) {
      console.error('Failed to check new abilities:', err);
      setError(err instanceof Error ? err : new Error('Failed to check new abilities'));
      return [];
    }
  };

  // 重置熊猫状态
  const resetState = async () => {
    try {
      setIsLoading(true);
      const resetedState = await resetPandaState();
      setPandaState(resetedState);
    } catch (err) {
      console.error('Failed to reset panda state:', err);
      setError(err instanceof Error ? err : new Error('Failed to reset panda state'));
    } finally {
      setIsLoading(false);
    }
  };

  // 刷新熊猫状态
  const refreshState = async () => {
    await loadPandaState();
  };

  // 提供上下文值
  const contextValue: PandaStateContextType = {
    pandaState,
    abilities,
    unlockedAbilities,
    isLoading,
    error,
    setMood,
    setEnergy,
    addExperience,
    resetState,
    refreshState,
    activateAbility: handleActivateAbility,
    checkNewAbilities
  };

  return (
    <PandaStateContext.Provider value={contextValue}>
      {children}
    </PandaStateContext.Provider>
  );
};

/**
 * 使用熊猫状态的Hook
 * @returns 熊猫状态上下文
 */
export const usePandaState = (): PandaStateContextType => {
  const context = useContext(PandaStateContext);
  if (context === undefined) {
    throw new Error('usePandaState must be used within a PandaStateProvider');
  }
  return context;
};
</file>

<file path="src/features/home/MoodsSection.tsx">
// src/features/home/MoodsSection.tsx
import React from 'react';
import type { HomeMoodsSectionLabels, MoodItem } from '@/types';
import Button from '@/components/common/Button';

interface MoodsSectionProps {
  labels: HomeMoodsSectionLabels | undefined;
  moods: readonly MoodItem[] | undefined; // Made readonly in type
  onRefresh: () => void;
  isFetching?: boolean;
}

const MoodsSection: React.FC<MoodsSectionProps> = ({ labels, moods, onRefresh, isFetching }) => {
  if (!labels) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Loading moods section...</p>;
  }

  return (
    <section className="page-content" style={{marginTop: '20px'}}> {/* Use class for styling */}
      <h4>{labels.sectionTitle}</h4> {/* Use h4 for sections within a page normally */}
      {moods && moods.length > 0 ? (
        <ul>
          {moods.map(mood => (
            <li key={mood.id}>{mood.name}: <strong>{mood.feeling}</strong></li>
          ))}
        </ul>
      ) : (
        <p>{labels.noMoodsMessage}</p>
      )}
      <Button onClick={onRefresh} isLoading={isFetching} loadingText="Refreshing...">
        {labels.refreshButtonText}
      </Button>
    </section>
  );
};
export default MoodsSection;
</file>

<file path="src/features/home/PandaSection.tsx">
// src/features/home/PandaSection.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import PandaAvatar from '@/components/game/PandaAvatar';
import { usePandaState } from '@/context/PandaStateProvider';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import AnimatedButton from '@/components/animation/AnimatedButton';
import GoldenGlow from '@/components/animation/GoldenGlow';
import LoadingSpinner from '@/components/common/LoadingSpinner';

interface PandaSectionLabels {
  sectionTitle?: string;
  levelLabel?: string;
  experienceLabel?: string;
  interactButtonText?: string;
  feedButtonText?: string;
  playButtonText?: string;
  trainButtonText?: string;
}

interface PandaSectionProps {
  labels?: PandaSectionLabels;
}

/**
 * 熊猫互动区域组件
 * 显示熊猫头像和互动按钮
 */
const PandaSection: React.FC<PandaSectionProps> = ({ labels }) => {
  const {
    pandaState,
    isLoading,
    setMood,
    addExperience
  } = usePandaState();

  const [interactionMode, setInteractionMode] = useState<'none' | 'feed' | 'play' | 'train'>('none');

  // 默认标签文本
  const defaultLabels: PandaSectionLabels = {
    sectionTitle: '熊猫伙伴',
    levelLabel: '等级',
    experienceLabel: '经验',
    interactButtonText: '互动',
    feedButtonText: '喂食',
    playButtonText: '玩耍',
    trainButtonText: '训练'
  };

  // 合并默认标签和传入的标签
  const mergedLabels = { ...defaultLabels, ...labels };

  // 定义熊猫状态更新处理函数
  const handlePandaStateUpdate = useCallback(() => {
    // 熊猫状态已经通过 usePandaState 获取，不需要额外处理
    console.log('Panda state updated in PandaSection');
  }, []);

  // 使用 useRegisterTableRefresh hook 监听熊猫状态变化
  useRegisterTableRefresh('pandaState', handlePandaStateUpdate);

  // 处理互动按钮点击
  const handleInteractClick = () => {
    if (interactionMode === 'none') {
      setInteractionMode('feed');
    } else {
      setInteractionMode('none');
    }
  };

  // 处理喂食按钮点击
  const handleFeedClick = async () => {
    await setMood('happy');
    await addExperience(10);
    setInteractionMode('none');
  };

  // 处理玩耍按钮点击
  const handlePlayClick = async () => {
    await setMood('happy');
    await addExperience(15);
    setInteractionMode('none');
  };

  // 处理训练按钮点击
  const handleTrainClick = async () => {
    await setMood('focused');
    await addExperience(20);
    setInteractionMode('none');
  };

  if (isLoading && !pandaState) {
    return <LoadingSpinner variant="jade" text="加载熊猫中..." />;
  }

  if (!pandaState) {
    return <div>无法加载熊猫状态</div>;
  }

  return (
    <motion.section
      className="panda-section"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
    >
      <motion.h3
        initial={{ opacity: 0, x: -20 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ delay: 0.2, duration: 0.5 }}
      >
        {mergedLabels.sectionTitle}
      </motion.h3>

      <div className="panda-container" style={{ textAlign: 'center', marginBottom: '20px' }}>
        <motion.div
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
        >
          {pandaState.level > 5 ? (
            <GoldenGlow intensity="medium">
              <PandaAvatar
                mood={pandaState.mood}
                energy={pandaState.energy}
                size={150}
                onClick={handleInteractClick}
                className={pandaState.mood}
              />
            </GoldenGlow>
          ) : (
            <PandaAvatar
              mood={pandaState.mood}
              energy={pandaState.energy}
              size={150}
              onClick={handleInteractClick}
              className={pandaState.mood}
            />
          )}
        </motion.div>

        <motion.div
          className="panda-stats"
          style={{ marginTop: '10px' }}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.3, duration: 0.5 }}
        >
          <p>
            <strong>{mergedLabels.levelLabel}:</strong> {pandaState.level} |
            <strong> {mergedLabels.experienceLabel}:</strong> {pandaState.experience}
          </p>
        </motion.div>
      </div>

      <AnimatePresence mode="wait">
        {interactionMode === 'none' ? (
          <motion.div
            key="interact"
            className="panda-actions"
            style={{ textAlign: 'center' }}
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            transition={{ duration: 0.3 }}
          >
            <AnimatedButton
              variant="jade"
              onClick={handleInteractClick}
              disabled={isLoading}
            >
              {isLoading ? '请稍候...' : mergedLabels.interactButtonText}
            </AnimatedButton>
          </motion.div>
        ) : (
          <motion.div
            key="buttons"
            className="panda-interaction-buttons"
            style={{
              display: 'flex',
              justifyContent: 'space-around',
              marginTop: '10px'
            }}
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            transition={{ duration: 0.3 }}
          >
            <AnimatedButton
              variant="jade"
              onClick={handleFeedClick}
              disabled={isLoading}
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
            >
              {mergedLabels.feedButtonText}
            </AnimatedButton>

            <AnimatedButton
              variant="jade"
              onClick={handlePlayClick}
              disabled={isLoading}
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
            >
              {mergedLabels.playButtonText}
            </AnimatedButton>

            <AnimatedButton
              variant="jade"
              onClick={handleTrainClick}
              disabled={isLoading}
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
            >
              {mergedLabels.trainButtonText}
            </AnimatedButton>
          </motion.div>
        )}
      </AnimatePresence>
    </motion.section>
  );
};

export default PandaSection;
</file>

<file path="src/features/home/WelcomeSection.tsx">
// src/features/home/WelcomeSection.tsx
import React from 'react';
import type { HomeWelcomeSectionLabels } from '@/types';

interface WelcomeSectionProps {
  labels: HomeWelcomeSectionLabels | undefined;
  username: string | undefined;
}

const WelcomeSection: React.FC<WelcomeSectionProps> = ({ labels, username }) => {
  if (!labels || username === undefined) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Initializing welcome message...</p>;
  }
  const welcomeText = labels.welcomeMessage.replace('{user}', username);
  return <p>{welcomeText}</p>;
};
export default WelcomeSection;
</file>

<file path="src/features/settings/LanguageSettingsSection.tsx">
// src/features/settings/LanguageSettingsSection.tsx
import React, { useState, useEffect } from 'react';
import { useLanguage } from '@/context/LanguageProvider';
import type { Language, SettingsLanguageSectionLabels } from '@/types';
import Button from '@/components/common/Button';

interface LanguageSettingsSectionProps {
  labels: SettingsLanguageSectionLabels | undefined;
  isUpdatingPage?: boolean; // Indicates if the parent page is fetching new labels
}

const LanguageSettingsSection: React.FC<LanguageSettingsSectionProps> = ({ labels, isUpdatingPage }) => {
  const { language, setLanguage } = useLanguage();
  const [selectedLocalLang, setSelectedLocalLang] = useState<Language>(language);
  const [showSuccess, setShowSuccess] = useState(false);

  useEffect(() => {
    setSelectedLocalLang(language); // Sync with global changes
    if (showSuccess) setShowSuccess(false); // Hide success if global lang changes elsewhere
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [language]); // Only re-sync local if global language changes

  if (!labels) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Loading language settings...</p>;
  }

  const handleSave = () => {
    if (selectedLocalLang !== language) {
      setLanguage(selectedLocalLang); // This will trigger page label refetch
      setShowSuccess(true);
      setTimeout(() => setShowSuccess(false), 2500);
    }
  };

  const currentLangDisplay = labels.currentLanguageIs.replace('{lang}', language.toUpperCase());

  return (
    <section className="task-item"> {/* Apply task-item style for a game-themed look */}
      <h4>{labels.sectionTitle}</h4>
      <p>{currentLangDisplay}</p>
      <div>
        <label htmlFor="lang-select-component" style={{ marginRight: '8px' }}>{labels.selectLanguagePrompt}</label>
        <select
          id="lang-select-component"
          value={selectedLocalLang}
          onChange={e => {
            setSelectedLocalLang(e.target.value as Language);
            if (showSuccess) setShowSuccess(false);
          }}
          disabled={isUpdatingPage}
        >
          <option value="en">{labels.langNameEn}</option>
          <option value="zh">{labels.langNameZh}</option>
        </select>
      </div>
      <Button
        onClick={handleSave}
        disabled={isUpdatingPage || selectedLocalLang === language}
        style={{marginTop: '15px'}}
        variant="jade" // Use jade button style
      >
        {labels.saveButtonText}
      </Button>
      {showSuccess && (
        <p style={{
          color: 'var(--ruyi-green)',
          marginTop: '10px',
          fontStyle:'italic',
          background: 'rgba(46, 139, 87, 0.1)',
          padding: '8px',
          borderRadius: 'var(--radius-sm)'
        }}>
          {labels.successMessage}
        </p>
      )}
    </section>
  );
};
export default LanguageSettingsSection;
</file>

<file path="src/features/tasks/TaskManager.tsx">
// src/features/tasks/TaskManager.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { AnimatePresence } from 'framer-motion';
import {
  TaskRecord,
  TaskStatus,
  TaskPriority,
  TaskType,
  createTask,
  updateTask,
  getAllTasks,
  initializeTaskCategories
} from '@/services/taskService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import TaskForm from '@/components/game/TaskForm';
import AnimatedTaskList from '@/components/animation/AnimatedTaskList';
import AnimatedButton from '@/components/animation/AnimatedButton';
import PageTransition from '@/components/animation/PageTransition';

interface TaskManagerLabels {
  sectionTitle?: string;
  createTaskButton?: string;
  filterAllLabel?: string;
  filterTodoLabel?: string;
  filterInProgressLabel?: string;
  filterCompletedLabel?: string;
  noTasksMessage?: string;
}

interface TaskManagerProps {
  labels?: TaskManagerLabels;
}

/**
 * 任务管理器组件，包含任务列表和任务表单
 */
const TaskManager: React.FC<TaskManagerProps> = ({ labels }) => {
  const [showForm, setShowForm] = useState(false);
  const [editingTask, setEditingTask] = useState<TaskRecord | null>(null);
  const [statusFilter, setStatusFilter] = useState<TaskStatus | undefined>(undefined);
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  // 默认标签
  const defaultLabels: TaskManagerLabels = {
    sectionTitle: '任务管理',
    createTaskButton: '创建新任务',
    filterAllLabel: '全部',
    filterTodoLabel: '待办',
    filterInProgressLabel: '进行中',
    filterCompletedLabel: '已完成',
    noTasksMessage: '暂无任务'
  };

  // 合并标签
  const mergedLabels = { ...defaultLabels, ...labels };

  // 使用 useRef 来避免依赖变化
  const setRefreshTriggerRef = React.useRef(setRefreshTrigger);

  // 更新 ref 当依赖变化时
  React.useEffect(() => {
    setRefreshTriggerRef.current = setRefreshTrigger;
  }, [setRefreshTrigger]);

  // 使用稳定的回调函数，不依赖于 setRefreshTrigger
  const handleDataRefresh = useCallback(() => {
    // 只需要触发刷新，不需要重新获取所有数据
    setRefreshTriggerRef.current(prev => prev + 1);
  }, []); // 没有依赖项，使用 ref 来获取最新值

  // 使用 useRegisterTableRefresh 监听 'tasks' 表的数据刷新
  useRegisterTableRefresh('tasks', handleDataRefresh);

  // 初始化任务类别
  useEffect(() => {
    initializeTaskCategories();
  }, []);

  // 处理创建任务
  const handleCreateTask = async (taskData: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'>) => {
    try {
      await createTask(taskData);
      setShowForm(false);
      // 不需要手动触发刷新，数据同步服务会自动触发
    } catch (error) {
      console.error('Failed to create task:', error);
      alert('创建任务失败，请重试');
    }
  };

  // 处理更新任务
  const handleUpdateTask = async (taskData: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'>) => {
    if (!editingTask?.id) return;

    try {
      await updateTask(editingTask.id, taskData);
      setEditingTask(null);
      setShowForm(false);
      // 不需要手动触发刷新，数据同步服务会自动触发
    } catch (error) {
      console.error('Failed to update task:', error);
      alert('更新任务失败，请重试');
    }
  };

  // 处理编辑任务
  const handleEditTask = async (taskId: number) => {
    try {
      const tasks = await getAllTasks();
      const task = tasks.find(t => t.id === taskId);

      if (task) {
        setEditingTask(task);
        setShowForm(true);
      }
    } catch (error) {
      console.error('Failed to get task for editing:', error);
      alert('获取任务详情失败，请重试');
    }
  };

  // 处理取消表单
  const handleCancelForm = () => {
    setShowForm(false);
    setEditingTask(null);
  };

  return (
    <PageTransition className="task-manager">
      <div className="task-manager-header">
        <h2>{mergedLabels.sectionTitle}</h2>

        {!showForm && (
          <AnimatedButton
            variant="jade"
            onClick={() => setShowForm(true)}
          >
            {mergedLabels.createTaskButton}
          </AnimatedButton>
        )}
      </div>

      <AnimatePresence mode="wait">
        {showForm ? (
          <PageTransition key="task-form">
            <TaskForm
              initialTask={editingTask || {}}
              onSubmit={editingTask ? handleUpdateTask : handleCreateTask}
              onCancel={handleCancelForm}
            />
          </PageTransition>
        ) : (
          <PageTransition key="task-list">
            <div className="task-filter-tabs">
              <button
                className={statusFilter === undefined ? 'active' : ''}
                onClick={() => setStatusFilter(undefined)}
              >
                {mergedLabels.filterAllLabel}
              </button>
              <button
                className={statusFilter === TaskStatus.TODO ? 'active' : ''}
                onClick={() => setStatusFilter(TaskStatus.TODO)}
              >
                {mergedLabels.filterTodoLabel}
              </button>
              <button
                className={statusFilter === TaskStatus.IN_PROGRESS ? 'active' : ''}
                onClick={() => setStatusFilter(TaskStatus.IN_PROGRESS)}
              >
                {mergedLabels.filterInProgressLabel}
              </button>
              <button
                className={statusFilter === TaskStatus.COMPLETED ? 'active' : ''}
                onClick={() => setStatusFilter(TaskStatus.COMPLETED)}
              >
                {mergedLabels.filterCompletedLabel}
              </button>
            </div>

            <AnimatedTaskList
              onEditTask={handleEditTask}
              filter={{ status: statusFilter }}
              refreshTrigger={refreshTrigger}
            />
          </PageTransition>
        )}
      </AnimatePresence>
    </PageTransition>
  );
};

export default TaskManager;
</file>

<file path="src/hooks/useDataRefresh.ts">
// src/hooks/useDataRefresh.ts
import { useEffect, useState, useCallback, useRef } from 'react';
import { useDataRefreshContext } from '@/context/DataRefreshProvider';
import { DataRefreshEvent } from '@/types/dataRefresh';

/**
 * 自定义 Hook，用于监听数据刷新事件
 *
 * @param tables 要监听的表名数组
 * @param callback 数据刷新时的回调函数
 * @returns 最近一次刷新的数据
 */
export function useDataRefresh(
  tables: string[],
  callback?: (event: DataRefreshEvent) => void
): DataRefreshEvent | null {
  const [lastRefresh, setLastRefresh] = useState<DataRefreshEvent | null>(null);
  const { registerRefreshListener } = useDataRefreshContext();

  useEffect(() => {
    // 为每个表注册监听器
    const unregisterFunctions = tables.map(table => {
      return registerRefreshListener(table, (data) => {
        const event = { table, data };
        setLastRefresh(event);

        if (callback) {
          callback(event);
        }
      });
    });

    // 清理函数
    return () => {
      unregisterFunctions.forEach(unregister => unregister());
    };
  }, [tables, callback, registerRefreshListener]);

  return lastRefresh;
}

/**
 * 自定义 Hook，用于监听特定表的数据刷新事件
 *
 * @param table 要监听的表名
 * @param callback 数据刷新时的回调函数
 * @returns 最近一次刷新的数据
 */
export function useTableRefresh(
  table: string,
  callback?: (data: any) => void
): any | null {
  const [lastData, setLastData] = useState<any | null>(null);
  const { registerRefreshListener } = useDataRefreshContext();

  useEffect(() => {
    // 注册表监听器
    const unregister = registerRefreshListener(table, (data) => {
      setLastData(data);

      if (callback) {
        callback(data);
      }
    });

    // 清理函数
    return unregister;
  }, [table, callback, registerRefreshListener]);

  return lastData;
}

/**
 * 自定义 Hook，用于注册表数据刷新监听器
 *
 * @param table 要监听的表名
 * @param callback 数据刷新时的回调函数
 * @returns 取消注册的函数
 */
export function useRegisterTableRefresh(
  table: string,
  callback: (data: any) => void
): () => void {
  const { registerRefreshListener } = useDataRefreshContext();

  // 使用 ref 来存储最新的回调函数，避免依赖变化
  const callbackRef = useRef(callback);

  // 更新 callbackRef 当 callback 变化时
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  // 使用 ref 来存储最新的 table 值
  const tableRef = useRef(table);

  // 更新 tableRef 当 table 变化时
  useEffect(() => {
    tableRef.current = table;
  }, [table]);

  // 使用 ref 来存储最新的 registerRefreshListener 函数
  const registerRefreshListenerRef = useRef(registerRefreshListener);

  // 更新 registerRefreshListenerRef 当 registerRefreshListener 变化时
  useEffect(() => {
    registerRefreshListenerRef.current = registerRefreshListener;
  }, [registerRefreshListener]);

  // 只在组件挂载时注册一次监听器
  useEffect(() => {
    // 创建一个稳定的回调函数，它总是使用最新的 callback
    const stableCallback = (data: any) => {
      // 使用 ref 获取最新的 callback
      callbackRef.current(data);
    };

    // 注册表监听器
    const unregister = registerRefreshListenerRef.current(tableRef.current, stableCallback);

    // 清理函数
    return unregister;
  }, []); // 没有依赖项，使用 ref 获取最新的值

  return () => {}; // 返回一个空函数，实际的取消注册在 useEffect 的清理函数中完成
}

/**
 * 手动触发数据刷新事件
 * 注意：此函数必须在React组件内部使用
 *
 * @param table 表名
 * @param data 数据
 */
export function useDataRefreshTrigger() {
  const { refreshTable } = useDataRefreshContext();

  return (table: string, data?: any): void => {
    refreshTable(table, data);
  };
}

/**
 * 直接触发数据刷新事件（不使用hook，可以在任何地方调用）
 *
 * @param table 表名
 * @param data 数据
 */
export function triggerDataRefresh(table: string, data?: any): void {
  const refreshEvent = new CustomEvent('dataRefresh', {
    detail: { table, data }
  });
  window.dispatchEvent(refreshEvent);
}
</file>

<file path="src/hooks/useInternationalizedQuery.ts">
// src/hooks/useInternationalizedQuery.ts
import {
  useQuery,
  type UseQueryOptions,
  type QueryKey,
  type UseQueryResult,
} from '@tanstack/react-query';
import type { ApiError, LocalizedContent } from '@/types';

interface UseInternationalizedQueryResult<TDataPayload, TLabelsBundle, TErrorResponse> {
  data: TDataPayload | undefined | null; // Data can be TDataPayload OR null
  labels: TLabelsBundle | undefined;
  isPending: boolean;
  isLoading: boolean;
  isFetching: boolean;
  isError: boolean;
  error: TErrorResponse | null;
  refetch: UseQueryResult<LocalizedContent<TDataPayload, TLabelsBundle>, TErrorResponse>['refetch'];
  status: UseQueryResult<LocalizedContent<TDataPayload, TLabelsBundle>, TErrorResponse>['status'];
  isSuccess: boolean;
}

export function useInternationalizedQuery<
  TLocalizedContent extends LocalizedContent<TDataPayload, TLabelsBundle>,
  TErrorResponse extends Error = ApiError,
  TDataPayload = TLocalizedContent['data'],
  TLabelsBundle = TLocalizedContent['labels'],
  TQueryKey extends QueryKey = QueryKey
>(
  options: UseQueryOptions<TLocalizedContent, TErrorResponse, TLocalizedContent, TQueryKey>
): UseInternationalizedQueryResult<TDataPayload, TLabelsBundle, TErrorResponse> {
  const {
    data: queryResult,
    isPending,
    isLoading,
    isFetching,
    isError,
    error,
    refetch,
    status,
    isSuccess,
  } = useQuery<TLocalizedContent, TErrorResponse, TLocalizedContent, TQueryKey>(options);

  return {
    data: queryResult?.data, // queryResult can be undefined during initial fetch
    labels: queryResult?.labels,
    isPending,
    isLoading,
    isFetching,
    isError,
    error,
    refetch,
    status,
    isSuccess,
  };
}
</file>

<file path="src/hooks/useLocalizedView.ts">
// src/hooks/useLocalizedView.ts
import { useLanguage } from '@/context/LanguageProvider';
import { useInternationalizedQuery } from './useInternationalizedQuery';
import type { ApiError, Language, LocalizedContent } from '@/types';
import { QueryKey, UseQueryOptions } from '@tanstack/react-query';

export function useLocalizedView<
  TDataPayload,
  TLabelsBundle
>(
  viewQueryKey: string | QueryKey,
  fetchViewFn: (lang: Language) => Promise<LocalizedContent<TDataPayload, TLabelsBundle>>,
  options?: Omit<UseQueryOptions<LocalizedContent<TDataPayload, TLabelsBundle>, ApiError, LocalizedContent<TDataPayload, TLabelsBundle>, QueryKey>, 'queryKey' | 'queryFn'>
) {
  const { language } = useLanguage();
  const fullQueryKeyWithLang: QueryKey = Array.isArray(viewQueryKey)
    ? [...viewQueryKey, language]
    : [viewQueryKey, language];

  return useInternationalizedQuery<
    LocalizedContent<TDataPayload, TLabelsBundle>,
    ApiError,
    TDataPayload,
    TLabelsBundle
  >({
    queryKey: fullQueryKeyWithLang,
    queryFn: () => fetchViewFn(language),
    enabled: !!language && (options?.enabled === undefined || options.enabled),
    ...options,
  });
}
</file>

<file path="src/main.tsx">
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';
import './index.css'; // Base styles
import './game-theme.css'; // Game-themed styles

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path="src/pages/AbilitiesPage.tsx">
// src/pages/AbilitiesPage.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { usePandaState } from '@/context/PandaStateProvider';
import AbilityList from '@/components/game/AbilityList';
import AbilityUnlockNotification from '@/components/game/AbilityUnlockNotification';
import PageTransition from '@/components/animation/PageTransition';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { PandaAbilityRecord } from '@/services/pandaAbilityService';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchAbilitiesPageView } from '@/services/localizedContentService';
import { AbilitiesPageViewLabelsBundle } from '@/types';

/**
 * 熊猫能力页面
 * 显示所有熊猫能力，并允许激活已解锁的能力
 */
const AbilitiesPage: React.FC = () => {
  const {
    pandaState,
    abilities,
    unlockedAbilities,
    isLoading: isPandaLoading,
    activateAbility,
    checkNewAbilities
  } = usePandaState();

  const [newlyUnlockedAbilities, setNewlyUnlockedAbilities] = useState<PandaAbilityRecord[]>([]);
  const [showUnlockNotification, setShowUnlockNotification] = useState(false);

  // 获取本地化标签
  const {
    labels: pageLabels,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<null, AbilitiesPageViewLabelsBundle>(
    'abilitiesPageViewContent',
    fetchAbilitiesPageView
  );

  // 合并加载状态
  const isLoading = isPandaLoading || isPending;

  // 检查新解锁的能力
  useEffect(() => {
    const checkForNewAbilities = async () => {
      const newAbilities = await checkNewAbilities();
      if (newAbilities.length > 0) {
        setNewlyUnlockedAbilities(newAbilities);
        setShowUnlockNotification(true);
      }
    };

    checkForNewAbilities();
  }, [checkNewAbilities]);

  // 关闭解锁通知
  const handleCloseUnlockNotification = () => {
    setShowUnlockNotification(false);
    setNewlyUnlockedAbilities([]);
  };

  // 激活能力
  const handleActivateAbility = async (abilityId: number) => {
    await activateAbility(abilityId);
  };

  // 显示错误状态
  if (isError) {
    return (
      <PageTransition>
        <div className="page-content">
          <ErrorDisplay
            error={error}
            title={pageLabels?.errorTitle || "加载能力失败"}
            messageTemplate={pageLabels?.errorMessage || "无法加载能力数据: {message}"}
            onRetry={refetch}
            retryButtonText={pageLabels?.retryButtonText || "重试"}
          />
        </div>
      </PageTransition>
    );
  }

  return (
    <PageTransition>
      <div className="page-content">
        <div className="bamboo-frame">
          <h2>{pageLabels?.pageTitle || "熊猫能力"}</h2>

          {isLoading ? (
            <div className="loading-container">
              <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "加载能力中..."} />
            </div>
          ) : (
            <>
              <div className="abilities-header">
                <motion.div
                  className="panda-level-info"
                  initial={{ opacity: 0, y: -20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.5 }}
                >
                  <h3>{pageLabels?.pandaLevelLabel || "熊猫等级"}: {pandaState?.level || 1}</h3>
                  <p>{pageLabels?.unlockedAbilitiesLabel || "解锁能力"}: {unlockedAbilities.length} / {abilities.length}</p>
                </motion.div>

                <motion.div
                  className="abilities-description"
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.5, delay: 0.2 }}
                >
                  <p>
                    {pageLabels?.abilitiesDescription ||
                      "熊猫能力可以帮助你更高效地完成任务，获得更多奖励。随着熊猫等级的提升，你将解锁更多强大的能力。"}
                  </p>
                </motion.div>
              </div>

              <AbilityList
                abilities={abilities}
                unlockedAbilities={unlockedAbilities}
                onActivateAbility={handleActivateAbility}
                pandaLevel={pandaState?.level || 1}
              />
            </>
          )}
        </div>

        {/* 能力解锁通知 */}
        {showUnlockNotification && (
          <AbilityUnlockNotification
            newlyUnlockedAbilities={newlyUnlockedAbilities}
            onClose={handleCloseUnlockNotification}
          />
        )}
      </div>
    </PageTransition>
  );
};

export default AbilitiesPage;
</file>

<file path="src/pages/ChallengesPage.tsx">
// src/pages/ChallengesPage.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import {
  ChallengeStatus,
  ChallengeType,
  ChallengeDifficulty,
  initializeChallengeCategories
} from '@/services/challengeService';
import ChallengeList from '@/components/game/ChallengeList';
import PageTransition from '@/components/animation/PageTransition';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import AnimatedButton from '@/components/animation/AnimatedButton';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { fetchChallengesPageView } from '@/services/localizedContentService';
import type { ChallengesPageViewLabelsBundle } from '@/types';

/**
 * 挑战页面
 * 显示挑战列表和过滤选项
 */
const ChallengesPage: React.FC = () => {
  const [filter, setFilter] = useState<{
    status?: ChallengeStatus;
    type?: ChallengeType;
    difficulty?: ChallengeDifficulty;
  }>({
    status: ChallengeStatus.ACTIVE
  });

  const {
    labels: pageLabels,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<null, ChallengesPageViewLabelsBundle>(
    'challengesPageViewContent',
    fetchChallengesPageView
  );

  // 初始化挑战类别
  useEffect(() => {
    initializeChallengeCategories();
  }, []);

  // 处理状态过滤
  const handleStatusFilter = (status?: ChallengeStatus) => {
    setFilter(prev => ({ ...prev, status }));
  };

  // 处理类型过滤
  const handleTypeFilter = (type?: ChallengeType) => {
    setFilter(prev => ({ ...prev, type }));
  };

  // 处理难度过滤
  const handleDifficultyFilter = (difficulty?: ChallengeDifficulty) => {
    setFilter(prev => ({ ...prev, difficulty }));
  };

  // 清除所有过滤器
  const clearAllFilters = () => {
    setFilter({});
  };

  // 显示加载状态
  if (isPending) {
    return (
      <PageTransition>
        <div className="challenges-page">
          <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "加载挑战中..."} />
        </div>
      </PageTransition>
    );
  }

  // 显示错误状态
  if (isError) {
    return (
      <PageTransition>
        <div className="challenges-page">
          <ErrorDisplay
            error={error}
            title={pageLabels?.errorTitle || "加载挑战失败"}
            messageTemplate={pageLabels?.errorMessage || "无法加载挑战数据: {message}"}
            onRetry={refetch}
            retryButtonText={pageLabels?.retryButtonText || "重试"}
          />
        </div>
      </PageTransition>
    );
  }

  return (
    <PageTransition>
      <motion.div
        className="challenges-page"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
      >
        <div className="page-header">
          <h1 className="page-title">{pageLabels?.pageTitle || '挑战'}</h1>
        </div>

        <div className="filter-section">
          <div className="filter-group">
            <h3 className="filter-title">状态</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleStatusFilter(undefined)}
                className={!filter.status ? 'active' : ''}
              >
                {pageLabels?.filters?.allLabel || '全部'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(ChallengeStatus.ACTIVE)}
                className={filter.status === ChallengeStatus.ACTIVE ? 'active' : ''}
              >
                {pageLabels?.filters?.activeLabel || '进行中'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(ChallengeStatus.COMPLETED)}
                className={filter.status === ChallengeStatus.COMPLETED ? 'active' : ''}
              >
                {pageLabels?.filters?.completedLabel || '已完成'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(ChallengeStatus.UPCOMING)}
                className={filter.status === ChallengeStatus.UPCOMING ? 'active' : ''}
              >
                {pageLabels?.filters?.upcomingLabel || '即将开始'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-group">
            <h3 className="filter-title">类型</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleTypeFilter(undefined)}
                className={!filter.type ? 'active' : ''}
              >
                {pageLabels?.filters?.typeAllLabel || '全部'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(ChallengeType.DAILY)}
                className={filter.type === ChallengeType.DAILY ? 'active' : ''}
              >
                {pageLabels?.filters?.typeDailyLabel || '每日'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(ChallengeType.WEEKLY)}
                className={filter.type === ChallengeType.WEEKLY ? 'active' : ''}
              >
                {pageLabels?.filters?.typeWeeklyLabel || '每周'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(ChallengeType.EVENT)}
                className={filter.type === ChallengeType.EVENT ? 'active' : ''}
              >
                {pageLabels?.filters?.typeEventLabel || '活动'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(ChallengeType.ONGOING)}
                className={filter.type === ChallengeType.ONGOING ? 'active' : ''}
              >
                {pageLabels?.filters?.typeOngoingLabel || '持续'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-group">
            <h3 className="filter-title">难度</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleDifficultyFilter(undefined)}
                className={!filter.difficulty ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyAllLabel || '全部'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleDifficultyFilter(ChallengeDifficulty.EASY)}
                className={filter.difficulty === ChallengeDifficulty.EASY ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyEasyLabel || '简单'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleDifficultyFilter(ChallengeDifficulty.MEDIUM)}
                className={filter.difficulty === ChallengeDifficulty.MEDIUM ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyMediumLabel || '中等'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleDifficultyFilter(ChallengeDifficulty.HARD)}
                className={filter.difficulty === ChallengeDifficulty.HARD ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyHardLabel || '困难'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleDifficultyFilter(ChallengeDifficulty.EXPERT)}
                className={filter.difficulty === ChallengeDifficulty.EXPERT ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyExpertLabel || '专家'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-actions">
            <AnimatedButton onClick={clearAllFilters} className="clear-filters-button">
              {pageLabels?.filters?.clearFiltersLabel || '清除所有过滤器'}
            </AnimatedButton>
          </div>
        </div>

        <div className="challenges-container">
          <ChallengeList filter={filter} />
        </div>
      </motion.div>
    </PageTransition>
  );
};

export default ChallengesPage;
</file>

<file path="src/pages/TasksPage.tsx">
// src/pages/TasksPage.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchTasksPageView } from '@/services';
import TaskManager from '@/features/tasks/TaskManager';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { pageTransition } from '@/utils/animation';
import type { TasksPageViewLabelsBundle } from '@/types';

const TasksPage: React.FC = () => {
  const {
    labels: pageLabels, isPending, isError, error, refetch
  } = useLocalizedView<null, TasksPageViewLabelsBundle>(
    'tasksPageViewContent',
    fetchTasksPageView
  );

  if (isPending) { // 完整页面初始加载
    return <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "加载任务页面内容..."} />;
  }

  if (isError) { // 关键错误：页面标签加载失败
    return (
      <div className="page-content">
        <ErrorDisplay
          error={error}
          title={pageLabels?.errorTitle || "任务页面错误"}
          messageTemplate={pageLabels?.errorMessage || "无法加载任务数据: {message}"}
          onRetry={refetch}
          retryButtonText={pageLabels?.retryButtonText || "重试"}
        />
      </div>
    );
  }

  return (
    <motion.div
      className="page-container"
      variants={pageTransition}
      initial="hidden"
      animate="visible"
      exit="exit"
    >
      <div className="bamboo-frame">
        <h2>{pageLabels?.pageTitle || "任务管理"}</h2>

        <TaskManager labels={pageLabels?.taskManager} />
      </div>
    </motion.div>
  );
};

export default TasksPage;
</file>

<file path="src/pages/TimelyRewardsPage.tsx">
// src/pages/TimelyRewardsPage.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import {
  TimelyRewardStatus,
  TimelyRewardType,
  initializeTimelyRewards
} from '@/services/timelyRewardService';
import TimelyRewardList from '@/components/game/TimelyRewardList';
import LuckyDraw from '@/components/game/LuckyDraw';
import PageTransition from '@/components/animation/PageTransition';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import AnimatedButton from '@/components/animation/AnimatedButton';
import ScrollDialog from '@/components/game/ScrollDialog';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { fetchTimelyRewardsPageView } from '@/services/localizedContentService';
import type { TimelyRewardsPageViewLabelsBundle } from '@/types';

/**
 * 及时奖励页面
 * 显示及时奖励列表和幸运抽奖
 */
const TimelyRewardsPage: React.FC = () => {
  const [filter, setFilter] = useState<{
    status?: TimelyRewardStatus;
    type?: TimelyRewardType;
  }>({
    status: TimelyRewardStatus.ACTIVE
  });
  const [showLuckyDraw, setShowLuckyDraw] = useState(false);

  const {
    labels: pageLabels,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<null, TimelyRewardsPageViewLabelsBundle>(
    'timelyRewardsPageViewContent',
    fetchTimelyRewardsPageView
  );

  // 初始化及时奖励
  useEffect(() => {
    initializeTimelyRewards();
  }, []);

  // 处理状态过滤
  const handleStatusFilter = (status?: TimelyRewardStatus) => {
    setFilter(prev => ({ ...prev, status }));
  };

  // 处理类型过滤
  const handleTypeFilter = (type?: TimelyRewardType) => {
    setFilter(prev => ({ ...prev, type }));
  };

  // 清除所有过滤器
  const clearAllFilters = () => {
    setFilter({});
  };

  // 打开幸运抽奖
  const openLuckyDraw = () => {
    setShowLuckyDraw(true);
  };

  // 关闭幸运抽奖
  const closeLuckyDraw = () => {
    setShowLuckyDraw(false);
  };

  if (isPending && !pageLabels) { // 完整页面初始加载
    return <LoadingSpinner variant="jade" text="加载及时奖励页面内容..." />;
  }

  if (isError && !pageLabels) { // 关键错误：页面标签加载失败
    return (
      <div className="page-content">
        <ErrorDisplay error={error} title="及时奖励页面错误" onRetry={refetch} />
      </div>
    );
  }

  return (
    <PageTransition>
      <motion.div
        className="timely-rewards-page"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
      >
        <div className="page-header">
          <h1 className="page-title">{pageLabels?.pageTitle || '及时奖励'}</h1>
          <AnimatedButton
            onClick={openLuckyDraw}
            className="lucky-draw-button"
          >
            {pageLabels?.luckyDraw?.buttonText || '幸运抽奖'}
          </AnimatedButton>
        </div>

        <div className="filter-section">
          <div className="filter-group">
            <h3 className="filter-title">状态</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleStatusFilter(undefined)}
                className={!filter.status ? 'active' : ''}
              >
                {pageLabels?.filters?.allLabel || '全部'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(TimelyRewardStatus.ACTIVE)}
                className={filter.status === TimelyRewardStatus.ACTIVE ? 'active' : ''}
              >
                {pageLabels?.filters?.activeLabel || '进行中'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(TimelyRewardStatus.COMPLETED)}
                className={filter.status === TimelyRewardStatus.COMPLETED ? 'active' : ''}
              >
                {pageLabels?.filters?.completedLabel || '已完成'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(TimelyRewardStatus.UPCOMING)}
                className={filter.status === TimelyRewardStatus.UPCOMING ? 'active' : ''}
              >
                {pageLabels?.filters?.upcomingLabel || '即将开始'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-group">
            <h3 className="filter-title">类型</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleTypeFilter(undefined)}
                className={!filter.type ? 'active' : ''}
              >
                {pageLabels?.filters?.typeAllLabel || '全部'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(TimelyRewardType.DAILY)}
                className={filter.type === TimelyRewardType.DAILY ? 'active' : ''}
              >
                {pageLabels?.filters?.typeDailyLabel || '每日奖励'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(TimelyRewardType.MORNING)}
                className={filter.type === TimelyRewardType.MORNING ? 'active' : ''}
              >
                {pageLabels?.filters?.typeMorningLabel || '早起鸟奖励'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(TimelyRewardType.STREAK)}
                className={filter.type === TimelyRewardType.STREAK ? 'active' : ''}
              >
                {pageLabels?.filters?.typeStreakLabel || '连续完成奖励'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(TimelyRewardType.SPECIAL)}
                className={filter.type === TimelyRewardType.SPECIAL ? 'active' : ''}
              >
                {pageLabels?.filters?.typeSpecialLabel || '特殊奖励'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-actions">
            <AnimatedButton onClick={clearAllFilters} className="clear-filters-button">
              {pageLabels?.filters?.clearFiltersLabel || '清除所有过滤器'}
            </AnimatedButton>
          </div>
        </div>

        <div className="rewards-container">
          <TimelyRewardList filter={filter} />
        </div>

        {/* 幸运抽奖模态框 */}
        {showLuckyDraw && (
          <ScrollDialog
            isOpen={showLuckyDraw}
            title={pageLabels?.luckyDraw?.title || '幸运抽奖'}
            onClose={closeLuckyDraw}
          >
            <div className="lucky-draw-dialog">
              <LuckyDraw onClose={closeLuckyDraw} />
            </div>
          </ScrollDialog>
        )}
      </motion.div>
    </PageTransition>
  );
};

export default TimelyRewardsPage;
</file>

<file path="src/services/challengeService.ts">
// src/services/challengeService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { generateRewardsForChallenge, RewardRecord } from './rewardService';
import { TaskRecord, TaskStatus } from './taskService';

// 挑战状态枚举
export enum ChallengeStatus {
  ACTIVE = 'active',         // 活跃中
  COMPLETED = 'completed',   // 已完成
  EXPIRED = 'expired',       // 已过期
  UPCOMING = 'upcoming'      // 即将开始
}

// 挑战类型枚举
export enum ChallengeType {
  DAILY = 'daily',           // 每日挑战
  WEEKLY = 'weekly',         // 每周挑战
  EVENT = 'event',           // 活动挑战
  ONGOING = 'ongoing'        // 持续性挑战
}

// 挑战难度枚举
export enum ChallengeDifficulty {
  EASY = 'easy',             // 简单
  MEDIUM = 'medium',         // 中等
  HARD = 'hard',             // 困难
  EXPERT = 'expert'          // 专家
}

// 挑战记录类型
export interface ChallengeRecord {
  id?: number;               // 挑战ID
  title: string;             // 挑战标题
  description: string;       // 挑战描述
  type: ChallengeType;       // 挑战类型
  difficulty: ChallengeDifficulty; // 挑战难度
  status: ChallengeStatus;   // 挑战状态
  progress: number;          // 进度（0-100）
  startDate: Date;           // 开始日期
  endDate?: Date;            // 结束日期（可选，持续性挑战可能没有）
  completedDate?: Date;      // 完成日期
  taskIds: number[];         // 关联的任务ID列表
  rewardIds?: number[];      // 奖励ID列表
  iconPath: string;          // 图标路径
  createdAt: Date;           // 创建时间
  updatedAt: Date;           // 更新时间
}

// 挑战完成记录类型
export interface ChallengeCompletionRecord {
  id?: number;               // 记录ID
  challengeId: number;       // 挑战ID
  userId: string;            // 用户ID
  completedDate: Date;       // 完成日期
  rewardIds: number[];       // 获得的奖励ID列表
  createdAt: Date;           // 创建时间
}

// 预定义的挑战类别
export const PREDEFINED_CHALLENGE_CATEGORIES = [
  {
    id: 1,
    name: '健康习惯',
    description: '培养健康的生活方式',
    iconPath: '/assets/challenges/health.svg'
  },
  {
    id: 2,
    name: '学习成长',
    description: '提升知识和技能',
    iconPath: '/assets/challenges/learning.svg'
  },
  {
    id: 3,
    name: '工作效率',
    description: '提高工作和学习效率',
    iconPath: '/assets/challenges/productivity.svg'
  },
  {
    id: 4,
    name: '心灵成长',
    description: '培养积极心态和情绪管理',
    iconPath: '/assets/challenges/mindfulness.svg'
  },
  {
    id: 5,
    name: '社交关系',
    description: '改善人际关系和社交技能',
    iconPath: '/assets/challenges/social.svg'
  }
];

/**
 * 初始化挑战类别
 * 如果数据库中没有挑战类别记录，则添加预定义的类别
 */
export async function initializeChallengeCategories(): Promise<void> {
  try {
    const categories = await db.table('challengeCategories').toArray();

    if (categories.length === 0) {
      // 逐个添加类别，避免批量添加时的冲突
      for (const category of PREDEFINED_CHALLENGE_CATEGORIES) {
        try {
          // 检查类别是否已存在
          const existingCategory = await db.table('challengeCategories').get(category.id);
          if (!existingCategory) {
            await db.table('challengeCategories').add(category);
          }
        } catch (err) {
          console.warn(`Failed to add challenge category ${category.id}: ${err}`);
        }
      }
    }
  } catch (err) {
    console.error('Failed to initialize challenge categories:', err);
  }
}

/**
 * 获取所有挑战类别
 */
export async function getAllChallengeCategories(): Promise<any[]> {
  return db.table('challengeCategories').toArray();
}

/**
 * 获取所有挑战
 * @param filter 过滤条件
 */
export async function getAllChallenges(filter?: {
  status?: ChallengeStatus;
  type?: ChallengeType;
  difficulty?: ChallengeDifficulty;
}): Promise<ChallengeRecord[]> {
  let collection = db.table('challenges').toCollection();

  if (filter) {
    if (filter.status) {
      collection = collection.filter(challenge => challenge.status === filter.status);
    }
    if (filter.type) {
      collection = collection.filter(challenge => challenge.type === filter.type);
    }
    if (filter.difficulty) {
      collection = collection.filter(challenge => challenge.difficulty === filter.difficulty);
    }
  }

  return collection.toArray();
}

/**
 * 获取单个挑战
 * @param id 挑战ID
 */
export async function getChallenge(id: number): Promise<ChallengeRecord | undefined> {
  return db.table('challenges').get(id);
}

/**
 * 创建新挑战
 * @param challengeData 挑战数据
 */
export async function createChallenge(
  challengeData: Omit<ChallengeRecord, 'id' | 'createdAt' | 'updatedAt' | 'status' | 'progress'>
): Promise<ChallengeRecord> {
  const now = new Date();

  const challenge: ChallengeRecord = {
    ...challengeData,
    status: ChallengeStatus.UPCOMING,
    progress: 0,
    createdAt: now,
    updatedAt: now
  };

  const id = await db.table('challenges').add(challenge);
  const newChallenge = { ...challenge, id: id as number };

  // 添加到同步队列
  await addSyncItem('challenges', 'create', newChallenge);

  return newChallenge;
}

/**
 * 更新挑战
 * @param id 挑战ID
 * @param challengeData 挑战数据
 */
export async function updateChallenge(
  id: number,
  challengeData: Partial<ChallengeRecord>
): Promise<ChallengeRecord> {
  const challenge = await db.table('challenges').get(id);

  if (!challenge) {
    throw new Error(`Challenge with id ${id} not found`);
  }

  const updatedChallenge = {
    ...challenge,
    ...challengeData,
    updatedAt: new Date()
  };

  await db.table('challenges').update(id, updatedChallenge);

  // 添加到同步队列
  await addSyncItem('challenges', 'update', updatedChallenge);

  return updatedChallenge;
}

/**
 * 删除挑战
 * @param id 挑战ID
 */
export async function deleteChallenge(id: number): Promise<void> {
  const challenge = await db.table('challenges').get(id);

  if (!challenge) {
    throw new Error(`Challenge with id ${id} not found`);
  }

  await db.table('challenges').delete(id);

  // 添加到同步队列
  await addSyncItem('challenges', 'delete', { id });
}

/**
 * 更新挑战进度
 * @param id 挑战ID
 * @param progress 进度值（0-100）
 */
export async function updateChallengeProgress(id: number, progress: number): Promise<ChallengeRecord> {
  const challenge = await db.table('challenges').get(id);

  if (!challenge) {
    throw new Error(`Challenge with id ${id} not found`);
  }

  // 确保进度在0-100范围内
  const validProgress = Math.max(0, Math.min(100, progress));

  // 如果进度达到100%，将状态更新为已完成
  let status = challenge.status;
  let completedDate = challenge.completedDate;

  if (validProgress >= 100 && status !== ChallengeStatus.COMPLETED) {
    status = ChallengeStatus.COMPLETED;
    completedDate = new Date();
  }

  const updatedChallenge = {
    ...challenge,
    progress: validProgress,
    status,
    completedDate,
    updatedAt: new Date()
  };

  await db.table('challenges').update(id, updatedChallenge);

  // 添加到同步队列
  await addSyncItem('challenges', 'update', updatedChallenge);

  return updatedChallenge;
}

/**
 * 完成挑战
 * @param id 挑战ID
 */
export async function completeChallenge(id: number): Promise<RewardRecord[]> {
  const challenge = await db.table('challenges').get(id);

  if (!challenge) {
    throw new Error(`Challenge with id ${id} not found`);
  }

  if (challenge.status === ChallengeStatus.COMPLETED) {
    throw new Error(`Challenge with id ${id} is already completed`);
  }

  // 更新挑战状态
  const updatedChallenge = {
    ...challenge,
    status: ChallengeStatus.COMPLETED,
    progress: 100,
    completedDate: new Date(),
    updatedAt: new Date()
  };

  await db.table('challenges').update(id, updatedChallenge);

  // 生成奖励
  const rewards = await generateRewardsForChallenge(updatedChallenge);

  // 创建挑战完成记录
  const completionRecord: ChallengeCompletionRecord = {
    challengeId: id,
    userId: 'current-user', // 在实际应用中，这应该是当前用户的ID
    completedDate: new Date(),
    rewardIds: rewards.map(reward => reward.id!),
    createdAt: new Date()
  };

  await db.table('challengeCompletions').add(completionRecord);

  // 添加到同步队列
  await addSyncItem('challenges', 'update', updatedChallenge);
  await addSyncItem('challengeCompletions', 'create', completionRecord);

  return rewards;
}

/**
 * 获取挑战关联的任务
 * @param challengeId 挑战ID
 */
export async function getChallengeTasks(challengeId: number): Promise<TaskRecord[]> {
  const challenge = await db.table('challenges').get(challengeId);

  if (!challenge) {
    throw new Error(`Challenge with id ${challengeId} not found`);
  }

  if (!challenge.taskIds || challenge.taskIds.length === 0) {
    return [];
  }

  return db.table('tasks')
    .where('id')
    .anyOf(challenge.taskIds)
    .toArray();
}

/**
 * 更新挑战进度基于任务完成情况
 * @param challengeId 挑战ID
 */
export async function updateChallengeProgressFromTasks(challengeId: number): Promise<ChallengeRecord> {
  const challenge = await db.table('challenges').get(challengeId);

  if (!challenge) {
    throw new Error(`Challenge with id ${challengeId} not found`);
  }

  if (!challenge.taskIds || challenge.taskIds.length === 0) {
    return challenge;
  }

  // 获取挑战关联的所有任务
  const tasks = await getChallengeTasks(challengeId);

  // 计算已完成任务的数量
  const completedTasks = tasks.filter(task => task.status === TaskStatus.COMPLETED);

  // 计算进度百分比
  const progress = Math.round((completedTasks.length / tasks.length) * 100);

  // 更新挑战进度
  return updateChallengeProgress(challengeId, progress);
}
</file>

<file path="src/services/dataSyncService.ts">
// src/services/dataSyncService.ts
import { db } from '@/db';
import { queryClient } from '@/services/queryClient';

// 同步状态枚举
export enum SyncStatus {
  IDLE = 'idle',
  SYNCING = 'syncing',
  SUCCESS = 'success',
  ERROR = 'error'
}

// 同步项目类型
export interface SyncItem {
  id: string;
  table: string;
  action: 'create' | 'update' | 'delete';
  data: any;
  timestamp: Date;
  retryCount: number;
  status: SyncStatus;
  error?: string;
}

// 同步配置
interface SyncConfig {
  autoSyncInterval: number; // 自动同步间隔（毫秒）
  maxRetryCount: number; // 最大重试次数
  batchSize: number; // 批量同步大小
}

// 默认同步配置
const DEFAULT_SYNC_CONFIG: SyncConfig = {
  autoSyncInterval: 60000, // 1分钟
  maxRetryCount: 3,
  batchSize: 10
};

// 当前同步状态
let currentSyncStatus: SyncStatus = SyncStatus.IDLE;
let syncConfig: SyncConfig = DEFAULT_SYNC_CONFIG;
let autoSyncInterval: NodeJS.Timeout | null = null;

/**
 * 初始化数据同步服务
 * @param config 同步配置
 */
export function initializeDataSync(config: Partial<SyncConfig> = {}): void {
  // 合并配置
  syncConfig = { ...DEFAULT_SYNC_CONFIG, ...config };

  // 启动自动同步
  startAutoSync();

  console.log('Data sync service initialized');
}

/**
 * 启动自动同步
 */
function startAutoSync(): void {
  if (autoSyncInterval) {
    clearInterval(autoSyncInterval);
  }

  autoSyncInterval = setInterval(() => {
    syncPendingItems().catch(err => {
      console.error('Auto sync failed:', err);
    });
  }, syncConfig.autoSyncInterval);
}

/**
 * 停止自动同步
 */
export function stopAutoSync(): void {
  if (autoSyncInterval) {
    clearInterval(autoSyncInterval);
    autoSyncInterval = null;
  }
}

/**
 * 添加同步项目
 * @param table 表名
 * @param action 操作类型
 * @param data 数据
 */
export async function addSyncItem(
  table: string,
  action: 'create' | 'update' | 'delete',
  data: any
): Promise<void> {
  try {
    // 检查表是否存在
    if (!db.tables.some(t => t.name === 'syncQueue')) {
      console.warn('syncQueue table does not exist yet, creating it');
      // 在实际应用中，这里应该创建表或重新初始化数据库
      // 但在这个示例中，我们只是记录警告并返回
      return;
    }

    // 检查数据是否有效
    if (!data || !data.id) {
      console.warn('Invalid data for sync item, skipping', data);
      return;
    }

    const syncItem: SyncItem = {
      id: `${table}_${data.id}_${Date.now()}`,
      table,
      action,
      data,
      timestamp: new Date(),
      retryCount: 0,
      status: SyncStatus.IDLE
    };

    // 添加到同步队列
    await db.table('syncQueue').add(syncItem);

    // 触发自定义事件，通知同步状态指示器更新
    try {
      const syncEvent = new CustomEvent('syncItemAdded', { detail: syncItem });
      window.dispatchEvent(syncEvent);
    } catch (eventErr) {
      console.error('Failed to dispatch sync event:', eventErr);
    }

    console.log(`Sync item added: ${table} ${action}`, data.id);

    // 如果是在线状态，立即尝试同步
    if (navigator.onLine) {
      syncPendingItems().catch(err => {
        console.error('Sync failed:', err);
      });
    }
  } catch (err) {
    console.error('Failed to add sync item:', err);
  }
}

/**
 * 同步待处理项目
 */
export async function syncPendingItems(): Promise<void> {
  // 如果已经在同步中，则跳过
  if (currentSyncStatus === SyncStatus.SYNCING) {
    return;
  }

  // 如果离线，则跳过
  if (!navigator.onLine) {
    return;
  }

  // 检查表是否存在
  try {
    if (!db.tables.some(table => table.name === 'syncQueue')) {
      console.warn('syncQueue table does not exist yet');
      return;
    }
  } catch (err) {
    console.error('Error checking syncQueue table:', err);
    return;
  }

  try {
    // 更新同步状态并触发事件
    currentSyncStatus = SyncStatus.SYNCING;
    const syncEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
    window.dispatchEvent(syncEvent);

    console.log('Sync started');

    // 获取待处理项目
    const pendingItems = await db.table('syncQueue')
      .where('status')
      .equals(SyncStatus.IDLE)
      .or('status')
      .equals(SyncStatus.ERROR)
      .filter(item => item.retryCount < syncConfig.maxRetryCount)
      .limit(syncConfig.batchSize)
      .toArray();

    if (pendingItems.length === 0) {
      currentSyncStatus = SyncStatus.IDLE;
      const syncCompleteEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
      window.dispatchEvent(syncCompleteEvent);
      console.log('No pending items to sync');
      return;
    }

    console.log(`Found ${pendingItems.length} items to sync`);

    // 批量处理项目
    for (const item of pendingItems) {
      try {
        // 在实际应用中，这里应该调用API进行同步
        // 这里只是模拟同步成功
        await simulateSyncItem(item);

        // 更新项目状态
        await db.table('syncQueue').update(item.id, {
          status: SyncStatus.SUCCESS
        });

        // 更新缓存，传递数据
        invalidateRelatedQueries(item.table, item.data);
      } catch (err) {
        console.error(`Sync item ${item.id} failed:`, err);

        // 更新重试次数和状态
        await db.table('syncQueue').update(item.id, {
          retryCount: item.retryCount + 1,
          status: SyncStatus.ERROR,
          error: err instanceof Error ? err.message : String(err)
        });
      }
    }

    // 清理已成功的项目
    await db.table('syncQueue')
      .where('status')
      .equals(SyncStatus.SUCCESS)
      .delete();

    // 更新同步状态并触发事件
    currentSyncStatus = SyncStatus.SUCCESS;
    const syncSuccessEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
    window.dispatchEvent(syncSuccessEvent);

    console.log('Sync completed successfully');

    // 2秒后重置状态为空闲
    setTimeout(() => {
      currentSyncStatus = SyncStatus.IDLE;
      const resetEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
      window.dispatchEvent(resetEvent);
    }, 2000);
  } catch (err) {
    console.error('Sync failed:', err);
    currentSyncStatus = SyncStatus.ERROR;

    // 触发错误事件
    const syncErrorEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
    window.dispatchEvent(syncErrorEvent);
  }
}

/**
 * 模拟同步项目（实际应用中应替换为真实API调用）
 */
async function simulateSyncItem(item: SyncItem): Promise<void> {
  // 模拟网络延迟
  await new Promise(resolve => setTimeout(resolve, 500));

  // 模拟同步成功
  console.log(`Simulated sync for item ${item.id}:`, item);
}

/**
 * 使相关查询缓存失效
 * @param table 表名
 * @param data 数据
 */
function invalidateRelatedQueries(table: string, data?: any): void {
  // 触发自定义事件，通知组件刷新
  // 这将通过 DataRefreshProvider 传播到所有使用 useDataRefresh 和 useTableRefresh 的组件
  const refreshEvent = new CustomEvent('dataRefresh', {
    detail: { table, data }
  });
  window.dispatchEvent(refreshEvent);

  // 根据表名使相关查询缓存失效
  switch (table) {
    case 'tasks':
      // 如果有特定任务ID，只使该任务的缓存失效
      if (data && data.id) {
        queryClient.invalidateQueries({
          queryKey: ['tasks', data.id],
          exact: true
        });
        // 同时使任务列表缓存失效，但不重新获取数据
        queryClient.invalidateQueries({
          queryKey: ['tasks'],
          exact: true,
          refetchType: 'none'
        });
      } else {
        // 否则使所有任务缓存失效
        queryClient.invalidateQueries({ queryKey: ['tasks'] });
      }
      break;
    case 'pandaState':
      queryClient.invalidateQueries({ queryKey: ['pandaState'] });
      break;
    case 'abilities':
      queryClient.invalidateQueries({ queryKey: ['abilities'] });
      break;
    case 'rewards':
      queryClient.invalidateQueries({ queryKey: ['rewards'] });
      break;
    default:
      // 默认使所有查询缓存失效，但不重新获取数据
      queryClient.invalidateQueries({
        refetchType: 'none'
      });
  }
}

/**
 * 获取当前同步状态
 */
export function getCurrentSyncStatus(): SyncStatus {
  return currentSyncStatus;
}

/**
 * 获取待同步项目数量
 */
export async function getPendingSyncCount(): Promise<number> {
  try {
    // 检查表是否存在
    if (!db.tables.some(table => table.name === 'syncQueue')) {
      console.warn('syncQueue table does not exist yet');
      return 0;
    }

    return db.table('syncQueue')
      .where('status')
      .equals(SyncStatus.IDLE)
      .or('status')
      .equals(SyncStatus.ERROR)
      .count();
  } catch (err) {
    console.error('Error getting pending sync count:', err);
    return 0;
  }
}

/**
 * 手动触发同步
 */
export async function manualSync(): Promise<void> {
  return syncPendingItems();
}
</file>

<file path="src/services/index.ts">
// src/services/index.ts
export * from './localizedContentService';
</file>

<file path="src/services/pandaAbilityService.ts">
// src/services/pandaAbilityService.ts
import { db } from '@/db';
import { RewardRarity } from './rewardService';

// 熊猫能力类型枚举
export enum AbilityType {
  PASSIVE = 'passive',   // 被动能力（常驻效果）
  ACTIVE = 'active',     // 主动能力（需要激活）
  ULTIMATE = 'ultimate'  // 终极能力（强力但有冷却）
}

// 熊猫能力效果类型枚举
export enum AbilityEffectType {
  EXPERIENCE_BOOST = 'experience_boost',       // 经验值提升
  ENERGY_BOOST = 'energy_boost',               // 能量提升
  TASK_EFFICIENCY = 'task_efficiency',         // 任务效率提升
  REWARD_BOOST = 'reward_boost',               // 奖励提升
  MOOD_STABILIZER = 'mood_stabilizer',         // 情绪稳定
  TIME_EXTENSION = 'time_extension',           // 时间延长
  FOCUS_ENHANCEMENT = 'focus_enhancement',     // 专注力增强
  INSPIRATION = 'inspiration',                 // 灵感激发
  RESILIENCE = 'resilience',                   // 韧性增强
  WISDOM = 'wisdom'                            // 智慧提升
}

// 熊猫能力记录类型
export interface PandaAbilityRecord {
  id?: number;
  name: string;
  description: string;
  type: AbilityType;
  effectType: AbilityEffectType;
  effectValue: number;
  iconPath: string;
  rarity: RewardRarity;
  requiredLevel: number;
  isUnlocked: boolean;
  isActive: boolean;
  cooldownMinutes?: number;
  lastUsedAt?: Date;
  unlockDate?: Date;
}

// 预定义的熊猫能力列表
const PREDEFINED_ABILITIES: PandaAbilityRecord[] = [
  // 被动能力 - 初级
  {
    name: '竹林之心',
    description: '被动：完成任务时获得的经验值增加10%',
    type: AbilityType.PASSIVE,
    effectType: AbilityEffectType.EXPERIENCE_BOOST,
    effectValue: 0.1,
    iconPath: '/assets/abilities/bamboo-heart.svg',
    rarity: RewardRarity.COMMON,
    requiredLevel: 2,
    isUnlocked: false,
    isActive: false
  },
  {
    name: '熊猫活力',
    description: '被动：熊猫能量恢复速度提高15%',
    type: AbilityType.PASSIVE,
    effectType: AbilityEffectType.ENERGY_BOOST,
    effectValue: 0.15,
    iconPath: '/assets/abilities/panda-vitality.svg',
    rarity: RewardRarity.COMMON,
    requiredLevel: 3,
    isUnlocked: false,
    isActive: false
  },

  // 主动能力 - 中级
  {
    name: '竹影专注',
    description: '主动：激活后，1小时内完成任务获得的经验值增加25%',
    type: AbilityType.ACTIVE,
    effectType: AbilityEffectType.FOCUS_ENHANCEMENT,
    effectValue: 0.25,
    iconPath: '/assets/abilities/bamboo-focus.svg',
    rarity: RewardRarity.UNCOMMON,
    requiredLevel: 5,
    isUnlocked: false,
    isActive: false,
    cooldownMinutes: 120
  },
  {
    name: '熊猫智慧',
    description: '主动：激活后，2小时内任务完成奖励数量增加20%',
    type: AbilityType.ACTIVE,
    effectType: AbilityEffectType.REWARD_BOOST,
    effectValue: 0.2,
    iconPath: '/assets/abilities/panda-wisdom.svg',
    rarity: RewardRarity.UNCOMMON,
    requiredLevel: 7,
    isUnlocked: false,
    isActive: false,
    cooldownMinutes: 240
  },

  // 终极能力 - 高级
  {
    name: '竹林大师',
    description: '终极：激活后，4小时内所有能力效果提升50%',
    type: AbilityType.ULTIMATE,
    effectType: AbilityEffectType.WISDOM,
    effectValue: 0.5,
    iconPath: '/assets/abilities/bamboo-master.svg',
    rarity: RewardRarity.RARE,
    requiredLevel: 10,
    isUnlocked: false,
    isActive: false,
    cooldownMinutes: 1440 // 24小时
  }
];

/**
 * 初始化熊猫能力系统
 * 如果数据库中没有能力记录，则添加预定义的能力
 */
export async function initializePandaAbilities(): Promise<void> {
  const abilities = await db.table('abilities').toArray();

  if (abilities.length === 0) {
    await db.table('abilities').bulkAdd(PREDEFINED_ABILITIES);
  }
}

/**
 * 获取所有熊猫能力
 */
export async function getAllPandaAbilities(): Promise<PandaAbilityRecord[]> {
  return db.table('abilities').toArray();
}

/**
 * 获取已解锁的熊猫能力
 */
export async function getUnlockedPandaAbilities(): Promise<PandaAbilityRecord[]> {
  try {
    // 检查表是否存在
    if (!db.tables.some(table => table.name === 'abilities')) {
      console.warn('abilities table does not exist yet');
      // 初始化能力系统
      await initializePandaAbilities();
    }

    // 尝试获取所有能力，然后在内存中过滤
    try {
      const allAbilities = await db.table('abilities').toArray();
      // 确保返回的是一个数组，并且每个元素都有正确的属性
      return allAbilities
        .filter(ability => ability && typeof ability === 'object')
        .filter(ability => ability.isUnlocked === true);
    } catch (err) {
      console.error('Error querying unlocked abilities:', err);
      // 如果查询失败，返回空数组
      return [];
    }
  } catch (err) {
    console.error('Error in getUnlockedPandaAbilities:', err);
    return [];
  }
}

/**
 * 获取可用的熊猫能力（已解锁且未在冷却中）
 */
export async function getAvailablePandaAbilities(): Promise<PandaAbilityRecord[]> {
  const now = new Date();
  const unlockedAbilities = await getUnlockedPandaAbilities();

  return unlockedAbilities.filter(ability => {
    // 被动能力总是可用
    if (ability.type === AbilityType.PASSIVE) {
      return true;
    }

    // 主动或终极能力需要检查冷却时间
    if (ability.lastUsedAt && ability.cooldownMinutes) {
      const cooldownEndTime = new Date(ability.lastUsedAt);
      cooldownEndTime.setMinutes(cooldownEndTime.getMinutes() + ability.cooldownMinutes);

      return now >= cooldownEndTime;
    }

    return true;
  });
}

/**
 * 检查并解锁熊猫能力
 * 根据熊猫当前等级解锁相应的能力
 * @param currentLevel 熊猫当前等级
 */
export async function checkAndUnlockAbilities(currentLevel: number): Promise<PandaAbilityRecord[]> {
  const abilities = await getAllPandaAbilities();
  const newlyUnlocked: PandaAbilityRecord[] = [];

  for (const ability of abilities) {
    if (!ability.isUnlocked && ability.requiredLevel <= currentLevel) {
      // 解锁能力
      const now = new Date();
      await db.table('abilities').update(ability.id!, {
        isUnlocked: true,
        unlockDate: now
      });

      // 添加到新解锁列表
      newlyUnlocked.push({
        ...ability,
        isUnlocked: true,
        unlockDate: now
      });
    }
  }

  return newlyUnlocked;
}

/**
 * 激活熊猫能力
 * @param abilityId 要激活的能力ID
 */
export async function activateAbility(abilityId: number): Promise<PandaAbilityRecord> {
  const ability = await db.table('abilities').get(abilityId);

  if (!ability) {
    throw new Error(`Ability with id ${abilityId} not found`);
  }

  if (!ability.isUnlocked) {
    throw new Error(`Ability with id ${abilityId} is not unlocked yet`);
  }

  // 被动能力不需要激活
  if (ability.type === AbilityType.PASSIVE) {
    return ability;
  }

  // 检查冷却时间
  if (ability.lastUsedAt && ability.cooldownMinutes) {
    const now = new Date();
    const cooldownEndTime = new Date(ability.lastUsedAt);
    cooldownEndTime.setMinutes(cooldownEndTime.getMinutes() + ability.cooldownMinutes);

    if (now < cooldownEndTime) {
      throw new Error(`Ability with id ${abilityId} is still in cooldown`);
    }
  }

  // 激活能力
  const now = new Date();
  const updatedAbility = {
    ...ability,
    isActive: true,
    lastUsedAt: now
  };

  await db.table('abilities').update(abilityId, updatedAbility);
  return updatedAbility;
}

/**
 * 获取能力效果描述
 * @param effectType 能力效果类型
 */
export function getAbilityEffectDescription(effectType: AbilityEffectType): string {
  switch (effectType) {
    case AbilityEffectType.EXPERIENCE_BOOST:
      return '经验值提升';
    case AbilityEffectType.ENERGY_BOOST:
      return '能量提升';
    case AbilityEffectType.TASK_EFFICIENCY:
      return '任务效率提升';
    case AbilityEffectType.REWARD_BOOST:
      return '奖励提升';
    case AbilityEffectType.MOOD_STABILIZER:
      return '情绪稳定';
    case AbilityEffectType.TIME_EXTENSION:
      return '时间延长';
    case AbilityEffectType.FOCUS_ENHANCEMENT:
      return '专注力增强';
    case AbilityEffectType.INSPIRATION:
      return '灵感激发';
    case AbilityEffectType.RESILIENCE:
      return '韧性增强';
    case AbilityEffectType.WISDOM:
      return '智慧提升';
    default:
      return '未知效果';
  }
}
</file>

<file path="src/services/pandaStateService.ts">
// src/services/pandaStateService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import type { PandaMood, EnergyLevel } from '@/components/game/PandaAvatar';

// 熊猫状态记录类型
export interface PandaStateRecord {
  id?: number;
  mood: PandaMood;
  energy: EnergyLevel;
  lastUpdated: Date;
  experience: number; // 经验值
  level: number; // 等级
}

// 默认熊猫状态
const DEFAULT_PANDA_STATE: PandaStateRecord = {
  mood: 'normal',
  energy: 'medium',
  lastUpdated: new Date(),
  experience: 0,
  level: 1
};

/**
 * 获取当前熊猫状态
 * 如果不存在，则创建默认状态
 */
export async function getPandaState(): Promise<PandaStateRecord> {
  // 检查数据库中是否已有熊猫状态记录
  const pandaState = await db.table('pandaState').toArray();

  if (pandaState.length === 0) {
    // 如果没有记录，创建默认状态
    const id = await db.table('pandaState').add(DEFAULT_PANDA_STATE);
    return { ...DEFAULT_PANDA_STATE, id };
  }

  return pandaState[0];
}

/**
 * 更新熊猫情绪状态
 * @param mood 新的情绪状态
 */
export async function updatePandaMood(mood: PandaMood): Promise<PandaStateRecord> {
  const currentState = await getPandaState();
  const updatedState = {
    ...currentState,
    mood,
    lastUpdated: new Date()
  };

  // 更新数据库
  await db.table('pandaState').update(currentState.id!, updatedState);

  // 添加同步项目
  await addSyncItem('pandaState', 'update', updatedState);

  return updatedState;
}

/**
 * 更新熊猫能量级别
 * @param energy 新的能量级别
 */
export async function updatePandaEnergy(energy: EnergyLevel): Promise<PandaStateRecord> {
  const currentState = await getPandaState();
  const updatedState = {
    ...currentState,
    energy,
    lastUpdated: new Date()
  };

  // 更新数据库
  await db.table('pandaState').update(currentState.id!, updatedState);

  // 添加同步项目
  await addSyncItem('pandaState', 'update', updatedState);

  return updatedState;
}

/**
 * 增加熊猫经验值
 * @param amount 增加的经验值数量
 */
export async function addPandaExperience(amount: number): Promise<PandaStateRecord> {
  const currentState = await getPandaState();
  const newExperience = currentState.experience + amount;

  // 简单的等级计算逻辑：每100点经验升一级
  const newLevel = Math.floor(newExperience / 100) + 1;

  const updatedState = {
    ...currentState,
    experience: newExperience,
    level: newLevel,
    lastUpdated: new Date()
  };

  // 如果升级了，更新情绪为开心
  if (newLevel > currentState.level) {
    updatedState.mood = 'happy';
  }

  // 更新数据库
  await db.table('pandaState').update(currentState.id!, updatedState);

  // 添加同步项目
  await addSyncItem('pandaState', 'update', updatedState);

  return updatedState;
}

/**
 * 重置熊猫状态（用于测试或重新开始）
 */
export async function resetPandaState(): Promise<PandaStateRecord> {
  const currentState = await getPandaState();
  const resetState = {
    ...DEFAULT_PANDA_STATE,
    id: currentState.id,
    lastUpdated: new Date()
  };

  // 更新数据库
  await db.table('pandaState').update(currentState.id!, resetState);

  // 添加同步项目
  await addSyncItem('pandaState', 'update', resetState);

  return resetState;
}
</file>

<file path="src/services/queryClient.ts">
// src/services/queryClient.ts
import { QueryClient } from '@tanstack/react-query';

// 创建 QueryClient 实例并导出，以便其他模块使用
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 2, // 2 minutes
      refetchOnWindowFocus: false, // Personal preference for demos
      retry: 1, // Retry failed queries once
    },
  },
});
</file>

<file path="src/services/rewardService.ts">
// src/services/rewardService.ts
import { db } from '@/db';
import { TaskType, TaskPriority, TaskRecord } from './taskService';

// 奖励类型枚举
export enum RewardType {
  EXPERIENCE = 'experience',   // 经验值
  COIN = 'coin',               // 金币
  ITEM = 'item',               // 物品
  BADGE = 'badge',             // 徽章
  ABILITY = 'ability'          // 熊猫能力
}

// 奖励稀有度枚举
export enum RewardRarity {
  COMMON = 'common',           // 普通
  UNCOMMON = 'uncommon',       // 不常见
  RARE = 'rare',               // 稀有
  EPIC = 'epic',               // 史诗
  LEGENDARY = 'legendary'      // 传说
}

// 奖励记录类型
export interface RewardRecord {
  id?: number;
  type: RewardType;
  rarity: RewardRarity;
  amount: number;
  name: string;
  description: string;
  iconPath: string;
  taskId?: number;
  obtainedAt: Date;
  isNew: boolean;
  isViewed: boolean;
}

// 物品类型枚举
export enum ItemType {
  FOOD = 'food',               // 食物
  TOY = 'toy',                 // 玩具
  DECORATION = 'decoration',   // 装饰
  SCROLL = 'scroll',           // 卷轴
  POTION = 'potion'            // 药水
}

// 物品记录类型
export interface ItemRecord {
  id?: number;
  type: ItemType;
  name: string;
  description: string;
  rarity: RewardRarity;
  iconPath: string;
  quantity: number;
  isUsable: boolean;
  effectDescription?: string;
  obtainedAt: Date;
}

// 徽章记录类型
export interface BadgeRecord {
  id?: number;
  name: string;
  description: string;
  rarity: RewardRarity;
  iconPath: string;
  obtainedAt: Date;
  isEquipped: boolean;
}

// 熊猫能力记录类型
export interface AbilityRecord {
  id?: number;
  name: string;
  description: string;
  rarity: RewardRarity;
  iconPath: string;
  obtainedAt: Date;
  isUnlocked: boolean;
  isActive: boolean;
  cooldownMinutes?: number;
  lastUsedAt?: Date;
}

/**
 * 根据任务生成奖励
 * @param task 完成的任务
 * @returns 生成的奖励
 */
export async function generateRewardsForTask(task: TaskRecord): Promise<RewardRecord[]> {
  const rewards: RewardRecord[] = [];
  const now = new Date();

  // 基础经验值奖励（已在taskService中处理）
  let experienceAmount = 10;

  // 根据优先级调整经验值
  switch (task.priority) {
    case TaskPriority.HIGH:
      experienceAmount += 15;
      break;
    case TaskPriority.MEDIUM:
      experienceAmount += 10;
      break;
    case TaskPriority.LOW:
      experienceAmount += 5;
      break;
  }

  // 根据任务类型调整经验值
  switch (task.type) {
    case TaskType.MAIN:
      experienceAmount += 20;
      break;
    case TaskType.DAILY:
      experienceAmount += 5;
      break;
    case TaskType.SIDE:
      experienceAmount += 10;
      break;
  }

  // 添加经验值奖励
  rewards.push({
    type: RewardType.EXPERIENCE,
    rarity: RewardRarity.COMMON,
    amount: experienceAmount,
    name: '经验值',
    description: '增加熊猫的经验值',
    iconPath: '/assets/rewards/experience.svg',
    taskId: task.id,
    obtainedAt: now,
    isNew: true,
    isViewed: false
  });

  // 添加金币奖励
  const coinAmount = calculateCoinReward(task);
  rewards.push({
    type: RewardType.COIN,
    rarity: RewardRarity.COMMON,
    amount: coinAmount,
    name: '竹币',
    description: '可用于购买物品和升级',
    iconPath: '/assets/rewards/coin.svg',
    taskId: task.id,
    obtainedAt: now,
    isNew: true,
    isViewed: false
  });

  // 随机物品奖励（概率性）
  if (shouldGetItemReward(task)) {
    const itemReward = generateRandomItemReward(task);
    rewards.push({
      ...itemReward,
      taskId: task.id,
      obtainedAt: now,
      isNew: true,
      isViewed: false
    });
  }

  // 保存奖励记录
  await saveRewards(rewards);

  return rewards;
}

/**
 * 计算金币奖励
 */
function calculateCoinReward(task: TaskRecord): number {
  let baseAmount = 5;

  // 根据优先级调整金币数量
  switch (task.priority) {
    case TaskPriority.HIGH:
      baseAmount += 15;
      break;
    case TaskPriority.MEDIUM:
      baseAmount += 10;
      break;
    case TaskPriority.LOW:
      baseAmount += 5;
      break;
  }

  // 根据任务类型调整金币数量
  switch (task.type) {
    case TaskType.MAIN:
      baseAmount += 20;
      break;
    case TaskType.DAILY:
      baseAmount += 5;
      break;
    case TaskType.SIDE:
      baseAmount += 10;
      break;
  }

  // 添加随机波动（±20%）
  const randomFactor = 0.8 + Math.random() * 0.4; // 0.8 到 1.2 之间
  return Math.round(baseAmount * randomFactor);
}

/**
 * 判断是否应该获得物品奖励
 */
function shouldGetItemReward(task: TaskRecord): boolean {
  let chance = 0.1; // 基础概率10%

  // 根据优先级调整概率
  switch (task.priority) {
    case TaskPriority.HIGH:
      chance += 0.2;
      break;
    case TaskPriority.MEDIUM:
      chance += 0.1;
      break;
    case TaskPriority.LOW:
      chance += 0.05;
      break;
  }

  // 根据任务类型调整概率
  switch (task.type) {
    case TaskType.MAIN:
      chance += 0.3;
      break;
    case TaskType.DAILY:
      chance += 0.05;
      break;
    case TaskType.SIDE:
      chance += 0.15;
      break;
  }

  return Math.random() < chance;
}

/**
 * 生成随机物品奖励
 */
function generateRandomItemReward(task: TaskRecord): RewardRecord {
  // 随机选择物品类型
  const itemTypes = [
    { type: ItemType.FOOD, weight: 0.4 },
    { type: ItemType.TOY, weight: 0.3 },
    { type: ItemType.DECORATION, weight: 0.1 },
    { type: ItemType.SCROLL, weight: 0.1 },
    { type: ItemType.POTION, weight: 0.1 }
  ];

  // 随机选择稀有度
  const rarityTypes = [
    { rarity: RewardRarity.COMMON, weight: 0.6 },
    { rarity: RewardRarity.UNCOMMON, weight: 0.25 },
    { rarity: RewardRarity.RARE, weight: 0.1 },
    { rarity: RewardRarity.EPIC, weight: 0.04 },
    { rarity: RewardRarity.LEGENDARY, weight: 0.01 }
  ];

  // 根据权重随机选择物品类型
  const randomTypeObj = weightedRandom(itemTypes);
  const randomType = randomTypeObj.type;

  // 根据权重随机选择稀有度
  const randomRarityObj = weightedRandom(rarityTypes);
  const randomRarity = randomRarityObj.rarity;

  // 根据类型和稀有度生成物品
  return generateItemByTypeAndRarity(randomType, randomRarity);
}

/**
 * 根据权重随机选择
 */
function weightedRandom<T>(items: Array<T & { weight: number }>): T {
  const totalWeight = items.reduce((sum, item) => sum + item.weight, 0);
  let random = Math.random() * totalWeight;

  for (const item of items) {
    random -= item.weight;
    if (random <= 0) {
      return item;
    }
  }

  return items[0]; // 默认返回第一个
}

/**
 * 根据类型和稀有度生成物品
 */
function generateItemByTypeAndRarity(itemType: ItemType, rarity: RewardRarity): RewardRecord {
  // 这里可以根据类型和稀有度从预定义的物品列表中选择
  // 简化版本，直接生成
  const itemNames: Record<ItemType, string[]> = {
    [ItemType.FOOD]: ['竹笋', '竹叶', '竹芽', '竹果', '竹糖'],
    [ItemType.TOY]: ['竹球', '竹环', '竹哑铃', '竹摇铃', '竹陀螺'],
    [ItemType.DECORATION]: ['竹帽', '竹围巾', '竹眼镜', '竹项链', '竹手镯'],
    [ItemType.SCROLL]: ['初级卷轴', '中级卷轴', '高级卷轴', '大师卷轴', '宗师卷轴'],
    [ItemType.POTION]: ['小型药水', '中型药水', '大型药水', '特效药水', '神奇药水']
  };

  const rarityDescriptions: Record<RewardRarity, string> = {
    [RewardRarity.COMMON]: '普通',
    [RewardRarity.UNCOMMON]: '不常见',
    [RewardRarity.RARE]: '稀有',
    [RewardRarity.EPIC]: '史诗',
    [RewardRarity.LEGENDARY]: '传说'
  };

  // 随机选择物品名称
  const names = itemNames[itemType];
  const name = names[Math.floor(Math.random() * names.length)];

  // 生成物品描述
  const description = `${rarityDescriptions[rarity]}的${name}`;

  // 生成图标路径
  const iconPath = `/assets/rewards/${itemType.toLowerCase()}_${rarity.toLowerCase()}.svg`;

  return {
    type: RewardType.ITEM,
    rarity,
    amount: 1,
    name,
    description,
    iconPath,
    obtainedAt: new Date(),
    isNew: true,
    isViewed: false
  };
}

/**
 * 保存奖励记录
 */
async function saveRewards(rewards: RewardRecord[]): Promise<void> {
  await db.table('rewards').bulkAdd(rewards);
}

/**
 * 获取未查看的奖励
 */
export async function getUnviewedRewards(): Promise<RewardRecord[]> {
  return db.table('rewards')
    .filter(reward => reward.isViewed === false)
    .toArray();
}

/**
 * 标记奖励为已查看
 */
export async function markRewardsAsViewed(rewardIds: number[]): Promise<void> {
  await Promise.all(
    rewardIds.map(id =>
      db.table('rewards')
        .update(id, { isViewed: true, isNew: false })
    )
  );
}

/**
 * 获取玩家的金币数量
 */
export async function getPlayerCoins(): Promise<number> {
  const coinRewards = await db.table('rewards')
    .where('type')
    .equals(RewardType.COIN)
    .toArray();

  return coinRewards.reduce((total, reward) => total + reward.amount, 0);
}

/**
 * 生成指定数量和稀有度的奖励
 * @param count 奖励数量
 * @param rarity 奖励稀有度
 * @returns 生成的奖励列表
 */
export async function generateRewards(count: number, rarity: RewardRarity): Promise<RewardRecord[]> {
  const rewards: RewardRecord[] = [];
  const now = new Date();

  for (let i = 0; i < count; i++) {
    // 随机选择物品类型
    const itemTypes = [
      { type: ItemType.FOOD, weight: 0.4 },
      { type: ItemType.TOY, weight: 0.3 },
      { type: ItemType.DECORATION, weight: 0.1 },
      { type: ItemType.SCROLL, weight: 0.1 },
      { type: ItemType.POTION, weight: 0.1 }
    ];

    // 根据权重随机选择物品类型
    const randomTypeObj = weightedRandom(itemTypes);
    const randomType = randomTypeObj.type;

    // 生成物品
    const reward = generateItemByTypeAndRarity(randomType, rarity);

    rewards.push({
      ...reward,
      obtainedAt: now,
      isNew: true,
      isViewed: false
    });
  }

  // 保存奖励记录
  await saveRewards(rewards);

  return rewards;
}

/**
 * 为挑战生成奖励
 * @param challenge 完成的挑战
 * @returns 生成的奖励列表
 */
export async function generateRewardsForChallenge(challenge: any): Promise<RewardRecord[]> {
  // 根据挑战难度决定奖励稀有度
  let rarity = RewardRarity.COMMON;

  if (challenge.difficulty === 'hard') {
    rarity = RewardRarity.RARE;
  } else if (challenge.difficulty === 'medium') {
    rarity = RewardRarity.UNCOMMON;
  } else if (challenge.difficulty === 'expert') {
    rarity = RewardRarity.EPIC;
  }

  // 生成2-4个奖励
  const count = 2 + Math.floor(Math.random() * 3);

  return generateRewards(count, rarity);
}
</file>

<file path="src/services/taskService.ts">
// src/services/taskService.ts
import { db } from '@/db';
import { addPandaExperience, updatePandaMood } from './pandaStateService';
import { generateRewardsForTask, RewardRecord } from './rewardService';
import { addSyncItem } from './dataSyncService';
import { checkTaskForTimelyReward, TimelyRewardRecord } from './timelyRewardService';

// 任务状态枚举
export enum TaskStatus {
  TODO = 'todo',
  IN_PROGRESS = 'in_progress',
  COMPLETED = 'completed',
  ARCHIVED = 'archived'
}

// 任务优先级枚举
export enum TaskPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high'
}

// 任务类型枚举
export enum TaskType {
  DAILY = 'daily',    // 日常任务
  MAIN = 'main',      // 主线任务
  SIDE = 'side'       // 支线任务
}

// 任务记录类型
export interface TaskRecord {
  id?: number;
  title: string;
  description?: string;
  categoryId: number;
  type: TaskType;
  priority: TaskPriority;
  status: TaskStatus;
  dueDate?: Date;
  reminderTime?: Date;
  estimatedMinutes?: number;
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
  repeatPattern?: string; // 例如: "daily", "weekly:1,3,5", "monthly:15"
  tags?: string[];
}

// 任务类别记录类型
export interface TaskCategoryRecord {
  id?: number;
  name: string;
  description?: string;
  color: string;
  icon?: string;
  isDefault: boolean;
  createdAt: Date;
}

// 任务完成记录类型
export interface TaskCompletionRecord {
  id?: number;
  taskId: number;
  completedAt: Date;
  experienceGained: number;
  notes?: string;
}

// 默认任务类别
const DEFAULT_CATEGORIES: Omit<TaskCategoryRecord, 'id'>[] = [
  {
    name: 'Work',
    description: 'Work related tasks',
    color: '#4A6FA5',
    icon: 'briefcase',
    isDefault: true,
    createdAt: new Date()
  },
  {
    name: 'Personal',
    description: 'Personal tasks',
    color: '#6B8F71',
    icon: 'user',
    isDefault: true,
    createdAt: new Date()
  },
  {
    name: 'Health',
    description: 'Health and fitness tasks',
    color: '#D98580',
    icon: 'heart',
    isDefault: true,
    createdAt: new Date()
  },
  {
    name: 'Learning',
    description: 'Learning and education tasks',
    color: '#B4A7D6',
    icon: 'book',
    isDefault: true,
    createdAt: new Date()
  }
];

/**
 * 初始化任务类别
 * 如果没有任务类别，则创建默认类别
 */
export async function initializeTaskCategories(): Promise<void> {
  const count = await db.taskCategories.count();
  if (count === 0) {
    console.log('Initializing default task categories...');
    await db.taskCategories.bulkAdd(DEFAULT_CATEGORIES);
  }
}

/**
 * 获取所有任务类别
 */
export async function getAllTaskCategories(): Promise<TaskCategoryRecord[]> {
  return db.taskCategories.toArray();
}

/**
 * 创建新的任务类别
 */
export async function createTaskCategory(category: Omit<TaskCategoryRecord, 'id' | 'createdAt'>): Promise<number> {
  const newCategory = {
    ...category,
    createdAt: new Date()
  };
  return db.taskCategories.add(newCategory);
}

/**
 * 获取所有任务
 * @param filter 可选的过滤条件
 */
export async function getAllTasks(filter?: {
  status?: TaskStatus;
  categoryId?: number;
  type?: TaskType;
  priority?: TaskPriority;
}): Promise<TaskRecord[]> {
  let query = db.tasks.toCollection();

  if (filter) {
    if (filter.status) {
      query = query.filter(task => task.status === filter.status);
    }
    if (filter.categoryId) {
      query = query.filter(task => task.categoryId === filter.categoryId);
    }
    if (filter.type) {
      query = query.filter(task => task.type === filter.type);
    }
    if (filter.priority) {
      query = query.filter(task => task.priority === filter.priority);
    }
  }

  return query.toArray();
}

/**
 * 创建新任务
 */
export async function createTask(task: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'>): Promise<number> {
  const now = new Date();
  const newTask = {
    ...task,
    status: TaskStatus.TODO,
    createdAt: now,
    updatedAt: now
  };

  // 添加任务到数据库
  const id = await db.tasks.add(newTask);

  // 添加同步项目
  await addSyncItem('tasks', 'create', { ...newTask, id });

  return id;
}

/**
 * 更新任务
 */
export async function updateTask(id: number, updates: Partial<Omit<TaskRecord, 'id' | 'createdAt'>>): Promise<void> {
  const task = await db.tasks.get(id);
  if (!task) {
    throw new Error(`Task with id ${id} not found`);
  }

  const updatedTask = {
    ...task,
    ...updates,
    updatedAt: new Date()
  };

  // 更新数据库
  await db.tasks.update(id, updatedTask);

  // 添加同步项目
  await addSyncItem('tasks', 'update', updatedTask);
}

/**
 * 完成任务
 * 更新任务状态为已完成，创建完成记录，生成奖励，并增加熊猫经验值
 * @returns 生成的奖励列表和及时奖励（如果有）
 */
export async function completeTask(id: number, notes?: string): Promise<{
  rewards: RewardRecord[];
  timelyReward?: TimelyRewardRecord | null;
}> {
  const task = await db.tasks.get(id);
  if (!task) {
    throw new Error(`Task with id ${id} not found`);
  }

  const now = new Date();

  // 计算获得的经验值（基于任务优先级和类型）
  let experienceGained = 10; // 基础经验值

  // 根据优先级增加经验值
  switch (task.priority) {
    case TaskPriority.HIGH:
      experienceGained += 15;
      break;
    case TaskPriority.MEDIUM:
      experienceGained += 10;
      break;
    case TaskPriority.LOW:
      experienceGained += 5;
      break;
  }

  // 根据任务类型增加经验值
  switch (task.type) {
    case TaskType.MAIN:
      experienceGained += 20;
      break;
    case TaskType.DAILY:
      experienceGained += 5;
      break;
    case TaskType.SIDE:
      experienceGained += 10;
      break;
  }

  // 更新任务状态
  await updateTask(id, {
    status: TaskStatus.COMPLETED,
    completedAt: now
  });

  // 创建完成记录
  await db.taskCompletions.add({
    taskId: id,
    completedAt: now,
    experienceGained,
    notes
  });

  // 增加熊猫经验值
  await addPandaExperience(experienceGained);

  // 更新熊猫心情为开心
  await updatePandaMood('happy');

  // 生成任务奖励
  const rewards = await generateRewardsForTask(task);

  // 检查是否符合及时奖励条件
  const timelyReward = await checkTaskForTimelyReward({
    ...task,
    status: TaskStatus.COMPLETED,
    completedAt: now
  });

  return {
    rewards,
    timelyReward
  };
}

/**
 * 获取任务统计信息
 */
export async function getTaskStats(): Promise<{
  total: number;
  completed: number;
  inProgress: number;
  todo: number;
  byCategory: Record<number, number>;
  byPriority: Record<TaskPriority, number>;
}> {
  const tasks = await db.tasks.toArray();

  const stats = {
    total: tasks.length,
    completed: tasks.filter(t => t.status === TaskStatus.COMPLETED).length,
    inProgress: tasks.filter(t => t.status === TaskStatus.IN_PROGRESS).length,
    todo: tasks.filter(t => t.status === TaskStatus.TODO).length,
    byCategory: {} as Record<number, number>,
    byPriority: {
      [TaskPriority.LOW]: 0,
      [TaskPriority.MEDIUM]: 0,
      [TaskPriority.HIGH]: 0
    }
  };

  // 按类别统计
  tasks.forEach(task => {
    if (!stats.byCategory[task.categoryId]) {
      stats.byCategory[task.categoryId] = 0;
    }
    stats.byCategory[task.categoryId]++;

    // 按优先级统计
    stats.byPriority[task.priority]++;
  });

  return stats;
}

/**
 * 获取任务完成历史
 */
export async function getTaskCompletionHistory(): Promise<TaskCompletionRecord[]> {
  return db.taskCompletions.toArray();
}

/**
 * 获取今日待办任务
 */
export async function getTodayTasks(): Promise<TaskRecord[]> {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);

  return db.tasks
    .where('dueDate')
    .between(today, tomorrow, true, false)
    .and(task => task.status !== TaskStatus.COMPLETED && task.status !== TaskStatus.ARCHIVED)
    .toArray();
}

/**
 * 获取逾期任务
 */
export async function getOverdueTasks(): Promise<TaskRecord[]> {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  return db.tasks
    .where('dueDate')
    .below(today)
    .and(task => task.status !== TaskStatus.COMPLETED && task.status !== TaskStatus.ARCHIVED)
    .toArray();
}

/**
 * 删除任务
 */
export async function deleteTask(id: number): Promise<void> {
  const task = await db.tasks.get(id);
  if (!task) {
    throw new Error(`Task with id ${id} not found`);
  }

  // 从数据库中删除
  await db.tasks.delete(id);

  // 添加同步项目
  await addSyncItem('tasks', 'delete', task);
}

/**
 * 归档任务
 */
export async function archiveTask(id: number): Promise<void> {
  await updateTask(id, { status: TaskStatus.ARCHIVED });
}
</file>

<file path="src/services/timelyRewardService.ts">
// src/services/timelyRewardService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { generateRewards, RewardRecord, RewardRarity } from './rewardService';
import { TaskRecord, TaskStatus } from './taskService';

// 及时奖励状态枚举
export enum TimelyRewardStatus {
  ACTIVE = 'active',         // 活跃中
  COMPLETED = 'completed',   // 已完成
  EXPIRED = 'expired',       // 已过期
  UPCOMING = 'upcoming'      // 即将开始
}

// 及时奖励类型枚举
export enum TimelyRewardType {
  DAILY = 'daily',           // 每日奖励
  MORNING = 'morning',       // 早起鸟奖励
  STREAK = 'streak',         // 连续完成奖励
  SPECIAL = 'special'        // 特殊奖励
}

// 及时奖励记录类型
export interface TimelyRewardRecord {
  id?: number;               // 奖励ID
  title: string;             // 奖励标题
  description: string;       // 奖励描述
  type: TimelyRewardType;    // 奖励类型
  status: TimelyRewardStatus; // 奖励状态
  progress: number;          // 进度（0-100）
  startTime: Date;           // 开始时间
  endTime: Date;             // 结束时间
  completedTime?: Date;      // 完成时间
  luckyPoints: number;       // 幸运点数
  taskIds?: number[];        // 关联的任务ID列表
  rewardIds?: number[];      // 奖励ID列表
  iconPath: string;          // 图标路径
  createdAt: Date;           // 创建时间
  updatedAt: Date;           // 更新时间
}

// 幸运点记录类型
export interface LuckyPointRecord {
  id?: number;               // 记录ID
  userId: string;            // 用户ID
  amount: number;            // 点数数量
  source: string;            // 来源
  timestamp: Date;           // 时间戳
  expiryDate?: Date;         // 过期日期
  isSpent: boolean;          // 是否已使用
  createdAt: Date;           // 创建时间
}

// 幸运抽奖记录类型
export interface LuckyDrawRecord {
  id?: number;               // 记录ID
  userId: string;            // 用户ID
  pointsSpent: number;       // 使用的点数
  rewards: RewardRecord[];   // 获得的奖励
  timestamp: Date;           // 时间戳
  createdAt: Date;           // 创建时间
}

// 奖品层级
export enum PrizeLevel {
  COMMON = 'common',         // 普通
  UNCOMMON = 'uncommon',     // 不常见
  RARE = 'rare',             // 稀有
  EPIC = 'epic',             // 史诗
  LEGENDARY = 'legendary'    // 传说
}

// 奖品层级概率配置
const PRIZE_LEVEL_PROBABILITIES = {
  [PrizeLevel.COMMON]: 0.6,      // 60%
  [PrizeLevel.UNCOMMON]: 0.25,   // 25%
  [PrizeLevel.RARE]: 0.1,        // 10%
  [PrizeLevel.EPIC]: 0.04,       // 4%
  [PrizeLevel.LEGENDARY]: 0.01   // 1%
};

// 奖品层级对应的奖励稀有度
const PRIZE_LEVEL_TO_RARITY: Record<PrizeLevel, string> = {
  [PrizeLevel.COMMON]: 'common',
  [PrizeLevel.UNCOMMON]: 'uncommon',
  [PrizeLevel.RARE]: 'rare',
  [PrizeLevel.EPIC]: 'epic',
  [PrizeLevel.LEGENDARY]: 'legendary'
};

/**
 * 初始化及时奖励系统
 */
export async function initializeTimelyRewards(): Promise<void> {
  // 检查是否已有及时奖励
  const count = await db.table('timelyRewards').count();

  if (count === 0) {
    // 创建默认的及时奖励
    await createDailyTimelyReward();
    await createMorningTimelyReward();
  }
}

/**
 * 创建每日及时奖励
 */
async function createDailyTimelyReward(): Promise<TimelyRewardRecord> {
  const now = new Date();
  const startTime = new Date(now);
  startTime.setHours(9, 0, 0, 0); // 每天9点开始

  const endTime = new Date(now);
  endTime.setHours(21, 0, 0, 0); // 每天21点结束

  // 如果当前时间已经超过今天的结束时间，则设置为明天
  if (now > endTime) {
    startTime.setDate(startTime.getDate() + 1);
    endTime.setDate(endTime.getDate() + 1);
  }

  const dailyReward: TimelyRewardRecord = {
    title: '每日及时完成',
    description: '在规定时间内完成任务，获得额外奖励',
    type: TimelyRewardType.DAILY,
    status: TimelyRewardStatus.ACTIVE,
    progress: 0,
    startTime,
    endTime,
    luckyPoints: 10,
    iconPath: '/assets/rewards/daily-reward.svg',
    createdAt: now,
    updatedAt: now
  };

  const id = await db.table('timelyRewards').add(dailyReward);
  const newReward = { ...dailyReward, id: id as number };

  // 添加到同步队列
  await addSyncItem('timelyRewards', 'create', newReward);

  return newReward;
}

/**
 * 创建早起鸟及时奖励
 */
async function createMorningTimelyReward(): Promise<TimelyRewardRecord> {
  const now = new Date();
  const startTime = new Date(now);
  startTime.setHours(5, 0, 0, 0); // 每天5点开始

  const endTime = new Date(now);
  endTime.setHours(9, 0, 0, 0); // 每天9点结束

  // 如果当前时间已经超过今天的结束时间，则设置为明天
  if (now > endTime) {
    startTime.setDate(startTime.getDate() + 1);
    endTime.setDate(endTime.getDate() + 1);
  }

  const morningReward: TimelyRewardRecord = {
    title: '早起鸟奖励',
    description: '早起完成任务，获得额外奖励',
    type: TimelyRewardType.MORNING,
    status: TimelyRewardStatus.ACTIVE,
    progress: 0,
    startTime,
    endTime,
    luckyPoints: 15,
    iconPath: '/assets/rewards/morning-reward.svg',
    createdAt: now,
    updatedAt: now
  };

  const id = await db.table('timelyRewards').add(morningReward);
  const newReward = { ...morningReward, id: id as number };

  // 添加到同步队列
  await addSyncItem('timelyRewards', 'create', newReward);

  return newReward;
}

/**
 * 获取所有及时奖励
 * @param filter 过滤条件
 */
export async function getAllTimelyRewards(filter?: {
  status?: TimelyRewardStatus;
  type?: TimelyRewardType;
}): Promise<TimelyRewardRecord[]> {
  let collection = db.table('timelyRewards').toCollection();

  if (filter) {
    if (filter.status) {
      collection = collection.filter(reward => reward.status === filter.status);
    }
    if (filter.type) {
      collection = collection.filter(reward => reward.type === filter.type);
    }
  }

  return collection.toArray();
}

/**
 * 获取单个及时奖励
 * @param id 奖励ID
 */
export async function getTimelyReward(id: number): Promise<TimelyRewardRecord | undefined> {
  return db.table('timelyRewards').get(id);
}

/**
 * 更新及时奖励进度
 * @param id 奖励ID
 * @param progress 进度值（0-100）
 */
export async function updateTimelyRewardProgress(id: number, progress: number): Promise<TimelyRewardRecord> {
  const reward = await db.table('timelyRewards').get(id);

  if (!reward) {
    throw new Error(`Timely reward with id ${id} not found`);
  }

  // 确保进度在0-100范围内
  const validProgress = Math.max(0, Math.min(100, progress));

  // 如果进度达到100%，将状态更新为已完成
  let status = reward.status;
  let completedTime = reward.completedTime;

  if (validProgress >= 100 && status !== TimelyRewardStatus.COMPLETED) {
    status = TimelyRewardStatus.COMPLETED;
    completedTime = new Date();
  }

  const updatedReward = {
    ...reward,
    progress: validProgress,
    status,
    completedTime,
    updatedAt: new Date()
  };

  await db.table('timelyRewards').update(id, updatedReward);

  // 添加到同步队列
  await addSyncItem('timelyRewards', 'update', updatedReward);

  return updatedReward;
}

/**
 * 完成及时奖励
 * @param id 奖励ID
 */
export async function completeTimelyReward(id: number): Promise<RewardRecord[]> {
  const reward = await db.table('timelyRewards').get(id);

  if (!reward) {
    throw new Error(`Timely reward with id ${id} not found`);
  }

  if (reward.status === TimelyRewardStatus.COMPLETED) {
    throw new Error(`Timely reward with id ${id} is already completed`);
  }

  // 检查是否在有效时间范围内
  const now = new Date();
  if (now < reward.startTime || now > reward.endTime) {
    throw new Error(`Timely reward with id ${id} is not active`);
  }

  // 更新奖励状态
  const updatedReward = {
    ...reward,
    status: TimelyRewardStatus.COMPLETED,
    progress: 100,
    completedTime: now,
    updatedAt: now
  };

  await db.table('timelyRewards').update(id, updatedReward);

  // 生成奖励
  const rewards = await generateRewards(2, 'uncommon' as RewardRarity);

  // 添加幸运点
  await addLuckyPoints(reward.luckyPoints, `完成及时奖励: ${reward.title}`);

  // 添加到同步队列
  await addSyncItem('timelyRewards', 'update', updatedReward);

  return rewards;
}

/**
 * 添加幸运点
 * @param amount 点数数量
 * @param source 来源
 */
export async function addLuckyPoints(amount: number, source: string): Promise<LuckyPointRecord> {
  const now = new Date();

  // 设置过期日期为30天后
  const expiryDate = new Date(now);
  expiryDate.setDate(expiryDate.getDate() + 30);

  const luckyPoint: LuckyPointRecord = {
    userId: 'current-user', // 在实际应用中，这应该是当前用户的ID
    amount,
    source,
    timestamp: now,
    expiryDate,
    isSpent: false,
    createdAt: now
  };

  const id = await db.table('luckyPoints').add(luckyPoint);
  const newLuckyPoint = { ...luckyPoint, id: id as number };

  // 添加到同步队列
  await addSyncItem('luckyPoints', 'create', newLuckyPoint);

  return newLuckyPoint;
}

/**
 * 获取用户的幸运点总数
 */
export async function getLuckyPointsTotal(): Promise<number> {
  const points = await db.table('luckyPoints')
    .where('userId')
    .equals('current-user')
    .and(point => !point.isSpent)
    .and(point => !point.expiryDate || point.expiryDate > new Date())
    .toArray();

  return points.reduce((total, point) => total + point.amount, 0);
}

/**
 * 进行幸运抽奖
 * @param pointsToSpend 要使用的点数
 */
export async function performLuckyDraw(pointsToSpend: number): Promise<LuckyDrawRecord> {
  // 检查用户是否有足够的点数
  const totalPoints = await getLuckyPointsTotal();
  if (totalPoints < pointsToSpend) {
    throw new Error(`Not enough lucky points. Required: ${pointsToSpend}, Available: ${totalPoints}`);
  }

  // 确定奖品层级
  const prizeLevel = determinePrizeLevel();

  // 生成奖励
  const rarityString = PRIZE_LEVEL_TO_RARITY[prizeLevel];
  const rarity = rarityString as RewardRarity;
  const rewards = await generateRewards(1, rarity);

  // 使用幸运点
  await spendLuckyPoints(pointsToSpend);

  const now = new Date();
  const luckyDraw: LuckyDrawRecord = {
    userId: 'current-user',
    pointsSpent: pointsToSpend,
    rewards,
    timestamp: now,
    createdAt: now
  };

  const id = await db.table('luckyDraws').add(luckyDraw);
  const newLuckyDraw = { ...luckyDraw, id: id as number };

  // 添加到同步队列
  await addSyncItem('luckyDraws', 'create', newLuckyDraw);

  return newLuckyDraw;
}

/**
 * 使用幸运点
 * @param amount 要使用的点数数量
 */
async function spendLuckyPoints(amount: number): Promise<void> {
  // 获取未使用的幸运点
  const points = await db.table('luckyPoints')
    .where('userId')
    .equals('current-user')
    .and(point => !point.isSpent)
    .and(point => !point.expiryDate || point.expiryDate > new Date())
    .sortBy('expiryDate'); // 先使用快过期的点数

  let remainingAmount = amount;

  for (const point of points) {
    if (remainingAmount <= 0) break;

    if (point.amount <= remainingAmount) {
      // 如果当前点数记录小于等于剩余需要使用的点数，则全部使用
      await db.table('luckyPoints').update(point.id!, { isSpent: true });
      await addSyncItem('luckyPoints', 'update', { ...point, isSpent: true });
      remainingAmount -= point.amount;
    } else {
      // 如果当前点数记录大于剩余需要使用的点数，则拆分记录
      await db.table('luckyPoints').update(point.id!, { amount: point.amount - remainingAmount });
      await addSyncItem('luckyPoints', 'update', { ...point, amount: point.amount - remainingAmount });

      // 创建一个新的已使用记录
      const spentPoint: LuckyPointRecord = {
        userId: point.userId,
        amount: remainingAmount,
        source: point.source,
        timestamp: point.timestamp,
        expiryDate: point.expiryDate,
        isSpent: true,
        createdAt: new Date()
      };

      await db.table('luckyPoints').add(spentPoint);
      await addSyncItem('luckyPoints', 'create', spentPoint);

      remainingAmount = 0;
    }
  }

  if (remainingAmount > 0) {
    throw new Error(`Not enough lucky points. Required: ${amount}, Used: ${amount - remainingAmount}`);
  }
}

/**
 * 确定奖品层级
 */
function determinePrizeLevel(): PrizeLevel {
  const random = Math.random();
  let cumulativeProbability = 0;

  for (const [level, probability] of Object.entries(PRIZE_LEVEL_PROBABILITIES)) {
    cumulativeProbability += probability;
    if (random <= cumulativeProbability) {
      return level as PrizeLevel;
    }
  }

  return PrizeLevel.COMMON; // 默认返回普通层级
}

/**
 * 检查任务是否在及时奖励时间窗口内
 * @param task 任务
 */
export async function checkTaskForTimelyReward(task: TaskRecord): Promise<TimelyRewardRecord | null> {
  if (task.status !== TaskStatus.COMPLETED) {
    return null;
  }

  const now = new Date();

  // 获取活跃的及时奖励
  const activeRewards = await db.table('timelyRewards')
    .where('status')
    .equals(TimelyRewardStatus.ACTIVE)
    .toArray();

  // 检查任务是否在任何及时奖励的时间窗口内
  for (const reward of activeRewards) {
    if (now >= reward.startTime && now <= reward.endTime) {
      // 更新及时奖励进度
      const updatedReward = await updateTimelyRewardProgress(
        reward.id!,
        reward.progress + 20 // 每完成一个任务增加20%的进度
      );

      return updatedReward;
    }
  }

  return null;
}

/**
 * 更新及时奖励状态
 * 检查所有及时奖励，更新它们的状态（过期、即将开始等）
 */
export async function updateTimelyRewardsStatus(): Promise<void> {
  const now = new Date();

  // 获取所有及时奖励
  const rewards = await db.table('timelyRewards').toArray();

  for (const reward of rewards) {
    let newStatus = reward.status;

    // 如果已经完成，则跳过
    if (reward.status === TimelyRewardStatus.COMPLETED) {
      continue;
    }

    // 检查是否过期
    if (now > reward.endTime) {
      newStatus = TimelyRewardStatus.EXPIRED;
    }
    // 检查是否活跃
    else if (now >= reward.startTime && now <= reward.endTime) {
      newStatus = TimelyRewardStatus.ACTIVE;
    }
    // 检查是否即将开始
    else if (now < reward.startTime) {
      newStatus = TimelyRewardStatus.UPCOMING;
    }

    // 如果状态有变化，则更新
    if (newStatus !== reward.status) {
      const updatedReward = {
        ...reward,
        status: newStatus,
        updatedAt: now
      };

      await db.table('timelyRewards').update(reward.id!, updatedReward);
      await addSyncItem('timelyRewards', 'update', updatedReward);
    }
  }
}
</file>

<file path="src/types/dataRefresh.ts">
// src/types/dataRefresh.ts

/**
 * 数据刷新事件类型
 */
export interface DataRefreshEvent {
  table: string;
  data?: any;
}
</file>

<file path="src/utils/animation.ts">
// src/utils/animation.ts
import { Variants } from 'framer-motion';

/**
 * 淡入动画变体
 */
export const fadeIn: Variants = {
  hidden: { opacity: 0 },
  visible: { 
    opacity: 1,
    transition: { duration: 0.5 }
  },
  exit: { 
    opacity: 0,
    transition: { duration: 0.3 }
  }
};

/**
 * 从下方滑入动画变体
 */
export const slideUp: Variants = {
  hidden: { 
    opacity: 0, 
    y: 20 
  },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: { 
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  },
  exit: { 
    opacity: 0, 
    y: 20,
    transition: { duration: 0.2 }
  }
};

/**
 * 从左侧滑入动画变体
 */
export const slideInLeft: Variants = {
  hidden: { 
    opacity: 0, 
    x: -50 
  },
  visible: { 
    opacity: 1, 
    x: 0,
    transition: { 
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  },
  exit: { 
    opacity: 0, 
    x: -50,
    transition: { duration: 0.2 }
  }
};

/**
 * 从右侧滑入动画变体
 */
export const slideInRight: Variants = {
  hidden: { 
    opacity: 0, 
    x: 50 
  },
  visible: { 
    opacity: 1, 
    x: 0,
    transition: { 
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  },
  exit: { 
    opacity: 0, 
    x: 50,
    transition: { duration: 0.2 }
  }
};

/**
 * 缩放动画变体
 */
export const scale: Variants = {
  hidden: { 
    opacity: 0, 
    scale: 0.8 
  },
  visible: { 
    opacity: 1, 
    scale: 1,
    transition: { 
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  },
  exit: { 
    opacity: 0, 
    scale: 0.8,
    transition: { duration: 0.2 }
  }
};

/**
 * 弹跳动画变体
 */
export const bounce: Variants = {
  hidden: { 
    opacity: 0, 
    y: 50,
    scale: 0.9
  },
  visible: { 
    opacity: 1, 
    y: 0,
    scale: 1,
    transition: { 
      type: 'spring', 
      stiffness: 400, 
      damping: 10 
    }
  },
  exit: { 
    opacity: 0, 
    y: 20,
    transition: { duration: 0.2 }
  }
};

/**
 * 水墨效果动画变体
 */
export const inkSplash: Variants = {
  hidden: { 
    opacity: 0, 
    scale: 0.1,
    filter: 'blur(10px)'
  },
  visible: { 
    opacity: 1, 
    scale: 1,
    filter: 'blur(0px)',
    transition: { 
      duration: 0.5,
      ease: [0.25, 0.1, 0.25, 1]
    }
  },
  exit: { 
    opacity: 0, 
    scale: 1.2,
    filter: 'blur(10px)',
    transition: { duration: 0.3 }
  }
};

/**
 * 竹叶摇摆动画变体
 */
export const bambooSway: Variants = {
  hidden: { 
    opacity: 0, 
    rotate: -5,
    y: 20
  },
  visible: { 
    opacity: 1, 
    rotate: 0,
    y: 0,
    transition: { 
      type: 'spring', 
      stiffness: 100, 
      damping: 10 
    }
  },
  exit: { 
    opacity: 0, 
    rotate: 5,
    y: -20,
    transition: { duration: 0.3 }
  }
};

/**
 * 金光闪烁动画变体
 */
export const goldenGlow: Variants = {
  hidden: { 
    opacity: 0, 
    filter: 'brightness(0.8) saturate(0.8)'
  },
  visible: { 
    opacity: 1, 
    filter: 'brightness(1.2) saturate(1.2)',
    transition: { 
      duration: 0.5,
      ease: [0.25, 0.1, 0.25, 1]
    }
  },
  exit: { 
    opacity: 0, 
    filter: 'brightness(1.5) saturate(1.5)',
    transition: { duration: 0.3 }
  }
};

/**
 * 列表项动画变体（用于列表中的项目，带有交错效果）
 */
export const listItem: Variants = {
  hidden: { 
    opacity: 0, 
    y: 20 
  },
  visible: (i: number) => ({ 
    opacity: 1, 
    y: 0,
    transition: { 
      delay: i * 0.1,
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  }),
  exit: { 
    opacity: 0, 
    y: 20,
    transition: { duration: 0.2 }
  }
};

/**
 * 页面过渡动画变体
 */
export const pageTransition: Variants = {
  hidden: { 
    opacity: 0, 
    y: 20 
  },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: { 
      duration: 0.5,
      ease: [0.25, 0.1, 0.25, 1]
    }
  },
  exit: { 
    opacity: 0, 
    y: -20,
    transition: { duration: 0.3 }
  }
};

/**
 * 创建带有延迟的容器动画变体
 * @param staggerChildren 子元素之间的延迟时间
 * @param delayChildren 所有子元素的初始延迟
 */
export const createContainerVariants = (
  staggerChildren = 0.1, 
  delayChildren = 0
): Variants => ({
  hidden: { opacity: 0 },
  visible: { 
    opacity: 1,
    transition: { 
      staggerChildren,
      delayChildren
    }
  },
  exit: { 
    opacity: 0,
    transition: { 
      staggerChildren: 0.05,
      staggerDirection: -1
    }
  }
});
</file>

<file path="src/utils/dateUtils.ts">
// src/utils/dateUtils.ts

/**
 * 格式化日期为易读的字符串（不包含时间）
 * @param dateString 日期字符串或Date对象
 * @returns 格式化后的日期字符串
 */
export function formatDate(dateString: string | Date): string {
  return formatTime(dateString, false);
}

/**
 * 格式化日期时间为易读的字符串
 * @param dateString 日期字符串或Date对象
 * @param includeTime 是否包含时间部分
 * @returns 格式化后的日期时间字符串
 */
export function formatTime(dateString: string | Date, includeTime: boolean = true): string {
  if (!dateString) return '';

  const date = typeof dateString === 'string' ? new Date(dateString) : dateString;

  // 检查日期是否有效
  if (isNaN(date.getTime())) {
    return 'Invalid Date';
  }

  // 格式化日期部分
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');

  const dateFormatted = `${year}-${month}-${day}`;

  // 如果不需要时间部分，直接返回日期
  if (!includeTime) {
    return dateFormatted;
  }

  // 格式化时间部分
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');

  return `${dateFormatted} ${hours}:${minutes}`;
}

/**
 * 计算两个日期之间的天数差
 * @param date1 第一个日期
 * @param date2 第二个日期，默认为当前日期
 * @returns 天数差
 */
export function daysBetween(date1: Date | string, date2: Date | string = new Date()): number {
  const d1 = typeof date1 === 'string' ? new Date(date1) : date1;
  const d2 = typeof date2 === 'string' ? new Date(date2) : date2;

  // 将时间部分设置为0，只比较日期部分
  d1.setHours(0, 0, 0, 0);
  d2.setHours(0, 0, 0, 0);

  // 计算毫秒差并转换为天数
  const diffTime = Math.abs(d2.getTime() - d1.getTime());
  const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

  return diffDays;
}

/**
 * 检查日期是否是今天
 * @param date 要检查的日期
 * @returns 是否是今天
 */
export function isToday(date: Date | string): boolean {
  const today = new Date();
  const checkDate = typeof date === 'string' ? new Date(date) : date;

  return (
    checkDate.getDate() === today.getDate() &&
    checkDate.getMonth() === today.getMonth() &&
    checkDate.getFullYear() === today.getFullYear()
  );
}

/**
 * 获取相对时间描述（例如：刚刚、5分钟前、1小时前等）
 * @param date 日期
 * @returns 相对时间描述
 */
export function getRelativeTimeDescription(date: Date | string): string {
  const now = new Date();
  const targetDate = typeof date === 'string' ? new Date(date) : date;

  const diffMs = now.getTime() - targetDate.getTime();
  const diffSecs = Math.floor(diffMs / 1000);
  const diffMins = Math.floor(diffSecs / 60);
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);

  if (diffSecs < 60) {
    return '刚刚';
  } else if (diffMins < 60) {
    return `${diffMins}分钟前`;
  } else if (diffHours < 24) {
    return `${diffHours}小时前`;
  } else if (diffDays < 30) {
    return `${diffDays}天前`;
  } else {
    return formatTime(targetDate, false);
  }
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src", "vite.config.ts"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})
</file>

<file path="development-tasks-updated.md">
# PandaHabit 开发任务文档：华丽游戏风格实现

## 1. 项目设置

### 1.1 环境配置
- [x] 设置开发环境（使用Vite）
- [ ] 设置测试和生产环境
- [ ] 为不同部署阶段配置环境变量
- [ ] 设置CI/CD管道，用于自动测试和部署
- [x] 配置代码检查和格式化工具（ESLint已配置）
- [x] 设置华丽游戏风格的设计系统和组件库（已实现基本主题和移动应用布局）

### 1.2 依赖管理
- [x] 安装和配置所需依赖：
  - [x] React和React DOM
  - [x] TypeScript
  - [x] React Router用于导航
  - [x] Dexie.js用于本地数据库
  - [x] React Query用于数据获取
  - [ ] 动画库（Framer Motion或React Spring）用于华丽动效
  - [🔄] 中文字体库（已添加Google Fonts，但需要添加更多中文字体）
  - [ ] 粒子效果库（用于华丽特效）
- [x] 使用npm设置包管理
- [ ] 为生产构建配置依赖优化
- [ ] 集成中国风素材库和图标系统

### 1.3 项目结构组织
- [x] 按照现有架构模式组织项目
- [ ] 为游戏特定组件创建专用目录
- [x] 设置资产管理结构，用于图像、动画和声音（已创建public/assets目录和SVG资源）
- [x] 建立样式组织（使用CSS文件）
- [x] 配置TypeScript路径以实现清晰导入（已配置@路径别名）
- [x] 创建华丽游戏风格的主题文件和变量（已完善game-theme.css，添加了中国风元素）

## 2. 核心基础设施开发

### 2.1 数据库架构实现
- [✅] 扩展现有Dexie.js架构，包括：
  - [x] 基本UI标签数据（已实现UILabelRecord）
  - [x] 用户配置文件和进度数据（已实现PandaStateRecord）
  - [x] 熊猫状态和定制数据（已实现PandaStateRecord和PandaAbilityRecord）
  - [x] 任务和挑战数据（已实现TaskRecord和TaskCompletionRecord）
  - [x] 资源和库存数据（已实现RewardRecord和ItemRecord）
  - [x] 成就和里程碑数据（已实现BadgeRecord）
- [x] 实现基本数据填充策略（已实现populateDB函数）
- [x] 实现数据迁移策略以进行更新（已实现数据库版本升级）
- [x] 创建数据验证实用程序（已实现各种服务中的验证逻辑）
- [x] 设置数据备份和同步机制（已实现dataSyncService）

### 2.2 API端点实现
- [✅] 实现模拟API服务：
  - [x] 创建基本服务层结构（已实现localizedContentService）
  - [🔄] 用户认证和配置文件管理
  - [x] 熊猫状态和互动（已实现pandaStateService）
  - [x] 任务管理和完成（已实现taskService）
  - [x] 挑战跟踪和奖励（已实现rewardService）
  - [x] 及时奖励和幸运抽奖（已实现rewardService中的随机奖励生成）
  - [x] 熊猫能力系统（已实现pandaAbilityService）
- [x] 创建具有基本错误处理的API服务层
- [x] 实现基本请求缓存（通过React Query）
- [x] 为开发和测试设置模拟API（使用Dexie.js）
- [x] 实现数据同步机制（已实现dataSyncService）

### 2.3 认证系统
- [ ] 实现用户注册和登录流程
- [ ] 设置安全的基于令牌的认证
- [ ] 创建账户管理功能
- [ ] 实现社交登录选项（如需要）
- [ ] 设置密码恢复机制
- [ ] 配置隐私和数据保护功能

### 2.4 国际化系统
- [x] 实现基本i18n系统（已实现LanguageProvider）
- [🔄] 扩展现有i18n系统以支持游戏特定内容
- [x] 为基本支持的语言创建翻译文件（英文和中文）
- [x] 实现基于语言选择的动态内容加载（通过useLocalizedView钩子）
- [ ] 设置更完善的翻译管理工作流程
- [ ] 确保正确处理RTL语言（如支持）
- [ ] 为日期、数字和货币实现特定于语言的格式化
- [ ] 确保华丽游戏风格元素在所有语言中保持一致

## 3. UI组件开发

### 3.1 通用组件
- [x] 设计并实现华丽版本的：
  - [x] 按钮（已实现基本按钮和游戏风格的jade-button、gold-button）
  - [ ] 输入字段和表单元素，添加水墨动效和传统纹饰
  - [x] 卡片和容器（已实现bamboo-frame样式）
  - [x] 模态框和对话框组件，设计为古代卷轴或窗棂样式
  - [x] 加载器和进度指示器（已实现jade-spinner和bamboo-progress）
  - [ ] 工具提示和弹出框，添加云纹装饰和优雅过渡
- [ ] 创建全面的组件库，并附带文档
- [x] 为所有组件实现响应式行为（已针对移动设备优化）
- [x] 添加动画和过渡效果（已使用Framer Motion实现）
- [x] 实现中国风特效系统（已实现水墨、金光、竹叶等特效）

### 3.2 布局组件
- [x] 实现基本AppShell组件
- [x] 使用华丽风格增强AppShell（已添加中国风装饰元素）
- [x] 创建基本Header组件
- [x] 增强Header组件（已针对移动应用优化，移除了顶部标题）
- [x] 设计Navigation组件（已实现移动应用风格的底部导航栏）
- [x] 开发基本页面布局模板
- [x] 实现针对不同屏幕尺寸的响应式布局调整（已针对移动设备优化）
- [x] 创建布局状态之间的过渡效果（已使用Framer Motion实现页面过渡）
- [x] 添加中国风背景和装饰元素（已添加中国风边框和装饰）

### 3.3 特定功能组件
- [x] 开发PandaAvatar组件，具有不同状态和动画（已实现基本熊猫头像组件）
- [x] 创建TaskCard组件（已实现带动画效果的任务卡片）
- [✅] 实现ChallengeCard组件，具有进度跟踪（已实现挑战卡片和列表组件）
- [ ] 设计各种资源类型的ResourceDisplay组件
- [ ] 开发不同奖励场景的RewardAnimation组件
- [ ] 创建具有引人入胜动画的LuckyDraw组件
- [ ] 实现具有支持性UI的ReflectionModule组件
- [x] 为所有组件添加华丽的中国风视觉元素和动效（已添加水墨、金光等特效）

## 4. 功能实现

### 4.1 熊猫伙伴系统
- [x] 实现熊猫状态管理（情绪、成长、能量）（已实现PandaStateProvider）
- [x] 创建熊猫互动机制（喂食、玩耍、训练）（已实现基本互动功能）
- [ ] 开发熊猫定制系统，包括传统中国风装饰元素
- [x] 实现熊猫成长和进化逻辑（已实现基本经验和等级系统）
- [x] 创建熊猫能力解锁系统（已实现能力解锁和激活功能）
- [x] 开发熊猫动画控制器，用于不同状态和动作（已实现基本状态动画）
- [ ] 实现环境定制和互动，融入中国园林元素

### 4.2 任务管理系统
- [x] 实现任务创建和编辑功能（已实现TaskForm组件）
- [x] 创建任务分类（日常、主线、支线）（已实现TaskType枚举和类别系统）
- [x] 开发任务调度和重复逻辑（已实现基本任务管理）
- [x] 实现任务完成和验证（已实现completeTask功能）
- [ ] 创建任务提醒系统，使用熊猫信使主题
- [ ] 开发复杂目标的任务分解
- [x] 实现任务过滤和排序（已实现基本过滤功能）
- [x] 添加华丽的任务完成动画和特效（已实现任务完成奖励系统）

### 4.3 挑战系统
- [✅] 创建挑战定义和管理（已实现挑战数据模型和服务）
- [✅] 实现挑战类型（日常、每周、活动、持续）（已实现ChallengeType枚举）
- [✅] 开发挑战生命周期和进度跟踪（已实现挑战状态和进度管理）
- [ ] 创建与日常任务的子任务集成
- [✅] 实现挑战奖励和完成逻辑（已实现completeChallenge功能）
- [ ] 开发挑战发现和推荐系统
- [ ] 创建合作社交挑战（如实施）
- [✅] 设计华丽的挑战地图和进度可视化（已实现挑战卡片和过滤界面）

### 4.4 及时奖励系统
- [✅] 实现符合条件任务的时间窗口跟踪（已实现timelyRewardService）
- [✅] 创建及时性进度条系统，设计为华丽卷轴（已实现TimelyRewardCard组件）
- [✅] 开发幸运点累积和管理（已实现LuckyPointsDisplay组件）
- [✅] 实现带有奖品层级的幸运抽奖机制（已实现LuckyDraw组件）
- [✅] 创建奖励分配和库存管理（已实现奖励生成和分发逻辑）
- [✅] 开发及时完成的视觉反馈（已实现及时奖励模态框）
- [✅] 实现"早起鸟"奖励机制（已实现早起鸟奖励类型）
- [✅] 添加华丽的抽奖动画和奖励展示效果（已实现抽奖动画和特效）

### 4.5 反思模块
- [ ] 创建反思机会的触发检测
- [ ] 实现温和、非判断性的对话系统
- [ ] 开发用户输入收集和处理
- [ ] 创建支持性反馈生成
- [ ] 实现可行建议系统
- [ ] 开发情绪跟踪和模式识别
- [ ] 创建自我同情强化机制
- [ ] 设计静心茶室环境和相关视觉效果

### 4.6 商店和货币化
- [ ] 实现带有物品类别的商店界面
- [ ] 创建物品预览和购买流程
- [ ] 开发VIP订阅管理
- [ ] 实现应用内购买集成
- [ ] 创建VIP福利激活和跟踪
- [ ] 开发促销功能（销售、限时物品）
- [ ] 实现收据验证和购买恢复
- [ ] 设计华丽的商店环境和购买动画

### 4.7 图片素材
生成csv管理所有页面的spirate、icon、图片、模型等素材，包含页面名称、素材文件名称，路径，大小，生成素材图片/icon等的提示词。

## 5. 集成和测试

### 5.1 组件集成
- [✅] 将UI组件与数据服务集成（已实现DataLoader组件和数据同步服务）
- [✅] 连接功能系统以创建连贯的游戏循环（已连接任务系统、奖励系统和熊猫伙伴系统）
- [✅] 实现功能之间的状态同步（已实现dataSyncService和状态同步机制）
- [✅] 实现数据同步后的局部UI更新（已实现useDataRefresh Hook和事件驱动的UI更新）
- [x] 创建不同应用部分之间的流畅过渡（已使用Framer Motion实现页面过渡）
- [✅] 开发错误处理和恢复机制（已实现错误处理和同步恢复机制）
- [x] 实现加载状态和占位符（已实现LoadingSpinner组件）
- [x] 确保华丽视觉风格在所有集成点保持一致（已实现统一的游戏风格）

### 5.2 端到端测试
- [ ] 为关键用户旅程创建全面的测试套件
- [ ] 实现核心功能的自动化测试
- [ ] 开发UI组件的视觉回归测试
- [ ] 创建性能基准和测试
- [ ] 实现跨浏览器和跨设备测试
- [ ] 开发可访问性测试程序
- [ ] 测试华丽动画和特效的性能影响

### 5.3 性能优化
- [x] 实现代码分割和延迟加载（已通过React.lazy实现）
- [✅] 优化资产加载和缓存（已优化SVG资源和实现数据缓存）
- [x] 实现高效渲染策略（已使用Framer Motion的性能优化特性）
- [ ] 创建性能监控工具
- [✅] 优化数据库查询和数据管理（已实现高效的数据库查询和同步机制）
- [✅] 实现内存管理最佳实践（已实现数据缓存和内存管理）
- [x] 优化华丽视觉效果和动画的性能（已使用Framer Motion的性能优化特性）

### 5.4 用户验收测试
- [ ] 创建beta测试计划
- [ ] 开发反馈收集机制
- [ ] 实现用户行为跟踪分析
- [ ] 创建功能优化的A/B测试框架
- [ ] 开发用户满意度测量
- [ ] 实现基于反馈的迭代改进过程
- [ ] 收集华丽游戏风格的用户体验反馈

## 6. 部署和维护

### 6.1 部署策略
- [x] 为生产创建构建优化（已实现Vite构建配置）
- [ ] 实现渐进式推出策略
- [ ] 开发功能标记，用于受控发布
- [ ] 创建关键问题的回滚机制
- [ ] 实现监控和警报系统
- [ ] 开发自动部署验证
- [x] 确保华丽视觉资产的高效交付（已优化SVG资源和动画性能）

### 6.2 监控和分析
- [ ] 实现错误跟踪和报告
- [ ] 创建性能监控仪表板
- [ ] 开发用户参与度分析
- [ ] 实现转化和留存跟踪
- [ ] 创建功能使用分析
- [ ] 开发货币化性能指标
- [ ] 监控华丽游戏元素的用户互动数据

### 6.3 更新计划
- [ ] 创建内容更新管道
- [ ] 实现季节性活动框架
- [ ] 开发功能扩展路线图
- [ ] 创建更新的用户沟通渠道
- [ ] 实现基于反馈的优先级排序
- [ ] 开发长期可持续性规划
- [ ] 规划华丽游戏风格的季节性更新和主题活动

## 7. 技术债务和文档

### 7.1 代码质量和维护
- [x] 实现代码文档（已为所有组件添加详细注释）
- [ ] 创建架构决策记录
- [x] 开发编码标准和最佳实践（已配置ESLint规则和TypeScript类型检查）
- [ ] 实现定期代码审查流程
- [ ] 创建技术债务跟踪和解决计划
- [ ] 开发知识共享机制
- [🔄] 建立华丽游戏风格实现的设计规范（已创建基本设计规范）

### 7.2 用户文档
- [ ] 创建应用内教程和帮助系统
- [ ] 开发用户指南和常见问题解答
- [ ] 实现上下文帮助和工具提示
- [ ] 创建入职材料
- [ ] 开发故障排除指南
- [ ] 实现反馈和支持渠道
- [ ] 提供华丽游戏风格元素的解释和背景故事

### 7.3 开发者文档
- [x] 创建项目文档（已实现详细的README和任务进度文档）
- [🔄] 创建全面的API文档（已为主要服务添加文档）
- [🔄] 开发组件库文档（已为主要组件添加文档）
- [✅] 实现系统架构文档（已创建数据同步与局部刷新架构文档）
- [x] 创建开发环境设置指南（已在README中提供）
- [ ] 开发贡献指南
- [ ] 实现版本控制和分支策略文档
- [🔄] 提供华丽游戏风格设计系统的详细说明（已在game-theme.css中提供基本说明）

## 8. 未来考虑

### 8.1 高级功能
- [ ] 规划高级熊猫互动和迷你游戏
- [ ] 开发复杂的习惯分析和见解
- [ ] 创建更深入的社交功能和责任小组
- [ ] 规划可穿戴设备集成
- [ ] 开发扩展的引导练习
- [ ] 创建主题季节性活动框架
- [ ] 设计更多华丽的游戏化元素和互动体验

### 8.2 平台扩展
- [ ] 规划网页版开发
- [ ] 考虑桌面应用可能性
- [ ] 评估智能手表伴侣应用
- [ ] 研究语音助手集成
- [ ] 考虑用于熊猫互动的AR/VR体验
- [ ] 评估跨平台同步
- [ ] 探索中国特色平台的集成（如微信小程序）

### 8.3 业务发展
- [ ] 创建合作伙伴关系和协作框架
- [ ] 开发内容创建者计划
- [ ] 规划本地化到其他市场
- [ ] 研究企业/组织版本
- [ ] 开发品牌扩展机会
- [ ] 创建长期可持续性模型
- [ ] 探索与中国传统文化品牌的合作机会

## 9. 进度总结

### 9.1 已完成项目（✓）
- 基本项目设置（Vite、React、TypeScript）
- 基本依赖安装（React Router、Dexie.js、React Query）
- 基本项目结构组织
- 基本国际化系统实现
- 基本数据库结构和填充策略
- 华丽游戏风格的UI组件（按钮、加载器、卡片等）
- 基本路由系统
- 移动应用布局优化（底部导航、响应式设计）
- 中国风视觉元素集成（装饰、边框、SVG资源）
- 游戏风格的主题系统（颜色、字体、间距等）
- 熊猫伙伴系统的基本功能（PandaAvatar组件、状态管理、互动机制）
- 任务管理系统的核心功能（任务创建、编辑、完成、分类、过滤）
- 动画系统集成（Framer Motion）
- 中国风特效组件（水墨、金光、竹叶等）
- 页面过渡动画
- 数据服务与UI组件的集成（DataLoader组件、数据同步服务）
- 熊猫能力解锁系统（能力定义、解锁和激活功能）
- 任务完成奖励系统（奖励生成和展示）
- 数据同步后的局部UI更新（useDataRefresh Hook和事件驱动的UI更新）
- 挑战系统的基本功能（挑战定义、过滤、完成和奖励）
- 及时奖励系统（时间窗口内完成任务获得额外奖励）
- 幸运点和幸运抽奖系统（累积幸运点进行抽奖）

### 9.2 进行中项目（🔄）
- 用户认证和配置文件管理

### 9.3 下一步优先事项
1. ✅ 实现熊猫伙伴系统的基本功能（PandaAvatar组件）
2. ✅ 开发任务管理系统的核心功能（TaskManager组件）
3. ✅ 添加动画库（Framer Motion）
4. ✅ 实现中国风特效系统（水墨、金光、竹叶等）
5. ✅ 开发模态框和对话框组件（古代卷轴或窗棂样式）
6. ✅ 实现任务完成奖励系统
7. ✅ 开发熊猫能力解锁系统
8. ✅ 添加更多中文字体和视觉资源
9. ✅ 实现数据同步后的局部UI更新（useDataRefresh Hook）
10. ✅ 开发挑战系统的基本功能（挑战定义、过滤、完成和奖励）
11. [✅] 实现及时奖励系统（已实现及时奖励和幸运抽奖功能）
12. [ ] 开发反思模块
</file>

<file path="package.json">
{
  "name": "minimal-dexie-i18n-v3-final",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.32.0",
    "@types/node": "^22.15.17",
    "dexie": "^3.2.7",
    "framer-motion": "^12.11.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.23.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@types/react-router-dom": "^5.3.3",
    "@typescript-eslint/eslint-plugin": "^7.2.0",
    "@typescript-eslint/parser": "^7.2.0",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "typescript": "^5.2.2",
    "vite": "^5.2.0"
  }
}
</file>

<file path="src/App.tsx">
// src/App.tsx
import React, { useEffect } from 'react';
import { BrowserRouter } from 'react-router-dom';
import { QueryClientProvider } from '@tanstack/react-query';
// import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { LanguageProvider } from '@/context/LanguageProvider';
import { PandaStateProvider } from '@/context/PandaStateProvider';
import { DataRefreshProvider } from '@/context/DataRefreshProvider';
import { populateDB, db } from '@/db';
import AppShell from '@/components/layout/AppShell';
import AppRouter from '@/router';
import { initializeDataSync } from '@/services/dataSyncService';
import { initializeTimelyRewards, updateTimelyRewardsStatus } from '@/services/timelyRewardService';
import { queryClient } from '@/services/queryClient';

const App: React.FC = () => {
  useEffect(() => {
    // 初始化和填充数据库
    const initDB = async () => {
      try {
        // Populate Dexie DB on app start for development
        if (import.meta.env.DEV) { // Vite specific dev check
          await populateDB();
        }

        // 初始化数据同步服务
        setTimeout(() => {
          try {
            initializeDataSync({
              autoSyncInterval: 30000, // 30秒
              maxRetryCount: 5,
              batchSize: 20
            });

            // 确保数据库表已创建
            try {
              // 检查及时奖励表是否存在
              db.table('timelyRewards').count().then(count => {
                console.log(`TimelyRewards table exists with ${count} records`);

                // 初始化及时奖励系统
                initializeTimelyRewards().then(() => {
                  console.log("Timely rewards initialized successfully");

                  // 更新及时奖励状态
                  updateTimelyRewardsStatus().then(() => {
                    console.log("Timely rewards status updated successfully");
                  }).catch(err => {
                    console.error("Failed to update timely rewards status:", err);
                  });
                }).catch(err => {
                  console.error("Failed to initialize timely rewards:", err);
                });
              }).catch(err => {
                console.error("Failed to access timelyRewards table:", err);
              });
            } catch (err) {
              console.error("Error during timely rewards initialization:", err);
            }
          } catch (syncErr) {
            console.error("Failed to initialize data sync service:", syncErr);
          }
        }, 2000); // 延迟2秒初始化同步服务，确保数据库已经准备好
      } catch (err) {
        console.error("Failed to initialize database:", err);
      }
    };

    initDB();

    // 监听在线状态变化
    const handleOnline = () => {
      console.log('App is online, triggering sync');
      import('@/services/dataSyncService').then(({ syncPendingItems }) => {
        syncPendingItems().catch(err => {
          console.error('Sync failed:', err);
        });
      }).catch(err => {
        console.error('Failed to import dataSyncService:', err);
      });
    };

    window.addEventListener('online', handleOnline);

    return () => {
      window.removeEventListener('online', handleOnline);

      // 停止自动同步
      import('@/services/dataSyncService').then(({ stopAutoSync }) => {
        stopAutoSync();
      }).catch(err => {
        console.error('Failed to import dataSyncService for cleanup:', err);
      });
    };
  }, []);

  return (
    <QueryClientProvider client={queryClient}>
      <LanguageProvider>
        <DataRefreshProvider>
          <PandaStateProvider>
            <BrowserRouter>
              <AppShell> {/* AppShell fetches global layout labels and provides overall structure */}
                <AppRouter /> {/* AppRouter handles page-specific content and routing */}
              </AppShell>
            </BrowserRouter>
          </PandaStateProvider>
        </DataRefreshProvider>
      </LanguageProvider>
      {/* <ReactQueryDevtools initialIsOpen={false} /> */}
    </QueryClientProvider>
  );
};
export default App;
</file>

<file path="src/components/layout/AppShell.tsx">
// src/components/layout/AppShell.tsx
import React, { ReactNode } from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchGlobalLayoutView } from '@/services';
import Header from './Header';
import Navigation from './Navigation';
import LoadingSpinner from '../common/LoadingSpinner';
import ErrorDisplay from '../common/ErrorDisplay';
import ChineseDecoration from '../decoration/ChineseDecoration';
import SyncStatusIndicator from '../common/SyncStatusIndicator';
import type { GlobalLayoutLabelsBundle, ApiError } from '@/types';

interface AppShellProps { children: ReactNode; }

const AppShell: React.FC<AppShellProps> = ({ children }) => {
  const {
    labels: globalLabels, isPending, isError, error, isFetching, refetch
  } = useLocalizedView<null, GlobalLayoutLabelsBundle>(
    'globalLayoutViewContent', // Unique query key for this "view"
    fetchGlobalLayoutView
  );

  if (isPending && !globalLabels) {
    // Use a very generic loading text if global labels themselves are not available
    return <LoadingSpinner variant="jade" text={globalLabels?.loadingGeneric || "Initializing Application..."} />;
  }

  if (isError || !globalLabels) { // Critical error if global labels fail
    return (
      <div style={{ padding: '20px' }}>
        <ErrorDisplay
          error={error} // Error from the hook
          title={globalLabels?.appErrorHeading || "Application Shell Error"}
          messageTemplate={globalLabels?.appErrorGeneralMessage || "Core UI failed. Details: {message}"}
          onRetry={refetch}
          retryButtonText="Retry Loading Shell"
        />
      </div>
    );
  }

  return (
    <div className="app-shell">
      {/* Add Chinese pattern decorative elements */}
      <div className="chinese-pattern top"></div>

      {/* 添加中国风装饰元素 */}
      <ChineseDecoration />

      <Header labels={globalLabels} isFetching={isFetching && !!globalLabels}/> {/* Pass fetching only if labels are loaded */}

      <main>{children}</main>

      {/* 移动应用底部导航 */}
      <Navigation labels={globalLabels} variant="bamboo" />

      {/* 同步状态指示器 */}
      <SyncStatusIndicator variant="standard" showCount={true} showLabel={true} />

      <div className="chinese-pattern bottom"></div>
    </div>
  );
};
export default AppShell;
</file>

<file path="src/components/layout/Navigation.tsx">
// src/components/layout/Navigation.tsx
import React from 'react';
import { NavLink } from 'react-router-dom';
import type { GlobalLayoutLabelsBundle } from '@/types';

interface NavigationProps {
  labels: GlobalLayoutLabelsBundle | undefined;
  variant?: 'default' | 'bamboo';
}

/**
 * Navigation component with support for game-themed style
 *
 * @param labels - Text labels for navigation items
 * @param variant - 'default' or 'bamboo' (game-themed)
 */
const Navigation: React.FC<NavigationProps> = ({
  labels,
  variant = 'bamboo' // Default to bamboo style for game theme
}) => {
  // Provide fallbacks for label properties
  const navHomeText = labels?.navHome || "Home";
  const navTasksText = labels?.navTasks || "Tasks";
  const navAbilitiesText = labels?.navAbilities || "Abilities";
  const navChallengesText = labels?.navChallenges || "Challenges";
  const navRewardsText = labels?.navRewards || "Rewards";
  const navSettingsText = labels?.navSettings || "Settings";

  if (!labels) { // Can show a minimal loading state or just render with fallbacks
    return <nav className={variant === 'bamboo' ? 'bamboo-nav' : ''}>Loading navigation...</nav>;
  }

  const navClass = variant === 'bamboo' ? 'bamboo-nav' : '';

  return (
    <nav className={navClass}>
      <NavLink
        to="/"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navHomeText}
      </NavLink>
      <NavLink
        to="/tasks"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navTasksText}
      </NavLink>
      <NavLink
        to="/abilities"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navAbilitiesText}
      </NavLink>
      <NavLink
        to="/challenges"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navChallengesText}
      </NavLink>
      <NavLink
        to="/rewards"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navRewardsText}
      </NavLink>
      <NavLink
        to="/settings"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navSettingsText}
      </NavLink>
    </nav>
  );
};

export default Navigation;
</file>

<file path="src/db.ts">
// src/db.ts
import Dexie, { Table } from 'dexie';
import type { UILabelRecord } from '@/types';
import type { PandaStateRecord } from '@/services/pandaStateService';
import type {
  TaskRecord,
  TaskCategoryRecord,
  TaskCompletionRecord
} from '@/services/taskService';
import type { RewardRecord, ItemRecord, BadgeRecord, AbilityRecord as RewardAbilityRecord } from '@/services/rewardService';
import type { PandaAbilityRecord } from '@/services/pandaAbilityService';
import type { SyncItem } from '@/services/dataSyncService';
import type { ChallengeRecord, ChallengeCompletionRecord } from '@/services/challengeService';
import type { TimelyRewardRecord, LuckyPointRecord, LuckyDrawRecord } from '@/services/timelyRewardService';
import type { SubtaskRecord } from '@/services/subtaskService';

export class AppDB extends Dexie {
  uiLabels!: Table<UILabelRecord, number>;
  pandaState!: Table<PandaStateRecord, number>;
  tasks!: Table<TaskRecord, number>;
  taskCategories!: Table<TaskCategoryRecord, number>;
  taskCompletions!: Table<TaskCompletionRecord, number>;
  subtasks!: Table<SubtaskRecord, number>;
  rewards!: Table<RewardRecord, number>;
  items!: Table<ItemRecord, number>;
  badges!: Table<BadgeRecord, number>;
  abilities!: Table<PandaAbilityRecord, number>;
  rewardAbilities!: Table<RewardAbilityRecord, number>;
  syncQueue!: Table<SyncItem, string>;
  challenges!: Table<ChallengeRecord, number>;
  challengeCategories!: Table<any, number>;
  challengeCompletions!: Table<ChallengeCompletionRecord, number>;
  timelyRewards!: Table<TimelyRewardRecord, number>;
  luckyPoints!: Table<LuckyPointRecord, number>;
  luckyDraws!: Table<LuckyDrawRecord, number>;

  constructor() {
    super('PandaHabitDB_V7'); // 更新数据库版本
    this.version(7).stores({
      uiLabels: '++id, scopeKey, labelKey, languageCode, &[scopeKey+labelKey+languageCode]',
      pandaState: '++id, mood, energy, lastUpdated, level',
      tasks: '++id, title, categoryId, priority, status, dueDate, createdAt',
      taskCategories: '++id, name, color, icon, isDefault',
      taskCompletions: '++id, taskId, completedAt, experienceGained',
      subtasks: '++id, parentTaskId, title, status, order, createdAt',
      rewards: '++id, type, rarity, taskId, obtainedAt, isViewed',
      items: '++id, type, rarity, quantity, obtainedAt',
      badges: '++id, rarity, obtainedAt, isEquipped',
      abilities: '++id, name, type, effectType, requiredLevel, isUnlocked, isActive',
      rewardAbilities: '++id, rarity, obtainedAt, isUnlocked, isActive',
      syncQueue: 'id, table, action, timestamp, status',
      challenges: '++id, title, type, difficulty, status, progress, startDate, endDate, createdAt',
      challengeCategories: '++id, name, description, iconPath',
      challengeCompletions: '++id, challengeId, userId, completedDate, createdAt',
      timelyRewards: '++id, title, type, status, startTime, endTime, createdAt',
      luckyPoints: '++id, userId, amount, isSpent, expiryDate, createdAt',
      luckyDraws: '++id, userId, pointsSpent, timestamp, createdAt'
    });
  }
}
export const db = new AppDB();

let hasAttemptedPopulation = false;

export async function populateDB() {
  if (hasAttemptedPopulation) return;
  hasAttemptedPopulation = true;

  const count = await db.uiLabels.count();
  if (count > 0) { /* console.log("DB V3 already populated."); */ return; }
  console.log("Populating Final V3 Dexie DB...");

  const labels: UILabelRecord[] = [
    // GlobalLayout scope
    { scopeKey: 'globalLayout', labelKey: 'appTitle', languageCode: 'en', translatedText: 'App V3 - Consistent' },
    { scopeKey: 'globalLayout', labelKey: 'appTitle', languageCode: 'zh', translatedText: '应用 V3 - 一致性' },
    { scopeKey: 'globalLayout', labelKey: 'navHome', languageCode: 'en', translatedText: 'Home' },
    { scopeKey: 'globalLayout', labelKey: 'navHome', languageCode: 'zh', translatedText: '主页' },
    { scopeKey: 'globalLayout', labelKey: 'navTasks', languageCode: 'en', translatedText: 'Tasks' },
    { scopeKey: 'globalLayout', labelKey: 'navTasks', languageCode: 'zh', translatedText: '任务' },
    { scopeKey: 'globalLayout', labelKey: 'navSettings', languageCode: 'en', translatedText: 'Settings' },
    { scopeKey: 'globalLayout', labelKey: 'navSettings', languageCode: 'zh', translatedText: '设定' },
    { scopeKey: 'globalLayout', labelKey: 'footerText', languageCode: 'en', translatedText: '© 2024 Final Demo App' },
    { scopeKey: 'globalLayout', labelKey: 'footerText', languageCode: 'zh', translatedText: '© 2024 最终演示应用' },
    { scopeKey: 'globalLayout', labelKey: 'loadingGeneric', languageCode: 'en', translatedText: 'Loading, one moment...' },
    { scopeKey: 'globalLayout', labelKey: 'loadingGeneric', languageCode: 'zh', translatedText: '加载中，请稍候...' },
    { scopeKey: 'globalLayout', labelKey: 'errorGeneric', languageCode: 'en', translatedText: 'An unexpected error occurred.' },
    { scopeKey: 'globalLayout', labelKey: 'errorGeneric', languageCode: 'zh', translatedText: '发生了一个意外错误。' },

    // homeView scope
    { scopeKey: 'homeView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'My Dashboard' },
    { scopeKey: 'homeView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '我的仪表板' },
    { scopeKey: 'homeView.welcomeSection', labelKey: 'welcomeMessage', languageCode: 'en', translatedText: 'Greetings, {user}! Have a productive day.' },
    { scopeKey: 'homeView.welcomeSection', labelKey: 'welcomeMessage', languageCode: 'zh', translatedText: '你好 {user}，祝你拥有高效的一天！' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Recent Mood Entries' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: '近期心情记录' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'noMoodsMessage', languageCode: 'en', translatedText: 'No moods logged. Why not add one?' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'noMoodsMessage', languageCode: 'zh', translatedText: '暂无心情记录。要不要添加一条？' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'refreshButtonText', languageCode: 'en', translatedText: 'Refresh Moods' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'refreshButtonText', languageCode: 'zh', translatedText: '刷新心情' },

    // 熊猫区域标签
    { scopeKey: 'homeView.pandaSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Panda Companion' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: '熊猫伙伴' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'levelLabel', languageCode: 'en', translatedText: 'Level' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'levelLabel', languageCode: 'zh', translatedText: '等级' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'experienceLabel', languageCode: 'en', translatedText: 'Experience' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'experienceLabel', languageCode: 'zh', translatedText: '经验' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'interactButtonText', languageCode: 'en', translatedText: 'Interact' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'interactButtonText', languageCode: 'zh', translatedText: '互动' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'feedButtonText', languageCode: 'en', translatedText: 'Feed' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'feedButtonText', languageCode: 'zh', translatedText: '喂食' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'playButtonText', languageCode: 'en', translatedText: 'Play' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'playButtonText', languageCode: 'zh', translatedText: '玩耍' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'trainButtonText', languageCode: 'en', translatedText: 'Train' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'trainButtonText', languageCode: 'zh', translatedText: '训练' },

    { scopeKey: 'homeView', labelKey: 'someActionText', languageCode: 'en', translatedText: 'Perform Action' },
    { scopeKey: 'homeView', labelKey: 'someActionText', languageCode: 'zh', translatedText: '执行操作' },

    // settingsView scope
    { scopeKey: 'settingsView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Configuration Panel' },
    { scopeKey: 'settingsView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '配置面板' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Display Language' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: '显示语言' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'selectLanguagePrompt', languageCode: 'en', translatedText: 'Select your preferred language:' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'selectLanguagePrompt', languageCode: 'zh', translatedText: '请选择您的偏好语言：' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'currentLanguageIs', languageCode: 'en', translatedText: 'Currently using: {lang}' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'currentLanguageIs', languageCode: 'zh', translatedText: '当前使用：{lang}' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameEn', languageCode: 'en', translatedText: 'English (US)' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameEn', languageCode: 'zh', translatedText: '美式英语' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameZh', languageCode: 'en', translatedText: 'Chinese (Simplified)' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameZh', languageCode: 'zh', translatedText: '简体中文' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'saveButtonText', languageCode: 'en', translatedText: 'Save Preferences' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'saveButtonText', languageCode: 'zh', translatedText: '保存偏好' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'successMessage', languageCode: 'en', translatedText: 'Preferences have been updated!' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'successMessage', languageCode: 'zh', translatedText: '偏好设置已更新！' },

    // tasksView scope
    { scopeKey: 'tasksView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Task Management' },
    { scopeKey: 'tasksView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '任务管理' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'My Tasks' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: '我的任务' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'createTaskButton', languageCode: 'en', translatedText: 'Create New Task' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'createTaskButton', languageCode: 'zh', translatedText: '创建新任务' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterAllLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterAllLabel', languageCode: 'zh', translatedText: '全部' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterTodoLabel', languageCode: 'en', translatedText: 'To Do' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterTodoLabel', languageCode: 'zh', translatedText: '待办' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterInProgressLabel', languageCode: 'en', translatedText: 'In Progress' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterInProgressLabel', languageCode: 'zh', translatedText: '进行中' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterCompletedLabel', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterCompletedLabel', languageCode: 'zh', translatedText: '已完成' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'noTasksMessage', languageCode: 'en', translatedText: 'No tasks found' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'noTasksMessage', languageCode: 'zh', translatedText: '暂无任务' },

    // challengesView scope
    { scopeKey: 'challengesView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Challenges' },
    { scopeKey: 'challengesView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '挑战' },
    { scopeKey: 'challengesView', labelKey: 'filterStatusLabel', languageCode: 'en', translatedText: 'Status' },
    { scopeKey: 'challengesView', labelKey: 'filterStatusLabel', languageCode: 'zh', translatedText: '状态' },
    { scopeKey: 'challengesView', labelKey: 'filterTypeLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'challengesView', labelKey: 'filterTypeLabel', languageCode: 'zh', translatedText: '类型' },
    { scopeKey: 'challengesView', labelKey: 'filterDifficultyLabel', languageCode: 'en', translatedText: 'Difficulty' },
    { scopeKey: 'challengesView', labelKey: 'filterDifficultyLabel', languageCode: 'zh', translatedText: '难度' },
    { scopeKey: 'challengesView', labelKey: 'filterAllLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'challengesView', labelKey: 'filterAllLabel', languageCode: 'zh', translatedText: '全部' },
    { scopeKey: 'challengesView', labelKey: 'filterActiveLabel', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'challengesView', labelKey: 'filterActiveLabel', languageCode: 'zh', translatedText: '进行中' },
    { scopeKey: 'challengesView', labelKey: 'filterCompletedLabel', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'challengesView', labelKey: 'filterCompletedLabel', languageCode: 'zh', translatedText: '已完成' },
    { scopeKey: 'challengesView', labelKey: 'filterUpcomingLabel', languageCode: 'en', translatedText: 'Upcoming' },
    { scopeKey: 'challengesView', labelKey: 'filterUpcomingLabel', languageCode: 'zh', translatedText: '即将开始' },
    { scopeKey: 'challengesView', labelKey: 'clearFiltersButton', languageCode: 'en', translatedText: 'Clear All Filters' },
    { scopeKey: 'challengesView', labelKey: 'clearFiltersButton', languageCode: 'zh', translatedText: '清除所有过滤器' },
    { scopeKey: 'challengesView', labelKey: 'noChallengesMessage', languageCode: 'en', translatedText: 'No challenges found' },
    { scopeKey: 'challengesView', labelKey: 'noChallengesMessage', languageCode: 'zh', translatedText: '暂无挑战' },
  ];
  await db.uiLabels.bulkAdd(labels);
  console.log("Final V3 DB populated.");
}
</file>

<file path="src/game-theme.css">
/* src/game-theme.css */
/* 华丽熊猫竹林主题 - PandaHabit 华丽游戏风格 */

/* 导入Google字体 */
@import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&family=Playfair+Display:wght@400;500;600;700&family=Fredoka+One&display=swap');
/* 导入中文字体 - 思源宋体 */
@import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700&display=swap');
/* 导入中文字体 - 思源黑体 */
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap');
/* 导入中文字体 - 站酷高端黑 */
@import url('https://fonts.font.im/css?family=ZCOOL+QingKe+HuangYou');
/* 导入中文字体 - 站酷快乐体 */
@import url('https://fonts.font.im/css?family=ZCOOL+KuaiLe');
/* 导入中文字体 - 站酷文艺体 */
@import url('https://fonts.font.im/css?family=ZCOOL+XiaoWei');
/* 导入中文字体 - 思源黑体 */
@import url('https://fonts.font.im/css?family=Ma+Shan+Zheng');

/* CSS变量主题颜色 */
:root {
  /* 华丽色彩方案 */
  --royal-jade: #1A5F4A; /* 皇家翡翠绿：代表成长、宁静与自然 */
  --bamboo-green: #88B04B; /* 富贵竹绿：象征熊猫的食物和活力 */
  --snow-white: #F7F9F9; /* 瑞雪白：提供视觉呼吸空间和清晰度 */
  --cinnabar-red: #D73E35; /* 朱砂红：传统中国红，象征喜庆、活力与好运 */
  --imperial-gold: #D4AF37; /* 华贵金：突出成就和高级元素 */
  --porcelain-blue: #1A6DB0; /* 青花蓝：代表水分和流动 */
  --peony-pink: #F8C8DC; /* 牡丹粉：增添温暖和情感连接 */
  --rosewood-purple: #5D3954; /* 紫檀紫：增添神秘感和高贵感 */
  --ruyi-green: #2E8B57; /* 如意绿：表示完成和积极成果 */
  --amber-yellow: #FFA500; /* 琥珀黄：引起注意但不刺眼 */
  --ink-gray: #8A8D91; /* 墨灰：用于次要文本和非活动元素 */

  /* 功能色彩 */
  --text-primary: var(--royal-jade);
  --text-secondary: var(--ink-gray);
  --text-light: var(--snow-white);
  --background-main: var(--snow-white);
  --background-panel: #FFFFFF;
  --border-color: var(--bamboo-green);
  --shadow-color: rgba(26, 95, 74, 0.2);
  --highlight-color: var(--imperial-gold);
  --accent-color: var(--cinnabar-red);

  /* 组件特定颜色 */
  --primary-green: var(--bamboo-green);
  --deep-green: var(--royal-jade);
  --light-green: rgba(136, 176, 75, 0.2);
  --deep-night: #333333;
  --accent-jade: #00BFA5;
  --accent-gold: var(--imperial-gold);

  /* 字体设置 */
  --font-main: 'Noto Sans SC', 'Quicksand', sans-serif;
  --font-accent: 'Noto Serif SC', 'Playfair Display', serif;
  --font-game: 'Fredoka One', cursive;
  --font-title: 'Ma Shan Zheng', cursive;
  --font-decorative: 'ZCOOL XiaoWei', serif;
  --font-fun: 'ZCOOL KuaiLe', cursive;
  --font-modern: 'ZCOOL QingKe HuangYou', sans-serif;

  /* 间距 */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;

  /* 圆角 */
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 16px;
  --radius-round: 50%;

  /* 动画时间 */
  --timing-quick: 0.2s;
  --timing-medium: 0.4s;
  --timing-slow: 0.8s;

  /* 特效 */
  --gold-gradient: linear-gradient(145deg, var(--imperial-gold), #FFA000);
  --jade-gradient: linear-gradient(145deg, var(--royal-jade), var(--bamboo-green));
  --red-gradient: linear-gradient(145deg, var(--cinnabar-red), #FF6B6B);
  --ink-animation: 0.8s ease-out;
}

/* 基础样式 - 移动应用 */
body {
  font-family: var(--font-main);
  background-color: var(--background-main);
  background-image: url('/assets/bamboo-bg-pattern.svg');
  background-size: 200px;
  background-attachment: fixed;
  color: var(--text-primary);
  line-height: 1.6;
  margin: 0;
  padding: 0;
  position: relative;
  max-width: 100vw;
  overflow-x: hidden;
  -webkit-tap-highlight-color: transparent; /* 移除移动端点击高亮 */
  touch-action: manipulation; /* 优化触摸操作 */
}

/* 添加水墨风格背景装饰 */
body::before {
  content: '';
  position: fixed;
  top: 0;
  right: 0;
  width: 300px;
  height: 300px;
  background-image: url('/assets/ink-splash.svg');
  background-size: contain;
  background-repeat: no-repeat;
  opacity: 0.1;
  z-index: -1;
  pointer-events: none;
}

body::after {
  content: '';
  position: fixed;
  bottom: 0;
  left: 0;
  width: 250px;
  height: 250px;
  background-image: url('/assets/bamboo-leaves.svg');
  background-size: contain;
  background-repeat: no-repeat;
  opacity: 0.1;
  z-index: -1;
  pointer-events: none;
}

#root {
  width: 100%;
  margin: 0 auto;
  padding: 0;
  position: relative;
  min-height: 100vh;
}

/* 中国风装饰元素 */
.chinese-pattern {
  position: fixed;
  width: 100%;
  height: 8px;
  background-image: url('/assets/chinese-pattern.svg');
  background-repeat: repeat-x;
  background-size: auto 100%;
  opacity: 0.8;
  z-index: 50;
}

.chinese-pattern.top {
  top: 0;
  left: 0;
}

.chinese-pattern.bottom {
  bottom: 70px; /* 为底部导航留出空间 */
  left: 0;
  transform: rotate(180deg);
}

/* 页面容器样式 */
.page-container {
  padding: 10px 0;
  margin-top: 10px;
  width: 100%;
  box-sizing: border-box;
}

/* 中国风装饰元素 - 云朵 */
.chinese-cloud {
  position: fixed;
  width: 200px;
  height: 100px;
  background-image: url('/assets/chinese-cloud.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.2;
  z-index: -1;
  pointer-events: none;
}

.chinese-cloud.top-right {
  top: 50px;
  right: 20px;
  transform: scale(0.8);
}

.chinese-cloud.top-left {
  top: 100px;
  left: 10px;
  transform: scale(0.6) rotate(10deg);
}

/* 中国风装饰元素 - 中国结 */
.chinese-knot {
  position: fixed;
  width: 100px;
  height: 150px;
  background-image: url('/assets/chinese-knot.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.7;
  z-index: 10;
  pointer-events: none;
}

.chinese-knot.top-right {
  top: 10px;
  right: 10px;
  transform: scale(0.5);
}

/* 中国风装饰元素 - 荷花 */
.lotus-flower {
  position: fixed;
  width: 150px;
  height: 150px;
  background-image: url('/assets/lotus-flower.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.5;
  z-index: -1;
  pointer-events: none;
}

.lotus-flower.bottom-left {
  bottom: 80px;
  left: 10px;
  transform: scale(0.6);
}

/* 中国风装饰元素 - 灯笼 */
.chinese-lantern {
  position: fixed;
  width: 100px;
  height: 150px;
  background-image: url('/assets/chinese-lantern.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.8;
  z-index: 10;
  pointer-events: none;
}

.chinese-lantern.top-left {
  top: 10px;
  left: 10px;
  transform: scale(0.5);
}

/* 中国风装饰元素 - 山水画 */
.mountain-landscape {
  position: fixed;
  width: 300px;
  height: 150px;
  background-image: url('/assets/mountain-landscape.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.2;
  z-index: -2;
  pointer-events: none;
}

.mountain-landscape.bottom {
  bottom: 70px;
  left: 50%;
  transform: translateX(-50%) scale(1.5);
}

/* 熊猫头像样式 */
.panda-avatar {
  position: relative;
  border-radius: 50%;
  overflow: hidden;
  box-shadow: 0 4px 8px var(--shadow-color);
  margin: 0 auto;
}

.panda-avatar::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  border-radius: 50%;
  box-shadow: inset 0 -3px 6px rgba(0,0,0,0.2);
  pointer-events: none;
}

.panda-avatar:hover {
  transform: translateY(-5px) scale(1.05) !important;
  box-shadow: 0 8px 16px var(--shadow-color);
}

.panda-avatar:active {
  transform: translateY(2px) scale(0.98) !important;
  box-shadow: 0 2px 4px var(--shadow-color);
}

/* 熊猫动画 */
@keyframes panda-bounce {
  0% { transform: translateY(0) scale(1); }
  50% { transform: translateY(-15px) scale(1.1); }
  100% { transform: translateY(0) scale(1); }
}

@keyframes panda-wiggle {
  0% { transform: rotate(0deg); }
  25% { transform: rotate(-5deg); }
  50% { transform: rotate(0deg); }
  75% { transform: rotate(5deg); }
  100% { transform: rotate(0deg); }
}

.panda-avatar.happy {
  animation: panda-wiggle 1s infinite;
}

.panda-avatar.tired {
  animation: panda-bounce 3s ease-in-out infinite;
}

/* 任务卡片样式 */
.task-card {
  background-color: var(--background-panel);
  border: 2px solid var(--primary-green);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  position: relative;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px var(--shadow-color);
}

.task-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 4px 8px var(--shadow-color);
}

.task-card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.task-title {
  margin: 0;
  font-size: 1.1rem;
  color: var(--text-primary);
}

.task-type-badge {
  font-size: 0.7rem;
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  font-weight: bold;
  color: white;
}

.task-type-main {
  background-color: var(--imperial-gold);
}

.task-type-daily {
  background-color: var(--bamboo-green);
}

.task-type-side {
  background-color: var(--ink-gray);
}

.task-description {
  margin-bottom: var(--spacing-sm);
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.task-meta {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  color: var(--text-secondary);
  margin-bottom: var(--spacing-sm);
}

.task-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-sm);
}

.task-action-complete,
.task-action-edit,
.task-action-delete {
  padding: 4px 8px;
  font-size: 0.8rem;
  border-radius: var(--radius-sm);
  cursor: pointer;
  border: none;
  transition: all 0.2s ease;
}

.task-action-complete {
  background-color: var(--bamboo-green);
  color: white;
}

.task-action-edit {
  background-color: var(--imperial-gold);
  color: white;
}

.task-action-delete {
  background-color: var(--cinnabar-red);
  color: white;
}

.task-priority-high {
  border-left: 4px solid var(--cinnabar-red);
}

.task-priority-medium {
  border-left: 4px solid var(--imperial-gold);
}

.task-priority-low {
  border-left: 4px solid var(--bamboo-green);
}

.task-status-completed {
  opacity: 0.7;
  background-color: rgba(136, 176, 75, 0.1);
}

.task-status-completed .task-title {
  text-decoration: line-through;
}

.task-status-in-progress {
  background-color: rgba(212, 175, 55, 0.1);
}

/* 任务列表样式 */
.task-list {
  position: relative;
  min-height: 100px;
}

.task-list-loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(255, 255, 255, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10;
}

.task-list-empty,
.task-list-error {
  text-align: center;
  padding: var(--spacing-lg);
  color: var(--text-secondary);
}

/* 任务表单样式 */
.task-form {
  margin-bottom: var(--spacing-lg);
}

.form-group {
  margin-bottom: var(--spacing-md);
}

.form-group label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-weight: 500;
  color: var(--text-primary);
}

.form-group input,
.form-group select,
.form-group textarea {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  background-color: white;
  font-size: 1rem;
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
  outline: none;
  border-color: var(--primary-green);
  box-shadow: 0 0 0 2px rgba(136, 176, 75, 0.2);
}

.form-group input.error,
.form-group select.error {
  border-color: var(--cinnabar-red);
}

.error-message {
  color: var(--cinnabar-red);
  font-size: 0.8rem;
  margin-top: 4px;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-md);
  margin-top: var(--spacing-lg);
}

/* 任务过滤器样式 */
.task-filter-tabs {
  display: flex;
  margin-bottom: var(--spacing-md);
  border-bottom: 1px solid var(--border-color);
  overflow-x: auto;
}

.task-filter-tabs button {
  padding: 8px 16px;
  background: none;
  border: none;
  cursor: pointer;
  font-size: 0.9rem;
  color: var(--text-secondary);
  position: relative;
  white-space: nowrap;
}

.task-filter-tabs button.active {
  color: var(--text-primary);
  font-weight: 500;
}

.task-filter-tabs button.active::after {
  content: '';
  position: absolute;
  bottom: -1px;
  left: 0;
  right: 0;
  height: 2px;
  background-color: var(--primary-green);
}

/* 任务管理器样式 */
.task-manager-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-md);
}

/* 小按钮样式 */
.jade-button-small {
  background: linear-gradient(to bottom, var(--bamboo-green), var(--deep-green));
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: 4px 8px;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.jade-button-small:hover {
  background: linear-gradient(to bottom, var(--bamboo-green), var(--deep-green));
  filter: brightness(1.1);
  transform: translateY(-1px);
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
}

/* 字体排版 */
h1, h2, h3 {
  font-family: var(--font-accent);
  color: var(--royal-jade);
  margin-top: 0;
  position: relative;
}

h1 {
  font-family: var(--font-title);
  font-size: 2.2rem;
  text-shadow: 1px 1px 2px var(--shadow-color);
  background: linear-gradient(to right, var(--royal-jade), var(--bamboo-green));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  letter-spacing: 0.5px;
  padding-bottom: var(--spacing-md);
  position: relative;
}

h2 {
  font-family: var(--font-decorative);
  font-size: 1.8rem;
  letter-spacing: 1px;
}

h3 {
  font-family: var(--font-modern);
  font-size: 1.4rem;
}

/* 添加中国风装饰线 */
h1::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100px;
  height: 3px;
  background: var(--gold-gradient);
  border-radius: var(--radius-sm);
}

/* 模态框样式 */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: var(--spacing-md);
}

.modal-content {
  position: relative;
  max-width: 90%;
  max-height: 90vh;
  overflow-y: auto;
  z-index: 1001;
}

.modal-container {
  position: relative;
  background-color: var(--background-panel);
  border-radius: var(--radius-md);
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
  overflow: hidden;
}

/* 卷轴风格模态框 */
.scroll-modal {
  background-color: #f8f0d8; /* 古纸色 */
  border: none;
  box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
  position: relative;
  padding: var(--spacing-lg) var(--spacing-xl);
  color: var(--deep-night);
}

.scroll-modal::before,
.scroll-modal::after {
  content: '';
  position: absolute;
  left: 0;
  right: 0;
  height: 30px;
  background-image: url('/assets/scroll-edge.svg');
  background-repeat: repeat-x;
  background-size: auto 100%;
}

.scroll-modal::before {
  top: 0;
  transform: rotateX(180deg);
}

.scroll-modal::after {
  bottom: 0;
}

.scroll-modal-content {
  max-height: 70vh;
  overflow-y: auto;
  padding: var(--spacing-md) 0;
  background-image: url('/assets/paper-texture.svg');
  background-repeat: repeat;
  background-size: 200px;
  position: relative;
}

.scroll-modal-header {
  text-align: center;
  margin-bottom: var(--spacing-lg);
  position: relative;
}

.scroll-modal-title {
  font-family: var(--font-accent);
  font-size: 1.8rem;
  color: var(--cinnabar-red);
  margin: 0;
  padding-bottom: var(--spacing-md);
  position: relative;
  display: inline-block;
}

.scroll-modal-title::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 10%;
  right: 10%;
  height: 2px;
  background: var(--gold-gradient);
}

.scroll-modal-close {
  position: absolute;
  top: var(--spacing-md);
  right: var(--spacing-md);
  background: none;
  border: none;
  font-size: 1.5rem;
  color: var(--cinnabar-red);
  cursor: pointer;
  width: 30px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-round);
  transition: all 0.2s ease;
}

.scroll-modal-close:hover {
  background-color: rgba(215, 62, 53, 0.1);
  transform: rotate(90deg);
}

.scroll-modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-md);
  margin-top: var(--spacing-lg);
  padding-top: var(--spacing-md);
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

/* 窗棂风格模态框 */
.lattice-modal {
  background-color: var(--background-panel);
  border: 4px solid var(--imperial-gold);
  border-radius: var(--radius-md);
  position: relative;
  overflow: hidden;
}

.lattice-modal-header {
  background: var(--gold-gradient);
  color: var(--deep-night);
  padding: var(--spacing-md) var(--spacing-lg);
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
}

.lattice-modal-title {
  font-family: var(--font-accent);
  font-size: 1.5rem;
  margin: 0;
  text-align: center;
  position: relative;
}

.lattice-modal-close {
  position: absolute;
  top: 50%;
  right: var(--spacing-md);
  transform: translateY(-50%);
  background: none;
  border: none;
  color: var(--deep-night);
  cursor: pointer;
  width: 30px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-round);
  transition: all 0.2s ease;
}

.lattice-modal-close:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

.lattice-modal-content {
  padding: var(--spacing-lg);
  position: relative;
  max-height: 70vh;
  overflow-y: auto;
}

.lattice-modal-content::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: url('/assets/lattice-pattern.svg');
  background-repeat: repeat;
  background-size: 100px;
  opacity: 0.05;
  pointer-events: none;
  z-index: -1;
}

.lattice-modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-md);
  padding: var(--spacing-md) var(--spacing-lg);
  background-color: rgba(212, 175, 55, 0.1);
  border-top: 1px solid var(--imperial-gold);
}

/* 奖励模态框样式 */
.reward-modal-content {
  padding: var(--spacing-md);
  text-align: center;
}

.reward-showcase {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--spacing-md);
}

.reward-title {
  font-family: var(--font-accent);
  font-size: 1.5rem;
  color: var(--cinnabar-red);
  margin-bottom: var(--spacing-lg);
  position: relative;
}

.reward-title::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 25%;
  right: 25%;
  height: 2px;
  background: var(--gold-gradient);
}

.reward-animation-container {
  margin: var(--spacing-lg) 0;
  height: 150px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.reward-details {
  margin: var(--spacing-md) 0;
  padding: var(--spacing-md);
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: var(--radius-md);
  max-width: 300px;
}

.reward-details h4 {
  font-family: var(--font-accent);
  font-size: 1.2rem;
  color: var(--deep-night);
  margin: 0 0 var(--spacing-sm) 0;
}

.reward-rarity {
  font-size: 0.9rem;
  color: var(--text-secondary);
  margin: 0 0 var(--spacing-sm) 0;
}

.reward-description {
  font-size: 1rem;
  margin: 0 0 var(--spacing-sm) 0;
}

.reward-amount {
  font-weight: bold;
  margin: var(--spacing-sm) 0 0 0;
}

.reward-navigation {
  margin-top: var(--spacing-lg);
  height: 50px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.rewards-summary {
  display: flex;
  flex-direction: column;
  width: 100%;
}

.rewards-summary-title {
  font-family: var(--font-accent);
  font-size: 1.5rem;
  color: var(--cinnabar-red);
  margin-bottom: var(--spacing-lg);
  position: relative;
  text-align: center;
}

.rewards-summary-title::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 25%;
  right: 25%;
  height: 2px;
  background: var(--gold-gradient);
}

.rewards-list {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
  margin: var(--spacing-md) 0;
  max-height: 300px;
  overflow-y: auto;
  padding: var(--spacing-sm);
}

.reward-item {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm);
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: var(--radius-md);
  transition: all 0.2s ease;
}

.reward-item:hover {
  background-color: rgba(255, 255, 255, 0.3);
  transform: translateY(-2px);
}

.reward-item-icon {
  margin-right: var(--spacing-md);
  display: flex;
  justify-content: center;
  align-items: center;
}

.reward-item-details {
  flex: 1;
  text-align: left;
}

.reward-item-details h4 {
  font-family: var(--font-accent);
  font-size: 1.1rem;
  color: var(--deep-night);
  margin: 0 0 var(--spacing-xs) 0;
}

.reward-item-description {
  font-size: 0.9rem;
  color: var(--text-secondary);
  margin: 0;
}

.reward-item-amount {
  font-weight: bold;
  font-size: 1.1rem;
  color: var(--imperial-gold);
  margin-left: var(--spacing-md);
}

.rewards-summary-footer {
  margin-top: var(--spacing-lg);
  display: flex;
  justify-content: center;
}

/* 熊猫能力样式 */
.abilities-header {
  margin-bottom: var(--spacing-lg);
  padding-bottom: var(--spacing-md);
  border-bottom: 1px solid var(--border-color);
}

.panda-level-info {
  margin-bottom: var(--spacing-md);
}

.panda-level-info h3 {
  font-family: var(--font-accent);
  color: var(--imperial-gold);
  margin-bottom: var(--spacing-xs);
}

.abilities-description {
  color: var(--text-secondary);
  font-size: 0.95rem;
  line-height: 1.5;
}

.ability-filters {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-sm);
  margin-bottom: var(--spacing-md);
}

.filter-button {
  background-color: var(--background-panel);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  padding: var(--spacing-xs) var(--spacing-sm);
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.filter-button:hover {
  background-color: var(--background-hover);
}

.filter-button.active {
  background-color: var(--jade-green);
  color: white;
  border-color: var(--jade-green);
}

.abilities-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: var(--spacing-md);
  margin-top: var(--spacing-md);
}

.ability-card {
  background-color: var(--background-panel);
  border-radius: var(--radius-md);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
}

.ability-card:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  transform: translateY(-2px);
}

.ability-card.locked {
  opacity: 0.7;
  filter: grayscale(0.5);
}

.ability-card.passive-ability {
  border-left: 4px solid var(--jade-green);
}

.ability-card.active-ability {
  border-left: 4px solid var(--imperial-blue);
}

.ability-card.ultimate-ability {
  border-left: 4px solid var(--imperial-gold);
}

.ability-card-header {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm);
  background-color: rgba(0, 0, 0, 0.03);
  border-bottom: 1px solid var(--border-color);
}

.ability-icon {
  width: 50px;
  height: 50px;
  margin-right: var(--spacing-sm);
  display: flex;
  justify-content: center;
  align-items: center;
}

.ability-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.ability-info {
  flex: 1;
}

.ability-name {
  font-family: var(--font-accent);
  font-size: 1.1rem;
  margin: 0 0 var(--spacing-xs) 0;
}

.ability-meta {
  display: flex;
  gap: var(--spacing-sm);
  font-size: 0.8rem;
  color: var(--text-secondary);
}

.ability-type, .ability-rarity {
  background-color: rgba(0, 0, 0, 0.05);
  padding: 2px 6px;
  border-radius: var(--radius-sm);
}

.ability-card-body {
  padding: var(--spacing-sm);
}

.ability-description {
  font-size: 0.9rem;
  line-height: 1.5;
  margin-bottom: var(--spacing-sm);
}

.ability-unlock-info {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-size: 0.85rem;
  color: var(--text-secondary);
  margin-top: var(--spacing-sm);
}

.ability-lock-icon {
  font-size: 1rem;
}

.ability-cooldown {
  font-size: 0.85rem;
  color: var(--text-secondary);
  margin-top: var(--spacing-sm);
}

.cooldown-remaining {
  color: var(--cinnabar-red);
}

.ability-card-footer {
  padding: var(--spacing-sm);
  border-top: 1px solid var(--border-color);
  display: flex;
  justify-content: flex-end;
}

.activate-button {
  background-color: var(--imperial-blue);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: var(--spacing-xs) var(--spacing-md);
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.activate-button:hover {
  background-color: var(--imperial-blue-dark);
}

.activate-button.unavailable {
  background-color: var(--text-disabled);
  cursor: not-allowed;
}

.no-abilities {
  text-align: center;
  padding: var(--spacing-lg);
  color: var(--text-secondary);
}

/* 能力详情样式 */
.ability-detail {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--spacing-md);
}

.ability-detail-icon {
  width: 80px;
  height: 80px;
  margin-bottom: var(--spacing-md);
}

.ability-detail-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.ability-detail-info {
  width: 100%;
  text-align: center;
}

.ability-detail-description {
  font-size: 1rem;
  line-height: 1.6;
  margin-bottom: var(--spacing-md);
}

.ability-detail-meta {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--spacing-sm);
  margin-bottom: var(--spacing-md);
}

.meta-item {
  background-color: rgba(0, 0, 0, 0.03);
  padding: var(--spacing-sm);
  border-radius: var(--radius-sm);
  display: flex;
  flex-direction: column;
  align-items: center;
}

.meta-label {
  font-size: 0.8rem;
  color: var(--text-secondary);
  margin-bottom: var(--spacing-xs);
}

.meta-value {
  font-weight: bold;
  font-size: 0.95rem;
}

.ability-detail-actions {
  margin-top: var(--spacing-md);
}

.activate-detail-button {
  background-color: var(--imperial-blue);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: var(--spacing-sm) var(--spacing-lg);
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.activate-detail-button:hover {
  background-color: var(--imperial-blue-dark);
}

.activate-detail-button:disabled {
  background-color: var(--text-disabled);
  cursor: not-allowed;
}

/* 能力解锁通知样式 */
.ability-unlock-content {
  padding: var(--spacing-md);
}

.ability-unlock-view {
  width: 100%;
  min-height: 300px;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.ability-unlock-single {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.ability-unlock-icon {
  width: 100px;
  height: 100px;
  margin-bottom: var(--spacing-md);
}

.ability-unlock-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.ability-unlock-title {
  font-family: var(--font-accent);
  font-size: 1.5rem;
  color: var(--imperial-gold);
  margin-bottom: var(--spacing-sm);
}

.ability-unlock-name {
  font-size: 1.2rem;
  margin-bottom: var(--spacing-md);
}

.ability-unlock-description {
  font-size: 1rem;
  line-height: 1.6;
  margin-bottom: var(--spacing-lg);
  max-width: 500px;
}

.ability-unlock-actions {
  margin-top: var(--spacing-md);
}

.ability-unlock-list {
  width: 100%;
  max-height: 300px;
  overflow-y: auto;
  margin: var(--spacing-md) 0;
}

.ability-unlock-item {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm);
  background-color: rgba(0, 0, 0, 0.03);
  border-radius: var(--radius-md);
  margin-bottom: var(--spacing-sm);
  transition: all 0.2s ease;
}

.ability-unlock-item:hover {
  background-color: rgba(0, 0, 0, 0.05);
}

.ability-unlock-item-icon {
  width: 40px;
  height: 40px;
  margin-right: var(--spacing-sm);
}

.ability-unlock-item-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.ability-unlock-item-info {
  flex: 1;
  text-align: left;
}

.ability-unlock-item-name {
  font-size: 1rem;
  margin: 0 0 var(--spacing-xs) 0;
}

.ability-unlock-item-description {
  font-size: 0.9rem;
  color: var(--text-secondary);
  margin: 0;
}

h2 {
  font-size: 1.8rem;
  margin-bottom: 0.8em;
  border-bottom: 2px solid var(--imperial-gold);
  padding-bottom: var(--spacing-sm);
  display: inline-block;
  position: relative;
}

/* 添加中国风装饰元素 */
h2::before {
  content: '❖';
  color: var(--cinnabar-red);
  position: absolute;
  left: -1.5rem;
  top: 0.2rem;
  font-size: 1rem;
}

h3 {
  font-size: 1.5rem;
  margin-bottom: 0.6em;
  color: var(--royal-jade);
  position: relative;
  padding-left: var(--spacing-md);
}

h3::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0.5rem;
  height: 1rem;
  width: 4px;
  background: var(--bamboo-green);
  border-radius: var(--radius-sm);
}

h4 {
  font-size: 1.2rem;
  margin-bottom: 0.5em;
  color: var(--ruyi-green);
  font-family: var(--font-main);
  font-weight: 600;
}

/* Bamboo Frame Container */
.bamboo-frame {
  background-color: var(--background-panel);
  border: 4px solid var(--primary-green);
  border-radius: var(--radius-md);
  box-shadow: 0 4px 12px var(--shadow-color);
  padding: var(--spacing-lg);
  position: relative;
  overflow: hidden;
  margin-bottom: var(--spacing-lg);
}

.bamboo-frame::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 12px;
  background: repeating-linear-gradient(
    to right,
    var(--primary-green),
    var(--primary-green) 20px,
    var(--deep-green) 20px,
    var(--deep-green) 30px
  );
  border-top-left-radius: var(--radius-md);
  border-top-right-radius: var(--radius-md);
}

.bamboo-frame::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 12px;
  background: repeating-linear-gradient(
    to right,
    var(--primary-green),
    var(--primary-green) 20px,
    var(--deep-green) 20px,
    var(--deep-green) 30px
  );
  border-bottom-left-radius: var(--radius-md);
  border-bottom-right-radius: var(--radius-md);
}

/* Jade Button */
.jade-button {
  background: linear-gradient(145deg, var(--accent-jade), var(--primary-green));
  color: white;
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-md) var(--spacing-lg);
  font-family: var(--font-main);
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(0, 191, 165, 0.3);
  transition: all var(--timing-quick) ease;
  position: relative;
  overflow: hidden;
}

.jade-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    rgba(255, 255, 255, 0) 0%,
    rgba(255, 255, 255, 0.2) 50%,
    rgba(255, 255, 255, 0) 100%
  );
  transition: left 0.8s ease;
}

.jade-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(0, 191, 165, 0.4);
}

.jade-button:hover::before {
  left: 100%;
}

.jade-button:active {
  transform: translateY(1px);
  box-shadow: 0 2px 4px rgba(0, 191, 165, 0.3);
}

.jade-button:disabled {
  background: #B0BEC5;
  cursor: not-allowed;
  box-shadow: none;
  transform: none;
}

/* Gold Button - for premium/special actions */
.gold-button {
  background: linear-gradient(145deg, var(--accent-gold), #FFA000);
  color: var(--deep-night);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-md) var(--spacing-lg);
  font-family: var(--font-main);
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(255, 215, 0, 0.3);
  transition: all var(--timing-quick) ease;
}

.gold-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(255, 215, 0, 0.4);
}

.gold-button:active {
  transform: translateY(1px);
  box-shadow: 0 2px 4px rgba(255, 215, 0, 0.3);
}

/* Navigation Bar - Mobile Style */
.bamboo-nav {
  display: flex;
  justify-content: space-around;
  background: linear-gradient(to right, var(--deep-green), var(--primary-green));
  padding: var(--spacing-md) var(--spacing-sm);
  box-shadow: 0 -2px 10px var(--shadow-color);
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 100;
}

.bamboo-nav a {
  color: white;
  text-decoration: none;
  padding: var(--spacing-md) var(--spacing-lg);
  border-radius: var(--radius-md);
  transition: all var(--timing-quick) ease;
  font-weight: 500;
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: 0.9rem;
}

.bamboo-nav a::before {
  content: '•';
  font-size: 1.5rem;
  margin-bottom: 4px;
}

.bamboo-nav a:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.bamboo-nav a.active {
  background-color: rgba(255, 255, 255, 0.2);
  box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
  font-weight: 700;
}

/* Add padding to main content to account for fixed navigation */
main {
  padding-bottom: 80px;
}

/* Loading Spinner - Jade Coin */
.jade-spinner {
  width: 50px;
  height: 50px;
  border-radius: var(--radius-round);
  border: 5px solid var(--accent-jade);
  border-top-color: var(--accent-gold);
  animation: spin 1s infinite linear;
  margin: var(--spacing-lg) auto;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Bamboo Progress Bar */
.bamboo-progress {
  height: 24px;
  background-color: var(--light-green);
  border-radius: var(--radius-lg);
  overflow: hidden;
  position: relative;
  margin: var(--spacing-md) 0;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
}

.bamboo-progress-fill {
  height: 100%;
  background: repeating-linear-gradient(
    45deg,
    var(--primary-green),
    var(--primary-green) 10px,
    var(--deep-green) 10px,
    var(--deep-green) 20px
  );
  border-radius: var(--radius-lg);
  transition: width var(--timing-medium) ease-out;
  position: relative;
}

.bamboo-progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  width: 10px;
  height: 100%;
  background-color: var(--accent-gold);
  border-top-right-radius: var(--radius-lg);
  border-bottom-right-radius: var(--radius-lg);
}

/* Task Item */
.task-item {
  background-color: white;
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  box-shadow: 0 2px 4px var(--shadow-color);
  display: flex;
  align-items: center;
  transition: transform var(--timing-quick) ease;
  border-left: 4px solid var(--primary-green);
}

.task-item:hover {
  transform: translateX(4px);
}

.task-item.completed {
  border-left-color: var(--accent-gold);
  background-color: rgba(255, 215, 0, 0.05);
}

.task-checkbox {
  width: 24px;
  height: 24px;
  border: 2px solid var(--primary-green);
  border-radius: var(--radius-sm);
  margin-right: var(--spacing-md);
  position: relative;
  cursor: pointer;
}

.task-checkbox.checked::after {
  content: '✓';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: var(--accent-gold);
  font-weight: bold;
}

/* Footer */
footer {
  text-align: center;
  margin-top: var(--spacing-xl);
  padding: var(--spacing-lg);
  color: var(--text-secondary);
  font-size: 0.9rem;
  background: linear-gradient(to right, var(--deep-green), var(--primary-green));
  color: white;
  border-radius: var(--radius-lg) var(--radius-lg) 0 0;
}

/* 数据加载器样式 */
.data-loader-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 200px;
  width: 100%;
}

.empty-state {
  text-align: center;
  padding: var(--spacing-lg);
  color: var(--text-secondary);
  font-style: italic;
}

/* 同步状态指示器样式 */
.sync-status-indicator {
  display: flex;
  align-items: center;
  padding: var(--spacing-xs) var(--spacing-sm);
  background-color: var(--background-panel);
  border-radius: var(--radius-full);
  box-shadow: var(--shadow-md);
  cursor: pointer;
  transition: all 0.2s ease;
  user-select: none;
  position: fixed;
  bottom: 80px;
  right: 20px;
  z-index: 100;
  border: 1px solid var(--border-color);
}

.sync-status-indicator:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.sync-status-indicator.minimal {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  justify-content: center;
  padding: 0;
}

.sync-status-indicator.detailed {
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--radius-md);
}

.sync-status-indicator.syncing {
  background-color: rgba(74, 144, 226, 0.1);
  border-color: var(--imperial-blue);
  animation: pulse 1.5s infinite;
}

.sync-status-indicator.success {
  background-color: rgba(136, 176, 75, 0.1);
  border-color: var(--jade-green);
}

.sync-status-indicator.error {
  background-color: rgba(215, 62, 53, 0.1);
  border-color: var(--cinnabar-red);
}

@keyframes pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(74, 144, 226, 0.4);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(74, 144, 226, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(74, 144, 226, 0);
  }
}

.sync-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  font-size: 1.2rem;
  margin-right: var(--spacing-xs);
}

.sync-status-indicator.minimal .sync-icon {
  margin-right: 0;
}

.sync-icon.syncing {
  color: var(--imperial-blue);
}

.sync-icon.success {
  color: var(--jade-green);
}

.sync-icon.error {
  color: var(--cinnabar-red);
}

.sync-icon.idle {
  color: var(--text-secondary);
}

.sync-label {
  font-size: 0.9rem;
  color: var(--text-primary);
  margin-right: var(--spacing-xs);
}

.sync-count {
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 20px;
  height: 20px;
  border-radius: var(--radius-full);
  background-color: var(--imperial-blue);
  color: white;
  font-size: 0.8rem;
  padding: 0 var(--spacing-xs);
}

/* 及时奖励卡片 */
.timely-reward-card {
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border: 1px solid var(--border-color);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  box-shadow: var(--shadow-md);
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
}

.timely-reward-card:hover {
  transform: translateY(-3px);
  box-shadow: var(--shadow-lg);
}

.reward-card-header {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.reward-icon {
  width: 48px;
  height: 48px;
  border-radius: var(--radius-round);
  overflow: hidden;
  margin-right: var(--spacing-md);
  background-color: var(--background-panel-dark);
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid var(--border-color);
}

.reward-icon img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.reward-title-section {
  flex: 1;
}

.reward-title {
  margin: 0 0 var(--spacing-xs) 0;
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--text-primary);
}

.reward-meta {
  display: flex;
  gap: var(--spacing-sm);
}

.reward-type,
.reward-status {
  font-size: 0.8rem;
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  background-color: var(--background-panel-dark);
}

.reward-card-body {
  margin-bottom: var(--spacing-md);
}

.reward-description {
  margin: 0 0 var(--spacing-md) 0;
  font-size: 0.9rem;
  color: var(--text-secondary);
  line-height: 1.4;
}

.reward-progress-section {
  margin-top: var(--spacing-md);
}

.reward-time-info {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  color: var(--text-tertiary);
  margin-top: var(--spacing-xs);
}

.reward-card-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.reward-points {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-size: 0.9rem;
  color: var(--imperial-gold);
  font-weight: 600;
}

.lucky-points-icon {
  font-size: 1.2rem;
}

.complete-reward-button {
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-xs) var(--spacing-md);
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.complete-reward-button:disabled {
  background: linear-gradient(145deg, var(--background-panel-dark), var(--background-panel));
  color: var(--text-tertiary);
  cursor: not-allowed;
}

.reward-completed-info {
  font-size: 0.8rem;
  color: var(--jade-green);
  font-weight: 600;
}

/* 奖励状态样式 */
.reward-active {
  border-left: 4px solid var(--imperial-blue);
}

.reward-completed {
  border-left: 4px solid var(--jade-green);
}

.reward-expired {
  border-left: 4px solid var(--cinnabar-red);
  opacity: 0.7;
}

.reward-upcoming {
  border-left: 4px solid var(--imperial-gold);
}

/* 及时奖励列表 */
.timely-reward-list {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

/* 幸运点显示 */
.lucky-points-display {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-sm) var(--spacing-md);
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border-radius: var(--radius-full);
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
  cursor: pointer;
  transition: all 0.2s ease;
}

.lucky-points-display:hover {
  box-shadow: var(--shadow-md);
}

.lucky-points-display.animating {
  animation: pulse 1s;
}

.lucky-points-icon {
  font-size: 1.2rem;
  color: var(--imperial-gold);
}

.lucky-points-value {
  font-weight: 600;
  color: var(--imperial-gold);
}

.lucky-points-label {
  font-size: 0.8rem;
  color: var(--text-secondary);
}

.lucky-points-compact {
  padding: var(--spacing-xs);
}

.lucky-points-large {
  padding: var(--spacing-md);
  font-size: 1.2rem;
}

.lucky-points-container {
  display: flex;
  justify-content: flex-end;
  margin-bottom: var(--spacing-md);
}

/* 幸运抽奖 */
.lucky-draw-container {
  padding: var(--spacing-md);
}

.lucky-draw-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-lg);
}

.lucky-draw-title {
  margin: 0;
  font-size: 1.5rem;
  color: var(--text-primary);
}

.lucky-draw-options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-lg);
}

.draw-option {
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border: 1px solid var(--border-color);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  box-shadow: var(--shadow-sm);
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.draw-option.selected {
  border: 2px solid var(--imperial-gold);
  box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
}

.draw-option.disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

.draw-option-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.draw-option-points {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-weight: 600;
  color: var(--imperial-gold);
}

.draw-option-label {
  margin: 0;
  font-size: 1.1rem;
  color: var(--text-primary);
}

.draw-option-description {
  margin: 0;
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.draw-option-insufficient {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: var(--spacing-xs);
  background-color: rgba(215, 62, 53, 0.8);
  color: white;
  font-size: 0.8rem;
  text-align: center;
}

.lucky-draw-actions {
  display: flex;
  justify-content: center;
  gap: var(--spacing-md);
  margin-top: var(--spacing-lg);
}

.draw-button {
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-sm) var(--spacing-lg);
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.draw-button:disabled {
  background: linear-gradient(145deg, var(--background-panel-dark), var(--background-panel));
  color: var(--text-tertiary);
  cursor: not-allowed;
}

.lucky-draw-results {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--spacing-lg);
}

/* 及时奖励页面 */
.timely-rewards-page {
  padding: var(--spacing-md);
}

.lucky-draw-button {
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-sm) var(--spacing-md);
  font-size: 0.9rem;
  font-weight: 600;
}

.lucky-draw-dialog {
  max-width: 800px;
}

/* 及时奖励模态框 */
.timely-reward-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.timely-reward-modal-backdrop {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(5px);
}

.timely-reward-modal-content {
  position: relative;
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border: 2px solid var(--imperial-gold);
  border-radius: var(--radius-md);
  padding: var(--spacing-lg);
  max-width: 90%;
  width: 500px;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: var(--shadow-lg), 0 0 20px rgba(212, 175, 55, 0.3);
  animation: scale-in 0.3s ease-out;
}

.timely-reward-modal-title {
  margin: 0 0 var(--spacing-md) 0;
  font-size: 1.5rem;
  color: var(--imperial-gold);
  text-align: center;
  text-shadow: 0 0 5px rgba(212, 175, 55, 0.5);
}

.timely-reward-modal-description {
  margin: 0 0 var(--spacing-md) 0;
  font-size: 1rem;
  color: var(--text-secondary);
  text-align: center;
}

.timely-reward-modal-actions {
  display: flex;
  justify-content: center;
  margin-top: var(--spacing-md);
}

@keyframes scale-in {
  0% {
    transform: scale(0.8);
    opacity: 0;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

/* 挑战卡片 */
.challenge-card {
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border: 1px solid var(--border-color);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  box-shadow: var(--shadow-md);
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
}

.challenge-card:hover {
  transform: translateY(-3px);
  box-shadow: var(--shadow-lg);
}

.challenge-card-header {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.challenge-icon {
  width: 48px;
  height: 48px;
  border-radius: var(--radius-round);
  overflow: hidden;
  margin-right: var(--spacing-md);
  background-color: var(--background-panel-dark);
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid var(--border-color);
}

.challenge-icon img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.challenge-title-section {
  flex: 1;
}

.challenge-title {
  margin: 0 0 var(--spacing-xs) 0;
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--text-primary);
}

.challenge-meta {
  display: flex;
  gap: var(--spacing-sm);
}

.challenge-difficulty,
.challenge-status {
  font-size: 0.8rem;
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  background-color: var(--background-panel-dark);
}

.challenge-card-body {
  margin-bottom: var(--spacing-md);
}

.challenge-description {
  margin: 0 0 var(--spacing-md) 0;
  font-size: 0.9rem;
  color: var(--text-secondary);
  line-height: 1.4;
}

.challenge-progress-section {
  margin-top: var(--spacing-md);
}

.challenge-dates {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  color: var(--text-tertiary);
  margin-top: var(--spacing-xs);
}

.challenge-card-footer {
  display: flex;
  justify-content: flex-end;
}

.complete-challenge-button {
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-xs) var(--spacing-md);
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.complete-challenge-button:disabled {
  background: linear-gradient(145deg, var(--background-panel-dark), var(--background-panel));
  color: var(--text-tertiary);
  cursor: not-allowed;
}

.challenge-completed-info {
  font-size: 0.8rem;
  color: var(--jade-green);
  font-weight: 600;
}

/* 挑战状态样式 */
.challenge-active {
  border-left: 4px solid var(--imperial-blue);
}

.challenge-completed {
  border-left: 4px solid var(--jade-green);
}

.challenge-expired {
  border-left: 4px solid var(--cinnabar-red);
  opacity: 0.7;
}

.challenge-upcoming {
  border-left: 4px solid var(--imperial-gold);
}

/* 挑战难度样式 */
.difficulty-easy {
  color: var(--jade-green);
}

.difficulty-medium {
  color: var(--imperial-blue);
}

.difficulty-hard {
  color: var(--imperial-gold);
}

.difficulty-expert {
  color: var(--cinnabar-red);
}

/* 挑战列表 */
.challenge-list {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

/* 挑战页面 */
.challenges-page {
  padding: var(--spacing-md);
}

.filter-section {
  margin-bottom: var(--spacing-lg);
  background-color: var(--background-panel-light);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  box-shadow: var(--shadow-sm);
}

.filter-group {
  margin-bottom: var(--spacing-md);
}

.filter-title {
  margin: 0 0 var(--spacing-xs) 0;
  font-size: 1rem;
  font-weight: 600;
  color: var(--text-primary);
}

.filter-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-xs);
}

.filter-actions {
  display: flex;
  justify-content: flex-end;
  margin-top: var(--spacing-md);
}

.clear-filters-button {
  font-size: 0.9rem;
}

/* 挑战详情 */
.challenge-details {
  padding: var(--spacing-md);
}

.challenge-header {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-md);
}

.challenge-icon-large {
  width: 64px;
  height: 64px;
  border-radius: var(--radius-md);
  margin-right: var(--spacing-md);
  border: 2px solid var(--border-color);
}

.challenge-meta-details {
  flex: 1;
}

.challenge-description-full {
  margin-bottom: var(--spacing-md);
  line-height: 1.6;
}

.challenge-progress-details {
  margin-bottom: var(--spacing-md);
}

.progress-bar-container {
  height: 12px;
  background-color: var(--background-panel-dark);
  border-radius: var(--radius-full);
  overflow: hidden;
}

.progress-bar-fill {
  height: 100%;
  background: linear-gradient(to right, var(--jade-green), var(--imperial-blue));
  border-radius: var(--radius-full);
}

.challenge-dates-details {
  margin-bottom: var(--spacing-md);
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.complete-challenge-button-large {
  width: 100%;
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-top: var(--spacing-md);
}

/* 及时奖励卡片 */
.timely-reward-card {
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  padding: 16px;
  margin-bottom: 16px;
  transition: all 0.3s ease;
  border-left: 4px solid #ccc;
  overflow: hidden;
  position: relative;
}

.timely-reward-card:hover {
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
  transform: translateY(-2px);
}

/* 状态样式 */
.timely-reward-card.reward-active {
  border-left-color: var(--bamboo-green);
}

.timely-reward-card.reward-completed {
  border-left-color: var(--rosewood-purple);
}

.timely-reward-card.reward-expired {
  border-left-color: var(--ink-gray);
  opacity: 0.8;
}

.timely-reward-card.reward-upcoming {
  border-left-color: var(--porcelain-blue);
}

/* 卡片头部 */
.reward-card-header {
  display: flex;
  align-items: center;
  margin-bottom: 12px;
}

.reward-icon {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  overflow: hidden;
  margin-right: 12px;
  background-color: #f5f5f5;
  display: flex;
  align-items: center;
  justify-content: center;
}

.reward-icon img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.reward-title-section {
  flex: 1;
}

.reward-title {
  margin: 0 0 4px 0;
  font-size: 18px;
  font-weight: 600;
}

.reward-meta {
  display: flex;
  align-items: center;
  font-size: 12px;
  color: var(--text-secondary);
}

.reward-type {
  margin-right: 8px;
  padding: 2px 6px;
  background-color: #f5f5f5;
  border-radius: 4px;
}

.reward-status {
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: 500;
}

.reward-status.reward-active {
  background-color: rgba(136, 176, 75, 0.1);
  color: var(--bamboo-green);
}

.reward-status.reward-completed {
  background-color: rgba(93, 57, 84, 0.1);
  color: var(--rosewood-purple);
}

.reward-status.reward-expired {
  background-color: rgba(138, 141, 145, 0.1);
  color: var(--ink-gray);
}

.reward-status.reward-upcoming {
  background-color: rgba(26, 109, 176, 0.1);
  color: var(--porcelain-blue);
}

/* 卡片内容 */
.reward-card-body {
  margin-bottom: 12px;
}

.reward-description {
  margin: 0 0 12px 0;
  font-size: 14px;
  color: var(--text-secondary);
  line-height: 1.5;
}

.reward-progress-section {
  margin-bottom: 8px;
}

.reward-time-info {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: var(--text-secondary);
  margin-top: 4px;
}

/* 卡片底部 */
.reward-card-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 8px;
  border-top: 1px solid #f0f0f0;
}

.reward-points {
  display: flex;
  align-items: center;
  font-size: 14px;
  font-weight: 500;
}

.lucky-points-icon {
  margin-right: 4px;
}

.lucky-points-value {
  color: var(--amber-yellow);
}

.complete-reward-button {
  padding: 6px 12px;
  background-color: var(--bamboo-green);
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.complete-reward-button:hover:not(:disabled) {
  background-color: var(--royal-jade);
}

.complete-reward-button:disabled {
  background-color: #e0e0e0;
  color: var(--ink-gray);
  cursor: not-allowed;
}

.reward-completed-info {
  font-size: 12px;
  color: var(--rosewood-purple);
}

/* 动画效果 */
@keyframes glow {
  0% {
    box-shadow: 0 0 5px rgba(136, 176, 75, 0.5);
  }
  50% {
    box-shadow: 0 0 15px rgba(136, 176, 75, 0.8);
  }
  100% {
    box-shadow: 0 0 5px rgba(136, 176, 75, 0.5);
  }
}

.timely-reward-card.reward-active:hover {
  animation: glow 2s infinite;
}
</file>

<file path="src/index.css">
/* 基本样式已移至game-theme.css */

/* 页面内容样式 */

.page-content, section.page-content { /* Allow section to also use page-content style */
  background-color: transparent;
  padding: 15px;
  margin-bottom: 20px;
  width: 100%;
  box-sizing: border-box;
}
section + section { margin-top: 25px; }


hr {
  border: 0;
  height: 1px;
  background-color: rgba(136, 176, 75, 0.3); /* 使用竹绿色 */
  margin: 25px 0;
}

ul {
  list-style-type: disc;
  padding-left: 20px;
}
li { margin-bottom: 5px; }


/* Common Components */
.button-common {
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1em;
  font-weight: 500;
  transition: background-color 0.2s, opacity 0.2s;
  margin-right: 10px; /* Default spacing for buttons */
}
.button-common:last-child { margin-right: 0; }

.button-common:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.button-primary {
  background-color: #3498db;
  color: white;
}
.button-primary:hover:not(:disabled) {
  background-color: #2980b9;
}
.button-secondary {
  background-color: #95a5a6;
  color: white;
}
.button-secondary:hover:not(:disabled) {
  background-color: #7f8c8d;
}


select {
  padding: 10px;
  border-radius: 4px;
  border: 1px solid #bdc3c7;
  margin-right: 10px;
  font-size: 1em;
  background-color: white;
}

.loading-spinner-overlay {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  min-height: 100px;
}
.loading-spinner {
  border: 4px solid #ecf0f1; /* Light grey */
  border-top: 4px solid #3498db; /* Blue */
  border-radius: 50%;
  width: 30px;
  height: 30px;
  animation: spin 0.8s linear infinite;
}
.loading-spinner-text { margin-top: 10px; font-style: italic; color: #555; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.error-container {
  border: 1px solid #e74c3c; /* Red */
  padding: 15px;
  border-radius: 5px;
  background-color: #fdedec; /* Light red */
  margin-bottom: 15px;
}
.error-container h3 { color: #c0392b; margin-bottom: 8px;}
.error-text { color: #c0392b; }
.error-code-text { font-size: 0.85em; color: #7f8c8d; margin-top: 5px; }
</file>

<file path="src/pages/HomePage.tsx">
// src/pages/HomePage.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchHomePageView } from '@/services';
import WelcomeSection from '@/features/home/WelcomeSection';
import MoodsSection from '@/features/home/MoodsSection';
import PandaSection from '@/features/home/PandaSection';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import AnimatedButton from '@/components/animation/AnimatedButton';
import { pageTransition } from '@/utils/animation';
import type { HomePageViewDataPayload, HomePageViewLabelsBundle, ApiError } from '@/types';

const HomePage: React.FC = () => {
  const {
    data: pageData, labels: pageLabels, isPending, isError, error, refetch, isFetching
  } = useLocalizedView<HomePageViewDataPayload, HomePageViewLabelsBundle>(
    'homePageViewContent',
    fetchHomePageView
  );

  if (isPending && !pageLabels) { // Full page initial load
    return <LoadingSpinner variant="jade" text="Loading Home Page Content..." />;
  }

  if (isError && !pageLabels) { // Critical: Page labels failed
    return (
      <div className="page-content">
        <ErrorDisplay error={error} title="Home Page Error" onRetry={refetch} />
      </div>
    );
  }

  // If labels are partially/fully loaded, but an error occurred or still pending data
  // We can render the page shell with what we have.
  const isLoadingData = isPending || (isFetching && !pageData); // True if data is still being fetched/refetched

  return (
    <motion.div
      className="page-container"
      variants={pageTransition}
      initial="hidden"
      animate="visible"
      exit="exit"
    >
      <div className="bamboo-frame"> {/* Wrap content in bamboo-frame */}
        <h2>{pageLabels?.pageTitle || "Dashboard"}</h2>

        <WelcomeSection labels={pageLabels?.welcomeSection} username={pageData?.username} />

        <PandaSection labels={pageLabels?.pandaSection} />

        <MoodsSection
          labels={pageLabels?.moodsSection}
          moods={pageData?.moods}
          onRefresh={refetch}
          isFetching={isFetching}
        />

        {/* Example of a page-level button using a page-level label with jade style */}
        {pageLabels?.someActionText && (
          <AnimatedButton
            variant="jade"
            onClick={() => alert('Action Confirmed!')}
            style={{marginTop: '20px'}}
          >
            {pageLabels.someActionText}
          </AnimatedButton>
        )}

        {/* Show specific data error if labels loaded but data part failed */}
        {isError && pageData === undefined && pageLabels && (
           <ErrorDisplay
              error={error}
              title={pageLabels.moodsSection?.sectionTitle || "Data Fetch Error"}
              messageTemplate="Could not load mood data. Details: {message}"
              onRetry={refetch}
           />
         )}
         {isLoadingData && pageLabels && ( // Show spinner for data if labels are present
             <LoadingSpinner variant="jade" text="Fetching latest data..." />
         )}
      </div>
    </motion.div>
  );
};
export default HomePage;
</file>

<file path="src/pages/SettingsPage.tsx">
// src/pages/SettingsPage.tsx
import React from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchSettingsPageView } from '@/services';
import LanguageSettingsSection from '@/features/settings/LanguageSettingsSection';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import PageTransition from '@/components/animation/PageTransition';
import DialogDemo from '@/components/game/DialogDemo';
import type { SettingsPageViewLabelsBundle, ApiError } from '@/types';

const SettingsPage: React.FC = () => {
  const {
    labels: pageLabels, isPending, isError, error, refetch, isFetching
  } = useLocalizedView<null, SettingsPageViewLabelsBundle>(
    'settingsPageViewContent',
    fetchSettingsPageView
  );

  if (isPending && !pageLabels) { // Full page initial load
    return <LoadingSpinner variant="jade" text="Loading Settings Page Content..." />;
  }

  if (isError || !pageLabels) { // Critical: Page labels failed
     return (
      <div className="page-content">
        <ErrorDisplay
          error={error}
          title={pageLabels?.pageTitle || "Settings Load Error"}
          messageTemplate="Could not load settings. Details: {message}"
          onRetry={refetch}
        />
      </div>
    );
  }

  return (
    <PageTransition>
      <div className="page-content"> {/* Use regular container first */}
        <div className="bamboo-frame"> {/* Wrap content in bamboo-frame */}
          <h2>{pageLabels.pageTitle || "Settings"}</h2>
          <LanguageSettingsSection
            labels={pageLabels.languageSection}
            isUpdatingPage={isFetching && !!pageLabels} // Page is fetching if labels are present but still fetching
          />

          {/* 对话框演示部分 */}
          <div style={{ marginTop: '30px', borderTop: '1px solid var(--border-color)', paddingTop: '20px' }}>
            <h3>UI组件演示</h3>
            <DialogDemo />
          </div>
        </div>
      </div>
    </PageTransition>
  );
};
export default SettingsPage;
</file>

<file path="src/router.tsx">
// src/router.tsx
import React, { Suspense, lazy } from 'react';
import { Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { AnimatePresence } from 'framer-motion';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// Lazy load page components
const HomePage = lazy(() => import('@/pages/HomePage'));
const SettingsPage = lazy(() => import('@/pages/SettingsPage'));
const TasksPage = lazy(() => import('@/pages/TasksPage'));
const AbilitiesPage = lazy(() => import('@/pages/AbilitiesPage'));
const ChallengesPage = lazy(() => import('@/pages/ChallengesPage'));
const TimelyRewardsPage = lazy(() => import('@/pages/TimelyRewardsPage'));

const AppRouter: React.FC = () => {
  const location = useLocation();

  return (
    <Suspense fallback={<LoadingSpinner variant="jade" text="Loading view..." />}>
      <Routes location={location}>
        <Route path="/" element={<HomePage />} />
        <Route path="/tasks" element={<TasksPage />} />
        <Route path="/abilities" element={<AbilitiesPage />} />
        <Route path="/challenges" element={<ChallengesPage />} />
        <Route path="/rewards" element={<TimelyRewardsPage />} />
        <Route path="/settings" element={<SettingsPage />} />
        <Route path="*" element={<Navigate to="/" replace />} /> {/* Fallback route */}
      </Routes>
    </Suspense>
  );
};
export default AppRouter;
</file>

<file path="src/services/localizedContentService.ts">
import { db } from '@/db';
import type {
  Language, LocalizedContent,
  HomePageViewLabelsBundle, HomePageViewDataPayload, MoodItem,
  SettingsPageViewLabelsBundle,
  TasksPageViewLabelsBundle,
  ChallengesPageViewLabelsBundle,
  TimelyRewardsPageViewLabelsBundle,
  AbilitiesPageViewLabelsBundle,
  GlobalLayoutLabelsBundle,
  UILabelRecord, ApiError,
  FetchHomePageViewResult, FetchSettingsPageViewResult, FetchGlobalLayoutViewResult,
  FetchTasksPageViewResult, FetchChallengesPageViewResult, FetchTimelyRewardsPageViewResult,
  FetchAbilitiesPageViewResult
} from '@/types';

const SIMULATED_DELAY_MS = 150;

function buildLabelsObject<TLabelsBundle>(records: UILabelRecord[], baseScope: string): TLabelsBundle {
  const labels = {} as any;
  records.forEach(record => {
    let keyPath = record.labelKey;
    if (record.scopeKey.startsWith(baseScope + '.') && record.scopeKey.length > baseScope.length) {
        const sectionPath = record.scopeKey.substring(baseScope.length + 1);
        keyPath = `${sectionPath}.${record.labelKey}`;
    } else if (record.scopeKey !== baseScope) {
        // This label is not directly under baseScope or a direct sub-scope path, might be an issue or intended for a different structure.
        // For this demo, we'll assume labels fetched by getScopedLabels are correctly targeted.
        // console.warn(`Label with key ${record.labelKey} has scope ${record.scopeKey} which is not directly under or part of ${baseScope}`);
    }

    const keys = keyPath.split('.');
    let current = labels;
    keys.forEach((key, index) => {
      if (index === keys.length - 1) {
        current[key] = record.translatedText;
      } else {
        current[key] = current[key] || {};
        current = current[key];
      }
    });
  });
  return labels as TLabelsBundle;
}

async function getScopedLabels<TLabelsBundle>(baseScopeKey: string, lang: Language): Promise<TLabelsBundle> {
  let labelRecords = await db.uiLabels
    .where('languageCode').equals(lang)
    .and((record: UILabelRecord) => record.scopeKey.startsWith(baseScopeKey))
    .toArray();

  if (!labelRecords.length && lang !== 'en') {
    console.warn(`No '${lang}' labels for scope ${baseScopeKey}, falling back to 'en'`);
    labelRecords = await db.uiLabels
      .where('languageCode').equals('en')
      .and((record: UILabelRecord) => record.scopeKey.startsWith(baseScopeKey))
      .toArray();
  }

  if (!labelRecords.length) {
    const errorMessage = `CRITICAL: No labels found for essential scope ${baseScopeKey} (lang: ${lang} or fallback 'en').`;
    console.error(errorMessage);
    // In a real app, you might throw an error or have a more robust fallback
    return {} as TLabelsBundle;
  }
  return buildLabelsObject<TLabelsBundle>(labelRecords, baseScopeKey);
}

export async function fetchGlobalLayoutView(lang: Language): Promise<FetchGlobalLayoutViewResult> {
  console.log(`SVC_DEXIE: Fetching GLOBAL LAYOUT VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<GlobalLayoutLabelsBundle>('globalLayout', lang);
  return { labels, data: null };
}

export async function fetchHomePageView(lang: Language): Promise<FetchHomePageViewResult> {
  console.log(`SVC_DEXIE: Fetching HOME PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS));
  const labels = await getScopedLabels<HomePageViewLabelsBundle>('homeView', lang);

  const moods: MoodItem[] = [
    { id: 1, name: labels.moodsSection?.sectionTitle || (lang === 'zh' ? '心情' : 'Moods'), feeling: lang === 'zh' ? '专注的' : 'Focused' },
    { id: 2, name: lang === 'zh' ? '锻炼会议' : 'Workout Session', feeling: lang === 'zh' ? '精力充沛的' : 'Energized' },
  ];
  const data: HomePageViewDataPayload = { username: "DevUser", moods };
  return { labels, data };
}

export async function fetchSettingsPageView(lang: Language): Promise<FetchSettingsPageViewResult> {
  console.log(`SVC_DEXIE: Fetching SETTINGS PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<SettingsPageViewLabelsBundle>('settingsView', lang);
  return { labels, data: null };
}

export async function fetchTasksPageView(lang: Language): Promise<FetchTasksPageViewResult> {
  console.log(`SVC_DEXIE: Fetching TASKS PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<TasksPageViewLabelsBundle>('tasksView', lang);
  return { labels, data: null };
}

export async function fetchChallengesPageView(lang: Language): Promise<FetchChallengesPageViewResult> {
  console.log(`SVC_DEXIE: Fetching CHALLENGES PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<ChallengesPageViewLabelsBundle>('challengesView', lang);
  return { labels, data: null };
}

export async function fetchTimelyRewardsPageView(lang: Language): Promise<FetchTimelyRewardsPageViewResult> {
  console.log(`SVC_DEXIE: Fetching TIMELY REWARDS PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<TimelyRewardsPageViewLabelsBundle>('timelyRewardsView', lang);
  return { labels, data: null };
}

export async function fetchAbilitiesPageView(lang: Language): Promise<FetchAbilitiesPageViewResult> {
  console.log(`SVC_DEXIE: Fetching ABILITIES PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<AbilitiesPageViewLabelsBundle>('abilitiesView', lang);
  return { labels, data: null };
}
</file>

<file path="src/types/index.ts">
// src/types/index.ts
export type Language = "en" | "zh";

export interface LanguageContextType {
  language: Language;
  setLanguage: (lang: Language) => void;
}

export interface ApiError extends Error { errorCode?: string; statusCode?: number; }

// Structure for Dexie uiLabels store
export interface UILabelRecord {
  id?: number;
  scopeKey: string; // e.g., "globalLayout", "homeView", "homeView.welcomeSection", "components.button"
  labelKey: string; // e.g., "appTitle", "welcomeMessage", "confirmText"
  languageCode: Language;
  translatedText: string;
}

// --- Generic Localized Content Structure (from services) ---
export interface LocalizedContent<TDataPayload, TLabelsBundle> {
  labels: TLabelsBundle;
  data: TDataPayload | null;
}

// --- Global / Layout Content Types ---
export interface GlobalLayoutLabelsBundle {
  appTitle: string;
  navHome: string;
  navTasks: string;
  navAbilities: string;
  navRewards: string;
  navChallenges: string;
  navSettings: string;
  footerText: string;
  loadingGeneric: string;
  errorGeneric: string;
  appErrorHeading?: string;
  appErrorGeneralMessage?: string;
}
export type FetchGlobalLayoutViewResult = LocalizedContent<null, GlobalLayoutLabelsBundle>;

// --- Home Page/View Specific Types ---
export interface HomeWelcomeSectionLabels {
  welcomeMessage: string;
}
export interface MoodItem { readonly id: number; readonly name: string; readonly feeling: string; }
export interface HomeMoodsSectionLabels {
  sectionTitle: string;
  noMoodsMessage: string;
  refreshButtonText: string;
}
export interface HomePandaSectionLabels {
  sectionTitle: string;
  levelLabel: string;
  experienceLabel: string;
  interactButtonText: string;
  feedButtonText: string;
  playButtonText: string;
  trainButtonText: string;
}
export interface HomePageViewLabelsBundle {
  pageTitle: string;
  welcomeSection: HomeWelcomeSectionLabels;
  moodsSection: HomeMoodsSectionLabels;
  pandaSection: HomePandaSectionLabels;
  someActionText: string; // Example of a page-level label for a generic action
}
export interface HomePageViewDataPayload {
  username: string;
  moods: readonly MoodItem[];
}
export type FetchHomePageViewResult = LocalizedContent<HomePageViewDataPayload, HomePageViewLabelsBundle>;

// --- Settings Page/View Specific Types ---
export interface SettingsLanguageSectionLabels {
  sectionTitle: string;
  selectLanguagePrompt: string;
  currentLanguageIs: string;
  langNameEn: string;
  langNameZh: string;
  saveButtonText: string;
  successMessage: string;
}
export interface SettingsPageViewLabelsBundle {
  pageTitle: string;
  languageSection: SettingsLanguageSectionLabels;
}
export type FetchSettingsPageViewResult = LocalizedContent<null, SettingsPageViewLabelsBundle>;

// --- Tasks Page/View Specific Types ---
export interface TaskManagerLabels {
  sectionTitle: string;
  createTaskButton: string;
  filterAllLabel: string;
  filterTodoLabel: string;
  filterInProgressLabel: string;
  filterCompletedLabel: string;
  noTasksMessage: string;
}
export interface TasksPageViewLabelsBundle {
  pageTitle: string;
  taskManager: TaskManagerLabels;
  loadingMessage?: string;
  errorTitle?: string;
  errorMessage?: string;
  retryButtonText?: string;
}
export type FetchTasksPageViewResult = LocalizedContent<null, TasksPageViewLabelsBundle>;

// --- Challenges Page/View Specific Types ---
export interface ChallengeFilterLabels {
  allLabel: string;
  activeLabel: string;
  completedLabel: string;
  upcomingLabel: string;
  typeAllLabel: string;
  typeDailyLabel: string;
  typeWeeklyLabel: string;
  typeEventLabel: string;
  typeOngoingLabel: string;
  difficultyAllLabel: string;
  difficultyEasyLabel: string;
  difficultyMediumLabel: string;
  difficultyHardLabel: string;
  difficultyExpertLabel: string;
  clearFiltersLabel: string;
}

export interface ChallengesPageViewLabelsBundle {
  pageTitle: string;
  filters: ChallengeFilterLabels;
  noChallengesMessage: string;
  loadingMessage?: string;
  errorTitle?: string;
  errorMessage?: string;
  retryButtonText?: string;
}
export type FetchChallengesPageViewResult = LocalizedContent<null, ChallengesPageViewLabelsBundle>;

// --- Timely Rewards Page/View Specific Types ---
export interface TimelyRewardFilterLabels {
  allLabel: string;
  activeLabel: string;
  completedLabel: string;
  upcomingLabel: string;
  typeAllLabel: string;
  typeDailyLabel: string;
  typeMorningLabel: string;
  typeStreakLabel: string;
  typeSpecialLabel: string;
  clearFiltersLabel: string;
}

export interface LuckyDrawLabels {
  title: string;
  buttonText: string;
  basicDrawLabel: string;
  advancedDrawLabel: string;
  premiumDrawLabel: string;
  basicDrawDescription: string;
  advancedDrawDescription: string;
  premiumDrawDescription: string;
  insufficientPointsLabel: string;
  drawingLabel: string;
  closeLabel: string;
  continueLabel: string;
}

export interface TimelyRewardsPageViewLabelsBundle {
  pageTitle: string;
  filters: TimelyRewardFilterLabels;
  luckyDraw: LuckyDrawLabels;
  noRewardsMessage: string;
}
export type FetchTimelyRewardsPageViewResult = LocalizedContent<null, TimelyRewardsPageViewLabelsBundle>;

// --- Abilities Page/View Specific Types ---
export interface AbilityFilterLabels {
  allLabel: string;
  activeLabel: string;
  lockedLabel: string;
  typeAllLabel: string;
  typeAttackLabel: string;
  typeDefenseLabel: string;
  typeUtilityLabel: string;
  typeSpecialLabel: string;
  clearFiltersLabel: string;
}

export interface AbilitiesPageViewLabelsBundle {
  pageTitle: string;
  filters: AbilityFilterLabels;
  noAbilitiesMessage: string;
  loadingMessage?: string;
  errorTitle?: string;
  errorMessage?: string;
  retryButtonText?: string;
  pandaLevelLabel?: string;
  unlockedAbilitiesLabel?: string;
  abilitiesDescription?: string;
}
export type FetchAbilitiesPageViewResult = LocalizedContent<null, AbilitiesPageViewLabelsBundle>;
</file>

</files>
