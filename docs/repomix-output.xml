This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
app-design-brief -v1.md
app-design-brief.md
boost-sub.md
checklist.md
component-multilingual-examples.md
development-tasks-updated.md
docs/component-development-guide.md
docs/data-sync-architecture.md
docs/multilingual-support-fixes.md
germini.md
index.html
issue.md
multilingual-implementation-guide.md
multilingual-support-fixes.md
package.json
page-design-document.md
prd.md
prompt.md
public/assets/abilities/bamboo-focus.svg
public/assets/abilities/bamboo-heart.svg
public/assets/abilities/bamboo-master.svg
public/assets/abilities/default-ability.svg
public/assets/abilities/panda-vitality.svg
public/assets/abilities/panda-wisdom.svg
public/assets/accessories/bamboo-hat.svg
public/assets/accessories/default.svg
public/assets/accessories/gold-frame.svg
public/assets/accessories/red-ribbon.svg
public/assets/bamboo-bg-pattern.svg
public/assets/bamboo-leaves.svg
public/assets/chinese-cloud.svg
public/assets/chinese-knot.svg
public/assets/chinese-lantern.svg
public/assets/chinese-pattern.svg
public/assets/environments/bamboo-path.svg
public/assets/environments/chinese-garden.svg
public/assets/environments/default.svg
public/assets/ink-splash.svg
public/assets/lattice-pattern.svg
public/assets/lotus-flower.svg
public/assets/mountain-landscape.svg
public/assets/panda-focused.svg
public/assets/panda-happy.svg
public/assets/panda-normal.svg
public/assets/panda-tired.svg
public/assets/paper-texture.svg
public/assets/rewards/coin.svg
public/assets/rewards/decoration_common.svg
public/assets/rewards/experience.svg
public/assets/rewards/food_common.svg
public/assets/rewards/food_uncommon.svg
public/assets/rewards/item_common.svg
public/assets/rewards/potion_common.svg
public/assets/rewards/scroll_common.svg
public/assets/rewards/toy_common.svg
public/assets/rewards/toy_uncommon.svg
public/assets/scroll-edge.svg
public/assets/sounds/README.md
README.md
screens.md
src/App.tsx
src/components/animation/AnimatedButton.tsx
src/components/animation/AnimatedContainer.tsx
src/components/animation/AnimatedItem.tsx
src/components/animation/AnimatedTaskCard.tsx
src/components/animation/AnimatedTaskList.tsx
src/components/animation/ChallengeCompletionAnimation.tsx
src/components/animation/GoldenGlow.tsx
src/components/animation/InkSplash.tsx
src/components/animation/PageTransition.tsx
src/components/animation/README.md
src/components/animation/RewardAnimation.tsx
src/components/animation/TaskCompletionAnimation.tsx
src/components/common/Button.tsx
src/components/common/DataLoader.tsx
src/components/common/ErrorDisplay.tsx
src/components/common/LoadingSpinner.tsx
src/components/common/Modal.tsx
src/components/common/ProgressBar.tsx
src/components/common/SyncStatusIndicator.tsx
src/components/decoration/ChineseDecoration.tsx
src/components/decoration/InkAnimation.tsx
src/components/decoration/LanternDecoration.tsx
src/components/game/AbilityCard.tsx
src/components/game/AbilityList.tsx
src/components/game/AbilityUnlockNotification.tsx
src/components/game/ChallengeCard.tsx
src/components/game/ChallengeDiscoveryCard.tsx
src/components/game/ChallengeDiscoverySection.tsx
src/components/game/ChallengeList.tsx
src/components/game/ChallengeRecommendationCard.tsx
src/components/game/DialogDemo.tsx
src/components/game/LatticeDialog.tsx
src/components/game/LuckyDraw.tsx
src/components/game/LuckyDrawWheel.tsx
src/components/game/LuckyPointsDisplay.tsx
src/components/game/PandaAvatar.tsx
src/components/game/README.md
src/components/game/ReflectionModule.tsx
src/components/game/ResourceDisplay.tsx
src/components/game/ResourceInventory.tsx
src/components/game/ResourceList.tsx
src/components/game/RewardModal.tsx
src/components/game/ScrollDialog.tsx
src/components/game/SocialChallengeCard.tsx
src/components/game/SocialChallengeDetailDialog.tsx
src/components/game/SocialChallengeForm.tsx
src/components/game/SocialChallengeList.tsx
src/components/game/TaskCard.tsx
src/components/game/TaskDetailDialog.tsx
src/components/game/TaskForm.tsx
src/components/game/TaskList.tsx
src/components/game/TimelyRewardCard.tsx
src/components/game/TimelyRewardList.tsx
src/components/layout/AppShell.tsx
src/components/layout/Header.tsx
src/components/layout/Navigation.tsx
src/components/panda/PandaCustomizationPanel.tsx
src/components/panda/PandaEnvironmentPanel.tsx
src/components/reflection/EnhancedReflectionModule.tsx
src/components/reflection/MoodTracker.tsx
src/components/reflection/README.md
src/components/reflection/ReflectionHistory.tsx
src/components/reflection/ReflectionTriggerNotification.tsx
src/components/store/CurrencyDisplay.tsx
src/components/store/StoreCategoryList.tsx
src/components/store/StoreItemCard.tsx
src/components/store/StoreItemPreview.tsx
src/components/store/VipSubscriptionCard.tsx
src/components/task/TaskCard.tsx
src/components/task/TaskDetailDialog.tsx
src/components/task/TaskReminderForm.tsx
src/components/task/TaskReminderNotification.tsx
src/components/tasks/SubtaskList.tsx
src/context/DataRefreshProvider.tsx
src/context/LanguageProvider.tsx
src/context/PandaStateProvider.tsx
src/db-turso.ts
src/db.ts
src/features/home/MoodsSection.tsx
src/features/home/PandaSection.tsx
src/features/home/WelcomeSection.tsx
src/features/settings/LanguageSettingsSection.tsx
src/features/tasks/TaskManager.tsx
src/game-theme.css
src/hooks/useComponentLabels.ts
src/hooks/useDataRefresh.ts
src/hooks/useInternationalizedQuery.ts
src/hooks/useLocalizedView.ts
src/index.css
src/main.tsx
src/pages/AbilitiesPage.tsx
src/pages/ChallengesPage.tsx
src/pages/HomePage.tsx
src/pages/SettingsPage.tsx
src/pages/StorePage.tsx
src/pages/TasksPage.tsx
src/pages/TeaRoomPage.tsx
src/pages/TimelyRewardsPage.tsx
src/router.tsx
src/scripts/addTimelyRewardCardLabels.js
src/services/abilityService.ts
src/services/challengeDiscoveryService.ts
src/services/challengeService.ts
src/services/dataSyncService.ts
src/services/gameInitService.ts
src/services/index.ts
src/services/localizedContentService.ts
src/services/pandaAbilityService.ts
src/services/pandaCustomizationService.ts
src/services/pandaStateService.ts
src/services/queryClient.ts
src/services/reflectionService.ts
src/services/rewardService.ts
src/services/socialChallengeService.ts
src/services/storeService.ts
src/services/subtaskService.ts
src/services/taskReminderService.ts
src/services/taskService.ts
src/services/timelyRewardService.ts
src/types/dataRefresh.ts
src/types/index.ts
src/utils/animation.ts
src/utils/dateUtils.ts
src/utils/localization.ts
src/utils/sound.ts
src/vite-env.d.ts
task.md
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app-design-brief -v1.md">
# PandaHabit App Design Brief: 华丽游戏风格

## 1. Introduction

### 1.1 Overview
PandaHabit是一款移动应用，通过引人入胜且支持性的虚拟宠物体验，帮助用户建立积极的习惯，改善自我护理，提升心理健康。用户通过完成现实生活中的任务和习惯来培养虚拟熊猫，创造一种共生关系，照顾自己直接有益于宠物，而宠物则提供陪伴、动力和温和的指导。

### 1.2 华丽游戏风格设计理念
PandaHabit的设计理念围绕创造一种**华丽奢华的游戏体验**，给人以高级感、沉浸感和情感满足感。应用旨在通过利用精美绚丽的视觉效果、精心设计的交互和令人惊叹的动画效果，将自我护理从一项琐事转变为一段愉悦的旅程。我们采用了东方美学与现代游戏设计相结合的方式，打造出一个既华丽壮观又温馨舒适的数字空间。

### 1.3 目标用户
- 寻求习惯养成和自我护理工具的个人
- 喜欢游戏化和虚拟宠物体验的用户
- 渴望获得支持性、温和方式进行个人发展的人群
- 年龄范围：18-45岁，重点关注年轻专业人士和学生
- 欣赏高品质数字体验并愿意投资优质应用的用户
- 对东方美学和华丽视觉风格有偏好的玩家

## 2. 华丽游戏风格分析

### 2.1 华丽游戏风格定义
对于PandaHabit，"华丽游戏风格"的定义包括：
- **绚丽华美的视觉效果**，包含精细的插画和动画，灵感来源于东方美学和传统中国艺术
- **金碧辉煌的色彩搭配**，融合深沉的宝石色调、金色点缀、精致的渐变和传统中国色彩
- **精雕细琢的UI元素**，注重阴影、高光和纹理细节，采用传统中国装饰元素（如云纹、如意纹）
- **流畅华丽的动画效果**，提供视觉反馈和愉悦感，动画风格融合现代游戏与传统水墨画动态美感
- **沉浸式音效设计**，结合平静的自然声音、传统中国乐器和温柔的音乐元素
- **精心设计的字体排版**，平衡可读性与美学吸引力，中文使用优雅的书法风格字体

### 2.2 视觉参考与灵感来源
- **高品质移动游戏**：《原神》(整体UI风格与动效)、《天涯明月刀》(中国风元素)、《阴阳师》(华丽特效)
- **中国传统艺术**：水墨画、竹子图案、山水画、传统纹饰、剪纸艺术、京剧脸谱元素
- **奢侈品牌应用**：上海滩、故宫文创、Louis Vuitton中国版
- **自然启发设计**：国家地理、高端度假村网站、中国园林设计
- **古典游戏美学**：《轩辕剑》系列、《仙剑奇侠传》系列的视觉风格
- **现代中国风设计**：当代中国插画师作品、新中式设计元素

### 2.3 华丽色彩方案
- **主要色彩**:
  - 皇家翡翠绿 (#1A5F4A)：代表成长、宁静与自然，灵感来自传统中国玉器
  - 富贵竹绿 (#88B04B)：象征熊猫的食物和活力，传递生机与希望
  - 瑞雪白 (#F7F9F9)：提供视觉呼吸空间和清晰度，象征纯净与和谐
  - 朱砂红 (#D73E35)：传统中国红，象征喜庆、活力与好运

- **点缀色彩**:
  - 华贵金 (#D4AF37)：突出成就和高级元素，灵感来自古代中国金饰
  - 青花蓝 (#1A6DB0)：代表水分和流动，灵感来自青花瓷
  - 牡丹粉 (#F8C8DC)：增添温暖和情感连接，灵感来自中国传统花卉
  - 紫檀紫 (#5D3954)：增添神秘感和高贵感，灵感来自传统家具

- **功能色彩**:
  - 如意绿 (#2E8B57)：表示完成和积极成果，灵感来自如意玉器
  - 琥珀黄 (#FFA500)：引起注意但不刺眼，灵感来自古代琥珀饰品
  - 墨灰 (#8A8D91)：用于次要文本和非活动元素，灵感来自水墨画

### 2.4 字体设计
- **主标题字体**:
  - 中文：**"方正清刻本悦宋"**，传递典雅与永恒感
  - 英文：**"Playfair Display"**，与中文字体风格相协调
  - 用于页面标题、成就名称和重要标签，配以金色描边增强华丽感

- **正文字体**:
  - 中文：**"思源宋体"**，高可读性，带有友好、平易近人的感觉
  - 英文：**"Nunito Sans"**，与中文字体搭配和谐
  - 用于任务描述、说明和一般内容，保持清晰易读

- **装饰字体**:
  - 中文：**"庞门正道行书"**，增添个人、亲密的触感，模仿传统书法
  - 英文：**"Caveat"**，手写风格元素
  - 谨慎使用于引言、反思和来自熊猫的特殊信息，增添情感连接

### 2.5 UI组件设计指南
- **按钮**：传统中国风格元素（如云纹、如意纹）装饰的软圆角矩形，配以精致渐变和金色点缀，点击时有华丽粒子效果
- **卡片**：层叠设计，带有精致阴影和纹理背景，边框采用传统中国纹饰，重要卡片有金色或红色描边
- **图标**：水墨画风格，笔触一致，圆润边角，融入传统中国元素（如竹、山水、花鸟）
- **进度指示器**：优雅的环形或线性设计，动画填充效果模仿水墨晕染，重要进度条采用卷轴或竹简形式
- **输入框**：简约设计，带有微妙边框和焦点状态，边框采用传统纹饰，激活时有水墨扩散效果
- **弹窗**：居中设计，装饰性框架采用传统窗棂样式，半透明背景模仿宣纸质感，重要弹窗有红色或金色装饰

## 3. 信息架构

### 3.1 导航结构
基于PRD，PandaHabit将使用底部标签导航，具有以下主要部分，每个导航图标都采用华丽的中国风设计：

1. **主页（竹林家园）**：主仪表盘，展示熊猫、及时奖励进度条和快速操作，背景为动态竹林场景
2. **任务（修行之路）**：日常任务列表和管理，设计为古代卷轴样式
3. **挑战（江湖历练）**：长期目标和特别活动，设计为地图探险风格
4. **旅程（成长之道）**：熊猫成长路径和里程碑，设计为传统山水画卷
5. **商店（珍宝阁）**：装饰物品、资源和VIP订阅，设计为古代商铺风格

次要导航包括：
- **熊猫互动（心灵相通）**：通过点击主页上的熊猫访问，设计为精美的互动场景
- **幸运抽奖（福缘抽签）**：通过顶部导航中的专用图标访问，设计为传统抽签与宝箱相结合的形式
- **设置（玉简设定）**：通过右上角的齿轮图标访问，图标设计为古代玉简
- **反思模块（静心茶室）**：根据用户行为情境触发，设计为宁静的传统茶室环境

### 3.2 用户流程图
关键用户流程包括，每个流程都配有华丽的过渡动画和视觉引导：

1. **新用户引导（初入仙境）**：
   - 应用介绍（古卷展开动画）→ 熊猫定制（水墨渲染效果）→ 首个任务设置（卷轴书写动画）→ 任务完成（金光特效）→ 奖励（宝箱开启动画）→ 主页（竹林展开效果）

2. **日常习惯打卡（每日修行）**：
   - 通知（熊猫信使动画）→ 任务页面（卷轴展开）→ 任务完成（墨迹渲染动画）→ 及时奖励（金币飞舞效果）→ 熊猫互动（熊猫欢喜动画）

3. **挑战参与（江湖探索）**：
   - 挑战页面（地图展开动画）→ 挑战选择（地点点亮效果）→ 日常子任务（小卷轴展开）→ 进度跟踪（地图路径点亮）→ 完成奖励（宝箱华丽开启）

4. **反思过程（茶道静心）**：
   - 触发事件（茶杯图标出现）→ 温和提示（熊猫邀请动画）→ 反思问题（水墨扩散效果）→ 支持性反馈（熊猫安慰动画）→ 行动建议（竹简展开效果）

5. **VIP转化（飞升之路）**：
   - 功能互动（金色光芒提示）→ VIP提示（华丽卷轴展开）→ 福利展示（金光特效展示）→ 订阅选择（玉璧选择界面）→ 购买确认（祥云环绕动画）

### 3.3 屏幕层次结构
屏幕层次结构遵循从一般到特定的逻辑进展，每一层都有独特的视觉风格：

- **第一层**：主标签屏幕（竹林家园、修行之路、江湖历练、成长之道、珍宝阁），设计为完整的场景画面
- **第二层**：特定功能屏幕（心灵相通、福缘抽签、玉简设定），设计为主场景的特写或变体
- **第三层**：详情屏幕（任务详情、挑战详情、物品详情），设计为精美的卷轴或玉简展开
- **第四层**：流程屏幕（静心茶室、VIP购买、任务创建），设计为特殊互动场景

## 4. Detailed UI/UX Design

### 4.1 主页（竹林家园）
主页是情感中心和主要仪表盘，需强化“华丽游戏风格”与互动体验：

- **顶部区域**：
  - 用户头像/资料（左上），VIP用户有专属徽章与动画光效
  - 货币显示（金币、钻石、幸运点），采用立体金属质感与粒子特效
  - 设置齿轮（右上），以玉简或祥云为造型，带入场动画
  - 幸运抽奖入口，常驻闪烁粒子与动态高亮

- **中央区域**：
  - 大幅精美熊猫插画，分阶段成长，状态与互动均有丰富动画（如眨眼、伸懒腰、撒娇）
  - 环境为动态竹林，随时间变化光影，加入蝴蝶、竹叶飘落等粒子动效
  - 及时性进度条设计为华丽卷轴或竹简，填充动画有水墨晕染与金光粒子
  - 奖励预览采用宝箱/卷轴展开动画，奖励图标有高光与弹跳特效

- **底部区域**：
  - 活跃任务快捷入口，卡片采用浮雕、金边、云纹等装饰，完成时有粒子爆发动画
  - 最近奖励日志，图标逐条滚动出现，带有淡入淡出与粒子点缀
  - 底部导航栏为自定义中国风图标，选中有祥云流动与高亮特效，整体采用半透明玉石质感

### 4.2 任务页（修行之路）
任务页需突出“古卷”与“华丽动效”主题，提升交互仪式感：

- **顶部区域**：
  - 日期展示采用书法字体与祥云装饰，背景为淡雅宣纸纹理
  - 每日进度条为卷轴展开动画，填充时有水墨晕染与金光粒子
  - 筛选/排序下拉菜单为玉佩/竹简造型，展开有弹性动画

- **任务列表**：
  - 滚动列表，每个任务卡片为立体浮雕卷轴，边框有金色描边与云纹
  - 任务类型图标为水墨风，任务名用宋体/书法字体，重要任务有特殊高亮
  - 奖励预览图标有弹跳与高光动画
  - 及时性任务有⏰/✨特效，完成时有粒子爆发与卷轴印章动画
  - 时间窗口倒计时为动态沙漏/水滴，挑战/自定义目标有专属标识（如火焰/熊猫头像）

- **新增任务按钮**：
  - 悬浮金色圆形按钮，中心为加号，按钮有脉冲光圈与粒子环绕

### 4.3 挑战页（江湖历练）
挑战页需强化“地图探险”与“成就感”视觉：

- **顶部区域**：
  - 挑战分类Tab为古代令牌/竹简造型，切换有翻转/卷轴展开动画
  - 顶部装饰随挑战主题变换（如山水、火焰、祥云）

- **挑战卡片**：
  - 卡片为立体浮雕，背景为地图/山水画卷，主标题用金色描边字体
  - 关键奖励有宝箱/玉璧高亮展示，奖励图标有光晕与粒子特效
  - 进度条为竹节/卷轴，填充有水墨流动动画
  - 时间限制为动态倒计时，未完成时有轻微闪烁
  - 子任务可展开，完成有印章/祥云动画
  - 接受/领取按钮为玉佩造型，点击有弹跳与粒子爆发

### 4.4 成长之道（旅程页）
成长之道需突出“进化仪式感”与“东方美学”：

- **成长路径可视化**：
  - 采用山水画卷式时间轴或树状结构，节点间用祥云/竹节连接
  - 每个节点为熊猫不同成长阶段小像，完成节点有金光高亮与粒子庆祝
  - 当前节点脉冲动画，未解锁节点半透明并有神秘光效
  - 奖励预览为玉简/宝箱展开，奖励图标有高光与弹跳

- **Milestone Log**:
  - Scrollable timeline with rich visual treatment
  - Achievement cards with decorative frames
  - Date stamps with elegant typography
  - Reward recap with animated icons

### 4.5 商店页（珍宝阁）
商店页需营造“奢华购物”与“收藏展示”氛围：

- **顶部区域**：
  - 搜索栏为玉简/祥云造型，输入时有光效流动
  - 分类筛选为立体玉佩/卷轴，选中有高亮与粒子环绕
  - 特色商品轮播为宝箱/玉璧展示，切换有翻转动画

- **商品网格**：
  - 商品卡片为浮雕金边，插画高精度并带有微动画
  - 价格用金色字体与立体货币图标，VIP商品有专属光效与标识

- **商品详情**：
  - 大图预览支持3D旋转，描述区用宋体/书法字体
  - 熊猫定制类商品有前后对比动画
  - 购买按钮为玉璧/祥云造型，点击有粒子爆发
  - 相关商品横向滚动，卡片有弹跳与高光

### 4.6 熊猫互动页（心灵相通）
强化“亲密互动”与“动态环境”体验：

- **环境设计**：
  - 背景为高精度中国园林，随时间变化光影，加入动态水面、竹叶、祥云等粒子
  - 环境元素可交互（如点击水池有涟漪，竹叶可飘落）

- **熊猫可视化**：
  - 熊猫大幅动态插画，情绪通过表情、动作、特效展现（如开心时有金光、撒娇时有爱心粒子）
  - 定制装饰高精度渲染，稀有物品有特殊光效

- **互动控件**：
  - 按钮为玉佩/祥云造型，点击有弹跳与粒子动画
  - 喂食、玩耍、训练均有专属动画与奖励反馈
  - 反思提示为温柔弹窗，背景虚化并有祥云环绕

### 4.7 幸运抽奖页（福缘抽签）
突出“仪式感”与“惊喜感”视觉：

- **顶部区域**：
  - 幸运点余额为立体玉璧计数器，周围常驻闪烁粒子

- **抽奖机制**：
  - 抽奖动画为华丽宝箱/转盘/竹简展开，粒子与音效营造期待氛围
  - 抽奖按钮为金色祥云造型，点击有高光与粒子爆发
  - 结果揭晓有卷轴展开、宝箱开启等庆祝动画

- **奖池展示**：
  - 奖品以画廊形式展示，稀有度用金光/祥云特效区分
  - 概率用精美数据可视化，近期中奖有时间轴动画

### 4.8 反思模块（静心茶室）
营造“静谧治愈”与“温柔支持”氛围：

- **视觉设计**：
  - 背景为淡雅茶室/山水，祥云、茶烟等柔和动画，整体色调温暖柔和
  - UI元素极简，减少干扰，输入区为宣纸/竹简造型

- **交互设计**：
  - 熊猫头像有同理心表情，文字对话采用逐字淡入动画
  - 输入方式为定制按钮/温柔文本框，反馈有水墨扩散动画
  - 阶段切换为卷轴展开/祥云流动，整体过渡平滑

## 5. Core Gameplay Elements

### 5.1 Panda Companion Visualization
The Panda companion is the emotional heart of the app and features:

- **Growth Stages**:
  - Infant: Small, extra fluffy with large eyes and playful movements
  - Youth: More active, curious expressions, developing unique personality
  - Adult: Graceful, wise appearance with confident posture
  - Perfect Form: Majestic presence with subtle glow effects and special animations

- **Emotional States**:
  - Happy: Bright eyes, smiling expression, energetic movements
  - Neutral: Calm demeanor, regular breathing animation
  - Concerned: Gentle head tilt, softer movements, attentive gaze

- **Customization Visualization**:
  - Seamless integration of accessories and clothing
  - Environment decorations that the Panda interacts with
  - Special effects for rare or VIP items

### 5.2 Resource System Visualization
Resources are presented with premium visual treatment:

- **Resource Icons**:
  - Bamboo: Detailed, realistic bamboo stalks with subtle shine
  - Water: Crystal-clear droplets with light refraction effects
  - Coins: Ornate gold coins with embossed panda design
  - Diamonds: Multi-faceted gems with light reflection and sparkle

- **Resource Animations**:
  - Collection: Satisfying gather animation with particle effects
  - Spending: Elegant transfer animation from inventory to use
  - Low resources: Subtle visual indicator without being punitive
  - Resource milestone: Special celebration animation

### 5.3 Timely Reward System Visualization
The Timely Reward System features premium visual elements:

- **Timeliness Bar**:
  - Elegant scroll or bamboo-themed progress indicator
  - Rich fill animation with particle effects
  - Reward preview with subtle highlight animation
  - Completion celebration with luxurious visual effects

- **Luck Points**:
  - Premium counter with sparkle animation
  - Earning visualization with floating point animation
  - Accumulation milestone effects with special visual treatment

- **On-Time Completion**:
  - Satisfying visual feedback for timely task completion
  - Special animation for "Early Bird" bonus
  - Elegant visual connection between task completion and rewards

### 5.4 Challenge System Visualization
Challenges are presented with immersive visual elements:

- **Challenge Categories**:
  - Visual theming for different challenge types
  - Custom illustrations for challenge backgrounds
  - Animated transitions between categories

- **Progress Tracking**:
  - Rich progress bar design with milestone markers
  - Sub-task completion visualization with elegant checkmarks
  - Time remaining indicator with premium countdown design

- **Reward Presentation**:
  - Treasure chest or gift box animation for claiming rewards
  - Particle effects and sound design for celebration
  - Reward showcase with detailed item presentation

## 6. Monetization Design

### 6.1 VIP Subscription UI/UX
The VIP subscription is presented with a premium, value-focused approach:

- **VIP Badge Design**:
  - Elegant, non-intrusive badge with subtle animation
  - Tiered designs for different subscription levels
  - Special visual effects for VIP users' avatars

- **VIP Benefits Visualization**:
  - Clear, visually rich comparison between free and VIP
  - Animated demonstrations of enhanced features
  - Before/after visualizations of rewards and progression

- **Subscription Flow**:
  - Elegant, distraction-free purchase screen
  - Tiered options with visual hierarchy based on value
  - Secure payment visualization with premium styling
  - Thank you/confirmation screen with celebratory animation

### 6.2 Shop Design
The Shop provides a luxurious shopping experience:

- **Item Categories**:
  - Visual theming for different item types
  - Elegant category icons with selection effects
  - Featured items carousel with premium presentation

- **Item Presentation**:
  - High-quality item illustrations with subtle animations
  - 3D preview capability for certain items
  - Try-before-buy visualization for Panda customizations
  - Limited-time items with special visual treatment

- **Purchase Experience**:
  - Smooth, satisfying purchase animation
  - Elegant confirmation screen with item showcase
  - Gift wrapping animation for new acquisitions
  - Inventory update visualization

### 6.3 Conversion Optimization
Conversion points are designed to be compelling yet non-intrusive:

- **Feature Discovery**:
  - Elegant "VIP Feature" indicators on locked content
  - Subtle glow or highlight effects to draw attention
  - Preview capabilities with "Upgrade to Access" messaging

- **Value Demonstration**:
  - Visual comparisons showing enhanced rewards
  - Progress acceleration visualizations
  - Exclusive item showcases with premium presentation

- **Contextual Prompts**:
  - Thoughtfully timed upgrade suggestions
  - Elegant modal design for upgrade prompts
  - Clear value proposition with visual support

## 7. Technical Implementation Guidelines

### 7.1 Integration with Existing Codebase
The implementation will build upon the existing React/TypeScript architecture:

- Leverage the current component structure while enhancing visual elements
- Maintain the existing data flow patterns while adding new features
- Extend the current state management approach to include new game elements

### 7.2 Internationalization Approach
Building on the existing i18n infrastructure:

- Extend the current language system to include game-specific terminology
- Ensure all new UI elements support multiple languages
- Implement culturally appropriate visual elements for different regions

### 7.3 Component Structure
The component architecture will follow a modular approach:

- **Atomic Design Methodology**:
  - Atoms: Basic UI elements (buttons, inputs, icons)
  - Molecules: Compound components (task cards, reward displays)
  - Organisms: Feature sections (task list, panda interaction area)
  - Templates: Page layouts with placeholder content
  - Pages: Complete screens with real content

- **Game-Specific Components**:
  - PandaAvatar: Handles rendering and animating the Panda
  - ResourceDisplay: Manages resource visualization
  - RewardAnimation: Controls reward presentation effects
  - ChallengeTracker: Visualizes challenge progress

### 7.4 State Management
The state management approach will handle game-specific requirements:

- User progress and achievements stored in persistent state
- Real-time interactions managed with local state
- Animation states controlled with dedicated hooks
- Game mechanics (timers, random events) managed with specialized services

## 8. Appendices

### 8.1 Asset Requirements
- High-resolution Panda illustrations in various poses and growth stages
- Premium UI element designs (buttons, cards, icons)
- Environmental elements and backgrounds
- Resource and reward visualizations
- Animation sequences for key interactions

### 8.2 Animation Specifications
- Micro-interactions for UI elements (button presses, switches, sliders)
- Character animations for the Panda (idle, happy, concerned, interactions)
- Reward and achievement celebrations
- Transition effects between screens and states

### 8.3 Accessibility Considerations
- Color contrast compliance for all UI elements
- Alternative text for decorative elements
- Keyboard navigation support
- Screen reader compatibility
- Motion reduction options for animations
</file>

<file path="boost-sub.md">
好的，这是一个非常棒的优化后的订阅付费引导Checklist！它确实更具战略性，并且融入了很多高级的用户增长和游戏化理念。

现在，让我们基于这份 **【游戏化App订阅增长黄金法则：Checklist 2.0】**，为您的 **PandaHabit** App 设计相关的界面和交互流程。

**核心前提：** PandaHabit 的核心是“健康生活伴侣”和“习惯养成助手”，因此付费引导应始终围绕“更好地支持用户达成目标”和“更愉快地与熊猫互动”展开，避免强迫感。

---

**PandaHabit 订阅付费引导界面设计与交互流程**

**目标：** 将Checklist 2.0中的策略转化为PandaHabit中的具体界面和用户体验。

---

### **一、清晰的价值主张 (Clear Value Proposition)**

*“让玩家一眼看懂‘我为什么需要这个？’并感到物超所值。”*

**1.1. 核心特权可视化与差异化**

*   **界面A1：VIP特权总览页面 (VIP Benefits Overview Page)**
    *   **触发点：** 点击主界面的“VIP”入口、特定功能引导弹窗的“了解详情”按钮。
    *   **布局：**
        *   **顶部醒目 Banner：** “成为熊猫守护者，解锁专属特权！” 或 “升级VIP，加速你的健康成长之旅！”。
        *   **对比列表/卡片：** 清晰并列展示 **免费版 (Free Panda Friend)** vs **VIP熊猫守护者 (VIP Panda Guardian)** 的核心权益差异。
            *   **身份彰显：**
                *   **免费版：** 普通熊猫头像框。
                *   **VIP版：** **[动态闪耀竹叶头像框]**、**[“守护者”专属称号显示在昵称旁]**、**[聊天气泡（若有社交）带有小皇冠]**。配有对比图。
            *   **功能/效率对比：**
                *   **任务资源获取：** 免费版：竹子x1；VIP版：竹子x2 **[额外部分用金色高亮]**。
                *   **熊猫成长速度：** 免费版：正常速度；VIP版：成长经验+50% **[经验条动画对比]**。
                *   **每日幸运抽奖：** 免费版：1次；VIP版：3次 **[额外次数高亮]**。
                *   **自定义目标(Goal)数量：** 免费版：1个；VIP版：5个。
            *   **专属内容解锁：**
                *   **熊猫外观：** 免费版：基础外观；VIP版：**[解锁专属VIP限定熊猫皮肤/饰品]** (展示预览图)。
                *   **特殊支线任务：** 免费版：无；VIP版：**[解锁“熊猫的秘密花园”系列专属支线任务，奖励丰厚]**。
                *   **高级冥想/呼吸课程：** 免费版：基础课程；VIP版：**[解锁所有高级/主题冥想与呼吸课程]**。
        *   **行动按钮：** “立即升级成为守护者”、“查看订阅选项”。
*   **界面A2：任务/成长节点即时收益反馈**
    *   **触发点：** 完成任务、熊猫升级、幸运抽奖获得奖励时。
    *   **交互：**
        *   **任务完成弹窗：**
            *   基础奖励：竹子 +10, 水 +5
            *   **[VIP额外奖励：竹子 +10 (金色高亮，旁边有小皇冠标记)，幸运点数 +5 (金色高亮)]**
            *   如果未订阅，额外奖励部分显示为灰色，并有小字提示：“成为守护者可获得此额外奖励！”
        *   **熊猫升级动画：** 升级后，除了基础属性提升，若用户是VIP，则弹出：“恭喜！作为守护者，熊猫额外获得XX点成长祝福！”
*   **界面A3：“解锁”型激励弹窗**
    *   **触发点：** 用户尝试访问VIP专属功能/内容时（如点击锁定的高级冥想课程、尝试创建第二个自定义目标）。
    *   **布局：**
        *   **标题：** “解锁[功能名称]的全部潜力！”
        *   **内容：** 简洁说明此功能的VIP优势，例如：“成为守护者，即可无限制创建自定义目标，并获得熊猫的智能拆解建议！”或“解锁这门深度睡眠冥想课程，让熊猫陪伴你安然入梦。”
        *   **行动按钮：** “了解守护者特权”、“暂时不用”。

**1.2. 营造“拥有感”与“损失规避”心理**

*   **界面B1：VIP特权限时体验**
    *   **触发点：** 新用户完成特定里程碑（如熊猫首次进化、连续登录3天）或特定活动期间。
    *   **弹窗设计：**
        *   **标题：** “限时福利：免费体验3天熊猫守护者特权！”
        *   **内容：** 简要列出可体验的核心特权（如双倍资源、专属外观试穿、高级课程体验）。
        *   **行动按钮：** “立即免费体验”、“以后再说”。
        *   **体验期间：** 用户界面上会临时显示VIP标识，相关功能临时解锁。
*   **界面B2：资源/时间节省提示**
    *   **触发点：** 用户熊猫体力不足无法进行探索、幸运点数不足无法抽奖、或自定义目标规划遇到困难时。
    *   **交互：**
        *   **情景提示条/小气泡：** “熊猫体力不足啦！守护者每日可额外领取熊猫能量零食哦！” 或 “想更快达成目标吗？守护者可以创建更多自定义目标，并获得熊猫的规划支持！”
        *   **行动按钮：** “了解守护者特权”。
*   **界面B3：订阅到期提醒**
    *   **触发点：** VIP订阅到期前3天、1天。
    *   **弹窗/通知设计：**
        *   **标题：** “熊猫守护者特权即将到期！”
        *   **内容：**
            *   视觉化倒计时（如沙漏动画）。
            *   回顾订阅期内已享受的核心价值：“在守护期间，您已额外获得了XXX竹子，您的熊猫成长速度提升了XX%，完成了X个守护者专属任务…”
            *   强调续订的好处：“续订即可继续享受这些特权，并解锁下个月的守护者专属礼包！”
            *   部分原VIP特权图标在主界面开始**[逐渐变灰或加上锁的角标]**作为视觉提醒。
        *   **行动按钮：** “立即续订”、“查看续订选项”、“暂不续订”。

---

### **二、智能化的付费场景 (Intelligent Payment Scenarios)**

*“在玩家最需要、最渴望或情绪最高涨的时刻，自然地呈现机会。”*

**2.1. 关键时刻与情感连接**

*   **界面C1：高光时刻助推弹窗**
    *   **触发点：** 用户熊猫达成重要进化、完成一个长期挑战、幸运抽奖获得稀有物品、首次填满准时进度条时。
    *   **弹窗设计：**
        *   **标题：** “太棒了！[成就描述]” 或 “幸运降临！”
        *   **内容：** 庆祝用户的成就，然后关联订阅价值：“想要更多这样的惊喜吗？成为守护者，未来完成挑战可获得双倍幸运点数，稀有物品掉率提升！” 或 “作为守护者，每次熊猫进化都能获得额外的成长祝福礼包哦！”
        *   **行动按钮：** “了解守护者福利”、“继续努力”。
*   **界面C2：痛点解决方案提示**
    *   **触发点：** 用户连续几天未完成核心习惯任务、情绪打卡持续低迷、自定义目标进展缓慢时。
    *   **交互（通过熊猫的对话气泡或情绪反思模块）：**
        *   **熊猫对话：** “感觉最近[习惯名称]有点难坚持呢… 守护者可以解锁熊猫的‘习惯冲刺计划’，我们一起制定更容易达成的小步骤吧！” 或 “心情有点低落吗？守护者可以解锁专属的‘阳光心情冥想系列’，让熊猫陪你找回活力。”
        *   **行动按钮/选项：** “了解守护者专属支持”、“我再试试”。
*   **界面C3：社交对比与向往（若有排行榜/好友功能）**
    *   **排行榜界面：**
        *   VIP用户拥有**[醒目的动态头像框和守护者徽章]**。
        *   排行榜下方可能有小提示：“想和他们一样闪耀吗？成为熊猫守护者，彰显你的独特身份！”
    *   **好友详情页/熊猫家园拜访：**
        *   清晰展示好友的VIP状态和其拥有的VIP专属熊猫外观/家园装饰。
        *   小提示：“你的好友[XXX]已经是熊猫守护者了，快加入行列，一起享受特权吧！”

**2.2. 限时稀缺与首购激励**

*   **界面D1：动态化限时优惠弹窗/商城模块**
    *   **触发点：** 新用户注册后特定时间（如24小时内）、特定节日活动期间。
    *   **设计：**
        *   **商城首页Banner/弹窗：** “新手启程礼：仅限72小时！订阅首月享5折优惠，并立即获赠[新手熊猫礼包]！”
        *   **[动态倒计时器]** 显著显示剩余时间。
        *   礼包内容可视化展示。
*   **界面D2：里程碑式首购礼包**
    *   **触发点：** 用户完成新手引导系列任务后，或熊猫达到特定等级（如5级）。
    *   **弹窗设计：**
        *   **标题：** “恭喜完成新手试炼！解锁您的专属首购订阅福利！”
        *   **内容：** 提供一个一次性的高性价比订阅包，例如：“订阅月卡，不仅享受所有守护者特权，还将额外获得[绝版熊猫幼崽期纪念装饰]！”
*   **界面D3：订阅专享内容/活动入口**
    *   **主界面活动中心/任务列表：**
        *   VIP专属活动/任务带有**[醒目的VIP皇冠标记]**。
        *   免费用户点击时，弹出提示：“此为熊猫守护者专属[活动/任务]，订阅即可参与，赢取丰厚奖励！”
        *   **允许“预览”：** 例如，可以查看活动介绍和奖励列表，但参与按钮置灰，旁边有“成为守护者参与”的链接。

---

### **三、灵活的订阅体系 (Flexible Subscription System)**

*“提供选择，但巧妙引导；重视首购，更要培养长期忠诚。”*

**3.1. 多层次与增值选项**

*   **界面E1：订阅选择页面 (Subscription Options Page)**
    *   **触发点：** 点击“了解VIP特权”或“升级”等按钮后跳转。
    *   **布局：**
        *   **至少2-3档选项卡片式并列展示：**
            *   **月卡 (Monthly Guardian):** [价格]，列出核心权益。
            *   **季卡 (Seasonal Guardian):** [价格] (通常比月卡单月价格略低)，列出核心权益 + [额外季度礼包]。**[标记“推荐”或“Popular Choice”]**
            *   **年卡 (Annual Guardian):** [价格] (单月价格最低)，列出核心权益 + [丰厚年度大礼包，如绝版皮肤、大量钻石] + [每月额外守护者福利]。**[标记“最佳价值”或“Best Value”]**
        *   每张卡片清晰标注**“平均每月花费”**，便于对比。
        *   权益列表使用**[✓ 图标和简洁文字]**，突出差异点。
        *   **默认选中“推荐”档位。**
        *   底部有“确认订阅”按钮和“恢复购买”链接。
*   **界面E2：叠加式/主题式小额订阅入口 (可选)**
    *   **触发点：** 在特定功能使用场景下。
    *   **例如，在“自定义目标”创建界面：** 如果用户想创建更多目标但已达免费上限，提示：“想无限制创建目标吗？试试‘目标大师月票’(小额)，或升级成为全能熊猫守护者！”
    *   **此类小额订阅应明确说明是主订阅的补充或特定功能的解锁，避免混淆。**

**3.2. 低门槛试用与精细化挽留**

*   **界面F1：“无风险”免费试用引导 (见界面B1)**
*   **界面F2：试用期价值回顾弹窗**
    *   **触发点：** 免费试用期结束前1-2天。
    *   **弹窗设计：**
        *   **标题：** “您的熊猫守护者体验即将结束！”
        *   **内容（数据化总结）：**
            *   “在过去的X天里，您：”
            *   “额外获得了 [XXX] 竹子和 [YYY] 水！”
            *   “熊猫成长速度提升了 [ZZ]%！”
            *   “解锁并体验了 [N] 个高级冥想课程！”
            *   “节省了大约 [M] 分钟的等待时间（若有加速功能）！”
        *   **行动按钮：** “立即订阅，保留所有特权！”、“查看订阅选项”、“暂时不了”。
*   **界面F3：人性化挽留策略页面/弹窗**
    *   **触发点：** 用户在App Store管理订阅，尝试取消PandaHabit的VIP时（通过服务器端验证实现，或在应用内提供“管理订阅”入口，若用户点击“取消”则触发）。
    *   **弹窗设计（多阶段）：**
        *   **第一层（确认取消）：** “真的要离开熊猫守护者行列吗？[熊猫做出委屈表情]” -> “确认取消” / “再考虑一下”
        *   **第二层（提供降级/折扣，若用户确认取消）：** “我们很遗憾您要离开。我们为您准备了一个特别优惠：**[续订下个月享7折优惠]**，或者您可以选择**[保留核心特权的基础版守护者（价格更低）]**？” -> “接受优惠” / “查看基础版” / “仍然取消”
        *   **第三层（休眠/问卷，若仍取消）：** “好吧，熊猫会想你的。您可以选择**[暂停订阅1个月，所有权益和进度将为您保留]**，未来随时可以回来。或者，可以花1分钟告诉我们离开的原因吗？这将帮助我们改进。” -> “暂停订阅” / “填写问卷” / “直接取消”
        *   **避免死缠烂打，提供清晰的退出路径。**

---

### **四、社交认同与竞争氛围 (Social Proof & Competitive Atmosphere)**

*(主要适用于有社交功能的情况)*

**4.1. 可见的社交影响力**

*   **界面G1：实时动态订阅信息 (可选，谨慎使用)**
    *   **位置：** 商店页面底部滚动条，或主城公告板（若有）。
    *   **内容：** “[玩家昵称] 刚刚加入了熊猫守护者行列，获得了[专属熊猫头饰]！” (需真实，低频，避免打扰)。
*   **界面G2：团队增益提示**
    *   **触发点：** 组队参与合作挑战时。
    *   **界面提示：** 若队伍中有VIP：“队伍中有守护者成员！本次挑战全队竹子获取+5%！”
*   **界面G3：分享裂变激励**
    *   **触发点：** 用户获得重要成就、稀有物品，或完成长期挑战。
    *   **分享弹窗：** 除了分享成就本身，增加一个选项：“邀请好友体验PandaHabit，TA可获得3天守护者试用，您将获得[XXX]竹子奖励！” 分享出去的链接带有专属邀请码。

**4.2. 荣誉与地位彰显**

*   **界面H1：排行榜差异化展示 (见界面C3)**
*   **界面H2：多维度排行榜**
    *   **排行榜页面：** 除了常规进度榜，可增加“熊猫爱心榜”（根据喂养、互动频率，VIP有加成）、“习惯毅力榜”（连续完成任务天数，VIP有特殊标识）。
*   **界面H3：订阅专属成就与称号**
    *   **成就页面/个人资料页：**
        *   **成就列表：** 包含“月度守护者”、“年度守护者”、“皇家赞助人”等与订阅相关的成就。
        *   **称号系统：** 用户可装备获得的称号，VIP称号带有特殊视觉效果。

---

### **五、数据驱动与用户体验保障 (Data-Driven & User Experience Assurance)**

*(这部分主要体现在后台数据分析和产品迭代策略上，前端界面体现较少，但对引导策略的制定至关重要。)*

**5.1. 精细化埋点与漏斗分析**
    *   **后台数据看板：** 展示各付费引导入口的曝光量、点击率、转化率；支付页面各档位选择比例；试用用户关键行为路径；流失节点等。

**5.2. 公平性与长期生态维护**
    *   **游戏内帮助/FAQ页面：** 清晰说明免费版与VIP版的权益区别，强调核心玩法对所有用户开放。
    *   **付费引导文案：** 措辞温和、透明，强调“支持”和“增值”，而非“必需”或“不付费就玩不下去”。
    *   **避免PVP失衡（若有PVP）：** 付费优势不应碾压技巧和策略。

---

### **六、前瞻性探索 (Forward-Looking Exploration)**

*(这部分属于远期规划，初期界面可能不涉及，但可预留接口或思路)*

**6.1. Web3/元宇宙整合**
    *   **个人资料页/成就页：** 可预留展示NFT徽章/数字藏品的区域。
**6.2. 内容共创与激励**
    *   **UGC内容提交/展示区：** 若有UGC功能（如自定义冥想引导分享），VIP用户可享有更高级的编辑工具，其作品旁可有特殊标识。
**6.3. 现实联动与品牌延伸**
    *   **活动中心/消息推送：** 发布线下活动信息，VIP用户报名入口可有优先标识或折扣提示。

---

**⚡ 实施核心原则与策略 (体现在整体设计中) ⚡**

1.  **用户洞察先行：** 所有引导文案、时机、价值点都基于对PandaHabit用户（希望养成好习惯、需要情感支持）的理解。
2.  **价值前置，付费后置：** 免费试用、功能预览、清晰的价值对比都是这一原则的体现。
3.  **A/B测试文化：**
    *   **可测试点：** 付费弹窗的文案、按钮颜色/文字、优惠力度、触发时机、订阅档位默认推荐等。
4.  **MVP与快速迭代：** 先上线核心的付费场景和价值展示，根据数据反馈调整和增加更精细化的引导。
5.  **长期视角：** 挽留策略、公平性保障、避免短期榨取，都是为了LTV。
6.  **红线自查：** 确保所有付费引导不破坏核心免费体验的完整性。

---

**📈 核心追踪指标 (后台数据重点关注) 📈**
*(同Checklist 2.0)*

---

这份界面设计和交互流程的构想，力求将Checklist 2.0的战略思想落地到PandaHabit的具体用户体验中。实际执行时，还需要配合优秀的视觉设计、流畅的动画效果以及精准的文案打磨，才能达到最佳效果。
</file>

<file path="component-multilingual-examples.md">
# PandaHabit 组件多语言支持示例

本文档提供了 PandaHabit 应用中常见组件的多语言支持实现示例，可作为开发者的参考指南。

## 目录

1. [基础组件](#基础组件)
2. [游戏组件](#游戏组件)
3. [任务组件](#任务组件)
4. [商店组件](#商店组件)
5. [反思组件](#反思组件)

## 基础组件

### Button 组件

```typescript
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'jade' | 'gold';
  size?: 'small' | 'medium' | 'large';
  onClick?: () => void;
  disabled?: boolean;
  className?: string;
  children: React.ReactNode;
  // 不需要 labels 属性，因为按钮文本通过 children 传入
}

const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'medium',
  onClick,
  disabled = false,
  className = '',
  children
}) => {
  // 实现...
};
```

### LoadingSpinner 组件

```typescript
interface LoadingSpinnerProps {
  variant?: 'primary' | 'secondary' | 'jade' | 'white';
  size?: 'small' | 'medium' | 'large';
  text?: string; // 加载文本
  className?: string;
}

const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  variant = 'primary',
  size = 'medium',
  text, // 可以传入本地化的加载文本
  className = ''
}) => {
  return (
    <div className={`loading-spinner-container ${className}`}>
      <div className={`spinner spinner-${variant} spinner-${size}`}>
        {/* 加载动画 */}
      </div>
      {text && <div className="loading-text">{text}</div>}
    </div>
  );
};
```

## 游戏组件

### ChallengeCard 组件

```typescript
interface ChallengeCardProps {
  challenge: ChallengeRecord;
  onClick?: (challenge: ChallengeRecord) => void;
  onComplete?: (challengeId: number) => void;
  labels?: {
    statusActive?: string;
    statusCompleted?: string;
    statusExpired?: string;
    statusUpcoming?: string;
    startLabel?: string;
    endLabel?: string;
    completedOnLabel?: string;
    completeButtonText?: string;
    inProgressText?: string;
  };
}

const ChallengeCard: React.FC<ChallengeCardProps> = ({
  challenge,
  onClick,
  onComplete,
  labels
}) => {
  // 获取挑战状态对应的文本
  const getStatusText = () => {
    switch (challenge.status) {
      case ChallengeStatus.ACTIVE:
        return labels?.statusActive || 'Active';
      case ChallengeStatus.COMPLETED:
        return labels?.statusCompleted || 'Completed';
      case ChallengeStatus.EXPIRED:
        return labels?.statusExpired || 'Expired';
      case ChallengeStatus.UPCOMING:
        return labels?.statusUpcoming || 'Upcoming';
      default:
        return '';
    }
  };

  // 处理点击事件
  const handleClick = () => {
    if (onClick) {
      onClick(challenge);
    }
  };

  // 处理完成挑战事件
  const handleComplete = (e: React.MouseEvent) => {
    e.stopPropagation(); // 阻止事件冒泡
    if (onComplete && challenge.status === ChallengeStatus.ACTIVE) {
      onComplete(challenge.id!);
    }
  };

  return (
    <motion.div
      className={`challenge-card ${getStatusClass()} ${getDifficultyClass()}`}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={handleClick}
    >
      {/* 挑战卡片头部 */}
      <div className="challenge-card-header">
        {/* ... */}
        <div className="challenge-meta">
          <span className={`challenge-status ${getStatusClass()}`}>
            {getStatusText()}
          </span>
        </div>
      </div>

      {/* 挑战卡片内容 */}
      <div className="challenge-card-body">
        <p className="challenge-description">{challenge.description}</p>
        <div className="challenge-dates">
          <span>{labels?.startLabel || 'Start'}: {formatTime(challenge.startDate, false)}</span>
          {challenge.endDate && (
            <span>{labels?.endLabel || 'End'}: {formatTime(challenge.endDate, false)}</span>
          )}
        </div>
      </div>

      {/* 挑战卡片底部 */}
      <div className="challenge-card-footer">
        {challenge.status === ChallengeStatus.ACTIVE && (
          <button
            className="complete-challenge-button"
            onClick={handleComplete}
            disabled={challenge.progress < 100}
          >
            {challenge.progress >= 100 
              ? (labels?.completeButtonText || 'Complete Challenge') 
              : (labels?.inProgressText || 'In Progress...')}
          </button>
        )}
        {challenge.status === ChallengeStatus.COMPLETED && (
          <div className="challenge-completed-info">
            <span className="completion-date">
              {labels?.completedOnLabel || 'Completed on'}: {formatTime(challenge.completedDate!, false)}
            </span>
          </div>
        )}
      </div>
    </motion.div>
  );
};
```

## 任务组件

### SubtaskList 组件

```typescript
interface SubtaskListProps {
  parentTaskId: number;
  onSubtasksChange?: (hasSubtasks: boolean) => void;
  labels?: {
    loadErrorMessage?: string;
    addErrorMessage?: string;
    completeErrorMessage?: string;
    deleteErrorMessage?: string;
    reorderErrorMessage?: string;
    addSubtaskPlaceholder?: string;
    addButtonText?: string;
    noSubtasksMessage?: string;
    deleteSubtaskAriaLabel?: string;
  };
}

const SubtaskList: React.FC<SubtaskListProps> = ({ 
  parentTaskId, 
  onSubtasksChange,
  labels 
}) => {
  const [subtasks, setSubtasks] = useState<SubtaskRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [newSubtaskTitle, setNewSubtaskTitle] = useState('');
  const [isAddingSubtask, setIsAddingSubtask] = useState(false);

  // 加载子任务
  const loadSubtasks = async () => {
    try {
      setIsLoading(true);
      setError(null);
      const loadedSubtasks = await getSubtasks(parentTaskId);
      setSubtasks(loadedSubtasks);
      
      // 通知父组件子任务状态变化
      if (onSubtasksChange) {
        onSubtasksChange(loadedSubtasks.length > 0);
      }
    } catch (err) {
      console.error('Failed to load subtasks:', err);
      setError(labels?.loadErrorMessage || 'Failed to load subtasks, please try again');
    } finally {
      setIsLoading(false);
    }
  };

  // 处理添加子任务
  const handleAddSubtask = async () => {
    if (!newSubtaskTitle.trim()) return;

    try {
      setIsAddingSubtask(true);
      await createSubtask({
        parentTaskId,
        title: newSubtaskTitle.trim()
      });
      setNewSubtaskTitle('');
      playSound(SoundType.BUTTON_CLICK, 0.3);
      await loadSubtasks();
    } catch (err) {
      console.error('Failed to add subtask:', err);
      setError(labels?.addErrorMessage || 'Failed to add subtask, please try again');
    } finally {
      setIsAddingSubtask(false);
    }
  };

  // JSX 部分
  return (
    <div className="subtasks-list">
      {/* 子任务列表 */}
      {/* ... */}
      
      {/* 添加子任务表单 */}
      <div className="add-subtask-form mt-4">
        <div className="flex">
          <input
            type="text"
            value={newSubtaskTitle}
            onChange={(e) => setNewSubtaskTitle(e.target.value)}
            placeholder={labels?.addSubtaskPlaceholder || "Add new subtask..."}
            className="flex-grow p-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-2 focus:ring-jade-500"
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                handleAddSubtask();
              }
            }}
          />
          <Button
            variant="jade"
            onClick={handleAddSubtask}
            disabled={!newSubtaskTitle.trim() || isAddingSubtask}
            className="rounded-l-none"
          >
            {isAddingSubtask ? (
              <LoadingSpinner variant="white" size="small" />
            ) : (
              labels?.addButtonText || 'Add'
            )}
          </Button>
        </div>
      </div>
    </div>
  );
};
```

## 商店组件

### StoreItemCard 组件

```typescript
interface StoreItemCardProps {
  item: StoreItemRecord;
  onPurchase?: (item: StoreItemRecord) => void;
  onPreview?: (item: StoreItemRecord) => void;
  userCoins?: number;
  userJade?: number;
  isVip?: boolean;
  labels?: {
    vipRequiredError?: string;
    insufficientCoinsError?: string;
    insufficientJadeError?: string;
    purchaseError?: string;
    rarityLabels?: {
      common?: string;
      uncommon?: string;
      rare?: string;
      epic?: string;
      legendary?: string;
    };
    vipExclusiveLabel?: string;
    saleLabel?: string;
    buyButtonText?: string;
  };
}

const StoreItemCard: React.FC<StoreItemCardProps> = ({
  item,
  onPurchase,
  onPreview,
  userCoins = 0,
  userJade = 0,
  isVip = false,
  labels
}) => {
  const [isPurchasing, setIsPurchasing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // 处理购买物品
  const handlePurchase = async (e: React.MouseEvent) => {
    e.stopPropagation(); // 阻止事件冒泡
    
    // 检查是否需要VIP
    if (item.vipRequired && !isVip) {
      setError(labels?.vipRequiredError || 'VIP membership required');
      return;
    }
    
    // 检查是否有足够的货币
    const price = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;
    if (item.priceType === PriceType.COINS && userCoins < price) {
      setError(labels?.insufficientCoinsError || 'Not enough coins');
      return;
    }
    if (item.priceType === PriceType.JADE && userJade < price) {
      setError(labels?.insufficientJadeError || 'Not enough jade');
      return;
    }
    
    // 购买物品
    try {
      setIsPurchasing(true);
      setError(null);
      
      // 调用购买API
      await purchaseStoreItem(item.id!);
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 通知父组件
      if (onPurchase) {
        onPurchase(item);
      }
    } catch (err) {
      console.error('Failed to purchase item:', err);
      setError(labels?.purchaseError || 'Failed to purchase item');
    } finally {
      setIsPurchasing(false);
    }
  };
  
  // JSX 部分
  return (
    <motion.div className="store-item-card">
      {/* 物品图片 */}
      <div className="item-image-container relative">
        {/* ... */}
        
        {/* VIP标签 */}
        {item.vipRequired && (
          <div className="vip-badge absolute top-2 left-2 px-2 py-1 rounded-full text-xs bg-amber-100 text-amber-800 border border-amber-300">
            {labels?.vipExclusiveLabel || 'VIP Exclusive'}
          </div>
        )}
        
        {/* 促销标签 */}
        {item.isOnSale && item.salePrice !== undefined && (
          <div className="sale-badge absolute bottom-2 left-2 px-2 py-1 rounded-full text-xs bg-red-100 text-red-800 border border-red-300">
            {labels?.saleLabel || 'Sale'}
          </div>
        )}
      </div>
      
      {/* 购买按钮 */}
      <Button
        variant="jade"
        size="small"
        onClick={handlePurchase}
        disabled={isPurchasing || !canAfford() || (item.vipRequired && !isVip)}
      >
        {isPurchasing ? (
          <LoadingSpinner variant="white" size="small" />
        ) : (
          labels?.buyButtonText || 'Buy'
        )}
      </Button>
    </motion.div>
  );
};
```

## 反思组件

### MoodTracker 组件

```typescript
interface MoodTrackerProps {
  onMoodRecorded?: (mood: MoodRecord) => void;
  compact?: boolean;
  className?: string;
  labels?: {
    title?: string;
    currentMoodQuestion?: string;
    intensityLabel?: string;
    noteLabel?: string;
    notePlaceholder?: string;
    recordMoodButton?: string;
    historyLabel?: string;
    backLabel?: string;
    noMoodsMessage?: string;
    intensityStrength?: {
      veryMild?: string;
      mild?: string;
      moderate?: string;
      strong?: string;
      veryStrong?: string;
    };
  };
}

const MoodTracker: React.FC<MoodTrackerProps> = ({
  onMoodRecorded,
  compact = false,
  className = '',
  labels
}) => {
  // 状态和逻辑...
  
  // 获取强度标签
  const getIntensityLabel = (intensity: MoodIntensity) => {
    switch (intensity) {
      case 1: return labels?.intensityStrength?.veryMild || 'Very Mild';
      case 2: return labels?.intensityStrength?.mild || 'Mild';
      case 3: return labels?.intensityStrength?.moderate || 'Moderate';
      case 4: return labels?.intensityStrength?.strong || 'Strong';
      case 5: return labels?.intensityStrength?.veryStrong || 'Very Strong';
      default: return 'Unknown';
    }
  };
  
  // JSX 部分
  return (
    <div className={`mood-tracker ${className}`}>
      <div className="mood-tracker-header flex justify-between items-center mb-4">
        <h2 className="text-xl font-bold text-jade-700">
          <span className="mr-2">🍵</span>
          {labels?.title || "Mood Tracking"}
        </h2>
        <Button
          variant="secondary"
          size="small"
          onClick={() => setShowHistory(!showHistory)}
        >
          {showHistory ? (labels?.backLabel || "Back") : (labels?.historyLabel || "History")}
        </Button>
      </div>
      
      {/* 情绪选择器 */}
      <div className="mood-selector">
        <h3 className="text-lg font-bold mb-3">
          {labels?.currentMoodQuestion || "How are you feeling right now?"}
        </h3>
        {/* 情绪选项 */}
      </div>
      
      {/* 强度选择器 */}
      <div className="intensity-selector mt-4">
        <h3 className="text-lg font-bold mb-2">
          {labels?.intensityLabel || "How intense is this feeling?"}
        </h3>
        {/* 强度滑块 */}
      </div>
      
      {/* 笔记输入框 */}
      <div className="note-input mt-4">
        <h3 className="text-lg font-bold mb-2">
          {labels?.noteLabel || "Anything you'd like to note? (optional)"}
        </h3>
        <textarea
          value={note}
          onChange={(e) => setNote(e.target.value)}
          className="w-full p-3 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500 h-24"
          placeholder={labels?.notePlaceholder || "Write down your thoughts..."}
        />
      </div>
      
      {/* 提交按钮 */}
      <div className="form-actions mt-4 flex justify-end">
        <Button
          variant="jade"
          onClick={handleSubmit}
          disabled={isSubmitting}
        >
          {labels?.recordMoodButton || "Record Mood"}
        </Button>
      </div>
    </div>
  );
};
```

## 结论

通过以上示例，可以看到如何为不同类型的组件实现多语言支持。关键点包括：

1. 为组件添加 `labels` 属性，包含所有需要本地化的文本
2. 为每个文本提供英文默认值作为回退
3. 确保错误消息和状态文本也使用本地化标签
4. 在父组件中正确传递标签给子组件

遵循这些模式可以确保 PandaHabit 应用提供一致的多语言体验。
</file>

<file path="docs/component-development-guide.md">
# 组件开发指南

本文档提供了PandaHabit应用中组件开发的指南和最佳实践，特别关注多语言支持和组件复用。

## 目录

1. [多语言支持](#多语言支持)
2. [组件设计原则](#组件设计原则)
3. [通用组件](#通用组件)
4. [数据刷新与局部更新](#数据刷新与局部更新)
5. [最佳实践](#最佳实践)

## 多语言支持

PandaHabit应用支持中文和英文两种语言，所有面向用户的文本都应该使用多语言支持机制。

### 多语言架构

应用使用以下架构实现多语言支持：

1. **LanguageProvider**：管理全局语言状态（`en` | `zh`）
2. **localizedContentService**：提供本地化内容的服务
3. **useLocalizedView**：用于获取页面级别的本地化内容
4. **useComponentLabels**：用于获取组件级别的本地化内容

### 组件中使用多语言

对于通用组件，应使用`useComponentLabels`钩子获取本地化标签：

```tsx
import { useComponentLabels } from '@/hooks/useComponentLabels';

const MyComponent = () => {
  const { labels } = useComponentLabels();
  
  return (
    <div>
      <h2>{labels.someSection.title}</h2>
      <p>{labels.someSection.description}</p>
      <button>{labels.button.submit}</button>
    </div>
  );
};
```

对于页面组件，应使用`useLocalizedView`钩子获取页面级别的本地化内容：

```tsx
const {
  labels: pageLabels,
  isPending,
  isError,
  error,
  refetch
} = useLocalizedView<null, PageViewLabelsBundle>(
  'pageViewContent',
  fetchPageView
);

// 处理加载状态
if (isPending && !pageLabels) {
  return <LoadingSpinner variant="jade" type="content" />;
}

// 处理错误状态
if (isError && !pageLabels) {
  return (
    <div className="page-content">
      <ErrorDisplay error={error} onRetry={refetch} />
    </div>
  );
}
```

### 添加新的本地化标签

1. 在`src/types/index.ts`中定义标签类型
2. 在`src/services/localizedContentService.ts`中添加获取标签的函数
3. 在数据库中添加对应的标签记录

## 组件设计原则

### 1. 组件分类

PandaHabit应用中的组件分为以下几类：

- **通用组件**：如Button、LoadingSpinner、ErrorDisplay等，位于`components/common`目录
- **布局组件**：如AppShell、Header、Navigation等，位于`components/layout`目录
- **功能组件**：如TaskList、PandaAvatar等，位于对应功能的目录
- **页面组件**：如HomePage、SettingsPage等，位于`pages`目录

### 2. 组件接口设计

- 组件应该有明确的接口定义（TypeScript接口）
- 提供合理的默认值和可选参数
- 使用解构赋值接收props
- 使用函数组件和React Hooks

### 3. 组件文档

每个组件都应该有清晰的文档注释，包括：

- 组件的功能描述
- 参数说明
- 使用示例

```tsx
/**
 * 按钮组件，支持不同样式和加载状态
 *
 * @param variant - 按钮样式：'primary'（默认）, 'secondary', 'jade'（游戏风格绿色）, 'gold'（高级）
 * @param isLoading - 是否显示加载状态
 * @param loadingText - 加载状态显示的文本（覆盖默认本地化文本）
 */
```

## 通用组件

PandaHabit应用提供了以下通用组件，应优先使用这些组件以保持UI一致性：

### Button

按钮组件，支持不同样式和加载状态。

```tsx
<Button 
  variant="jade" 
  isLoading={isSubmitting} 
  onClick={handleSubmit}
>
  提交
</Button>
```

### LoadingSpinner

加载指示器组件，支持游戏风格。

```tsx
<LoadingSpinner 
  variant="jade" 
  type="data" 
  text="自定义加载文本" 
/>
```

### ErrorDisplay

错误显示组件，用于展示错误信息。

```tsx
<ErrorDisplay 
  error={error} 
  onRetry={handleRetry} 
  errorType="network" 
/>
```

### DataLoader

数据加载组件，处理加载、错误和空数据状态。

```tsx
<DataLoader
  isLoading={isLoading}
  isError={isError}
  error={error}
  data={data}
  onRetry={refetch}
>
  {(data) => (
    // 渲染数据
    <div>{data.name}</div>
  )}
</DataLoader>
```

### Modal

模态框组件，用于显示弹出内容。

```tsx
<Modal
  isOpen={isOpen}
  onClose={handleClose}
  closeOnOutsideClick={true}
>
  <div>模态框内容</div>
</Modal>
```

## 数据刷新与局部更新

PandaHabit应用使用DataRefreshProvider实现数据同步后的局部UI更新。

### 使用DataRefreshProvider

```tsx
// 监听多个表
useDataRefresh(['table1', 'table2'], (event) => {
  // 处理数据刷新
});

// 或监听单个表
useTableRefresh('tableName', (data) => {
  // 处理表数据刷新
});
```

## 最佳实践

### 1. 避免硬编码文本

❌ 错误示例：
```tsx
<button>提交</button>
<p>暂无数据</p>
```

✅ 正确示例：
```tsx
<button>{labels.button.submit}</button>
<p>{labels.emptyState.noData}</p>
```

### 2. 使用组件而非直接使用HTML元素

❌ 错误示例：
```tsx
<button className="button-primary" onClick={handleClick}>
  {isLoading ? "加载中..." : "提交"}
</button>
```

✅ 正确示例：
```tsx
<Button 
  variant="primary" 
  isLoading={isLoading} 
  onClick={handleClick}
>
  提交
</Button>
```

### 3. 处理加载和错误状态

❌ 错误示例：
```tsx
if (isLoading) return <div>加载中...</div>;
if (isError) return <div>出错了</div>;
```

✅ 正确示例：
```tsx
if (isLoading) return <LoadingSpinner type="data" />;
if (isError) return <ErrorDisplay error={error} onRetry={refetch} />;
```

### 4. 使用DataLoader组件处理数据加载

❌ 错误示例：
```tsx
if (isLoading) return <LoadingSpinner />;
if (isError) return <ErrorDisplay error={error} />;
if (!data) return <div>暂无数据</div>;
return <div>{data.name}</div>;
```

✅ 正确示例：
```tsx
<DataLoader
  isLoading={isLoading}
  isError={isError}
  error={error}
  data={data}
  onRetry={refetch}
>
  {(data) => <div>{data.name}</div>}
</DataLoader>
```

### 5. 使用局部刷新而非整页刷新

❌ 错误示例：
```tsx
// 数据变化时刷新整个组件
useEffect(() => {
  fetchData();
}, [someData]);
```

✅ 正确示例：
```tsx
// 监听特定表的变化
useTableRefresh('tableName', (updatedData) => {
  // 只更新受影响的部分
  updateLocalState(updatedData);
});
```
</file>

<file path="docs/multilingual-support-fixes.md">
# 组件多语言支持开发指南

本文档提供了PandaHabit应用中组件多语言支持的实现指南和最佳实践，帮助开发者正确使用多语言功能并避免硬编码文本。

## 目录

1. [多语言架构概述](#多语言架构概述)
2. [组件多语言支持实现](#组件多语言支持实现)
3. [常见组件的多语言支持](#常见组件的多语言支持)
4. [硬编码文本修复指南](#硬编码文本修复指南)
5. [最佳实践](#最佳实践)

## 多语言架构概述

PandaHabit应用使用以下架构实现多语言支持：

1. **LanguageProvider**：管理全局语言状态（`en` | `zh`）
   - 提供当前语言和切换语言的方法
   - 将语言选择保存到本地存储

2. **localizedContentService**：提供本地化内容的服务
   - 从数据库获取特定语言的标签
   - 为各个页面和组件提供本地化内容

3. **useLocalizedView**：用于获取页面级别的本地化内容
   - 自动处理语言切换
   - 提供加载状态和错误处理

4. **useComponentLabels**：用于获取组件级别的本地化内容
   - 提供通用组件所需的本地化标签
   - 包含合理的默认值作为后备

## 组件多语言支持实现

### 组件标签类型定义

在`src/types/index.ts`中，我们定义了组件标签的类型：

```typescript
// 按钮标签
export interface ButtonLabels {
  loading: string;
  retry: string;
  confirm: string;
  cancel: string;
  save: string;
  close: string;
  submit: string;
  edit: string;
  delete: string;
  back: string;
  next: string;
}

// 加载状态标签
export interface LoadingLabels {
  generic: string;
  data: string;
  content: string;
  saving: string;
  processing: string;
}

// 错误标签
export interface ErrorLabels {
  generic: string;
  title: string;
  retry: string;
  details: string;
  networkError: string;
  serverError: string;
  unknownError: string;
}

// 空状态标签
export interface EmptyStateLabels {
  generic: string;
  noData: string;
  noResults: string;
  noItems: string;
}

// 模态框标签
export interface ModalLabels {
  close: string;
  confirm: string;
  cancel: string;
}

// 组件标签集合
export interface ComponentsLabelsBundle {
  button: ButtonLabels;
  loading: LoadingLabels;
  error: ErrorLabels;
  emptyState: EmptyStateLabels;
  modal: ModalLabels;
}
```

### 获取组件标签的服务

在`src/services/localizedContentService.ts`中，我们添加了获取组件标签的函数：

```typescript
/**
 * 获取组件本地化标签
 * 
 * @param lang - 语言代码
 * @returns 组件标签集合
 */
export async function fetchComponentsLabels(lang: Language): Promise<FetchComponentsLabelsResult> {
  console.log(`SVC_DEXIE: Fetching COMPONENTS LABELS for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<ComponentsLabelsBundle>('components', lang);
  return { labels, data: null };
}
```

### 组件标签Hook

在`src/hooks/useComponentLabels.ts`中，我们创建了一个专用Hook来获取组件标签：

```typescript
/**
 * 获取组件本地化标签的Hook
 * 
 * @returns 组件标签和加载/错误状态
 */
export function useComponentLabels() {
  const {
    labels: componentLabels,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<null, ComponentsLabelsBundle>(
    'componentsLabels',
    fetchComponentsLabels
  );

  // 默认后备标签
  const fallbackLabels: Partial<ComponentsLabelsBundle> = {
    button: {
      loading: 'Loading...',
      retry: 'Retry',
      // ... 其他按钮标签
    },
    loading: {
      generic: 'Loading...',
      data: 'Loading data...',
      // ... 其他加载标签
    },
    // ... 其他标签类别
  } as ComponentsLabelsBundle;

  // 合并获取的标签和后备标签，优先使用获取的标签
  const mergedLabels = componentLabels
    ? {
        button: { ...fallbackLabels.button, ...componentLabels.button },
        // ... 合并其他标签类别
      }
    : fallbackLabels;

  return {
    labels: mergedLabels,
    isPending,
    isError,
    error,
    refetch
  };
}
```

## 常见组件的多语言支持

### Button组件

```tsx
const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'primary',
  isLoading = false,
  loadingText,
  ...props
}) => {
  // 获取本地化标签
  const { labels } = useComponentLabels();
  // 使用提供的loadingText或回退到本地化标签
  const finalLoadingText = loadingText || labels.button.loading;
  
  return (
    <button
      className={`${baseStyle} ${variantStyle}`.trim()}
      disabled={isLoading || props.disabled}
      {...props}
    >
      {isLoading ? finalLoadingText : children}
    </button>
  );
};
```

### LoadingSpinner组件

```tsx
const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  text,
  variant = 'default',
  type = 'generic'
}) => {
  const { labels } = useComponentLabels();
  const spinnerClass = variant === 'jade' ? 'jade-spinner' : 'loading-spinner';
  
  // 使用提供的text或回退到基于type的本地化标签
  const displayText = text || labels.loading[type];

  return (
    <div className="loading-spinner-overlay">
      <div className={spinnerClass}></div>
      {displayText && <p className="loading-spinner-text">{displayText}</p>}
    </div>
  );
};
```

### ErrorDisplay组件

```tsx
const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  title,
  messageTemplate,
  onRetry,
  retryButtonText,
  errorType = 'generic',
}) => {
  const { labels } = useComponentLabels();
  
  // 使用提供的值或回退到本地化标签
  const displayTitle = title || labels.error.title;
  const displayMessageTemplate = messageTemplate || labels.error.details;
  const displayRetryButtonText = retryButtonText || labels.error.retry;
  
  // ... 错误处理逻辑
  
  return (
    <div className="error-container" role="alert">
      <h3>{displayTitle}</h3>
      <p className="error-text">{finalMessage}</p>
      {/* ... 其他错误信息 */}
      {onRetry && (
        <Button onClick={onRetry} variant="secondary">
          {displayRetryButtonText}
        </Button>
      )}
    </div>
  );
};
```

### DataLoader组件

```tsx
function DataLoader<T>({
  isLoading,
  isError,
  error,
  data,
  loadingText,
  errorTitle,
  onRetry,
  emptyState,
  children,
  loadingComponent,
  errorComponent
}: DataLoaderProps<T>) {
  // 获取本地化标签
  const { labels } = useComponentLabels();
  
  // ... 加载、错误和空数据状态处理
  
  // 空数据状态示例
  if (!data) {
    return (
      <motion.div className="data-loader-container">
        {emptyState || (
          <div className="empty-state">
            <p>{labels.emptyState.noData}</p>
          </div>
        )}
      </motion.div>
    );
  }
  
  // 渲染数据
  return <>{children(data)}</>;
}
```

## 硬编码文本修复指南

### 识别硬编码文本

硬编码文本是指直接写在组件中的文本字符串，例如：

```tsx
// 硬编码文本示例
<button>提交</button>
<p>暂无数据</p>
<div>加载中...</div>
```

### 修复步骤

1. **识别组件中的硬编码文本**
   - 查找直接写在JSX中的字符串
   - 查找默认值中的字符串

2. **添加适当的标签类型**
   - 如果是通用文本（如"加载中"、"提交"等），使用现有的ComponentsLabelsBundle
   - 如果是特定功能的文本，添加新的标签类型

3. **使用useComponentLabels获取标签**
   - 在组件中导入并使用useComponentLabels
   - 使用标签替换硬编码文本

4. **提供合理的默认值作为后备**
   - 确保即使标签获取失败也能显示合理的文本

## 最佳实践

### 1. 避免硬编码文本

❌ 错误示例：
```tsx
<button>提交</button>
<p>暂无数据</p>
```

✅ 正确示例：
```tsx
<button>{labels.button.submit}</button>
<p>{labels.emptyState.noData}</p>
```

### 2. 使用组件而非直接使用HTML元素

❌ 错误示例：
```tsx
<button className="button-primary" onClick={handleClick}>
  {isLoading ? "加载中..." : "提交"}
</button>
```

✅ 正确示例：
```tsx
<Button 
  variant="primary" 
  isLoading={isLoading} 
  onClick={handleClick}
>
  {labels.button.submit}
</Button>
```

### 3. 处理加载和错误状态

❌ 错误示例：
```tsx
if (isLoading) return <div>加载中...</div>;
if (isError) return <div>出错了</div>;
```

✅ 正确示例：
```tsx
if (isLoading) return <LoadingSpinner type="data" />;
if (isError) return <ErrorDisplay error={error} onRetry={refetch} />;
```

### 4. 提供覆盖选项但使用默认本地化文本

❌ 错误示例：
```tsx
<Button loadingText="Loading...">Submit</Button>
```

✅ 正确示例：
```tsx
// 不指定loadingText，使用默认本地化文本
<Button isLoading={isSubmitting}>{labels.button.submit}</Button>

// 或在需要特殊文本时提供覆盖
<Button loadingText={customLoadingText}>Custom Action</Button>
```

### 5. 使用类型系统确保标签完整性

❌ 错误示例：
```tsx
// 未定义类型，可能缺少标签
const labels = {
  submit: "提交",
  cancel: "取消"
};
```

✅ 正确示例：
```tsx
// 使用接口确保标签完整性
interface ButtonLabels {
  submit: string;
  cancel: string;
  edit: string;
  // 其他必要标签
}

const labels: ButtonLabels = {
  submit: "提交",
  cancel: "取消",
  edit: "编辑"
  // TypeScript会检查是否缺少标签
};
```
</file>

<file path="germini.md">
好的，以下是PandaHabit App Design Brief的独立完整内容，已避免使用“保持不变”或“与上相同”等词语，并确保所有部分都是具体和详细的。

---

**PandaHabit App Design Brief: 华丽游戏风格 (融合订阅增长优化)**

**版本:** 1.2
**日期:** May 15, 2025
**状态:** 最终稿

## 1. Introduction

### 1.1 Overview
PandaHabit是一款移动应用，通过引人入胜且支持性的虚拟宠物体验，帮助用户建立积极的习惯，改善自我护理，提升心理健康。用户通过完成现实生活中的任务和习惯来培养虚拟熊猫，创造一种共生关系，照顾自己直接有益于宠物，而宠物则提供陪伴、动力和温和的指导。

### 1.2 华丽游戏风格设计理念 (融合价值驱动)
PandaHabit的设计理念围绕创造一种**华丽奢华且价值驱动的游戏体验**，给人以高级感、沉浸感和情感满足感。应用旨在通过利用精美绚丽的视觉效果、精心设计的交互和令人惊叹的动画效果，将自我护理从一项琐事转变为一段愉悦的旅程。我们采用了东方美学与现代游戏设计相结合的方式，打造出一个既华丽壮观又温馨舒适的数字空间。所有华丽的视觉和交互，都服务于清晰地传递PandaHabit为用户带来的核心价值，特别是VIP订阅所能提供的卓越支持与体验升级。

### 1.3 目标用户
-   寻求习惯养成和自我护理工具的个人。
-   喜欢游戏化和虚拟宠物体验的用户。
-   渴望获得支持性、温和方式进行个人发展的人群。
-   年龄范围：18-45岁，重点关注年轻专业人士和学生。
-   欣赏高品质数字体验并清晰感知价值后愿意投资优质应用的用户。
-   对东方美学和华丽视觉风格有偏好的玩家。

## 2. 华丽游戏风格分析 (强调订阅价值的视觉呈现)

### 2.1 华丽游戏风格定义
对于PandaHabit，"华丽游戏风格"的定义包括：
-   **绚丽华美的视觉效果**，包含精细的插画和动画，灵感来源于东方美学和传统中国艺术。VIP专属内容（如皮肤、场景）将采用更高级别的细节和光效，以彰显其独特性。
-   **金碧辉煌的色彩搭配**，融合深沉的宝石色调、金色点缀、精致的渐变和传统中国色彩。金色和特定宝石色（如紫檀紫）将优先用于VIP相关元素，营造尊贵感。
-   **精雕细琢的UI元素**，注重阴影、高光和纹理细节，采用传统中国装饰元素（如云纹、如意纹）。VIP相关按钮、卡片将拥有更复杂的纹饰和更显著的动态效果。
-   **流畅华丽的动画效果**，提供视觉反馈和愉悦感，动画风格融合现代游戏与传统水墨画动态美感。VIP特权带来的加速、额外奖励等将通过更炫丽、更具冲击力的动画来体现。
-   **沉浸式音效设计**，结合平静的自然声音、传统中国乐器和温柔的音乐元素。VIP专属场景或互动将配备独特的背景音乐或音效。
-   **精心设计的字体排版**，平衡可读性与美学吸引力，中文使用优雅的书法风格字体。VIP身份标识、特权描述将使用更具艺术感的字体或特殊排版。

### 2.2 视觉参考与灵感来源
-   **高品质移动游戏**：《原神》(整体UI风格与动效)、《天涯明月刀》(中国风元素)、《阴阳师》(华丽特效)。
-   **中国传统艺术**：水墨画、竹子图案、山水画、传统纹饰、剪纸艺术、京剧脸谱元素。
-   **奢侈品牌应用**：上海滩、故宫文创、Louis Vuitton中国版。
-   **自然启发设计**：国家地理、高端度假村网站、中国园林设计。
-   **古典游戏美学**：《轩辕剑》系列、《仙剑奇侠传》系列的视觉风格。
-   **现代中国风设计**：当代中国插画师作品、新中式设计元素。

### 2.3 华丽色彩方案 (突出VIP尊贵感)
-   **主要色彩**:
    -   皇家翡翠绿 (#1A5F4A)：代表成长、宁静与自然，灵感来自传统中国玉器。
    -   富贵竹绿 (#88B04B)：象征熊猫的食物和活力，传递生机与希望。
    -   瑞雪白 (#F7F9F9)：提供视觉呼吸空间和清晰度，象征纯净与和谐。
    -   朱砂红 (#D73E35)：传统中国红，象征喜庆、活力与好运。
-   **点缀色彩**:
    -   **华贵金 (#D4AF37):** 大量用于VIP身份标识、特权奖励、付费按钮、重要成就等，象征尊贵与价值。
    -   青花蓝 (#1A6DB0)：代表水分和流动，灵感来自青花瓷。
    -   牡丹粉 (#F8C8DC)：增添温暖和情感连接，灵感来自中国传统花卉。
    -   **紫檀紫 (#5D3954):** 可用于VIP专属界面的背景或高级订阅档位的视觉强调，增添神秘与高贵。
-   **功能色彩**:
    -   如意绿 (#2E8B57)：表示完成和积极成果，灵感来自如意玉器。VIP用户完成任务或获得奖励时，此绿色可带有金色粒子效果。
    -   琥珀黄 (#FFA500)：引起注意但不刺眼，灵感来自古代琥珀饰品。
    -   墨灰 (#8A8D91)：用于次要文本和非活动元素，灵感来自水墨画。

### 2.4 字体设计 (区分普通与VIP信息)
-   **主标题字体**:
    -   中文："方正清刻本悦宋"，传递典雅与永恒感。
    -   英文："Playfair Display"，与中文字体风格相协调。
    -   用于页面标题、成就名称和重要标签，配以金色描边增强华丽感。
-   **正文字体**:
    -   中文："思源宋体"，高可读性，带有友好、平易近人的感觉。
    -   英文："Nunito Sans"，与中文字体搭配和谐。
    -   用于任务描述、说明和一般内容，保持清晰易读。
-   **装饰字体 / VIP专属字体**:
    -   中文："庞门正道行书" 或 更具识别度的付费书法字体（如“汉仪尚巍手书”）。
    -   英文："Caveat" 或 更优雅的衬线手写体。
    -   用于VIP特权描述、专属活动标题、熊猫的特殊VIP问候等，增强独特性和情感连接。

### 2.5 UI组件设计指南 (强化VIP元素的视觉层级)
-   **按钮**：
    *   普通按钮：传统中国风格元素装饰的软圆角矩形，配以精致渐变。
    *   VIP/付费引导按钮：采用更华丽的云纹、如意纹或龙纹装饰，颜色以华贵金、朱砂红为主，配以动态光效、更显著的粒子效果，点击动画更具冲击力。
-   **卡片**：
    *   普通卡片：层叠设计，精致阴影和纹理背景，传统纹饰边框。
    *   VIP特权展示卡片/订阅选项卡片：边框采用更复杂的金色或红色描边，背景可使用丝绸或锦缎等高级纹理，重要信息区域可有微光浮动效果。
-   **图标**：
    *   普通图标：水墨画风格，笔触一致，圆润边角。
    *   VIP专属功能图标：在水墨风格基础上增加金色点缀或微小动态光效，使其在视觉上更突出。
-   **进度指示器**：
    *   普通进度条：优雅环形或线性，水墨晕染填充。
    *   及时性进度条/VIP加速进度条：采用更华丽的卷轴或龙形竹简形式，填充动画可加入金色粒子流光效果，完成时有更盛大的庆祝动画。
-   **输入框**：简约设计，带有微妙边框和焦点状态，边框采用传统纹饰，激活时有水墨扩散效果。
-   **弹窗**：
    *   普通弹窗：居中设计，装饰性框架采用传统窗棂样式，半透明背景模仿宣纸质感。
    *   VIP引导/优惠弹窗：框架可采用更华丽的雕花或镶金设计，背景可加入动态祥云或牡丹盛开等元素，按钮设计参照VIP按钮。

## 3. 信息架构 (融入付费引导点)

### 3.1 导航结构
PandaHabit将使用底部标签导航，具有以下主要部分，每个导航图标都采用华丽的中国风设计：

1.  **主页（竹林家园）**：主仪表盘，展示熊猫、及时奖励进度条和快速操作。背景为动态竹林场景。显眼位置预留VIP身份标识和快速升级入口（如一个闪耀的皇冠图标）。
2.  **任务（修行之路）**：日常任务列表和管理，设计为古代卷轴样式。任务奖励预览时，清晰区分免费与VIP额外奖励（视觉上用金色高亮VIP部分）。
3.  **挑战（江湖历练）**：长期目标和特别活动，设计为地图探险风格。VIP专属挑战用特殊标识（如金色龙纹）和更华丽的卡片背景。
4.  **旅程（成长之道）**：熊猫成长路径和里程碑，设计为传统山水画卷。VIP用户在成长路径上可解锁额外的奖励节点或专属纪念物。
5.  **商店（珍宝阁）**：装饰物品、资源和VIP订阅，设计为古代商铺风格。商店首页显著位置展示“熊猫守护者特权”入口和限时订阅优惠。

次要导航包括：
-   **熊猫互动（心灵相通）**：通过点击主页上的熊猫访问，设计为精美的互动场景。
-   **幸运抽奖（福缘抽签）**：通过顶部导航中的专用图标访问，设计为传统抽签与宝箱相结合的形式。VIP用户每日可获得额外免费抽奖次数，界面上清晰提示。
-   **设置（玉简设定）**：通过右上角的齿轮图标访问，图标设计为古代玉简。
-   **反思模块（静心茶室）**：根据用户行为情境触发，设计为宁静的传统茶室环境。部分高级反思引导或深度心理支持工具可作为VIP特权。
-   **VIP中心（紫宸殿/麒麟阁）**：通过主页VIP图标或商店进入，集中展示所有VIP特权、订阅选项、专属活动和礼包领取。设计极为华丽，彰显尊贵。

### 3.2 用户流程图 (集成订阅引导策略)
关键用户流程包括，每个流程都配有华丽的过渡动画和视觉引导：

1.  **新用户引导（初入仙境）**：
    *   应用介绍（古卷展开动画）→ 熊猫定制（水墨渲染效果）→ 首个任务设置（卷轴书写动画）→ 任务完成（金光特效）→ 奖励（宝箱开启动画，清晰展示免费奖励，并用灰色或锁定的形式预览VIP可额外获得的奖励，附带“成为守护者解锁”提示）→ 主页（竹林展开效果）。
    *   完成新手引导系列任务后，触发“里程碑式首购礼包”弹窗（界面D2）。
2.  **日常习惯打卡（每日修行）**：
    *   通知（熊猫信使动画）→ 任务页面（卷轴展开）→ 任务完成（墨迹渲染动画，VIP额外奖励部分用金色高亮并播放更华丽的粒子效果）→ 及时奖励（金币飞舞效果）→ 熊猫互动（熊猫欢喜动画）。
    *   若熊猫体力不足/幸运点数不足，触发“资源/时间节省提示”（界面B2）。
3.  **挑战参与（江湖探索）**：
    *   挑战页面（地图展开动画）→ 挑战选择（地点点亮效果，若为VIP专属挑战，点击后提示“此为守护者专属历练，立即加入？”）→ 日常子任务（小卷轴展开）→ 进度跟踪（地图路径点亮）→ 完成奖励（宝箱华丽开启）。
    *   完成重要挑战/获得稀有掉落，触发“高光时刻助推弹窗”（界面C1）。
4.  **反思过程（茶道静心）**：
    *   触发事件（茶杯图标出现）→ 温和提示（熊猫邀请动画）→ 反思问题（水墨扩散效果）→ 支持性反馈（熊猫安慰动画，若用户持续低迷，熊猫可推荐“守护者专属阳光心情冥想系列”）→ 行动建议（竹简展开效果）。
5.  **VIP转化（飞升之路）**：
    *   情景触发点 (如点击锁定的VIP功能、看到VIP好友的专属外观、遇到痛点时的解决方案提示)。
    *   引导至“VIP特权总览页”（界面A1）或直接弹出“订阅选择页面”（界面E1）。
    *   订阅选择页面（界面E1）：强调锚点定价、价值打包，“最佳价值”选项使用更华丽的边框和动态光效。
    *   购买确认（祥云环绕动画，伴随“恭喜成为熊猫守护者！”的华丽文本和熊猫的祝贺动画）。

### 3.3 屏幕层次结构
屏幕层次结构遵循从一般到特定的逻辑进展，每一层都有独特的视觉风格：

-   **第一层**：主标签屏幕（竹林家园、修行之路、江湖历练、成长之道、珍宝阁），设计为完整的场景画面。
-   **第二层**：特定功能屏幕（心灵相通、福缘抽签、玉简设定、VIP中心），设计为主场景的特写或变体。
-   **第三层**：详情屏幕（任务详情、挑战详情、物品详情、VIP特权详情），设计为精美的卷轴或玉简展开。
-   **第四层**：流程屏幕（静心茶室、VIP购买流程、任务创建流程），设计为特殊互动场景。

## 4. Detailed UI/UX Design (融入Checklist 2.0策略的界面细节)

### 4.1 主页（竹林家园）
主页是情感中心和主要仪表盘，强化“华丽游戏风格”与互动体验：

-   **顶部区域**：
    *   用户头像/资料（左上），VIP用户头像框为动态闪耀竹叶/祥云框，昵称旁显示“守护者”金色称号。
    *   货币显示（金币、钻石、幸运点），采用立体金属质感与粒子特效。
    *   设置齿轮（右上），以玉简或祥云为造型，带入场动画。
    *   幸运抽奖入口，常驻闪烁粒子与动态高亮。VIP用户可在此看到每日额外免费抽奖次数的提示。
-   **中央区域**：
    *   大幅精美熊猫插画，分阶段成长，状态与互动均有丰富动画（如眨眼、伸懒腰、撒娇）。
    *   环境为动态竹林，随时间变化光影，加入蝴蝶、竹叶飘落等粒子动效。
    *   及时性进度条设计为华丽卷轴或竹简，填充动画有水墨晕染与金光粒子。VIP用户的进度条填充速度可有视觉上的加速感（如更快的粒子流动），或进度条本身设计更华丽。
    *   奖励预览采用宝箱/卷轴展开动画，奖励图标有高光与弹跳特效。
-   **底部区域**：
    *   活跃任务快捷入口，卡片采用浮雕、金边、云纹等装饰，完成时有粒子爆发动画。若任务有VIP额外奖励，在卡片上用小皇冠+金色数字清晰标出。
    *   最近奖励日志，图标逐条滚动出现，带有淡入淡出与粒子点缀。
    *   底部导航栏为自定义中国风图标，选中有祥云流动与高亮特效，整体采用半透明玉石质感。
-   **浮动VIP引导按钮/Banner**：
    *   若用户非VIP，在主页的合适位置（如熊猫旁边/任务区上方）可设置一个不打扰但可见的“成为守护者”入口，图标为华丽皇冠或玉佩，可带有微弱的呼吸光效。点击进入VIP中心或订阅选择页。

### 4.2 任务页（修行之路）
任务页突出“古卷”与“华丽动效”主题，提升交互仪式感：

-   **顶部区域**：
    *   日期展示采用书法字体与祥云装饰，背景为淡雅宣纸纹理。
    *   每日进度条为卷轴展开动画，填充时有水墨晕染与金光粒子。
    *   筛选/排序下拉菜单为玉佩/竹简造型，展开有弹性动画。
-   **任务列表**：
    *   滚动列表，每个任务卡片为立体浮雕卷轴，边框有金色描边与云纹。
    *   任务类型图标为水墨风，任务名用宋体/书法字体，重要任务有特殊高亮。
    *   奖励预览图标有弹跳与高光动画。清晰区分基础奖励和VIP额外奖励，后者用金色数字+小皇冠标识。若非VIP，额外奖励部分置灰并有“守护者专享”提示。
    *   及时性任务有⏰/✨特效，完成时有粒子爆发与卷轴印章动画。
    *   时间窗口倒计时为动态沙漏/水滴，挑战/自定义目标有专属标识（如火焰/熊猫头像）。
    *   VIP用户完成任务时，奖励飞向用户的动画可以更丰富、粒子效果更华丽。
-   **新增任务按钮**：
    *   悬浮金色圆形按钮，中心为加号，按钮有脉冲光圈与粒子环绕。

### 4.3 挑战页（江湖历练）
挑战页强化“地图探险”与“成就感”视觉：

-   **顶部区域**：
    *   挑战分类Tab为古代令牌/竹简造型，切换有翻转/卷轴展开动画。
    *   顶部装饰随挑战主题变换（如山水、火焰、祥云）。
-   **挑战卡片**：
    *   卡片为立体浮雕，背景为地图/山水画卷，主标题用金色描边字体。
    *   VIP专属挑战卡片背景采用更高级的动态山水画卷或星空图，边框为龙纹/凤纹等高级图腾，标题使用特殊书法字体。
    *   关键奖励有宝箱/玉璧高亮展示，奖励图标有光晕与粒子特效。若挑战完成后VIP有额外奖励，在奖励预览中清晰标出。
    *   进度条为竹节/卷轴，填充有水墨流动动画。
    *   时间限制为动态倒计时，未完成时有轻微闪烁。
    *   子任务可展开，完成有印章/祥云动画。
    *   接受/领取按钮为玉佩造型，点击有弹跳与粒子爆发。

### 4.4 成长之道（旅程页）
成长之道突出“进化仪式感”与“东方美学”：

-   **成长路径可视化**：
    *   采用山水画卷式时间轴或树状结构，节点间用祥云/竹节连接。
    *   每个节点为熊猫不同成长阶段小像，完成节点有金光高亮与粒子庆祝。
    *   VIP用户在成长路径上可解锁额外的奖励节点，解锁专属纪念装饰品或熊猫互动动作。这些VIP节点用更华丽的图标（如镶金玉璧）表示。
    *   当前节点脉冲动画，未解锁节点半透明并有神秘光效。
    *   奖励预览为玉简/宝箱展开，奖励图标有高光与弹跳。
-   **Milestone Log**:
    *   Scrollable timeline with rich visual treatment.
    *   Achievement cards with decorative frames and gold accents for significant milestones.
    *   Date stamps with elegant calligraphy-style typography.
    *   Reward recap with animated icons and particle effects.

### 4.5 商店页（珍宝阁）
商店页营造“奢华购物”与“收藏展示”氛围：

-   **顶部区域**：
    *   搜索栏为玉简/祥云造型，输入时有光效流动。
    *   分类筛选为立体玉佩/卷轴，选中有高亮与粒子环绕。
    *   特色商品轮播为宝箱/玉璧展示，切换有翻转动画。
    *   显著的“VIP中心/成为守护者”入口，可设计为华丽的卷轴或牌匾，带有动态光效。
    *   限时订阅优惠Banner采用动态倒计时器和吸引人的视觉设计（界面D1）。
-   **商品网格**：
    *   商品卡片为浮雕金边，插画高精度并带有微动画。
    *   VIP专属商品带有醒目的“VIP专享”金色标签或皇冠角标，商品卡片背景更华丽。商店内设立“守护者秘宝”等专区。
    *   价格用金色字体与立体货币图标，VIP商品有专属光效与标识。若VIP购买有折扣，清晰标出原价、折扣价和节省金额。
-   **商品详情**：
    *   大图预览支持3D旋转，描述区用宋体/书法字体。
    *   熊猫定制类商品有前后对比动画。
    *   购买按钮为玉璧/祥云造型，点击有粒子爆发。
    *   相关商品横向滚动，卡片有弹跳与高光。
-   **订阅选择模块**：直接在商店首页或次级页面嵌入界面E1（订阅选择页面）的卡片式设计，方便用户随时查看和选择。

### 4.6 熊猫互动页（心灵相通）
强化“亲密互动”与“动态环境”体验：

-   **环境设计**：
    *   背景为高精度中国园林，随时间变化光影，加入动态水面、竹叶、祥云等粒子。
    *   环境元素可交互（如点击水池有涟漪，竹叶可飘落）。
-   **熊猫可视化**：
    *   熊猫大幅动态插画，情绪通过表情、动作、特效展现（如开心时有金光、撒娇时有爱心粒子）。
    *   定制装饰高精度渲染，稀有物品有特殊光效。
-   **互动控件**：
    *   按钮为玉佩/祥云造型，点击有弹跳与粒子动画。
    *   喂食、玩耍、训练均有专属动画与奖励反馈。
    *   熊猫可解锁一些只有VIP才能触发的特殊互动动画或对话（如熊猫表演一段特殊的才艺、分享一段“智慧箴言”）。
    *   反思提示为温柔弹窗，背景虚化并有祥云环绕。

### 4.7 幸运抽奖页（福缘抽签）
突出“仪式感”与“惊喜感”视觉：

-   **顶部区域**：
    *   幸运点余额为立体玉璧计数器，周围常驻闪烁粒子。
-   **抽奖机制**：
    *   抽奖动画为华丽宝箱/转盘/竹简展开，粒子与音效营造期待氛围。
    *   抽奖按钮为金色祥云造型，点击有高光与粒子爆发。
    *   结果揭晓有卷轴展开、宝箱开启等庆祝动画。
    *   清晰显示VIP用户剩余的每日免费抽奖次数。按钮旁可有“守护者每日免费X次”提示。
-   **奖池展示**：
    *   奖品以画廊形式展示，稀有度用金光/祥云特效区分。
    *   若VIP在奖池中有专属物品或更高的稀有物品获取概率，应在奖池说明中或通过视觉暗示（如VIP抽奖时转盘上有更多金色格子）。
    *   概率用精美数据可视化，近期中奖有时间轴动画。可在此页面底部滚动显示“玩家XXX刚刚通过福缘抽签获得了[稀有物品]！”（若为VIP，可加上守护者标识）。

### 4.8 反思模块（静心茶室）
营造“静谧治愈”与“温柔支持”氛围：

-   **视觉设计**：
    *   背景为淡雅茶室/山水，祥云、茶烟等柔和动画，整体色调温暖柔和。
    *   UI元素极简，减少干扰，输入区为宣纸/竹简造型。
-   **交互设计**：
    *   熊猫头像有同理心表情，文字对话采用逐字淡入动画。
    *   输入方式为定制按钮/温柔文本框，反馈有水墨扩散动画。
    *   若熊猫推荐的调适方案中有高级冥想课程或深度心理支持工具，而用户非VIP，则会提示“此为守护者专属支持，升级后可体验完整版，获得熊猫更深层的陪伴。”
    *   阶段切换为卷轴展开/祥云流动，整体过渡平滑。

### 4.9 VIP中心页（紫宸殿/麒麟阁）
集中展示所有VIP权益，提供清晰的价值对比，并作为订阅和管理入口：

-   **设计风格：** 极尽华丽，采用宫殿、仙境等高级意象。背景可以是动态的星空、祥云缭绕的山巅或华丽的宫殿内景。
-   **内容模块：**
    *   **身份象征：** 顶部展示用户当前的VIP等级（若已订阅）或“加入守护者行列”的醒目入口。展示VIP专属头像框、称号的预览。
    *   **核心特权展示区：** 以图文并茂的卡片或滚动列表形式，清晰展示各项VIP特权，并与免费版进行视觉化对比。例如：“资源获取UP！” 卡片，左边是普通熊猫，右边是戴着皇冠的VIP熊猫，旁边分别显示获取的竹子数量（1 vs 2），VIP部分用金色和粒子特效。 “成长加速！”卡片，用动态进度条对比免费与VIP的成长速度。 “专属内容解锁！”卡片，展示VIP专属皮肤、任务、课程的精美预览图。
    *   **订阅选项模块：** (界面E1设计) 清晰展示月卡、季卡、年卡选项，突出“推荐”和“最佳价值”，标明价格和平均每月花费。
    *   **守护者专属福利区：** 展示当月/当季VIP可领取的专属礼包、参与的专属活动等。
    *   **价值回顾/推荐理由：** (可选) 结合用户数据（若已试用或曾订阅），展示“您已节省/额外获得...”，或引用其他“守护者”的好评。
    *   **FAQ/帮助：** 解答关于VIP订阅的常见问题。

## 5. Core Gameplay Elements (强调VIP的视觉和体验升级)

### 5.1 Panda Companion Visualization
The Panda companion is the emotional heart of the app and features:

-   **Growth Stages**:
    -   Infant: Small, extra fluffy with large eyes and playful movements.
    -   Youth: More active, curious expressions, developing unique personality.
    -   Adult: Graceful, wise appearance with confident posture.
    -   Perfect Form: Majestic presence with subtle glow effects and special animations.
-   **Emotional States**:
    -   Happy: Bright eyes, smiling expression, energetic movements, often accompanied by playful particle effects.
    -   Neutral: Calm demeanor, regular breathing animation, soft ambient sounds.
    -   Concerned: Gentle head tilt, softer movements, attentive gaze, perhaps a subtle sigh animation.
-   **Customization Visualization**:
    -   Seamless integration of accessories and clothing with high-fidelity rendering.
    -   Environment decorations that the Panda interacts with dynamically (e.g., sleeps on a VIP bed, plays with a VIP toy).
    -   **VIP专属皮肤/饰品**：具有更复杂的细节、独特的光效（如流光、粒子环绕）或动态效果（如尾巴摆动时有星尘散落）。
    -   **VIP专属环境装饰**：更华丽、更具主题性的家园装饰，熊猫可以与之进行特殊互动。

### 5.2 Resource System Visualization
Resources are presented with premium visual treatment:

-   **Resource Icons**:
    -   Bamboo: Detailed, realistic bamboo stalks with subtle shine and gentle sway animation.
    -   Water: Crystal-clear droplets with light refraction effects and shimmering highlights.
    -   Coins: Ornate gold coins with embossed panda design, metallic sheen, and slight spinning effect.
    -   Diamonds: Multi-faceted gems with light reflection, sparkle animation, and a subtle glow.
-   **Resource Animations**:
    -   Collection: Satisfying gather animation where icons fly towards the HUD with particle trails and a distinct collection sound.
    -   Spending: Elegant transfer animation from inventory to use, with resources visually depleting or transforming.
    -   Low resources: Subtle visual indicator (e.g., resource icon slightly dimmed) without being punitive.
    -   Resource milestone: Special celebration animation when a large amount is collected or spent.
    -   **VIP额外获取**：当VIP用户获得额外资源时，这些额外的资源图标会以更醒目的金色光芒飞向库存，并伴有清脆的特殊音效。

### 5.3 Timely Reward System Visualization
The Timely Reward System features premium visual elements:

-   **Timeliness Bar**:
    -   Elegant scroll or bamboo-themed progress indicator with intricate patterns.
    -   Rich fill animation with flowing ink/golden light particle effects.
    *   VIP用户的进度条填充动画可以更快，或者每次填充的“光芒”更亮、范围更大。
    -   Reward preview with subtle highlight animation, showcasing the valuable item. 如果Timeliness Bar的最终奖励对VIP有额外加成或专属内容，应在预览中清晰标出。
    -   Completion celebration with luxurious visual effects like unfolding scrolls, blooming flowers, or auspicious cloud formations.
-   **Luck Points**:
    -   Premium counter designed as a glowing orb or a lucky charm, with sparkle animation.
    -   Earning visualization with floating point animation, points having a distinct golden shimmer or lucky symbol.
    -   Accumulation milestone effects with special visual treatment, e.g., the counter glowing brighter.
-   **On-Time Completion**:
    -   Satisfying visual feedback for timely task completion, like a golden checkmark appearing or a seal stamp animation.
    -   Special animation for "Early Bird" bonus, perhaps a sunrise motif or a chirping bird sound.
    -   Elegant visual connection between task completion and rewards, with particles flowing from the task to the Timeliness Bar and Luck Point counter.

### 5.4 Challenge System Visualization
Challenges are presented with immersive visual elements:

-   **Challenge Categories**:
    -   Visual theming for different challenge types (e.g., misty mountains for long-term challenges, festive lanterns for event challenges).
    -   Custom illustrations for challenge backgrounds, reflecting Oriental aesthetics.
    -   Animated transitions between categories, like a scroll unfurling or a map panning.
-   **Progress Tracking**:
    -   Rich progress bar design with milestone markers stylized as jade pieces or calligraphy strokes.
    -   Sub-task completion visualization with elegant checkmarks or an ink stamp appearing.
    -   Time remaining indicator with premium countdown design, perhaps a traditional Chinese hourglass or a burning incense stick.
-   **Reward Presentation**:
    *   Treasure chest or ornate gift box animation for claiming rewards, opening with a flourish and light effects.
    *   Particle effects (like golden dust or flower petals) and celebratory sound design.
    *   Reward showcase with detailed item presentation, items appearing with a shimmer or glow.
    *   **VIP额外奖励：** 领取挑战奖励时，若VIP有额外奖励，会分阶段展示：先展示基础奖励，然后华丽动画效果后，再展示VIP专属的额外奖励部分，强化获得感。

## 6. Monetization Design (基于Checklist 2.0的优化)

### 6.1 VIP Subscription UI/UX
The VIP subscription is presented with a premium, value-focused approach:

-   **VIP Badge Design**:
    *   Elegant, non-intrusive badge with subtle animation (e.g., a gently glowing bamboo leaf crown or a jade pendant with a "守" character).
    *   Tiered designs for different subscription levels (e.g., Bronze, Silver, Gold Panda Guardian) with increasingly ornate details.
    *   Special visual effects for VIP users' avatars, like a flowing aura or unique particle trail in social contexts.
    *   在用户头像、排行榜、聊天（若有）等处，VIP徽章（如动态竹叶皇冠）需醒目且设计精良，是身份的直接彰显。
-   **VIP Benefits Visualization (in VIP Center Page - 紫宸殿/麒麟阁)**:
    *   Clear, visually rich comparison between free and VIP using side-by-side infographics or animated carousels.
    *   Animated demonstrations of enhanced features (e.g., faster Panda growth, increased resource gain with golden particle effects).
    *   Before/after visualizations of rewards and progression (e.g., a split screen showing a free user's reward vs. a VIP's enhanced reward for the same task).
    *   核心是对比和可视化。 使用并排布局、动画演示、数据对比（如“节省XX时间”、“资源获取+XX%”）来清晰展示价值。
-   **Subscription Flow (via VIP Center or contextual prompts)**:
    *   Elegant, distraction-free purchase screen with a luxurious background (e.g., silk brocade, starry night sky).
    *   Tiered options (Monthly, Seasonal, Annual) presented as ornate jade tablets or scrolls, with visual hierarchy based on value. 季卡标记“推荐”，年卡标记“最佳价值”并突出其极致性价比和额外专属大礼包。
    *   Secure payment visualization with premium styling, perhaps a golden seal animation upon confirmation.
    *   Thank you/confirmation screen with a celebratory animation featuring the Panda and auspicious symbols.
    *   “无风险”试用引导（界面B1）：在合适时机（如新手期结束）提供3-7天核心VIP功能免费试用，试用结束前通过价值回顾弹窗（界面F2）强化转化。
    *   人性化挽留（界面F3）：在用户尝试退订时，提供降级、折扣、休眠保留等选项，避免强硬。

### 6.2 Shop Design (珍宝阁)
The Shop provides a luxurious shopping experience:

-   **Item Categories**:
    *   Visual theming for different item types (e.g., Panda skins in a "Wardrobe Pavilion", decorations in a "Garden Emporium").
    *   Elegant category icons with selection effects (e.g., icons glowing or subtly animating).
    *   Featured items carousel with premium presentation using dynamic lighting and particle effects.
    *   商店内设立“守护者秘宝”等专区，陈列VIP才能购买的顶级外观或道具，使用更华丽的卡片和背景。
-   **Item Presentation**:
    *   High-quality item illustrations with subtle animations (e.g., clothing gently swaying, decorations emitting a soft glow).
    *   3D preview capability for certain items, allowing users to rotate and inspect details.
    *   Try-before-buy visualization for Panda customizations, showing the item on the user's current Panda.
    *   Limited-time items with special visual treatment, like a golden border or a countdown timer display.
-   **Purchase Experience**:
    *   Smooth, satisfying purchase animation, like items flying into an ornate treasure chest.
    *   Elegant confirmation screen with item showcase and a thank you message in calligraphy.
    *   Gift wrapping animation for new acquisitions, perhaps tied with a silk ribbon.
    *   Inventory update visualization with items appearing in a beautifully designed inventory screen.
-   **Limited-Time Offers (融入界面D1)**:
    *   动态化限时优惠：针对新用户或特定节日，推出高性价比的“新手特惠订阅包”或“节日限定订阅礼遇”，配合醒目的倒计时器。

### 6.3 Conversion Optimization (融入Checklist 2.0的场景化策略)
Conversion points are designed to be compelling yet non-intrusive:

-   **Feature Discovery / “解锁”型激励 (融入界面A3)**:
    *   Elegant "VIP Feature" indicators (e.g., a small golden lock icon or a subtle shimmer) on locked content or features.
    *   Subtle glow or highlight effects to draw attention to VIP-exclusive options.
    *   Preview capabilities for some VIP content (e.g., watching a snippet of a VIP meditation course) with "Upgrade to Access Full Content" messaging.
    *   当用户尝试访问VIP功能时，弹出引导弹窗，清晰说明此功能的VIP优势，并提供“了解守护者特权”的直接入口。
-   **Value Demonstration / 关键时刻与情感连接 (融入界面A2, C1, C2)**:
    *   Visual comparisons showing enhanced rewards (e.g., a split screen showing free vs. VIP loot drops).
    *   Progress acceleration visualizations (e.g., an animated bar graph showing faster Panda growth for VIPs).
    *   Exclusive item showcases with premium presentation and particle effects.
    *   高光时刻助推：成就达成、稀有掉落后，提示“订阅后此类奖励翻倍/永久提升”。
    *   痛点解决方案：遇到瓶颈时，提供订阅作为“优雅”的解决方案（如“守护者专享再试一次机会”）。
    *   即时收益反馈：任务完成、升级时，明确展示订阅带来的“额外”收益。
-   **Contextual Prompts (融入界面B2)**:
    *   Thoughtfully timed upgrade suggestions, appearing when users might most appreciate VIP benefits (e.g., after running out of energy, or when facing a difficult challenge).
    *   Elegant modal design for upgrade prompts, using soft animations and calming visuals.
    *   Clear value proposition with visual support, focusing on how VIP enhances the user's journey.
    *   在用户面临资源短缺或耗时操作时，适时提示订阅如何高效解决。
-   **社交对比与向往 (融入界面C3, G2, H1, H2, H3)**:
    *   排行榜、好友列表清晰展示VIP标识及其带来的可见优势（专属外观、更高排名加成），激发向往。
    *   订阅用户组队时能为全队带来微小增益。

## 7. Technical Implementation Guidelines

### 7.1 Integration with Existing Codebase
The implementation will build upon the existing React/TypeScript architecture:

-   Leverage the current component structure while enhancing visual elements with more detailed styling and animations, potentially using libraries like Framer Motion for sophisticated effects.
-   Maintain the existing data flow patterns (e.g., Redux, Context API) while adding new state slices for game-specific data like Panda stats, inventory, and Timely Reward progress.
-   Extend the current state management approach to include new game elements, ensuring efficient updates for dynamic UIs.

### 7.2 Internationalization Approach
Building on the existing i18n infrastructure (e.g., i18next):

-   Extend the current language system to include game-specific terminology, ensuring all narrative text, UI labels, and Panda dialogues are translatable.
-   Ensure all new UI elements, including dynamically generated text for rewards and VIP benefits, support multiple languages and varying text lengths.
-   Implement culturally appropriate visual elements for different regions, such as specific festival themes or color symbolism, where applicable and manageable.

### 7.3 Component Structure
The component architecture will follow a modular approach, potentially Atomic Design:

-   **Atomic Design Methodology**:
    -   Atoms: Basic UI elements (buttons with ornate borders, inputs with subtle textures, icons with water-ink style).
    -   Molecules: Compound components (task cards with卷轴styling, reward displays with particle effects, Panda status indicators).
    -   Organisms: Feature sections (Task List with scrollable卷轴, Panda Interaction Area with dynamic background, Shop item grid).
    -   Templates: Page layouts with placeholder content, defining the structure for Home, Task, Shop pages.
    -   Pages: Complete screens with real content, populated via state and props.
-   **Game-Specific Components**:
    -   PandaAvatar: Handles rendering and animating the Panda across growth stages, emotions, and with equipped customizations.
    *   ResourceDisplay: Manages resource visualization with華麗金屬質感 and particle effects for updates.
    *   RewardAnimation: Controls reward presentation effects (e.g.,寶箱開啟, 金幣飛舞).
    *   ChallengeTracker: Visualizes challenge progress with dynamically updating地圖/山水畫卷.
    *   TimelinessBarComponent: Renders the華麗卷軸/竹簡style progress bar with水墨暈染fill.
    *   LuckyDrawMachine: Handles the福緣抽签animation and reward reveal sequence.

### 7.4 State Management
The state management approach (e.g., Redux Toolkit, Zustand) will handle game-specific requirements:

-   User progress (levels, XP, completed tasks/challenges), achievements, and milestones stored in persistent state, synced with backend.
-   Real-time interactions (e.g., Panda mood changes, immediate reward feedback) managed with local component state or efficient global state updates to prevent unnecessary re-renders.
-   Animation states (e.g., for transitions, reward reveals, Panda expressions) controlled with dedicated hooks or state variables.
-   Game mechanics (timers for tasks/events, random events for Lucky Draw, Panda's needs decay) managed with specialized services or thunks/sagas, interacting with the backend for validation and persistence.

## 8. Appendices

### 8.1 Asset Requirements
-   High-resolution Panda illustrations in various poses, emotional states, and growth stages, suitable for dynamic animation.
-   Premium UI element designs (buttons with cloud/ruyi patterns, cards with silk/brocade textures, icons in water-ink style with gold accents).
-   Environmental elements and backgrounds (dynamic bamboo forests, serene tea rooms, majestic mountain landscapes, ornate palace interiors for VIP Center).
-   Resource and reward visualizations (detailed bamboo, crystal water, ornate coins, multifaceted diamonds, treasure chests, scrolls).
-   Animation sequences for key interactions (Panda movements, resource collection, reward celebrations, UI transitions with ink-wash effects).
-   Unique assets for VIP skins, decorations, and exclusive event rewards, designed to be visibly superior.

### 8.2 Animation Specifications
-   Micro-interactions for UI elements (button presses with particle bursts, switches with jade-like clicks, sliders with smooth ink trails).
-   Character animations for the Panda (idle states with subtle breathing/blinking, expressive happy/concerned/playful animations, specific animations for interacting with VIP items).
-   Reward and achievement celebrations (e.g., scroll unfurling with golden text, treasure chest opening with a shower of coins and gems, Panda performing a celebratory dance).
-   Transition effects between screens and states (e.g., ink wash wipes, page turns like an ancient book, shimmering portals for entering special areas like the VIP Center).
-   Timely Reward System animations: Bar filling with flowing golden ink, Luck Points appearing with a sparkle, Lucky Draw machine animations (spinning wheel, bamboo fortune sticks falling).

### 8.3 Accessibility Considerations
-   Color contrast compliance for all UI elements, ensuring text is readable against ornate backgrounds. Provide high-contrast mode if necessary.
-   Alternative text for decorative elements and complex visuals, especially for images conveying important information.
-   Keyboard navigation support for key interactive elements.
-   Screen reader compatibility, with proper labeling for buttons, icons, and dynamic content.
-   Motion reduction options for animations, allowing users to disable or simplify complex visual effects if they cause discomfort.
-   Clear and legible typography choices, even for stylized fonts, ensuring readability for all users.

---

This updated Design Brief aims to provide a comprehensive and actionable guide for creating PandaHabit with a distinctive "华丽游戏风格" while strategically embedding effective subscription growth principles. The emphasis is on creating an experience that is not only visually stunning but also deeply engaging and valuable to the user, making the premium offering a natural and desirable upgrade.
</file>

<file path="multilingual-implementation-guide.md">
# PandaHabit 多语言实现指南

本文档提供了在 PandaHabit 应用中实现和维护多语言支持的详细指南，包括组件级别的多语言支持、标签管理和最佳实践。

## 多语言架构概述

PandaHabit 使用以下架构来支持多语言：

1. **LanguageProvider**：全局语言上下文提供者，管理当前选择的语言
2. **useLocalizedView**：自定义钩子，用于获取特定页面或视图的本地化内容
3. **localizedContentService**：服务层，负责从数据库获取本地化标签
4. **标签数据库**：使用 Dexie.js 存储所有语言的标签

## 组件级别多语言支持实现

### 1. 组件接口定义

所有需要显示文本的组件都应该接受 `labels` 属性：

```typescript
interface ComponentProps {
  // 其他属性
  labels?: {
    // 组件需要的所有文本标签
    title?: string;
    description?: string;
    buttonText?: string;
    // 其他标签...
  };
}
```

### 2. 组件实现

组件应该使用传入的标签，并提供英文默认值作为回退：

```typescript
const MyComponent: React.FC<ComponentProps> = ({ labels, ...props }) => {
  return (
    <div>
      <h2>{labels?.title || "Default Title"}</h2>
      <p>{labels?.description || "Default description text."}</p>
      <button>{labels?.buttonText || "Click Me"}</button>
    </div>
  );
};
```

### 3. 嵌套组件

对于包含子组件的组件，应该将相关标签传递给子组件：

```typescript
const ParentComponent: React.FC<ParentProps> = ({ labels, ...props }) => {
  return (
    <div>
      <h1>{labels?.title || "Parent Title"}</h1>
      <ChildComponent 
        labels={labels?.childComponent}
        {...childProps} 
      />
    </div>
  );
};
```

## 页面级别多语言支持实现

### 1. 使用 useLocalizedView 钩子

所有页面组件都应该使用 `useLocalizedView` 钩子获取本地化内容：

```typescript
const MyPage: React.FC = () => {
  const {
    labels: pageLabels,
    data,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<MyPageDataType, MyPageLabelsBundle>(
    'myPageViewContent',
    fetchMyPageView
  );

  // 使用 pageLabels 渲染页面内容
  // ...
};
```

### 2. 传递标签给子组件

页面组件应该将相关标签传递给子组件：

```typescript
<MyComponent 
  labels={pageLabels?.myComponent}
  // 其他属性
/>
```

## 标签管理

### 1. 标签组织

标签应该按照以下层次结构组织：

```
[页面/视图].[组件].[标签]
```

例如：

- `homeView.welcomeSection.title`
- `challengesView.challengeCard.statusActive`
- `storeView.itemCard.buyButton`

### 2. 标签包类型定义

为每个页面或视图定义标签包类型：

```typescript
export interface ChallengesPageViewLabelsBundle {
  pageTitle: string;
  loadingMessage?: string;
  errorTitle?: string;
  retryButtonText?: string;
  filters?: {
    statusLabel?: string;
    typeLabel?: string;
    // 其他过滤器标签
  };
  challengeCard?: {
    statusActive?: string;
    statusCompleted?: string;
    // 其他卡片标签
  };
  // 其他组件标签
}
```

### 3. 添加新标签

当添加新标签时，需要：

1. 更新相关的标签包类型定义
2. 在数据库中添加所有支持语言的标签
3. 更新组件以使用新标签

## 最佳实践

### 1. 组件设计

- 所有显示文本的组件都应该支持多语言
- 组件应该接受 `labels` 属性，并为所有文本提供英文默认值
- 避免在组件中硬编码任何语言的文本

### 2. 错误处理

- 错误消息应该使用多语言标签
- 提供有意义的默认英文错误消息作为回退

### 3. 动态内容

- 对于动态生成的内容，考虑使用模板字符串和占位符
- 确保日期、数字和货币格式化考虑语言特定的格式

### 4. 测试

- 为每个组件编写测试，确保它们在不同语言设置下正确渲染
- 测试语言切换功能，确保所有组件正确更新

## 示例实现

### 组件示例：ChallengeCard

```typescript
interface ChallengeCardProps {
  challenge: ChallengeRecord;
  onClick?: (challenge: ChallengeRecord) => void;
  onComplete?: (challengeId: number) => void;
  labels?: {
    statusActive?: string;
    statusCompleted?: string;
    statusExpired?: string;
    statusUpcoming?: string;
    startLabel?: string;
    endLabel?: string;
    completedOnLabel?: string;
    completeButtonText?: string;
    inProgressText?: string;
  };
}

const ChallengeCard: React.FC<ChallengeCardProps> = ({ 
  challenge, 
  onClick, 
  onComplete,
  labels 
}) => {
  // 获取挑战状态对应的文本
  const getStatusText = () => {
    switch (challenge.status) {
      case ChallengeStatus.ACTIVE:
        return labels?.statusActive || 'Active';
      case ChallengeStatus.COMPLETED:
        return labels?.statusCompleted || 'Completed';
      case ChallengeStatus.EXPIRED:
        return labels?.statusExpired || 'Expired';
      case ChallengeStatus.UPCOMING:
        return labels?.statusUpcoming || 'Upcoming';
      default:
        return '';
    }
  };

  // 组件其余部分...
};
```

### 页面示例：ChallengesPage

```typescript
const ChallengesPage: React.FC = () => {
  const {
    labels: pageLabels,
    data,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<ChallengesPageDataPayload, ChallengesPageViewLabelsBundle>(
    'challengesPageViewContent',
    fetchChallengesPageView
  );

  // 渲染挑战卡片
  const renderChallenges = () => {
    return challenges.map(challenge => (
      <ChallengeCard
        key={challenge.id}
        challenge={challenge}
        onClick={handleChallengeClick}
        onComplete={handleCompleteChallenge}
        labels={pageLabels?.challengeCard}
      />
    ));
  };

  // 页面其余部分...
};
```

## 结论

通过遵循本指南中的原则和最佳实践，PandaHabit 应用可以提供一致的多语言体验，并为未来添加更多语言支持奠定基础。正确实现多语言支持不仅提高了应用的可访问性，还增强了用户体验。
</file>

<file path="multilingual-support-fixes.md">
# PandaHabit 多语言支持修复文档

## 问题概述

在对 PandaHabit 应用进行多语言支持检查时，发现许多组件中存在硬编码的中文文本，导致即使用户选择了英语作为界面语言，部分界面元素仍然显示中文。这种不一致性影响了用户体验，需要系统性地修复。

## 问题分类

### 1. 组件级别的本地化缺失

- 许多组件没有接收或正确使用多语言标签
- 组件内部的文本（按钮、标签、描述等）直接硬编码为中文
- 错误消息和状态文本通常是硬编码的中文

### 2. 标签作用域不完整

- 数据库中可能缺少某些组件的英文标签
- 标签的作用域（scopeKey）设置不正确，导致组件无法获取正确的标签

### 3. 组件未使用本地化钩子

- 一些组件没有使用 `useLocalizedView` 钩子
- 父组件获取了本地化标签，但没有正确地将这些标签传递给子组件

## 问题组件清单

### 反思和情绪相关组件

1. **MoodTracker.tsx**
   - 虽然已添加 labels 参数，但仍有部分中文文本未使用标签
   - 例如："强度:"、"暂无情绪记录"等

2. **EnhancedReflectionModule.tsx**
   - 包含大量硬编码中文文本
   - 例如："我注意到你的情绪有些波动。想聊聊吗？"、"任务未能按时完成。这没关系，我们可以一起反思一下。"
   - 生成建议行动的函数中有硬编码中文标签如"焦虑"、"压力"、"疲惫"等

3. **ReflectionModule.tsx**
   - 包含硬编码中文文本
   - 例如："分享你的想法（可以是任何感受、困难或成就）"、"继续"、"谢谢你的分享"等

### 游戏和挑战相关组件

1. **ChallengeCard.tsx**
   - 状态文本硬编码为中文："进行中"、"已完成"、"已过期"、"即将开始"
   - 日期标签硬编码为中文："开始:"、"结束:"、"完成于:"
   - 按钮文本硬编码为中文："完成挑战"、"进行中..."

2. **ChallengeDiscoveryCard.tsx**
   - 错误信息和提示信息硬编码为中文："无法加载挑战数据"、"加载挑战失败，请重试"等
   - 日期标签硬编码为中文："开始日期:"、"结束日期:"
   - 按钮文本硬编码为中文："稍后再说"、"接受挑战"

3. **StoreItemCard.tsx**
   - 错误信息硬编码为中文："需要VIP会员才能购买"、"金币不足"、"玉石不足"
   - VIP标签硬编码为中文："VIP专属"
   - 促销标签硬编码为中文："促销"
   - 按钮文本硬编码为中文："购买"

### 任务相关组件

1. **TaskManager.tsx**
   - 默认标签硬编码为中文："任务管理"、"创建新任务"、"全部"、"待办"、"进行中"、"已完成"、"暂无任务"

2. **SubtaskList.tsx**
   - 错误信息硬编码为中文："加载子任务失败，请重试"、"添加子任务失败，请重试"等
   - 按钮和输入框占位符硬编码为中文："添加新子任务..."、"添加"
   - 删除按钮的aria-label硬编码为中文："删除子任务"

3. **TasksPage.tsx**
   - 加载消息硬编码为中文："加载任务页面内容..."

## 解决方案

### 1. 组件级别修复

为每个组件添加标准化的多语言支持：

1. **添加 labels 参数**：
   ```typescript
   interface ComponentProps {
     // 其他属性
     labels?: {
       // 组件需要的所有文本标签
     };
   }
   ```

2. **替换硬编码文本**：
   ```typescript
   // 替换前
   <Button onClick={handleSubmit}>购买</Button>
   
   // 替换后
   <Button onClick={handleSubmit}>{labels?.buyButton || "Buy"}</Button>
   ```

3. **确保英文默认值**：所有标签都应提供英文默认值作为回退

### 2. 类型定义更新

为每个页面视图的标签包添加所有需要的标签：

```typescript
// 例如，为挑战页面添加标签
export interface ChallengesPageViewLabelsBundle {
  pageTitle: string;
  loadingMessage?: string;
  errorTitle?: string;
  retryButtonText?: string;
  filters?: {
    statusLabel?: string;
    typeLabel?: string;
    difficultyLabel?: string;
    allLabel?: string;
    activeLabel?: string;
    completedLabel?: string;
    upcomingLabel?: string;
    // 其他过滤器标签
  };
  challengeCard?: {
    statusActive?: string;
    statusCompleted?: string;
    statusExpired?: string;
    statusUpcoming?: string;
    startLabel?: string;
    endLabel?: string;
    completedOnLabel?: string;
    completeButtonText?: string;
    inProgressText?: string;
  };
  // 其他标签
}
```

### 3. 数据库更新

在 `db.ts` 中添加所有新标签的英文和中文翻译：

```typescript
// 英文标签
{ id: generateId(), languageCode: 'en', scopeKey: 'challengesView.challengeCard.statusActive', value: 'Active' },
{ id: generateId(), languageCode: 'en', scopeKey: 'challengesView.challengeCard.statusCompleted', value: 'Completed' },
// ...

// 中文标签
{ id: generateId(), languageCode: 'zh', scopeKey: 'challengesView.challengeCard.statusActive', value: '进行中' },
{ id: generateId(), languageCode: 'zh', scopeKey: 'challengesView.challengeCard.statusCompleted', value: '已完成' },
// ...
```

### 4. 页面组件更新

确保页面组件正确传递标签给子组件：

```typescript
// 例如，在 ChallengesPage 中
<ChallengeCard 
  challenge={challenge}
  onClick={handleChallengeClick}
  onComplete={handleCompleteChallenge}
  labels={pageLabels?.challengeCard}
/>
```

## 修复优先级

根据用户界面的重要性，建议按以下顺序优先处理：

1. **核心游戏组件**：
   - ChallengeCard.tsx
   - StoreItemCard.tsx
   - TaskCard.tsx

2. **用户交互频繁的组件**：
   - SubtaskList.tsx
   - MoodTracker.tsx
   - TaskManager.tsx

3. **其他支持组件**：
   - EnhancedReflectionModule.tsx
   - ChallengeDiscoveryCard.tsx
   - VipSubscriptionCard.tsx

## 修复示例

以 ChallengeCard.tsx 为例，修复方式如下：

### 修复前：

```typescript
// 获取挑战状态对应的文本
const getStatusText = () => {
  switch (challenge.status) {
    case ChallengeStatus.ACTIVE:
      return '进行中';
    case ChallengeStatus.COMPLETED:
      return '已完成';
    case ChallengeStatus.EXPIRED:
      return '已过期';
    case ChallengeStatus.UPCOMING:
      return '即将开始';
    default:
      return '';
  }
};

// JSX 中
<span>开始: {formatTime(challenge.startDate, false)}</span>
{challenge.endDate && (
  <span>结束: {formatTime(challenge.endDate, false)}</span>
)}

// 按钮文本
{challenge.progress >= 100 ? '完成挑战' : '进行中...'}
```

### 修复后：

```typescript
// 添加 labels 参数到接口
interface ChallengeCardProps {
  challenge: ChallengeRecord;
  onClick?: (challenge: ChallengeRecord) => void;
  onComplete?: (challengeId: number) => void;
  labels?: {
    statusActive?: string;
    statusCompleted?: string;
    statusExpired?: string;
    statusUpcoming?: string;
    startLabel?: string;
    endLabel?: string;
    completedOnLabel?: string;
    completeButtonText?: string;
    inProgressText?: string;
  };
}

// 获取挑战状态对应的文本
const getStatusText = () => {
  switch (challenge.status) {
    case ChallengeStatus.ACTIVE:
      return labels?.statusActive || 'Active';
    case ChallengeStatus.COMPLETED:
      return labels?.statusCompleted || 'Completed';
    case ChallengeStatus.EXPIRED:
      return labels?.statusExpired || 'Expired';
    case ChallengeStatus.UPCOMING:
      return labels?.statusUpcoming || 'Upcoming';
    default:
      return '';
  }
};

// JSX 中
<span>{labels?.startLabel || 'Start'}: {formatTime(challenge.startDate, false)}</span>
{challenge.endDate && (
  <span>{labels?.endLabel || 'End'}: {formatTime(challenge.endDate, false)}</span>
)}

// 按钮文本
{challenge.progress >= 100 ? (labels?.completeButtonText || 'Complete Challenge') : (labels?.inProgressText || 'In Progress...')}
```

## 测试计划

1. **组件级测试**：
   - 为每个修复的组件编写单元测试，确保它们正确使用标签
   - 测试不同语言设置下的组件渲染

2. **集成测试**：
   - 测试页面组件是否正确传递标签给子组件
   - 测试语言切换功能是否正确更新所有组件的文本

3. **用户界面测试**：
   - 在不同语言设置下手动测试应用
   - 确保所有文本都正确显示为选定的语言

## 结论

通过系统性地修复多语言支持问题，PandaHabit 应用将能够为用户提供一致的多语言体验。这些修复不仅提高了应用的质量，还为未来添加更多语言支持奠定了基础。
</file>

<file path="screens.md">
好的，这是一个非常庞大的任务，因为“包含所有页面的完整界面设计”实际上相当于一个完整的UI/UX设计交付物。由于文本格式的限制，我无法像Figma那样提供可交互的原型或精确的像素级布局，但我可以尽力用**更详细的文本描述和结构化布局**来描绘PandaHabit的关键页面，并串联起之前讨论的所有功能和付费引导策略。

**核心原则：** 界面设计将遵循“简洁、治愈、引导性强、熊猫元素突出”的原则。颜色以柔和的自然色系为主（如竹绿色、天空蓝、大地棕），点缀少量明亮的强调色。

---

**PandaHabit App - 完整界面设计描述 (Conceptual)**

---

**全局元素 (Global Elements):**

*   **状态栏 (Status Bar):** 标准的移动设备状态栏 (时间, Wi-Fi, 电量)。
*   **导航栏 (Navigation Bar - 若有顶部导航):** 通常包含页面标题，返回按钮 (若非一级页面)。
*   **底部标签导航栏 (Bottom Tab Bar - 主要导航):** 固定在屏幕底部，包含4-5个核心模块入口。
*   **熊猫形象 (Panda Avatar):** 在多个界面以不同形式出现，作为情感连接和引导的核心。
*   **统一的按钮风格：** 圆角，清晰的文字标签，有明确的点击反馈。
*   **统一的卡片风格：** 圆角，有轻微阴影，内容组织清晰。
*   **一致的图标风格：** 简洁、表意明确，与整体风格统一。
*   **字体：** 选择易读、友好的无衬线字体。

---

**主要页面设计描述:**

**I. 启动与账户 (Launch & Account)**

**1. 闪屏页 (Splash Screen)**
    *   **布局：** 全屏。
    *   **元素：**
        *   PandaHabit Logo (动态的，如熊猫眨眼或竹叶飘落)。
        *   底部显示版本号和加载动画 (可选)。
    *   **交互：** 自动跳转到登录/注册页或主页 (如果已登录)。

**2. 欢迎/引导页 (Welcome/Onboarding Screens - 首次启动)**
    *   **布局：** 通常3-5屏轮播。
    *   **元素 (每屏不同主题)：**
        *   **屏1 (概念引入):** 大幅治愈系熊猫插画。“遇见你的健康生活伴侣，PandaHabit！” 简短介绍App核心价值。
        *   **屏2 (习惯养成):** 图示化的习惯养成过程。“和熊猫一起，轻松养成好习惯。”
        *   **屏3 (情感支持):** 熊猫与用户互动的温馨场景。“熊猫时刻关心你，给予温暖支持。”
        *   **屏4 (个性化):** 展示可爱的熊猫皮肤和家园装饰。“打造你独一无二的熊猫伙伴。” ( subtly hinting at customization through engagement/VIP)
        *   **屏5 (准备开始/权限请求):** “准备好开始你的PandaHabit之旅了吗？” 请求必要的权限 (如通知)。
    *   **交互：** 左右滑动切换，底部有指示点和“跳过”/“下一步”/“开始”按钮。

**3. 登录/注册页 (Login/Register Page)**
    *   **布局：** 居中对齐。
    *   **元素：**
        *   PandaHabit Logo。
        *   输入框：邮箱/手机号、密码。
        *   按钮：“登录”、“注册”。
        *   第三方登录选项 (如Apple, Google, Facebook)。
        *   链接：“忘记密码？”、“用户协议”、“隐私政策”。
    *   **交互：** 标准表单输入和提交。

**4. 熊猫初始设置页 (Initial Panda Setup - 首次注册后)**
    *   **布局：** 引导式步骤。
    *   **元素：**
        *   **步骤1 (命名):** “给你的熊猫伙伴取个可爱的名字吧！” 输入框。
        *   **步骤2 (基础外观选择 - 可选):** 提供几种免费的基础熊猫颜色/小配饰供选择。“选择熊猫的初始模样。”
        *   **步骤3 (第一个习惯引导):** “让我们从一个小习惯开始，比如‘每天喝一杯水’。熊猫会陪你一起！” 预设几个简单习惯选项，或允许输入。
    *   **交互：** 点击“下一步”完成设置。

---

**II. 核心体验与互动 (Core Experience & Interaction)**

**5. 主页/家园 (Home Page / Panda's Home)**
    *   **布局：**
        *   **顶部状态栏：**
            *   左：用户头像 (点击进入个人资料)、昵称、**[VIP标识]** (若有)。
            *   中：**[熊猫当前心情状态]** (如开心、平静、有点饿)。
            *   右：**[金币]** 数量、**[钻石]** 数量 (若有)、**[幸运点数]** 数量 (⭐)。
        *   **主视觉区 (占据大部分屏幕)：**
            *   **[动态熊猫]** 在其“家园”场景中活动 (如玩耍、休息、期待互动)。熊猫外观根据用户自定义和成长阶段变化。
            *   **[准时进度条 (Timeliness Bar)]** 清晰可见，显示当前进度和最终大奖图标。
        *   **快捷互动按钮 (围绕熊猫或在固定区域)：**
            *   **“喂食”** (竹子/水/肉图标，根据熊猫需求高亮)。
            *   **“互动/玩耍”** (如小球图标，点击触发与熊猫的简单互动动画或小游戏)。
            *   **“心情打卡”** (表情图标，每日一次)。
        *   **核心任务引导区 (底部或侧边栏)：**
            *   显示1-2个当前最重要的**[主线任务]** 或 **[即将到期的挑战子任务]**，包含任务描述、进度、奖励预览、**[准时奖励标识⏰]**。点击可跳转到任务详情或任务列表。
        *   **底部标签导航栏 (Fixed Bottom Tab Bar)：**
            *   **“家园”** (当前页，高亮)。
            *   **“任务”** (跳转到任务列表页)。
            *   **“成长/旅程”** (跳转到熊猫成长/里程碑页)。
            *   **“抽奖/奖励”** (跳转到幸运抽奖/奖励中心页)。
            *   **“商店”** (跳转到商店页)。
    *   **交互：**
        *   点击熊猫触发简单动画/问候。
        *   点击互动按钮执行相应操作。
        *   点击任务引导区跳转。
        *   可左右滑动切换家园场景 (若有多个场景)。
        *   **[VIP特权入口]**: 可能在用户头像旁或设置菜单中，有醒目“VIP”标识。

**6. 任务列表页 (Task List Page)**
    *   **布局：**
        *   **顶部：**
            *   日期显示。
            *   “今日任务完成进度” (如 “3/5 已完成”)。
            *   筛选按钮 (按类型：日常/主线/支线/挑战；按状态：未完成/已完成)。
            *   **[“+ 添加任务”按钮 (VIP用户可创建更多自定义任务)]**
        *   **任务列表区 (可滚动)：**
            *   每个任务以**[卡片形式]**展示：
                *   任务名称 (如“喝水3次”、“完成5分钟冥想”)。
                *   任务图标 (如水滴、莲花)。
                *   **[任务来源标识]** (如主线、支线、挑战🔥、自定义👤)。
                *   奖励预览 (如“+10竹子，+5水，+5幸运点数”)。
                *   **[准时奖励标识⏰]** 及**[完成时间窗口提示]** (如“今日23:59前”)。
                *   进度条 (若任务可分步完成，如喝水1/3次)。
                *   **[完成复选框/按钮]**。
            *   已完成任务置灰或打勾，可折叠或移至列表底部。
    *   **交互：**
        *   点击复选框/按钮标记任务完成 -> 触发奖励动画和音效，**[准时进度条和幸运点数更新动画]**。
        *   点击任务卡片本身 -> 弹出**[任务详情弹窗]**。

**7. 任务详情弹窗 (Task Details Modal)**
    *   **布局：** 模态弹窗。
    *   **元素：**
        *   任务名称。
        *   详细描述和完成标准。
        *   所属挑战/目标 (若有，可点击跳转)。
        *   详细奖励列表 (基础奖励 + VIP额外奖励预览)。
        *   准时奖励说明。
        *   相关引导 (如“进行冥想”按钮直接跳转到冥想功能)。
        *   编辑/删除按钮 (针对自定义任务)。
    *   **交互：** 关闭弹窗，或通过引导按钮跳转。

**8. 熊猫成长/旅程页 (Panda Growth/Journey Page)**
    *   **布局：**
        *   **顶部标签页：** “成长之路”、“里程碑”、“成就”。
        *   **“成长之路”标签下：**
            *   **[熊猫当前等级和经验条]**。
            *   **[进化树/成长路径图]**：清晰展示熊猫的各个成长阶段 (幼年->少年->成年->完美形态)，以及每个阶段解锁的核心能力/外观/装备。已解锁的高亮，未解锁的置灰并显示解锁条件（如等级、消耗资源）。
            *   **[技能/能力列表]**：展示熊猫已掌握和可学习的辅助技能 (如“目标拆解助手”、“高级冥想引导者”)。
        *   **“里程碑”标签下：**
            *   按**[用户生命周期（新手/成长/成熟）]**或时间轴展示已达成和待达成的里程碑。
            *   每个里程碑显示名称、描述、达成条件、奖励预览、**[“领取奖励”按钮（若已达成未领取）]**。
        *   **“成就”标签下：**
            *   分类展示各类成就 (宠物成长、资源收集、任务完成、社交等)。
            *   每个成就显示名称、描述、达成条件、进度、奖励、**[“领取奖励”按钮]**。
    *   **交互：**
        *   点击未解锁的成长节点/技能 -> 显示详细解锁条件和效果。
        *   点击已达成的里程碑/成就 -> 领取奖励，触发庆祝动画。

**9. 幸运抽奖/奖励中心页 (Lucky Draw/Rewards Center Page)**
    *   **布局：**
        *   **顶部标签页：** “幸运抽奖”、“奖励历史/背包”。
        *   **“幸运抽奖”标签下：**
            *   **[醒目的抽奖主视觉]** (如旋转的竹筒、闪耀的宝箱)。
            *   **[当前幸运点数余额 ⭐]**。
            *   **[“抽1次”按钮 (消耗XXX幸运点数)]**。
            *   **[“抽10次”按钮 (通常有优惠，消耗YYY幸运点数)]**。
            *   **[奖池预览区]**：滚动展示或以图标形式展示奖池中的部分稀有奖励，吸引用户。可点击查看完整奖池及概率 (可选)。
            *   **[VIP每日免费抽奖次数提示/入口]** (若有)。
        *   **“奖励历史/背包”标签下：**
            *   列表形式展示用户近期获得的各类奖励 (任务、抽奖、成就、里程碑等)。
            *   可按类型筛选 (如皮肤、道具、资源)。
    *   **交互：**
        *   点击抽奖按钮 -> 触发抽奖动画 -> 展示获得奖励弹窗。
        *   浏览奖励历史，点击特定奖励可查看详情 (如皮肤预览)。

**10. 商店页 (Shop Page)**
    *   **布局：**
        *   **顶部：**
            *   **[搜索框]**。
            *   **[可横向滑动的分类标签]** (如“熊猫外观”、“家园装饰”、“实用道具”、“VIP特惠”、“资源补充”)。
        *   **商品展示区 (网格或列表)：**
            *   每个商品以**[卡片形式]**展示：商品图片、名称、价格 (金币/钻石/真实货币)、**[“购买”按钮]**。
            *   **[VIP专属商品]** 带有特殊角标。
            *   **[限时折扣商品]** 带有倒计时和折扣标识。
        *   **醒目的VIP订阅入口/广告Banner：** (见下一节付费引导界面)
    *   **交互：**
        *   点击分类标签筛选商品。
        *   点击商品卡片 -> 进入**[商品详情页]**。
        *   点击购买按钮 -> 触发购买流程 (确认弹窗 -> 支付接口)。

**11. 商品详情页 (Item Details Page)**
    *   **布局：**
        *   **[大幅商品图片/3D预览 (如熊猫皮肤可旋转查看)]**。
        *   商品名称、详细描述、属性/效果说明。
        *   价格。
        *   **[“试穿/预览”按钮 (针对外观类商品)]** -> 在熊猫模型上展示效果。
        *   **[“购买”按钮]**。
    *   **交互：** 购买，试穿，返回商店。

**12. 熊猫互动/详情页 (Pet Interaction/Details Page - 可从家园点击熊猫进入或独立入口)**
    *   **布局：**
        *   **顶部：** 熊猫名称、等级、心情、体力/健康值条。
        *   **主视觉：** 更大的可互动熊猫模型。
        *   **互动按钮区：** “喂食”、“清洁”、“玩耍”、“训练”、“学习技能”。
        *   **装备/外观切换区：** 展示已拥有的皮肤和饰品，可进行更换。
        *   **技能树/能力详情：** 查看已掌握和可学习的技能及其效果。
    *   **交互：**
        *   点击互动按钮触发相应动画和效果 (如喂食消耗资源，熊猫心情变好)。
        *   更换熊猫外观。
        *   升级技能 (若有此机制)。

**13. 心情打卡/反思模块 (Mood Check-in/Reflection Module - 通常为弹窗或引导流程)**
    *   **心情打卡 (每日一次，家园触发)：**
        *   **界面：** 简洁的表情选择 (如5个从难过到开心的熊猫表情) 或滑块。
        *   **交互：** 用户选择后，熊猫给出对应反馈 (如用户选开心，熊猫也开心；用户选难过，熊猫表示关心并可能**[引导至反思模块]**)。
    *   **反思模块 (当用户挣扎或选择深入反思时触发)：**
        *   **界面：** 对话式界面，熊猫头像和对话气泡。平静的背景。
        *   **元素：**
            *   熊猫提出的引导性问题 (文本)。
            *   用户回复选项 (按钮式选择) 或简短文本输入框。
            *   熊猫的共情回应和积极建议 (文本)。
        *   **交互：** 点击选项或输入文字，逐步推进对话。

**14. 个人资料/设置页 (Profile/Settings Page)**
    *   **布局：** 列表式。
    *   **元素：**
        *   用户头像、昵称、ID、**[VIP状态及到期日]**。
        *   数据统计 (累计完成任务数、熊猫最高等级、成就点数等)。
        *   账户管理 (修改密码、绑定邮箱/手机)。
        *   通知设置。
        *   音效/音乐开关。
        *   帮助与反馈/FAQ。
        *   联系客服。
        *   隐私政策、用户协议。
        *   “登出”按钮。
        *   **[“管理VIP订阅”入口]** (跳转至VIP总览或App Store订阅管理)。
    *   **交互：** 点击各条目进入相应设置或信息展示。

---

**III. VIP付费引导与管理界面 (VIP Onboarding & Management)**

**15. VIP特权总览页 (VIP Benefits Overview Page - 界面A1变种/扩展)**
    *   **触发点：** 点击“VIP”入口、商店内VIP广告、特定功能引导。
    *   **布局：** 精美设计的全屏页面。
        *   **顶部：** “成为熊猫守护者，尊享非凡体验！” 或类似吸引性标题，配合VIP专属视觉元素。
        *   **核心价值展示区 (卡片式/轮播式)：**
            *   **卡片1 (加速成长):** 图文并茂展示经验加成、资源获取加成、熊猫成长速度对比。
            *   **卡片2 (专属特权):** 展示可解锁的专属熊猫外观、家园装饰、高级课程、自定义目标功能。
            *   **卡片3 (丰厚福利):** 展示每日额外幸运抽奖次数、VIP专属签到奖励、月度/季度大礼包。
            *   **卡片4 (身份象征):** 展示专属头像框、称号、聊天气泡。
        *   **[用户评价/推荐语 (可选，社交证明)]**。
        *   **行动按钮区 (底部固定)：** “查看订阅计划” (引导至订阅选择页)。
    *   **交互：** 左右滑动查看不同价值点卡片，点击按钮进入下一步。

**16. 订阅选择页 (Subscription Options Page - 界面E1)**
    *   **布局：** (如前述) 至少2-3档订阅计划 (月/季/年) 卡片式并列。
        *   每档清晰列出价格、平均每月花费、核心权益差异。
        *   **[“推荐”/“最受欢迎”/“最佳价值”角标]** 突出引导。
        *   默认选中推荐档位。
        *   清晰的“确认订阅并支付”按钮。
        *   小字链接：“恢复购买”、“订阅条款”。
    *   **交互：** 选择不同档位，查看权益变化，点击确认支付 -> 调用平台支付接口。

**17. VIP限时体验引导弹窗 (VIP Limited-Time Trial Offer - 界面B1)**
    *   **布局：** (如前述) 简洁明了的弹窗。
        *   标题、核心试用特权列表、倒计时（若适用）、“立即免费试用”按钮。
    *   **交互：** 点击试用后，相关VIP功能临时解锁，主界面显示临时VIP标识和试用到期倒计时。

**18. 试用期价值回顾弹窗 (Trial Value Summary - 界面F2)**
    *   **布局：** (如前述) 试用到期前弹出。
        *   数据化展示试用期间获得的额外价值。
        *   “立即订阅保留特权”按钮。
    *   **交互：** 引导用户付费转化。

**19. VIP订阅到期提醒弹窗 (VIP Expiry Reminder - 界面B3)**
    *   **布局：** (如前述) 到期前几天弹出。
        *   视觉化倒计时、价值回顾、续订好处、续订按钮。
        *   部分VIP特权图标开始变灰。
    *   **交互：** 引导用户续订。

**20. 订阅挽留页面/流程 (Subscription Cancellation Retention Flow - 界面F3)**
    *   **触发点：** 用户尝试在应用内管理订阅并表达取消意愿时 (若平台允许此流程)。
    *   **布局 (多步弹窗/页面流)：**
        *   **步骤1 (确认):** “真的要离开吗？熊猫会想你的。” [确认取消] / [再想想]。
        *   **步骤2 (优惠/降级):** “我们为您准备了特别挽留优惠：[7折续订] 或 [保留核心特权的基础版守护者]。” [接受优惠] / [查看基础版] / [仍然取消]。
        *   **步骤3 (休眠/反馈):** “您可以选择[暂停订阅1个月，权益保留]。或告诉我们离开的原因，帮助我们改进。” [暂停订阅] / [填写问卷] / [直接取消]。
    *   **交互：** 根据用户选择推进流程，始终提供清晰的退出路径。

---

**IV. 其他辅助页面 (Other Supporting Pages)**

**21. 通知中心/消息页 (Notification Center/Messages Page)**
    *   **布局：** 列表式。
    *   **元素：**
        *   系统通知 (版本更新、活动预告、维护公告)。
        *   任务/挑战完成提醒 (若用户错过即时弹窗)。
        *   熊猫的特殊问候/关心 (如“今天天气不错，记得出门走走哦！”)。
        *   好友互动消息 (若有)。
    *   **交互：** 点击消息查看详情，可标记已读/删除。

**22. 帮助与反馈/FAQ页 (Help & Feedback/FAQ Page)**
    *   **布局：** 可搜索的FAQ列表，问题分类。
    *   **元素：**
        *   常见问题解答 (如何完成任务、熊猫如何成长、VIP权益说明等)。
        *   “联系客服”入口 (表单/邮件链接)。
        *   “提交反馈/建议”入口。
    *   **交互：** 搜索关键词，展开/折叠问题答案。

---

**总结与强调：**

*   **情感化设计：** 熊猫的表情、动作、对话应贯穿始终，传递温暖和支持。
*   **清晰的视觉引导：** 通过颜色、大小、动画等手段突出重点信息和可操作元素。
*   **流畅的交互：** 减少不必要的点击，提供即时反馈。
*   **价值驱动的付费引导：** 所有付费提示都应与用户当下场景的需求或渴望相关联，清晰展示VIP带来的实际好处。
*   **A/B测试：** 上述界面中的文案、按钮、布局、触发时机等都应作为A/B测试的候选，持续优化。

这份描述尽可能详细地勾勒了PandaHabit的界面宇宙。在实际设计过程中，每个页面还需要细化到具体的组件、间距、字体大小、颜色代码等，并制作可交互原型进行用户测试。
</file>

<file path="src/hooks/useComponentLabels.ts">
// src/hooks/useComponentLabels.ts
import { useLocalizedView } from './useLocalizedView';
import { fetchComponentsLabels } from '@/services/localizedContentService';
import type { ComponentsLabelsBundle } from '@/types';

/**
 * Hook to access localized labels for common UI components
 *
 * @returns An object containing component labels and loading/error states
 */
export function useComponentLabels() {
  const {
    labels: componentLabels,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<null, ComponentsLabelsBundle>(
    'componentsLabels',
    fetchComponentsLabels
  );

  // Default fallback labels for critical components
  const fallbackLabels: Partial<ComponentsLabelsBundle> = {
    button: {
      loading: 'Loading...',
      retry: 'Retry',
      confirm: 'Confirm',
      cancel: 'Cancel',
      save: 'Save',
      close: 'Close',
      submit: 'Submit',
      edit: 'Edit',
      delete: 'Delete',
      back: 'Back',
      next: 'Next'
    },
    loading: {
      generic: 'Loading...',
      data: 'Loading data...',
      content: 'Loading content...',
      saving: 'Saving...',
      processing: 'Processing...'
    },
    error: {
      generic: 'An error occurred',
      title: 'Error',
      retry: 'Try Again',
      details: 'Details: {message}',
      networkError: 'Network error',
      serverError: 'Server error',
      unknownError: 'Unknown error'
    },
    emptyState: {
      generic: 'No data available',
      noData: 'No data',
      noResults: 'No results found',
      noItems: 'No items'
    },
    modal: {
      close: 'Close',
      confirm: 'Confirm',
      cancel: 'Cancel'
    },
    taskReminder: {
      title: 'Panda Messenger',
      subtitle: 'Task Reminder',
      defaultMessage: 'You have a task to handle.',
      reminderTimeLabel: 'Reminder time:',
      dismissButton: 'Dismiss',
      laterButton: 'Later',
      viewTaskButton: 'View Task',
      unknownTask: 'Unknown Task'
    }
  } as ComponentsLabelsBundle;

  // Merge fetched labels with fallback labels, prioritizing fetched labels
  const mergedLabels = componentLabels
    ? {
        button: { ...fallbackLabels.button, ...componentLabels.button },
        loading: { ...fallbackLabels.loading, ...componentLabels.loading },
        error: { ...fallbackLabels.error, ...componentLabels.error },
        emptyState: { ...fallbackLabels.emptyState, ...componentLabels.emptyState },
        modal: { ...fallbackLabels.modal, ...componentLabels.modal },
        taskReminder: { ...fallbackLabels.taskReminder, ...componentLabels.taskReminder }
      }
    : fallbackLabels;

  return {
    labels: mergedLabels,
    isPending,
    isError,
    error,
    refetch
  };
}
</file>

<file path="src/scripts/addTimelyRewardCardLabels.js">
// src/scripts/addTimelyRewardCardLabels.js
// 此脚本用于向数据库添加TimelyRewardCard组件的标签

// 导入数据库
const { db } = require('../db');

// 定义要添加的标签
const timelyRewardCardLabels = [
  // 类型标签
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeLabel', languageCode: 'zh', translatedText: '类型' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeDaily', languageCode: 'en', translatedText: 'Daily Reward' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeDaily', languageCode: 'zh', translatedText: '每日奖励' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeMorning', languageCode: 'en', translatedText: 'Early Bird Reward' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeMorning', languageCode: 'zh', translatedText: '早起鸟奖励' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeStreak', languageCode: 'en', translatedText: 'Streak Reward' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeStreak', languageCode: 'zh', translatedText: '连续完成奖励' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeSpecial', languageCode: 'en', translatedText: 'Special Reward' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeSpecial', languageCode: 'zh', translatedText: '特殊奖励' },
  
  // 状态标签
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusLabel', languageCode: 'en', translatedText: 'Status' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusLabel', languageCode: 'zh', translatedText: '状态' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusActive', languageCode: 'en', translatedText: 'Active' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusActive', languageCode: 'zh', translatedText: '进行中' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusCompleted', languageCode: 'en', translatedText: 'Completed' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusCompleted', languageCode: 'zh', translatedText: '已完成' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusExpired', languageCode: 'en', translatedText: 'Expired' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusExpired', languageCode: 'zh', translatedText: '已过期' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusUpcoming', languageCode: 'en', translatedText: 'Upcoming' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusUpcoming', languageCode: 'zh', translatedText: '即将开始' },
  
  // 其他标签
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'remainingTimeLabel', languageCode: 'en', translatedText: 'Remaining time' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'remainingTimeLabel', languageCode: 'zh', translatedText: '剩余时间' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'timeEnded', languageCode: 'en', translatedText: 'Ended' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'timeEnded', languageCode: 'zh', translatedText: '已结束' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'hourUnit', languageCode: 'en', translatedText: 'h' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'hourUnit', languageCode: 'zh', translatedText: '小时' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'minuteUnit', languageCode: 'en', translatedText: 'm' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'minuteUnit', languageCode: 'zh', translatedText: '分钟' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'luckyPointsLabel', languageCode: 'en', translatedText: 'Lucky Points' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'luckyPointsLabel', languageCode: 'zh', translatedText: '幸运点' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'claimRewardButton', languageCode: 'en', translatedText: 'Claim Reward' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'claimRewardButton', languageCode: 'zh', translatedText: '领取奖励' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'inProgressButton', languageCode: 'en', translatedText: 'In Progress...' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'inProgressButton', languageCode: 'zh', translatedText: '进行中...' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedOnLabel', languageCode: 'en', translatedText: 'Completed on' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedOnLabel', languageCode: 'zh', translatedText: '完成于' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'progressLabel', languageCode: 'en', translatedText: 'Progress' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'progressLabel', languageCode: 'zh', translatedText: '进度' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'startTimeLabel', languageCode: 'en', translatedText: 'Start Time' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'startTimeLabel', languageCode: 'zh', translatedText: '开始时间' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'endTimeLabel', languageCode: 'en', translatedText: 'End Time' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'endTimeLabel', languageCode: 'zh', translatedText: '结束时间' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedTimeLabel', languageCode: 'en', translatedText: 'Completed Time' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedTimeLabel', languageCode: 'zh', translatedText: '完成时间' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'continueEffortButton', languageCode: 'en', translatedText: 'Keep Going' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'continueEffortButton', languageCode: 'zh', translatedText: '继续努力' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'noRewardsMessage', languageCode: 'en', translatedText: 'No timely rewards available' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'noRewardsMessage', languageCode: 'zh', translatedText: '暂无及时奖励' },
];

// 添加标签到数据库
async function addTimelyRewardCardLabels() {
  try {
    console.log('Adding TimelyRewardCard labels to database...');
    
    // 检查标签是否已存在
    for (const label of timelyRewardCardLabels) {
      const existingLabel = await db.uiLabels
        .where({
          scopeKey: label.scopeKey,
          labelKey: label.labelKey,
          languageCode: label.languageCode
        })
        .first();
      
      if (!existingLabel) {
        await db.uiLabels.add(label);
        console.log(`Added label: ${label.scopeKey}.${label.labelKey} (${label.languageCode})`);
      } else {
        console.log(`Label already exists: ${label.scopeKey}.${label.labelKey} (${label.languageCode})`);
      }
    }
    
    console.log('TimelyRewardCard labels added successfully.');
  } catch (error) {
    console.error('Error adding TimelyRewardCard labels:', error);
  }
}

// 执行添加标签操作
addTimelyRewardCardLabels();
</file>

<file path="src/services/abilityService.ts">
// src/services/abilityService.ts
import { db } from '@/db';
import { 
  AbilityType, 
  PandaAbilityRecord, 
  initializePandaAbilities, 
  getAllPandaAbilities 
} from './pandaAbilityService';

/**
 * Unlock a specific ability by key
 * @param abilityKey The key of the ability to unlock (e.g., 'focus_boost')
 * @param abilityType The type of the ability (passive, active, ultimate)
 */
export async function unlockAbility(abilityKey: string, abilityType: AbilityType): Promise<PandaAbilityRecord | null> {
  try {
    // Ensure abilities are initialized
    await initializePandaAbilities();
    
    // Get all abilities
    const abilities = await getAllPandaAbilities();
    
    // Find the ability by key and type
    // Note: In a real implementation, we would have a more robust way to find abilities by key
    // For now, we'll use a simple name-based approach
    const abilityToUnlock = abilities.find(ability => {
      const nameLower = ability.name.toLowerCase();
      const keyParts = abilityKey.split('_');
      
      // Check if all parts of the key are in the name
      return keyParts.every(part => nameLower.includes(part)) && ability.type === abilityType;
    });
    
    if (!abilityToUnlock) {
      console.warn(`No ability found with key ${abilityKey} and type ${abilityType}`);
      return null;
    }
    
    // Unlock the ability
    const now = new Date();
    const updatedAbility = {
      ...abilityToUnlock,
      isUnlocked: true,
      unlockDate: now
    };
    
    await db.table('abilities').update(abilityToUnlock.id!, updatedAbility);
    return updatedAbility;
  } catch (error) {
    console.error(`Error unlocking ability ${abilityKey}:`, error);
    return null;
  }
}

/**
 * Get all unlocked abilities
 */
export async function getUnlockedAbilities(): Promise<PandaAbilityRecord[]> {
  try {
    // Ensure abilities are initialized
    await initializePandaAbilities();
    
    // Get all abilities and filter for unlocked ones
    const abilities = await getAllPandaAbilities();
    return abilities.filter(ability => ability.isUnlocked);
  } catch (error) {
    console.error('Error getting unlocked abilities:', error);
    return [];
  }
}

/**
 * Get abilities by type
 * @param type The type of abilities to get
 */
export async function getAbilitiesByType(type: AbilityType): Promise<PandaAbilityRecord[]> {
  try {
    // Ensure abilities are initialized
    await initializePandaAbilities();
    
    // Get all abilities and filter by type
    const abilities = await getAllPandaAbilities();
    return abilities.filter(ability => ability.type === type);
  } catch (error) {
    console.error(`Error getting abilities of type ${type}:`, error);
    return [];
  }
}

/**
 * Get ability by ID
 * @param id The ID of the ability to get
 */
export async function getAbilityById(id: number): Promise<PandaAbilityRecord | undefined> {
  try {
    return await db.table('abilities').get(id);
  } catch (error) {
    console.error(`Error getting ability with ID ${id}:`, error);
    return undefined;
  }
}
</file>

<file path="src/services/gameInitService.ts">
// src/services/gameInitService.ts
import { db } from '@/db';
import { generateTestChallengeData } from './challengeService';
import { initializeTimelyRewards, addLuckyPoints } from './timelyRewardService';
import { recordMood, MoodType } from './reflectionService';
import { createTask, TaskStatus, TaskPriority, TaskCategory, TaskType } from './taskService';
import { updatePandaState, PandaState } from './pandaStateService';
import { generateRewards, RewardRarity, RewardType } from './rewardService';
import { unlockAbility } from './abilityService';
import { AbilityType } from './pandaAbilityService';

/**
 * Initialize game data
 * Creates sample data for all game systems
 */
export async function initializeGameData(): Promise<void> {
  try {
    console.log('Starting game data initialization...');

    // Initialize challenges
    await generateTestChallengeData();

    // Initialize timely rewards
    await initializeTimelyRewards();

    // Add some lucky points
    await addLuckyPoints(50, 'Game initialization');

    // Record initial mood
    await recordMood({
      userId: 'current-user',
      mood: 'content',
      intensity: 3,
      note: 'Starting my productivity journey'
    });

    // Create some initial tasks
    await createInitialTasks();

    // Initialize panda state
    await updatePandaState({
      mood: 'content',
      energy: 80 as any, // Type assertion to handle number vs enum
      level: 1,
      experience: 0,
      name: 'Bamboo',
      outfit: 'default',
      accessories: []
    });

    // Generate some initial rewards
    await generateInitialRewards();

    // Unlock initial abilities
    await unlockInitialAbilities();

    console.log('Game data initialization completed successfully');
  } catch (error) {
    console.error('Error initializing game data:', error);
  }
}

/**
 * Create initial tasks
 */
async function createInitialTasks(): Promise<void> {
  const now = new Date();
  const tomorrow = new Date(now);
  tomorrow.setDate(tomorrow.getDate() + 1);

  const nextWeek = new Date(now);
  nextWeek.setDate(nextWeek.getDate() + 7);

  // Get category IDs
  const categories = await db.table('taskCategories').toArray();
  const getCategoryId = (name: string) => {
    const category = categories.find(c => c.name.toLowerCase() === name.toLowerCase());
    return category ? category.id : 1; // Default to first category if not found
  };

  const tasks = [
    {
      title: 'Set up daily routine',
      description: 'Create a structured daily routine to improve productivity',
      status: TaskStatus.TODO,
      priority: TaskPriority.HIGH,
      categoryId: getCategoryId('Personal'),
      type: TaskType.DAILY,
      dueDate: tomorrow,
      estimatedMinutes: 30,
      tags: ['planning', 'productivity']
    },
    {
      title: 'Complete project proposal',
      description: 'Finish the draft proposal for the new project',
      status: TaskStatus.TODO,
      priority: TaskPriority.MEDIUM,
      categoryId: getCategoryId('Work'),
      type: TaskType.MAIN,
      dueDate: nextWeek,
      estimatedMinutes: 120,
      tags: ['work', 'project']
    },
    {
      title: 'Morning meditation',
      description: 'Practice mindfulness meditation for 10 minutes',
      status: TaskStatus.COMPLETED,
      priority: TaskPriority.MEDIUM,
      categoryId: getCategoryId('Health'),
      type: TaskType.DAILY,
      completedAt: new Date(now.getTime() - 2 * 60 * 60 * 1000), // 2 hours ago
      estimatedMinutes: 10,
      tags: ['health', 'mindfulness']
    },
    {
      title: 'Weekly grocery shopping',
      description: 'Buy groceries for the week',
      status: TaskStatus.TODO,
      priority: TaskPriority.LOW,
      categoryId: getCategoryId('Errands'),
      type: TaskType.SIDE,
      dueDate: tomorrow,
      estimatedMinutes: 60,
      tags: ['shopping', 'food']
    }
  ];

  for (const task of tasks) {
    await createTask(task);
  }
}

/**
 * Generate initial rewards
 */
async function generateInitialRewards(): Promise<void> {
  // Generate some common rewards
  await generateRewards(2, RewardRarity.COMMON, RewardType.ITEM);

  // Generate an uncommon reward
  await generateRewards(1, RewardRarity.UNCOMMON, RewardType.CURRENCY);
}

/**
 * Unlock initial abilities
 */
async function unlockInitialAbilities(): Promise<void> {
  // Unlock basic abilities
  await unlockAbility('focus_boost', AbilityType.PASSIVE);
  await unlockAbility('quick_start', AbilityType.ACTIVE);
}
</file>

<file path="src/utils/localization.ts">
// src/utils/localization.ts
import { db } from '@/db';

/**
 * Get a localized label from the database
 * @param scopeKey The scope key of the label (e.g., 'abilities')
 * @param labelKey The label key (e.g., 'bambooHeart.name')
 * @param languageCode The language code (e.g., 'en', 'zh')
 * @returns The localized text or null if not found
 */
export async function getLocalizedLabel(
  scopeKey: string,
  labelKey: string,
  languageCode: string
): Promise<string | null> {
  try {
    // Check if the database is initialized
    if (!db.tables.some(table => table.name === 'uiLabels')) {
      console.warn('uiLabels table does not exist yet');
      return null;
    }

    // Query the database for the label
    const label = await db.table('uiLabels')
      .where('[scopeKey+labelKey+languageCode]')
      .equals([scopeKey, labelKey, languageCode])
      .first();

    return label ? label.translatedText : null;
  } catch (error) {
    console.error(`Error getting localized label for ${scopeKey}.${labelKey} in ${languageCode}:`, error);
    return null;
  }
}

/**
 * Get all localized labels for a specific scope and language
 * @param scopeKey The scope key of the labels (e.g., 'abilities')
 * @param languageCode The language code (e.g., 'en', 'zh')
 * @returns An object with label keys as properties and translated text as values
 */
export async function getLocalizedLabels(
  scopeKey: string,
  languageCode: string
): Promise<Record<string, string>> {
  try {
    // Check if the database is initialized
    if (!db.tables.some(table => table.name === 'uiLabels')) {
      console.warn('uiLabels table does not exist yet');
      return {};
    }

    // Query the database for all labels in the scope and language
    const labels = await db.table('uiLabels')
      .where('[scopeKey+languageCode]')
      .equals([scopeKey, languageCode])
      .toArray();

    // Convert to an object with label keys as properties
    const result: Record<string, string> = {};
    for (const label of labels) {
      result[label.labelKey] = label.translatedText;
    }

    return result;
  } catch (error) {
    console.error(`Error getting localized labels for ${scopeKey} in ${languageCode}:`, error);
    return {};
  }
}

/**
 * Get the current language code from localStorage
 * @returns The current language code (defaults to 'en')
 */
export function getCurrentLanguageCode(): string {
  return localStorage.getItem('language') || 'en';
}

/**
 * Set the current language code in localStorage
 * @param languageCode The language code to set
 */
export function setCurrentLanguageCode(languageCode: string): void {
  localStorage.setItem('language', languageCode);
}

/**
 * Format a date according to the current locale
 * @param date The date to format
 * @param options The Intl.DateTimeFormatOptions to use
 * @returns The formatted date string
 */
export function formatLocalizedDate(
  date: Date,
  options: Intl.DateTimeFormatOptions = { 
    year: 'numeric', 
    month: 'short', 
    day: 'numeric' 
  }
): string {
  const languageCode = getCurrentLanguageCode();
  return new Intl.DateTimeFormat(languageCode, options).format(date);
}

/**
 * Format a number according to the current locale
 * @param number The number to format
 * @param options The Intl.NumberFormatOptions to use
 * @returns The formatted number string
 */
export function formatLocalizedNumber(
  number: number,
  options: Intl.NumberFormatOptions = { 
    style: 'decimal'
  }
): string {
  const languageCode = getCurrentLanguageCode();
  return new Intl.NumberFormat(languageCode, options).format(number);
}
</file>

<file path="task.md">
# 设计与实现差异记录

## 1. 目录结构与组件分布
- 设计文档建议采用原子设计法（Atoms、Molecules、Organisms），实际 `src/components` 下已分为 common、animation、decoration、game、layout、panda、reflection、store、task、tasks 等子目录，基本覆盖设计要求，但部分命名与分层略有不同。
- 没有单独的 `game` 目录，游戏化相关内容分布在 `components/game`、`panda`、`store` 等，需统一文档与实现的术语。

## 2. 主要页面实现情况
- 设计文档要求的主要页面（主页、任务、挑战、成长/旅程、商店、反思/茶室等）在 `src/pages` 下均有对应实现（如 HomePage、TasksPage、ChallengesPage、StorePage、TeaRoomPage 等），基本覆盖。
- 页面命名与设计文档略有差异，如“成长之道”在代码中为 JourneyPage 或未明确命名。

## 3. 视觉风格与动画
- 设计文档强调华丽中国风、金色点缀、渐变、粒子动画等，`components/animation` 下有丰富动画组件（如 GoldenGlow、InkSplash、RewardAnimation、TaskCompletionAnimation），但需进一步核查是否所有页面和交互均已应用。
- `components/decoration` 提供了中国风装饰组件（如 ChineseDecoration、LanternDecoration），但实际页面装饰应用情况需进一步核查。

## 4. UI原子组件
- 设计文档要求按钮、输入框、进度条等需有中国风装饰、金色点缀、动画反馈，`components/common` 下有 Button、ProgressBar、Modal 等基础组件，但未见输入框（Input）组件，需补充。
- 按钮、进度条等是否完全符合设计稿的视觉细节（如软圆角、金色描边、粒子特效）需进一步对比。

## 5. 游戏化与虚拟宠物
- 设计文档对熊猫成长、情感状态、资源系统、奖励系统等有详细描述，`components/game` 下有 PandaAvatar、ResourceDisplay、TimelyRewardCard、LuckyDraw 等组件，基本覆盖。
- 熊猫成长阶段、情感状态、定制化等细节实现情况需进一步核查（如 PandaCustomizationPanel、PandaEnvironmentPanel 是否完整实现所有设计要求）。

## 6. 反思与支持模块
- 设计文档有“反思模块（静心茶室）”，`pages/TeaRoomPage.tsx` 及 `components/reflection` 下有相关实现（EnhancedReflectionModule、MoodTracker 等），需进一步核查交互与动画细节是否达标。

## 7. 其他差异与建议
- 设计文档对字体、色彩、动画、装饰等有详细要求，需结合实际 UI 进一步对比（如字体是否已全局应用，色彩方案是否一致）。
- 建议后续梳理每个页面和核心组件的 UI 细节与交互，逐项对照设计文档补齐差异。

---

> 本文件为初步差异梳理，建议后续结合具体 UI 截图和代码细节进一步完善。
</file>

<file path=".gitignore">
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage
/.nyc_output

# next.js
/.next/
/out/
/dist/

# production
/build

# misc
.DS_Store
*.pem
# .env
# .env.local
.env.development.local
.env.test.local
.env.production.local
# .env.mock

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
# .env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# IDE
.idea/
.vscode/
*.swp
*.swo

# Capacitor
/android/
/ios/
/capacitor/

# Database
/data/
*.db
*.sqlite
*.sqlite3

# Logs
/logs/
*.log

# Cache
.cache/
.temp/

# Build
/dist/
/build/
/out/

# Test
/coverage/
/.nyc_output/

# Misc
.DS_Store
Thumbs.db
*.bak
*.tmp
*.temp
</file>

<file path="app-design-brief.md">
# PandaHabit App Design Brief: 华丽游戏风格

## 1. Introduction

### 1.1 Overview
PandaHabit是一款移动应用，通过引人入胜且支持性的虚拟宠物体验，帮助用户建立积极的习惯，改善自我护理，提升心理健康。用户通过完成现实生活中的任务和习惯来培养虚拟熊猫，创造一种共生关系，照顾自己直接有益于宠物，而宠物则提供陪伴、动力和温和的指导。

### 1.2 华丽游戏风格设计理念（融合价值驱动）
PandaHabit的设计理念围绕创造一种**华丽奢华且价值驱动的游戏体验**，给人以高级感、沉浸感和情感满足感。应用旨在通过利用精美绚丽的视觉效果、精心设计的交互和令人惊叹的动画效果，将自我护理从一项琐事转变为一段愉悦的旅程。我们采用了东方美学与现代游戏设计相结合的方式，打造出一个既华丽壮观又温馨舒适的数字空间。所有华丽的视觉和交互，都服务于清晰地传递PandaHabit为用户带来的核心价值，特别是VIP订阅所能提供的卓越支持与体验升级。

### 1.3 目标用户
- 寻求习惯养成和自我护理工具的个人
- 喜欢游戏化和虚拟宠物体验的用户
- 渴望获得支持性、温和方式进行个人发展的人群
- 年龄范围：18-45岁，重点关注年轻专业人士和学生
- 欣赏高品质数字体验并愿意投资优质应用的用户
- 对东方美学和华丽视觉风格有偏好的玩家

## 2. 华丽游戏风格分析

### 2.1 华丽游戏风格定义

对于PandaHabit，"华丽游戏风格"的定义包括：
- **绚丽华美的视觉效果**，包含精细的插画和动画，灵感来源于东方美学和传统中国艺术。VIP专属内容（如皮肤、场景）将采用更高级别的细节和光效，以彰显其独特性。
- **金碧辉煌的色彩搭配**，融合深沉的宝石色调、金色点缀、精致的渐变和传统中国色彩。金色和特定宝石色（如紫檀紫）将优先用于VIP相关元素，营造尊贵感。
- **精雕细琢的UI元素**，注重阴影、高光和纹理细节，采用传统中国装饰元素（如云纹、如意纹）。VIP相关按钮、卡片将拥有更复杂的纹饰和更显著的动态效果。
- **流畅华丽的动画效果**，提供视觉反馈和愉悦感，动画风格融合现代游戏与传统水墨画动态美感。VIP特权带来的加速、额外奖励等将通过更炫丽、更具冲击力的动画来体现。
- **沉浸式音效设计**，结合平静的自然声音、传统中国乐器和温柔的音乐元素。VIP专属场景或互动将配备独特的背景音乐或音效。
- **精心设计的字体排版**，平衡可读性与美学吸引力，中文使用优雅的书法风格字体。VIP身份标识、特权描述将使用更具艺术感的字体或特殊排版。

### 2.2 视觉参考与灵感来源
- **高品质移动游戏**：《原神》(整体UI风格与动效)、《天涯明月刀》(中国风元素)、《阴阳师》(华丽特效)
- **中国传统艺术**：水墨画、竹子图案、山水画、传统纹饰、剪纸艺术、京剧脸谱元素
- **奢侈品牌应用**：上海滩、故宫文创、Louis Vuitton中国版
- **自然启发设计**：国家地理、高端度假村网站、中国园林设计
- **古典游戏美学**：《轩辕剑》系列、《仙剑奇侠传》系列的视觉风格
- **现代中国风设计**：当代中国插画师作品、新中式设计元素

### 2.3 华丽色彩方案（突出VIP尊贵感）
- **主要色彩**:
  - 皇家翡翠绿 (#1A5F4A)：代表成长、宁静与自然，灵感来自传统中国玉器
  - 富贵竹绿 (#88B04B)：象征熊猫的食物和活力，传递生机与希望
  - 瑞雪白 (#F7F9F9)：提供视觉呼吸空间和清晰度，象征纯净与和谐
  - 朱砂红 (#D73E35)：传统中国红，象征喜庆、活力与好运
- **点缀色彩**:
  - **华贵金 (#D4AF37):** 大量用于VIP身份标识、特权奖励、付费按钮、重要成就等，象征尊贵与价值。
  - 青花蓝 (#1A6DB0)：代表水分和流动，灵感来自青花瓷
  - 牡丹粉 (#F8C8DC)：增添温暖和情感连接，灵感来自中国传统花卉
  - **紫檀紫 (#5D3954):** 可用于VIP专属界面的背景或高级订阅档位的视觉强调，增添神秘与高贵。
- **功能色彩**:
  - 如意绿 (#2E8B57)：表示完成和积极成果，灵感来自如意玉器。VIP用户完成任务或获得奖励时，此绿色可带有金色粒子效果。
  - 琥珀黄 (#FFA500)：引起注意但不刺眼，灵感来自古代琥珀饰品
  - 墨灰 (#8A8D91)：用于次要文本和非活动元素，灵感来自水墨画

### 2.4 字体设计（区分普通与VIP信息）
- **主标题字体**:
  - 中文："方正清刻本悦宋"，传递典雅与永恒感。
  - 英文："Playfair Display"，与中文字体风格相协调。
  - 用于页面标题、成就名称和重要标签，配以金色描边增强华丽感。
- **正文字体**:
  - 中文："思源宋体"，高可读性，带有友好、平易近人的感觉。
  - 英文："Nunito Sans"，与中文字体搭配和谐。
  - 用于任务描述、说明和一般内容，保持清晰易读。
- **装饰字体 / VIP专属字体**:
  - 中文："庞门正道行书" 或 更具识别度的付费书法字体（如“汉仪尚巍手书”）。
  - 英文："Caveat" 或 更优雅的衬线手写体。
  - 用于VIP特权描述、专属活动标题、熊猫的特殊VIP问候等，增强独特性和情感连接。

### 2.5 UI组件设计指南（强化VIP元素的视觉层级）
- **按钮**：
  * 普通按钮：传统中国风格元素装饰的软圆角矩形，配以精致渐变。
  * VIP/付费引导按钮：采用更华丽的云纹、如意纹或龙纹装饰，颜色以华贵金、朱砂红为主，配以动态光效、更显著的粒子效果，点击动画更具冲击力。
- **卡片**：
  * 普通卡片：层叠设计，精致阴影和纹理背景，传统纹饰边框。
  * VIP特权展示卡片/订阅选项卡片：边框采用更复杂的金色或红色描边，背景可使用丝绸或锦缎等高级纹理，重要信息区域可有微光浮动效果。
- **图标**：
  * 普通图标：水墨画风格，笔触一致，圆润边角。
  * VIP专属功能图标：在水墨风格基础上增加金色点缀或微小动态光效，使其在视觉上更突出。
- **进度指示器**：
  * 普通进度条：优雅环形或线性，水墨晕染填充。
  * 及时性进度条/VIP加速进度条：采用更华丽的卷轴或龙形竹简形式，填充动画可加入金色粒子流光效果，完成时有更盛大的庆祝动画。
- **输入框**：简约设计，带有微妙边框和焦点状态，边框采用传统纹饰，激活时有水墨扩散效果。
- **弹窗**：
  * 普通弹窗：居中设计，装饰性框架采用传统窗棂样式，半透明背景模仿宣纸质感。
  * VIP引导/优惠弹窗：框架可采用更华丽的雕花或镶金设计，背景可加入动态祥云或牡丹盛开等元素，按钮设计参照VIP按钮。

## 3. 信息架构

### 3.1 导航结构
基于PRD，PandaHabit将使用底部标签导航，具有以下主要部分，每个导航图标都采用华丽的中国风设计：

1. **主页（竹林家园）**：主仪表盘，展示熊猫、及时奖励进度条和快速操作，背景为动态竹林场景
2. **任务（修行之路）**：日常任务列表和管理，设计为古代卷轴样式
3. **挑战（江湖历练）**：长期目标和特别活动，设计为地图探险风格
4. **旅程（成长之道）**：熊猫成长路径和里程碑，设计为传统山水画卷
5. **商店（珍宝阁）**：装饰物品、资源和VIP订阅，设计为古代商铺风格

次要导航包括：
- **熊猫互动（心灵相通）**：通过点击主页上的熊猫访问，设计为精美的互动场景
- **幸运抽奖（福缘抽签）**：通过顶部导航中的专用图标访问，设计为传统抽签与宝箱相结合的形式
- **设置（玉简设定）**：通过右上角的齿轮图标访问，图标设计为古代玉简
- **反思模块（静心茶室）**：根据用户行为情境触发，设计为宁静的传统茶室环境

### 3.2 用户流程图
关键用户流程包括，每个流程都配有华丽的过渡动画和视觉引导：

1. **新用户引导（初入仙境）**：
   - 应用介绍（古卷展开动画）→ 熊猫定制（水墨渲染效果）→ 首个任务设置（卷轴书写动画）→ 任务完成（金光特效）→ 奖励（宝箱开启动画）→ 主页（竹林展开效果）

2. **日常习惯打卡（每日修行）**：
   - 通知（熊猫信使动画）→ 任务页面（卷轴展开）→ 任务完成（墨迹渲染动画）→ 及时奖励（金币飞舞效果）→ 熊猫互动（熊猫欢喜动画）

3. **挑战参与（江湖探索）**：
   - 挑战页面（地图展开动画）→ 挑战选择（地点点亮效果）→ 日常子任务（小卷轴展开）→ 进度跟踪（地图路径点亮）→ 完成奖励（宝箱华丽开启）

4. **反思过程（茶道静心）**：
   - 触发事件（茶杯图标出现）→ 温和提示（熊猫邀请动画）→ 反思问题（水墨扩散效果）→ 支持性反馈（熊猫安慰动画）→ 行动建议（竹简展开效果）

5. **VIP转化（飞升之路）**：
   - 功能互动（金色光芒提示）→ VIP提示（华丽卷轴展开）→ 福利展示（金光特效展示）→ 订阅选择（玉璧选择界面）→ 购买确认（祥云环绕动画）

### 3.3 屏幕层次结构
屏幕层次结构遵循从一般到特定的逻辑进展，每一层都有独特的视觉风格：

- **第一层**：主标签屏幕（竹林家园、修行之路、江湖历练、成长之道、珍宝阁），设计为完整的场景画面
- **第二层**：特定功能屏幕（心灵相通、福缘抽签、玉简设定），设计为主场景的特写或变体
- **第三层**：详情屏幕（任务详情、挑战详情、物品详情），设计为精美的卷轴或玉简展开
- **第四层**：流程屏幕（静心茶室、VIP购买、任务创建），设计为特殊互动场景

## 4. Detailed UI/UX Design

### 4.1 主页（竹林家园）
主页是情感中心和主要仪表盘，需强化“华丽游戏风格”与互动体验：

- **顶部区域**：
  - 用户头像/资料（左上），VIP用户有专属徽章与动画光效
  - 货币显示（金币、钻石、幸运点），采用立体金属质感与粒子特效
  - 设置齿轮（右上），以玉简或祥云为造型，带入场动画
  - 幸运抽奖入口，常驻闪烁粒子与动态高亮

- **中央区域**：
  - 大幅精美熊猫插画，分阶段成长，状态与互动均有丰富动画（如眨眼、伸懒腰、撒娇）
  - 环境为动态竹林，随时间变化光影，加入蝴蝶、竹叶飘落等粒子动效
  - 及时性进度条设计为华丽卷轴或竹简，填充动画有水墨晕染与金光粒子
  - 奖励预览采用宝箱/卷轴展开动画，奖励图标有高光与弹跳特效

- **底部区域**：
  - 活跃任务快捷入口，卡片采用浮雕、金边、云纹等装饰，完成时有粒子爆发动画
  - 最近奖励日志，图标逐条滚动出现，带有淡入淡出与粒子点缀
  - 底部导航栏为自定义中国风图标，选中有祥云流动与高亮特效，整体采用半透明玉石质感

### 4.2 任务页（修行之路）
任务页需突出“古卷”与“华丽动效”主题，提升交互仪式感：

- **顶部区域**：
  - 日期展示采用书法字体与祥云装饰，背景为淡雅宣纸纹理
  - 每日进度条为卷轴展开动画，填充时有水墨晕染与金光粒子
  - 筛选/排序下拉菜单为玉佩/竹简造型，展开有弹性动画

- **任务列表**：
  - 滚动列表，每个任务卡片为立体浮雕卷轴，边框有金色描边与云纹
  - 任务类型图标为水墨风，任务名用宋体/书法字体，重要任务有特殊高亮
  - 奖励预览图标有弹跳与高光动画
  - 及时性任务有⏰/✨特效，完成时有粒子爆发与卷轴印章动画
  - 时间窗口倒计时为动态沙漏/水滴，挑战/自定义目标有专属标识（如火焰/熊猫头像）

- **新增任务按钮**：
  - 悬浮金色圆形按钮，中心为加号，按钮有脉冲光圈与粒子环绕

### 4.3 挑战页（江湖历练）
挑战页需强化“地图探险”与“成就感”视觉：

- **顶部区域**：
  - 挑战分类Tab为古代令牌/竹简造型，切换有翻转/卷轴展开动画
  - 顶部装饰随挑战主题变换（如山水、火焰、祥云）

- **挑战卡片**：
  - 卡片为立体浮雕，背景为地图/山水画卷，主标题用金色描边字体
  - 关键奖励有宝箱/玉璧高亮展示，奖励图标有光晕与粒子特效
  - 进度条为竹节/卷轴，填充有水墨流动动画
  - 时间限制为动态倒计时，未完成时有轻微闪烁
  - 子任务可展开，完成有印章/祥云动画
  - 接受/领取按钮为玉佩造型，点击有弹跳与粒子爆发

### 4.4 成长之道（旅程页）
成长之道需突出“进化仪式感”与“东方美学”：

- **成长路径可视化**：
  - 采用山水画卷式时间轴或树状结构，节点间用祥云/竹节连接
  - 每个节点为熊猫不同成长阶段小像，完成节点有金光高亮与粒子庆祝
  - 当前节点脉冲动画，未解锁节点半透明并有神秘光效
  - 奖励预览为玉简/宝箱展开，奖励图标有高光与弹跳

- **Milestone Log**:
  - Scrollable timeline with rich visual treatment
  - Achievement cards with decorative frames
  - Date stamps with elegant typography
  - Reward recap with animated icons

### 4.5 商店页（珍宝阁）
商店页需营造“奢华购物”与“收藏展示”氛围：

- **顶部区域**：
  - 搜索栏为玉简/祥云造型，输入时有光效流动
  - 分类筛选为立体玉佩/卷轴，选中有高亮与粒子环绕
  - 特色商品轮播为宝箱/玉璧展示，切换有翻转动画

- **商品网格**：
  - 商品卡片为浮雕金边，插画高精度并带有微动画
  - 价格用金色字体与立体货币图标，VIP商品有专属光效与标识

- **商品详情**：
  - 大图预览支持3D旋转，描述区用宋体/书法字体
  - 熊猫定制类商品有前后对比动画
  - 购买按钮为玉璧/祥云造型，点击有粒子爆发
  - 相关商品横向滚动，卡片有弹跳与高光

### 4.6 熊猫互动页（心灵相通）
强化“亲密互动”与“动态环境”体验：

- **环境设计**：
  - 背景为高精度中国园林，随时间变化光影，加入动态水面、竹叶、祥云等粒子
  - 环境元素可交互（如点击水池有涟漪，竹叶可飘落）

- **熊猫可视化**：
  - 熊猫大幅动态插画，情绪通过表情、动作、特效展现（如开心时有金光、撒娇时有爱心粒子）
  - 定制装饰高精度渲染，稀有物品有特殊光效

- **互动控件**：
  - 按钮为玉佩/祥云造型，点击有弹跳与粒子动画
  - 喂食、玩耍、训练均有专属动画与奖励反馈
  - 反思提示为温柔弹窗，背景虚化并有祥云环绕

### 4.7 幸运抽奖页（福缘抽签）
突出“仪式感”与“惊喜感”视觉：

- **顶部区域**：
  - 幸运点余额为立体玉璧计数器，周围常驻闪烁粒子

- **抽奖机制**：
  - 抽奖动画为华丽宝箱/转盘/竹简展开，粒子与音效营造期待氛围
  - 抽奖按钮为金色祥云造型，点击有高光与粒子爆发
  - 结果揭晓有卷轴展开、宝箱开启等庆祝动画

- **奖池展示**：
  - 奖品以画廊形式展示，稀有度用金光/祥云特效区分
  - 概率用精美数据可视化，近期中奖有时间轴动画

### 4.8 反思模块（静心茶室）
营造“静谧治愈”与“温柔支持”氛围：

- **视觉设计**：
  - 背景为淡雅茶室/山水，祥云、茶烟等柔和动画，整体色调温暖柔和
  - UI元素极简，减少干扰，输入区为宣纸/竹简造型

- **交互设计**：
  - 熊猫头像有同理心表情，文字对话采用逐字淡入动画
  - 输入方式为定制按钮/温柔文本框，反馈有水墨扩散动画
  - 阶段切换为卷轴展开/祥云流动，整体过渡平滑

## 5. Core Gameplay Elements

### 5.1 Panda Companion Visualization
The Panda companion is the emotional heart of the app and features:

- **Growth Stages**:
  - Infant: Small, extra fluffy with large eyes and playful movements
  - Youth: More active, curious expressions, developing unique personality
  - Adult: Graceful, wise appearance with confident posture
  - Perfect Form: Majestic presence with subtle glow effects and special animations

- **Emotional States**:
  - Happy: Bright eyes, smiling expression, energetic movements
  - Neutral: Calm demeanor, regular breathing animation
  - Concerned: Gentle head tilt, softer movements, attentive gaze

- **Customization Visualization**:
  - Seamless integration of accessories and clothing
  - Environment decorations that the Panda interacts with
  - Special effects for rare or VIP items

### 5.2 Resource System Visualization
Resources are presented with premium visual treatment:

- **Resource Icons**:
  - Bamboo: Detailed, realistic bamboo stalks with subtle shine
  - Water: Crystal-clear droplets with light refraction effects
  - Coins: Ornate gold coins with embossed panda design
  - Diamonds: Multi-faceted gems with light reflection and sparkle

- **Resource Animations**:
  - Collection: Satisfying gather animation with particle effects
  - Spending: Elegant transfer animation from inventory to use
  - Low resources: Subtle visual indicator without being punitive
  - Resource milestone: Special celebration animation

### 5.3 Timely Reward System Visualization
The Timely Reward System features premium visual elements:

- **Timeliness Bar**:
  - Elegant scroll or bamboo-themed progress indicator
  - Rich fill animation with particle effects
  - Reward preview with subtle highlight animation
  - Completion celebration with luxurious visual effects

- **Luck Points**:
  - Premium counter with sparkle animation
  - Earning visualization with floating point animation
  - Accumulation milestone effects with special visual treatment

- **On-Time Completion**:
  - Satisfying visual feedback for timely task completion
  - Special animation for "Early Bird" bonus
  - Elegant visual connection between task completion and rewards

### 5.4 Challenge System Visualization
Challenges are presented with immersive visual elements:

- **Challenge Categories**:
  - Visual theming for different challenge types
  - Custom illustrations for challenge backgrounds
  - Animated transitions between categories

- **Progress Tracking**:
  - Rich progress bar design with milestone markers
  - Sub-task completion visualization with elegant checkmarks
  - Time remaining indicator with premium countdown design

- **Reward Presentation**:
  - Treasure chest or gift box animation for claiming rewards
  - Particle effects and sound design for celebration
  - Reward showcase with detailed item presentation

## 6. Monetization Design

### 6.1 VIP订阅 UI/UX 设计与付费引导策略

PandaHabit 的VIP订阅体系采用分层、价值驱动、游戏化体验与用户心理激励相结合的设计，全面融合Checklist 2.0与最新增长策略，具体包括：

#### 6.1.1 VIP特权可视化与差异化
- 主页、个人资料、排行榜等处，VIP用户拥有专属徽章、动态光效、昵称特殊标识。
- VIP权益总览页：采用对比卡片清晰展示免费与VIP的核心差异（如奖励倍增、成长加速、专属外观/任务/课程等），配合高亮动画与视觉强化。
- 任务、成长、抽奖等关键节点，VIP额外奖励以金色高亮、皇冠标记、粒子特效等方式即时反馈，未订阅用户可见灰色预览并引导升级。

#### 6.1.2 智能化付费场景与弹窗引导
- 关键时刻（如熊猫进化、挑战达成、稀有奖励获得）弹窗庆祝并顺势推荐VIP权益，按钮文案与视觉强化“立即升级享更多惊喜”。
- 用户遇到瓶颈、资源短缺、功能受限时，弹出温和提示条/气泡，说明VIP可带来的便利与加速。
- 访问VIP专属内容时，弹窗简明介绍该功能优势，并提供“了解守护者特权”入口。

#### 6.1.3 灵活订阅体系与试用/挽留机制
- 订阅选择页采用卡片式并列布局，突出“推荐”与“最佳价值”档位，清晰列出价格、权益、平均月费。
- 新用户/活动期间弹窗引导免费试用VIP，试用期间界面临时显示VIP标识，相关功能解锁。
- 试用到期前弹窗数据化回顾试用期间获得的额外价值，强化转化意愿。
- 用户尝试取消订阅时，分阶段弹窗挽留：先情感挽留（熊猫表情）、再提供优惠/降级/休眠选项，最后引导填写反馈，始终保证退出路径清晰。

#### 6.1.4 社交认同与荣誉激励
- 商店、主城、排行榜等处低频滚动显示“玩家XXX刚刚成为VIP”，增强社交影响。
- 团队挑战中，队伍有VIP成员时全队获得小幅增益。
- 订阅专属成就、称号系统，VIP用户可装备带有特殊视觉效果的荣誉称号。

#### 6.1.5 转化与A/B测试优化
- 所有付费提示与弹窗均与用户当前场景需求紧密关联，突出VIP带来的实际好处。
- 付费引导文案、按钮、布局、触发时机等均纳入A/B测试，持续数据驱动优化。
- 保证核心免费体验完整，VIP更多为加速与增值，避免“付费墙”阻塞。

#### 6.1.6 前瞻性探索与创新
- 预留NFT徽章、UGC激励、现实联动等创新付费模式接口。

### 6.2 商店与VIP商品体验
- 商店首页Banner、分类标签、商品卡片均突出VIP专属内容，VIP商品有特殊光效与角标。
- 购买流程配合粒子爆发、玉璧/祥云动画，VIP商品购买需验证VIP身份。
- VIP专属礼包、限时优惠、首购礼包等均有动态倒计时与视觉强化。

### 6.3 关键界面与流程补充
- 主页、任务页、成长页等处，VIP相关入口、奖励、功能均有高亮、动画、专属标识。
- 订阅到期前，部分VIP特权图标逐渐变灰或加锁，配合倒计时弹窗提醒续订。
- 试用、转化、挽留、社交激励等所有流程均有详细弹窗、按钮、动画与文案设计，确保体验流畅且具吸引力。

### 6.4 数据驱动与公平性保障
- 全路径转化追踪、用户分层、行为分析、退订原因收集等数据埋点，持续优化付费引导。
- 明确红线：核心玩法对所有用户开放，VIP仅加速/增值，PVP平衡、定价透明。

## 7. Technical Implementation Guidelines

### 7.1 Integration with Existing Codebase
The implementation will build upon the existing React/TypeScript architecture:

- Leverage the current component structure while enhancing visual elements
- Maintain the existing data flow patterns while adding new features
- Extend the current state management approach to include new game elements

### 7.2 Internationalization Approach
Building on the existing i18n infrastructure:

- Extend the current language system to include game-specific terminology
- Ensure all new UI elements support multiple languages
- Implement culturally appropriate visual elements for different regions

### 7.3 Component Structure
The component architecture will follow a modular approach:

- **Atomic Design Methodology**:
  - Atoms: Basic UI elements (buttons, inputs, icons)
  - Molecules: Compound components (task cards, reward displays)
  - Organisms: Feature sections (task list, panda interaction area)
  - Templates: Page layouts with placeholder content
  - Pages: Complete screens with real content

- **Game-Specific Components**:
  - PandaAvatar: Handles rendering and animating the Panda
  - ResourceDisplay: Manages resource visualization
  - RewardAnimation: Controls reward presentation effects
  - ChallengeTracker: Visualizes challenge progress

### 7.4 State Management
The state management approach will handle game-specific requirements:

- User progress and achievements stored in persistent state
- Real-time interactions managed with local state
- Animation states controlled with dedicated hooks
- Game mechanics (timers, random events) managed with specialized services

## 8. Appendices

### 8.1 Asset Requirements
- High-resolution Panda illustrations in various poses and growth stages
- Premium UI element designs (buttons, cards, icons)
- Environmental elements and backgrounds
- Resource and reward visualizations
- Animation sequences for key interactions

### 8.2 Animation Specifications
- Micro-interactions for UI elements (button presses, switches, sliders)
- Character animations for the Panda (idle, happy, concerned, interactions)
- Reward and achievement celebrations
- Transition effects between screens and states

### 8.3 Accessibility Considerations
- Color contrast compliance for all UI elements
- Alternative text for decorative elements
- Keyboard navigation support
- Screen reader compatibility
- Motion reduction options for animations
</file>

<file path="checklist.md">
好的，这份游戏化App订阅付费引导Checklist非常详尽，已经涵盖了很多关键点。结合YouTube上一些产品设计、游戏化和用户增长“大神”们常分享的理念，我们可以从以下几个方面进行梳理和优化，使其更聚焦、更具战略性，并强调一些他们可能会反复强调的原则：

**核心优化思路：**

1.  **强化“用户中心”和“价值驱动”**：大神们通常强调，最好的付费引导是让用户“心甘情愿”地付费，因为他们清晰感知到了价值，而不是被“套路”。
2.  **简化决策，突出锚点**：避免过多选择，利用心理学锚点引导用户选择最优方案。
3.  **测试与迭代的强调**：将A/B测试和数据驱动的理念更深地融入。
4.  **长期主义与用户信任**：避免短期榨取，建立长期信任关系。
5.  **更精炼的分类和命名**：让Checklist更易理解和传播。

**优化后的订阅付费引导Checklist建议：**

---

**【游戏化App订阅增长黄金法则：Checklist 2.0】**

**🎯 核心目标：在提升订阅转化的同时，最大化用户生命周期价值 (LTV) 并维护健康的游戏生态。**

---

### **一、清晰的价值主张 (Clear Value Proposition)**
*“让玩家一眼看懂‘我为什么需要这个？’并感到物超所值。”*

✅ **核心特权可视化与差异化**
-   [ ] **身份彰显：** 订阅身份的专属视觉标识（如特殊头像框、动态称号、聊天气泡、角色光环）。
-   [ ] **功能/效率对比：** 清晰展示订阅版在核心体验上的显著优势（例如：免费版建造耗时1小时 vs 订阅版15分钟，并配有加速动画；免费每日奖励x1 vs 订阅x3）。
-   [ ] **即时收益反馈：** 在关键节点（如战斗胜利、任务完成、升级）明确展示订阅带来的“额外”即时收益（如额外经验条、专属掉落物图标+数量，配合音效和粒子效果）。
-   [ ] **“解锁”型激励：** 巧妙展示订阅可解锁的内容或加速的进度，例如“订阅即可立即体验后续章节/获得高级资源包/解锁专属角色故事线”。

✅ **营造“拥有感”与“损失规避”心理**
-   [ ] **订阅特权“预览”/“限时体验”：** 允许免费玩家短暂体验部分核心订阅功能（如关键战斗前“本次战斗可试用VIP急速模式”），体验后提示“订阅保留此特权”。
-   [ ] **资源/时间节省提示：** 当玩家面临资源短缺或耗时操作时，适时提示订阅如何高效解决问题（例如“订阅立享每日免费体力补给/建造队列+1”）。
-   [ ] **订阅到期提醒与价值重申：** 到期前通过视觉化倒计时（如逐渐“变灰”的特权图标）、权限“逐步失效”预览等方式提醒，并重申订阅期间已享受的价值或“若续订可继续享有XX特权”。

---

### **二、智能化的付费场景 (Intelligent Payment Scenarios)**
*“在玩家最需要、最渴望或情绪最高涨的时刻，自然地呈现机会。”*

✅ **关键时刻与情感连接**
-   [ ] **高光时刻助推：** 在玩家获得成就、稀有掉落、险胜PVP等积极情绪顶点，适时推荐相关订阅增益（如“订阅后此类奖励翻倍/永久提升爆率/解锁专属庆祝动作”）。
-   [ ] **痛点解决方案：** 在玩家遇到挫折、瓶颈（如PVP连续失败、高难度关卡卡关、重要物品合成失败）时，提供订阅作为“优雅”的解决方案（如订阅专享“再试一次”机会、“属性临时增强”道具、“保底成功率”特权）。
-   [ ] **社交对比与向往：** 在排行榜、好友列表、观战等场景，清晰展示高阶玩家的订阅标识及其带来的可见优势（如专属外观、更高排名加成），激发向往。

✅ **限时稀缺与首购激励**
-   [ ] **动态化限时优惠：** 商城或特定触发点出现“仅剩XX小时：新手特惠订阅包/节日限定订阅礼遇”（配合倒计时器）。
-   [ ] **里程碑式首购礼包：** 新玩家在特定游戏进度或注册时长内（如完成新手教程后/注册3天内）解锁的一次性高价值首购订阅包。
-   [ ] **订阅专享内容/活动：** 提供订阅用户才能完整体验的副本、活动、剧情或区域（允许免费玩家“试玩”或“预览”一小部分以激发兴趣）。

---

### **三、灵活的订阅体系 (Flexible Subscription System)**
*“提供选择，但巧妙引导；重视首购，更要培养长期忠诚。”*

✅ **多层次与增值选项**
-   [ ] **锚点定价与价值打包：** 提供至少2-3档订阅选项（如基础版/高级版/尊享版，或月卡/季卡/年卡），清晰标注每档核心权益差异和“每元价值比”，默认推荐或高亮“最受欢迎”/“最佳价值”选项。
-   [ ] **“一步到位”的长期订阅激励：** 强调年卡等长期订阅的极致性价比和额外专属奖励（如“年卡用户额外赠送绝版皮肤+每月特权礼包”）。
-   [ ] **叠加式/主题式小额订阅：** 考虑推出针对特定需求的小额订阅包（如“建造加速月票”、“PVP畅行证”），可与主订阅叠加。

✅ **低门槛试用与精细化挽留**
-   [ ] **“无风险”免费试用：** 提供限时（如3-7天）核心VIP功能免费试用，结合试用专属任务引导用户充分体验价值。
-   [   ] **试用期价值回顾：** 试用结束前1-2天，通过数据化“成就报告”或“价值总结”弹窗（如“试用期间您已额外获得XX资源，节省XX时间”）强化订阅欲望。
-   [ ] **人性化挽留策略：** 在用户尝试退订时，提供降级选项（保留部分核心特权）、临时折扣、休眠特权保留（“暂停订阅X个月，权益冻结”）或通过互动小游戏提供挽留优惠，避免强硬阻拦。

---

### **四、社交认同与竞争氛围 (Social Proof & Competitive Atmosphere)**
*“让他人成为你最好的推销员，用竞争点燃付费欲望。”*

✅ **可见的社交影响力**
-   [ ] **实时动态订阅信息：** 在支付页面或主城等区域，适度滚动显示“玩家XXX刚刚加入了VIP行列！”（需注意频率和真实性）。
-   [ ] **团队增益与互惠：** 订阅用户在组队时能为全队带来微小但可见的增益（如“队伍中有VIP成员，全队经验+X%”），或邀请好友订阅双方均可获益。
-   [ ] **分享裂变激励：** 鼓励玩家分享带有订阅推广信息（如“分享我的专属战绩，好友点击可领取3天VIP试用”）的成就或精彩时刻。

✅ **荣誉与地位彰显**
-   [ ] **排行榜差异化展示：** Top玩家及订阅玩家在排行榜上拥有醒目的VIP标识、专属背景板或动态效果。
-   [ ] **多维度排行榜：** 设立“总贡献榜”（包含付费行为）、“订阅专属荣耀榜”等，让付费行为获得额外认可。
-   [ ] **订阅专属成就与称号：** 设计一系列与订阅等级、时长或消费相关的独特成就和称号（如“皇家赞助人”、“月度守护者”）。

---

### **五、数据驱动与用户体验保障 (Data-Driven & User Experience Assurance)**
*“用数据指导决策，用公平赢得人心，这是持续增长的基石。”*

✅ **精细化埋点与漏斗分析**
-   [ ] **全路径转化追踪：** 监控从引导入口曝光、点击，到支付页面浏览、各档位选择，再到支付成功的完整漏斗数据。
-   [ ] **用户分层与行为分析：** 识别高潜力付费用户、已流失订阅用户、试用未转化用户等群体，分析其行为特征以优化策略。
-   [ ] **退订原因分析：** 在挽留环节后，对最终退订用户进行简短问卷（可选），收集退订原因数据。

✅ **公平性与长期生态维护 (红线！)**
-   [ ] **核心体验完整性：** 确保非订阅用户也能完整体验游戏的核心玩法和主线剧情，订阅更多是“加速”或“增值”而非“必需”。
-   [ ] **避免“付费墙”阻塞：** 关键的游戏进程不应被硬性付费墙完全卡死。
-   [ ] **PVP平衡性考量：** 付费带来的PVP优势应控制在合理范围，避免严重破坏竞技公平性（可通过匹配机制、数值调整等平衡）。
-   [ ] **透明化定价与营销：** 杜绝虚假宣传、模糊定价和永久性“限时”折扣，保持营销活动的真实性与诚信。

---

### **六、前瞻性探索 (Forward-Looking Exploration) (可选，小步快跑)**
*“保持创新，探索未来付费模式的可能性。”*

🔘 **Web3/元宇宙整合**
-   [ ] 订阅用户可获得限量版NFT徽章/数字藏品，或在合作的元宇宙平台中享有特殊身份标识（评估实际用户价值与实现成本）。
🔘 **内容共创与激励**
-   [ ] 订阅用户享有更高级的UGC编辑器权限，其创作的优质内容若被官方采纳或推广可获得游戏内奖励或小额分润。
🔘 **现实联动与品牌延伸**
-   [ ] 订阅用户享有游戏周边折扣、线下活动优先参与权或门票优惠等。

---

**⚡ 实施核心原则与策略 ⚡**

1.  **用户洞察先行：** 深入理解你的目标用户，他们的核心需求、痛点以及对付费的真实态度。
2.  **价值前置，付费后置：** 先让用户充分感知和体验到订阅的潜在好处，再引导付费。
3.  **A/B测试文化：**
    *   **关键变量：** 付费引导文案（情感vs利益）、弹窗时机（成就后vs失败后）、价格锚点、权益组合、视觉设计等。
    *   **小范围测试，数据验证，逐步推广。**
4.  **MVP与快速迭代：** 从影响最大的几个点开始（如场景化触发、价值可视化），快速上线验证，根据数据反馈持续优化。
5.  **长期视角：** 关注LTV而非短期ARPU，警惕涸泽而渔。用户信任是最高壁垒。
6.  **红线自查：** 定期（如每月）审视是否触碰“五、数据驱动与用户体验保障”中的公平性条款。

**📈 核心追踪指标 (示例目标值) 📈**
*   **付费转化率 (Pay Point Conversion Rate):** 各付费引导点的转化表现。
*   **首次订阅转化率 (First-Time Subscriber Conversion Rate)**
*   **试用-转-付费转化率 (Trial-to-Paid Conversion Rate)**
*   **付费渗透率 (Paying User Penetration Rate)** (目标 > 8-12% 取决于游戏类型)
*   **ARPPU (Average Revenue Per Paying User)**
*   **订阅用户 LTV (Lifetime Value)**
*   **订阅用户留存率 (Subscriber Retention Rate - 次月、季度)** (目标次月 > 60-70%)
*   **首充用户7日/30日回购率 (First Purchase 7/30-Day Repurchase Rate)** (目标7日 > 25-35%)

---

**这份优化后的Checklist更强调战略思考、用户心理和数据驱动，希望能帮助团队构建一个更健康、更可持续的游戏化App订阅生态。**
</file>

<file path="docs/data-sync-architecture.md">
# 熊猫习惯 - 数据同步与局部刷新架构

## 1. 概述

本文档描述了熊猫习惯应用中的数据同步和局部刷新架构，包括数据流、同步机制和UI更新策略。这种架构旨在提供高效的数据管理和响应式用户界面，同时保持良好的离线功能。

## 2. 核心组件

### 2.1 数据同步服务 (dataSyncService)

数据同步服务负责管理应用数据与后端服务器之间的同步。它提供以下功能：

- **同步队列管理**：跟踪需要同步的数据项
- **自动同步**：定期尝试同步待处理项目
- **手动同步**：允许用户手动触发同步
- **错误处理和重试**：处理同步失败并实现重试机制
- **网络状态监控**：在网络恢复时自动同步

关键函数：
- `initializeDataSync`: 初始化同步服务
- `addSyncItem`: 将项目添加到同步队列
- `syncPendingItems`: 同步待处理项目
- `getPendingSyncCount`: 获取待同步项目数量
- `getCurrentSyncStatus`: 获取当前同步状态

### 2.2 数据刷新钩子 (useDataRefresh)

`useDataRefresh` 是一个自定义 React Hook，用于监听数据变化并触发组件更新。它提供以下功能：

- **表特定监听**：监听特定数据表的变化
- **回调函数**：在数据变化时执行自定义逻辑
- **局部更新**：支持精确更新而非全页面刷新

变体：
- `useDataRefresh`: 监听多个表的变化
- `useTableRefresh`: 监听单个表的变化
- `triggerDataRefresh`: 手动触发数据刷新事件

## 3. 数据流程

### 3.1 数据创建/更新流程

1. 用户在UI中创建或更新数据（如任务）
2. 数据首先保存到本地数据库（Dexie.js）
3. 数据变更添加到同步队列（通过 `addSyncItem`）
4. 触发 `syncItemAdded` 事件，通知UI更新
5. 如果在线，立即尝试同步；否则等待网络恢复
6. 同步成功后，触发 `dataRefresh` 事件，通知相关组件更新

### 3.2 数据同步状态流程

1. 同步状态变化时，触发 `syncStatusChanged` 事件
2. SyncStatusIndicator 组件监听事件并更新显示
3. 同步完成后，触发 `dataRefresh` 事件
4. 使用 `useDataRefresh` 或 `useTableRefresh` 的组件接收更新并刷新UI

## 4. 组件集成

以下组件已集成数据同步和局部刷新机制：

### 4.1 任务管理相关组件

- **TaskManager**: 使用 `useDataRefresh` 监听任务数据变化
- **AnimatedTaskList**: 使用 `useTableRefresh` 监听任务表变化，实现任务列表的局部更新

### 4.2 熊猫状态相关组件

- **PandaStateProvider**: 使用 `useTableRefresh` 监听熊猫状态和能力变化
- **AbilityList**: 使用 `useTableRefresh` 监听能力表变化

### 4.3 奖励相关组件

- **RewardModal**: 使用 `useTableRefresh` 监听奖励表变化

### 4.4 UI反馈组件

- **SyncStatusIndicator**: 显示同步状态和待同步项目数量，监听 `syncItemAdded` 和 `syncStatusChanged` 事件

## 5. 错误处理

数据同步架构包含多层错误处理机制：

1. **同步错误处理**：
   - 记录失败的同步尝试
   - 实现指数退避重试策略
   - 在网络恢复时自动重试

2. **UI错误处理**：
   - 显示同步错误状态
   - 提供手动重试选项
   - 在错误状态下保持应用可用

3. **数据一致性**：
   - 使用乐观更新策略（先更新UI，后同步数据）
   - 在同步失败时回滚到服务器状态

## 6. 最佳实践

### 6.1 组件集成指南

要将新组件集成到数据同步架构中：

1. 导入适当的 Hook：
   ```typescript
   import { useDataRefresh } from '@/hooks/useDataRefresh';
   // 或
   import { useTableRefresh } from '@/hooks/useDataRefresh';
   ```

2. 在组件中使用 Hook：
   ```typescript
   // 监听多个表
   useDataRefresh(['table1', 'table2'], (event) => {
     // 处理数据刷新
   });
   
   // 或监听单个表
   useTableRefresh('tableName', (data) => {
     // 处理表数据刷新
   });
   ```

3. 实现数据变更时的局部更新逻辑

### 6.2 数据操作指南

在修改数据时：

1. 首先更新本地数据库
2. 使用 `addSyncItem` 将变更添加到同步队列
3. 依赖数据同步服务和 `useDataRefresh` 机制自动更新UI

## 7. 性能考虑

- **选择性更新**：只更新变更的数据，而不是整个列表
- **防抖动和节流**：限制短时间内的多次更新
- **懒加载**：仅在需要时加载数据
- **缓存**：缓存频繁访问的数据以减少数据库查询

## 8. 未来改进

- **冲突解决**：实现更复杂的冲突解决策略
- **批量同步优化**：改进批量同步性能
- **同步优先级**：实现基于优先级的同步队列
- **数据压缩**：减少同步数据的大小
- **增量同步**：只同步变更的字段而非整个记录
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- You can add a link to an icon file here if you have one -->
    <!-- <link rel="icon" type="image/svg+xml" href="/vite.svg" /> -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minimal Dexie I18n Demo V3</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="issue.md">
# React Hooks 无限循环调用问题修复报告

## 问题描述

在 PandaHabit 应用中，我们发现了几个组件存在 React Hooks 的使用问题，导致无限循环渲染和以下错误：

1. **Invalid hook call 错误**：
   ```
   Uncaught Error: Invalid hook call. Hooks can only be called inside of the body of a function component.
   ```

2. **Maximum update depth exceeded 警告**：
   ```
   Warning: Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.
   ```

## 问题原因

这些问题主要由以下几个原因导致：

1. **违反 React Hooks 规则**：在非函数组件顶层或自定义 Hook 内部调用 Hooks
2. **依赖数组不正确**：在 useEffect 中使用了会在每次渲染时变化的依赖
3. **循环依赖**：组件之间存在循环依赖关系
4. **直接在组件函数体内调用 Hook**：而不是在 useEffect 或其他 Hook 中调用

## 修复方案

### 1. 修复 `registerTableRefreshListener` 函数

**问题**：
`registerTableRefreshListener` 函数不是一个自定义 Hook（不以 "use" 开头），但它内部使用了 `useDataRefreshContext` Hook。

**修复**：
将其改为自定义 Hook `useRegisterTableRefresh`，并在内部使用 useEffect 处理订阅和清理：

```typescript
// 修改前
export function registerTableRefreshListener(
  table: string,
  callback: (data: any) => void
): () => void {
  const { registerRefreshListener } = useDataRefreshContext();
  return registerRefreshListener(table, callback);
}

// 修改后 (第一次尝试)
export function useRegisterTableRefresh(
  table: string,
  callback: (data: any) => void
): () => void {
  const { registerRefreshListener } = useDataRefreshContext();

  useEffect(() => {
    // 注册表监听器
    const unregister = registerRefreshListener(table, callback);

    // 清理函数
    return unregister;
  }, [table, callback, registerRefreshListener]);

  return () => {}; // 返回一个空函数，实际的取消注册在 useEffect 的清理函数中完成
}

// 最终修复 (使用 useRef 避免依赖变化)
export function useRegisterTableRefresh(
  table: string,
  callback: (data: any) => void
): () => void {
  const { registerRefreshListener } = useDataRefreshContext();

  // 使用 ref 来存储最新的回调函数，避免依赖变化
  const callbackRef = useRef(callback);

  // 更新 callbackRef 当 callback 变化时
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  // 使用 ref 来存储最新的 table 值
  const tableRef = useRef(table);

  // 更新 tableRef 当 table 变化时
  useEffect(() => {
    tableRef.current = table;
  }, [table]);

  // 使用 ref 来存储最新的 registerRefreshListener 函数
  const registerRefreshListenerRef = useRef(registerRefreshListener);

  // 更新 registerRefreshListenerRef 当 registerRefreshListener 变化时
  useEffect(() => {
    registerRefreshListenerRef.current = registerRefreshListener;
  }, [registerRefreshListener]);

  // 只在组件挂载时注册一次监听器
  useEffect(() => {
    // 创建一个稳定的回调函数，它总是使用最新的 callback
    const stableCallback = (data: any) => {
      // 使用 ref 获取最新的 callback
      callbackRef.current(data);
    };

    // 注册表监听器
    const unregister = registerRefreshListenerRef.current(tableRef.current, stableCallback);

    // 清理函数
    return unregister;
  }, []); // 没有依赖项，使用 ref 获取最新的值

  return () => {}; // 返回一个空函数，实际的取消注册在 useEffect 的清理函数中完成
}
```

### 2. 修复 `ChallengeList` 组件

**问题**：
直接在组件函数体内调用 `registerTableRefreshListener`，导致每次渲染都会重新注册监听器。

**修复**：
1. 使用 `useCallback` 包装回调函数
2. 使用新的 `useRegisterTableRefresh` Hook

```typescript
// 修改前
useTableRefresh('challenges', (challengeData) => {
  // 处理逻辑...
});

// 修改后
const handleChallengeDataUpdate = useCallback((challengeData: any) => {
  // 处理逻辑...
}, [loadChallenges, filter]);

// 使用 useRegisterTableRefresh hook 监听挑战表的变化
useRegisterTableRefresh('challenges', handleChallengeDataUpdate);
```

### 3. 修复 `AnimatedTaskList` 组件

**问题**：
与 `ChallengeList` 组件类似，直接在组件函数体内调用 `useTableRefresh`。

**修复**：
1. 使用 `useCallback` 包装回调函数
2. 使用新的 `useRegisterTableRefresh` Hook
3. 使用 `useRef` 避免依赖变化

```typescript
// 修改前
useTableRefresh('tasks', (taskData) => {
  // 处理逻辑...
});

// 修改后 (第一次尝试)
const handleTaskDataUpdate = useCallback((taskData: any) => {
  // 处理逻辑...
}, [loadTasks, filter]);

// 使用 useRegisterTableRefresh hook 监听任务表的变化
useRegisterTableRefresh('tasks', handleTaskDataUpdate);

// 最终修复 (使用 useRef)
// 定义任务数据更新处理函数 - 使用 useRef 来避免依赖变化
const filterRef = React.useRef(filter);
const loadTasksRef = React.useRef(loadTasks);

// 更新 refs 当依赖变化时
React.useEffect(() => {
  filterRef.current = filter;
  loadTasksRef.current = loadTasks;
}, [filter, loadTasks]);

// 使用稳定的回调函数，不依赖于 filter 或 loadTasks
const handleTaskDataUpdate = useCallback((taskData: any) => {
  // 使用 ref 值而不是直接依赖
  const currentFilter = filterRef.current;
  const currentLoadTasks = loadTasksRef.current;

  // 如果有特定任务数据，则更新该任务
  if (taskData && taskData.id) {
    setTasks(prevTasks => {
      // 处理逻辑...
    });
  } else {
    // 如果没有特定任务数据，则重新加载所有任务
    currentLoadTasks();
  }
}, [/* 没有依赖项，使用 ref 来获取最新值 */]);

// 使用 useRegisterTableRefresh hook 监听任务表的变化
useRegisterTableRefresh('tasks', handleTaskDataUpdate);
```

### 4. 修复 `TaskManager` 组件

**问题**：
使用 `useDataRefresh` 监听任务表变化，但没有正确处理依赖关系，导致无限循环。

**修复**：
1. 使用 `useRegisterTableRefresh` 代替 `useDataRefresh`
2. 使用 `useRef` 来避免依赖变化

```typescript
// 修改前
const handleDataRefresh = useCallback(() => {
  setRefreshTrigger(prev => prev + 1);
}, []);

// 监听 'tasks' 表的数据刷新
useDataRefresh(['tasks'], () => handleDataRefresh());

// 修改后 (第一次尝试)
const handleDataRefresh = useCallback(() => {
  setRefreshTrigger(prev => prev + 1);
}, [setRefreshTrigger]); // 明确依赖 setRefreshTrigger

// 使用 useRegisterTableRefresh 监听 'tasks' 表的数据刷新
useRegisterTableRefresh('tasks', handleDataRefresh);

// 最终修复 (使用 useRef)
// 使用 useRef 来避免依赖变化
const setRefreshTriggerRef = React.useRef(setRefreshTrigger);

// 更新 ref 当依赖变化时
React.useEffect(() => {
  setRefreshTriggerRef.current = setRefreshTrigger;
}, [setRefreshTrigger]);

// 使用稳定的回调函数，不依赖于 setRefreshTrigger
const handleDataRefresh = useCallback(() => {
  // 只需要触发刷新，不需要重新获取所有数据
  setRefreshTriggerRef.current(prev => prev + 1);
}, []); // 没有依赖项，使用 ref 来获取最新值

// 使用 useRegisterTableRefresh 监听 'tasks' 表的数据刷新
useRegisterTableRefresh('tasks', handleDataRefresh);
```

### 5. 修复循环依赖问题

**问题**：
`App.tsx` 和 `dataSyncService.ts` 之间存在循环依赖。

**修复**：
创建单独的 `queryClient.ts` 文件，将 `queryClient` 实例移出 `App.tsx`：

```typescript
// src/services/queryClient.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 2, // 2 minutes
      refetchOnWindowFocus: false,
      retry: 1,
    },
  },
});
```

## 全局检查类似问题的方法

为了全局检查类似的问题，可以采取以下步骤：

1. **检查所有直接使用 Hook 的非 Hook 函数**：
   - 搜索所有不以 "use" 开头但内部调用了 React Hooks 的函数
   - 将这些函数改为自定义 Hook（以 "use" 开头）或移除内部的 Hook 调用

2. **检查所有组件中直接在函数体内调用的 Hook**：
   - 搜索所有在组件函数体内直接调用的 Hook（不在 useEffect 等其他 Hook 内部）
   - 将这些调用移到 useEffect 或其他适当的 Hook 中

3. **检查所有 useEffect 的依赖数组**：
   - 确保所有 useEffect 都有正确的依赖数组
   - 使用 ESLint 的 exhaustive-deps 规则检查依赖项是否完整

4. **检查循环依赖**：
   - 分析模块导入关系，找出可能的循环依赖
   - 重构代码，将共享的逻辑或数据移到单独的模块中

5. **使用 React DevTools 的 Profiler**：
   - 监控组件的重新渲染次数
   - 识别渲染次数异常多的组件

## 预防措施

1. **遵循 React Hooks 规则**：
   - 只在 React 函数组件或自定义 Hook 中调用 Hooks
   - 不要在条件语句、循环或嵌套函数中调用 Hooks
   - 确保自定义 Hook 名称以 "use" 开头

2. **正确使用 useEffect 依赖数组**：
   - 包含 effect 中使用的所有外部变量
   - 使用 useCallback 和 useMemo 稳定化依赖项

3. **避免循环依赖**：
   - 设计清晰的模块结构
   - 将共享逻辑抽取到单独的模块

4. **使用 ESLint 插件**：
   - 安装 eslint-plugin-react-hooks
   - 启用 rules-of-hooks 和 exhaustive-deps 规则

通过以上措施，可以有效预防和解决 React Hooks 相关的无限循环渲染问题。

## 多语言支持更新

为了确保所有页面都使用一致的多语言支持方式，我们进行了以下更新：

1. **更新 ChallengesPage**：
   - 使用 `useLocalizedView` 获取多语言标签
   - 将硬编码的文本替换为标签
   - 添加错误处理和加载状态的多语言支持

2. **更新 AbilitiesPage**：
   - 添加 `useLocalizedView` 获取多语言标签
   - 创建相应的类型定义
   - 将硬编码的文本替换为标签
   - 添加错误处理和加载状态的多语言支持

3. **更新 TasksPage**：
   - 修复条件判断和错误处理
   - 添加错误处理和加载状态的多语言支持

4. **更新类型定义**：
   - 为 `TasksPageViewLabelsBundle` 添加缺失的属性
   - 为 `ChallengesPageViewLabelsBundle` 添加缺失的属性
   - 创建 `AbilitiesPageViewLabelsBundle` 类型定义

5. **添加本地化服务函数**：
   - 添加 `fetchAbilitiesPageView` 函数

通过这些更新，所有页面现在都使用了一致的多语言支持方式，并且正确使用了 DataRefreshProvider 来管理数据同步后的局部刷新。
</file>

<file path="page-design-document.md">
# PandaHabit 页面设计文档

## 1. 概述

PandaHabit 是一款华丽游戏风格的习惯养成应用，采用中国风视觉元素，以熊猫伙伴为核心角色。本文档描述了应用程序的页面结构、设计原则和主要组件。

本应用采用多语言支持，所有页面的静态文本都通过 useLocalizedView 钩子从本地化服务获取，支持中文和英文界面。

## 2. 设计原则

### 2.1 视觉风格

- **华丽游戏风格**：采用精美的游戏界面设计，包括装饰性边框、精致图标和动画效果
- **中国风元素**：融入水墨、竹叶、金光等中国传统视觉元素
- **熊猫主题**：以熊猫为核心角色，贯穿整个应用程序

### 2.2 用户体验原则

- **直观易用**：界面简洁明了，操作流程直观
- **即时反馈**：用户操作后提供即时视觉和音效反馈
- **渐进式引导**：逐步引导用户了解功能，避免信息过载
- **奖励机制**：完成任务后提供丰富的奖励和成就系统

### 2.3 响应式设计

- **移动优先**：以移动设备为主要目标平台
- **自适应布局**：适应不同屏幕尺寸和方向
- **触摸友好**：按钮和交互元素设计适合触摸操作

## 3. 页面结构

### 3.1 主页 (HomePage)

**功能**：应用程序的入口点，展示用户概览和熊猫伙伴状态

**主要组件**：
- WelcomeSection：欢迎用户，显示当前日期和时间
- PandaSection：展示熊猫伙伴及其状态
- MoodsSection：显示用户心情记录和统计

**设计特点**：
- 竹叶装饰边框
- 水墨风格背景
- 熊猫动画效果

### 3.2 任务页面 (TasksPage)

**功能**：管理用户的任务和习惯

**主要组件**：
- TaskManager：任务管理器，包含任务列表和过滤器
- AnimatedTaskList：动画任务列表，显示任务卡片
- TaskForm：创建和编辑任务的表单

**设计特点**：
- 任务卡片采用卷轴设计
- 完成任务时的金光特效
- 任务优先级视觉区分

### 3.3 能力页面 (AbilitiesPage)

**功能**：展示和管理熊猫伙伴的能力

**主要组件**：
- AbilityTree：能力树，展示能力之间的关系
- AbilityCard：能力卡片，显示能力详情
- AbilityUnlockModal：解锁能力的模态框

**设计特点**：
- 树状结构展示能力关系
- 已解锁和未解锁能力的视觉区分
- 解锁动画效果

### 3.4 挑战页面 (ChallengesPage)

**功能**：展示和管理用户挑战

**主要组件**：
- ChallengeList：挑战列表，显示挑战卡片
- ChallengeFilter：挑战过滤器，按状态、类型和难度过滤
- ChallengeCard：挑战卡片，显示挑战详情和进度

**设计特点**：
- 挑战卡片采用华丽边框设计
- 进度条采用中国风元素
- 挑战完成时的庆祝动画

### 3.5 及时奖励页面 (TimelyRewardsPage)

**功能**：展示和管理及时奖励和幸运抽奖

**主要组件**：
- TimelyRewardList：及时奖励列表，显示奖励卡片
- TimelyRewardCard：及时奖励卡片，显示奖励详情和进度
- LuckyDraw：幸运抽奖组件，使用幸运点进行抽奖

**设计特点**：
- 奖励卡片采用金色边框设计
- 幸运抽奖采用转盘动画
- 奖励获取时的特效动画

### 3.6 设置页面 (SettingsPage)

**功能**：管理应用程序设置和用户偏好

**主要组件**：
- LanguageSelector：语言选择器
- ThemeSelector：主题选择器
- NotificationSettings：通知设置
- AccountSettings：账户设置

**设计特点**：
- 简洁的设置界面
- 分类组织设置项
- 即时应用设置变更

## 4. 共享组件

### 4.1 导航组件 (Navigation)

**功能**：在不同页面之间导航

**设计特点**：
- 底部导航栏，适合移动设备
- 图标和文字结合
- 当前页面高亮显示

### 4.2 模态框组件 (Modal)

**功能**：显示弹出内容

**设计特点**：
- 半透明背景遮罩
- 动画进入和退出效果
- 支持点击外部区域关闭

### 4.3 卷轴对话框 (ScrollDialog)

**功能**：以卷轴形式显示重要信息

**设计特点**：
- 古代卷轴设计
- 装饰性边框和纹理
- 展开和收起动画

### 4.4 奖励模态框 (RewardModal)

**功能**：展示获得的奖励

**设计特点**：
- 华丽的金色边框
- 奖励展示动画
- 粒子特效

### 4.5 熊猫头像 (PandaAvatar)

**功能**：显示熊猫伙伴

**设计特点**：
- 根据状态变化表情和动作
- 互动动画效果
- 装饰性边框

## 5. 动画系统

### 5.1 页面过渡动画

- 页面进入：淡入和上移
- 页面退出：淡出和下移
- 页面切换：交叉淡入淡出

### 5.2 元素动画

- 按钮：悬停放大，点击缩小
- 卡片：悬停轻微上浮，添加阴影
- 列表项：进入时序列动画

### 5.3 特效动画

- 完成任务：金光特效
- 解锁能力：水墨扩散效果
- 获得奖励：粒子爆炸效果

## 6. 响应式设计策略

### 6.1 移动设备 (< 768px)

- 单列布局
- 底部导航栏
- 简化的卡片设计

### 6.2 平板设备 (768px - 1024px)

- 双列布局
- 侧边导航栏
- 更详细的卡片设计

### 6.3 桌面设备 (> 1024px)

- 多列布局
- 顶部导航栏
- 完整的卡片设计，包含更多信息

## 7. 主题系统

### 7.1 颜色主题

- **默认主题**：竹青绿为主色调，金色为强调色
- **夜间主题**：深蓝为主色调，银色为强调色
- **节日主题**：红色为主色调，金色为强调色

### 7.2 字体系统

- 标题：华丽的中文书法字体
- 正文：清晰易读的无衬线字体
- 强调：装饰性中文字体

### 7.3 间距系统

- 采用 8px 基础网格系统
- 移动设备使用更紧凑的间距
- 桌面设备使用更宽松的间距

## 8. 国际化支持

### 8.1 多语言实现

- 支持中文和英文界面
- 使用 useLocalizedView 钩子加载本地化内容
- 根据语言调整布局和字体大小

### 8.2 本地化内容服务

- 使用 localizedContentService 提供本地化内容
- 每个页面都有对应的 fetch 函数，如 fetchHomePageView、fetchSettingsPageView 等
- 本地化内容包括标签（labels）和数据（data）两部分

### 8.3 页面本地化实现

每个页面都遵循相同的本地化模式：

1. 导入 useLocalizedView 钩子和对应的 fetch 函数
2. 在组件中使用 useLocalizedView 获取本地化内容
3. 处理加载状态和错误状态
4. 使用获取到的标签渲染页面内容

示例代码：

```typescript
const {
  labels: pageLabels,
  isPending,
  isError,
  error,
  refetch
} = useLocalizedView<null, PageViewLabelsBundle>(
  'pageViewContent',
  fetchPageView
);

// 处理加载状态
if (isPending && !pageLabels) {
  return <LoadingSpinner variant="jade" text="加载页面内容..." />;
}

// 处理错误状态
if (isError && !pageLabels) {
  return (
    <div className="page-content">
      <ErrorDisplay error={error} title="页面错误" onRetry={refetch} />
    </div>
  );
}

// 使用标签渲染页面内容
return (
  <div>
    <h1>{pageLabels?.pageTitle || '默认标题'}</h1>
    {/* 其他页面内容 */}
  </div>
);
```

## 9. 总结

PandaHabit 的页面设计融合了华丽游戏风格和中国传统视觉元素，以熊猫伙伴为核心角色，通过精美的界面设计、流畅的动画效果和丰富的奖励机制，为用户提供愉悦的习惯养成体验。
</file>

<file path="prd.md">
Okay, here is the comprehensive, standalone Product Requirements Document (PRD) for **PandaHabit**, incorporating all the previously discussed elements, including competitor analysis solutions, the Timely Reward System (Scheme C), User Journeys, API Structure Analysis, and detailed Page Descriptions.

---

**Product Requirements Document: PandaHabit**

**Version:** 1.0
**Date:** May 15, 2025
**Status:** Draft

**1. Introduction**

*   **1.1. Overview:** PandaHabit is a mobile application designed to help users build positive habits, improve self-care routines, and enhance mental well-being through an engaging and supportive virtual pet experience. Users nurture a virtual Panda by completing real-life tasks and habits, creating a symbiotic relationship where taking care of oneself directly benefits the pet, and the pet, in turn, offers companionship, motivation, and gentle guidance.
*   **1.2. Vision:** To be the most supportive and engaging habit-building companion, transforming self-care from a chore into a rewarding journey. We aim to foster genuine, long-term positive change by providing proactive support, gentle accountability, meaningful emotional connection, and sustained engagement, overcoming the known shortcomings of existing apps in the market.
*   **1.3. Goals:**
    *   Increase user consistency in desired habits (e.g., hydration, mindfulness, exercise).
    *   Improve user self-reported mood and well-being.
    *   Achieve high user retention and engagement through a rewarding core loop and meaningful progression.
    *   Provide a genuinely supportive and non-judgmental environment, especially when users face challenges.
    *   Establish PandaHabit as a leader in the gamified self-care app market by directly addressing competitor weaknesses (lack of active support, becoming boring, punitive mechanics, negative reinforcement).
    *   Successfully monetize through a valuable VIP subscription model.
*   **1.4. Target Audience:** Individuals seeking tools for habit formation, self-care, mood tracking, motivation, and stress management. Particularly relevant for those who enjoy gamification, virtual pets, and desire a supportive, gentle approach. Also targets users dissatisfied with existing apps due to lack of active help, waning engagement, or negative experiences.

**2. User Journeys**

*   **2.1. New User Onboarding & First Task:**
    1.  User downloads and opens PandaHabit.
    2.  Welcomed with a brief intro to the concept (Panda companion for habits).
    3.  User customizes their initial Panda appearance (basic options).
    4.  User is guided to set their first simple habit/task (e.g., "Drink a glass of water").
    5.  Panda companion provides encouragement.
    6.  User completes the task in real life.
    7.  User opens the app and marks the task complete on the **Task Page**.
    8.  User receives base resource rewards (e.g., Bamboo, Water).
    9.  **Timely Reward:** User also sees the **Timeliness Bar** fill slightly and receives **Luck Points** (with visual feedback).
    10. User is guided to feed the Panda with the earned resources on the **Home Page** or **Pet Interaction Page**.
    11. Panda reacts positively to being fed.
    12. User is introduced to the main **Home Page** interface.
*   **2.2. Daily Habit Check-in & Timely Reward:**
    1.  User receives a gentle reminder notification (optional, Panda-themed).
    2.  User opens the app, landing on the **Home Page**.
    3.  User navigates to the **Task Page**.
    4.  User reviews their daily tasks (some marked with ⏰ for Timely Rewards).
    5.  User completes several tasks within their time windows.
    6.  User marks tasks complete in the app.
    7.  User receives base resources for each task.
    8.  **Timely Reward:** For each on-time task, the **Timeliness Bar** progresses, and **Luck Points** are awarded with visual feedback.
    9.  User sees their total Luck Points increase on the HUD.
    10. User might navigate to the **Lucky Draw Page** to spend points or check the Timeliness Bar reward progress on the Home Page.
*   **2.3. Engaging with a Challenge:**
    1.  User navigates to the **Challenge Page**.
    2.  User browses active Challenges (Daily, Weekly, Event, Continuous).
    3.  User selects a Challenge (e.g., "7-Day Meditation Streak").
    4.  Challenge details show the overall goal, final reward, and component sub-tasks (e.g., "Meditate 5 mins today").
    5.  User accepts the Challenge.
    6.  The relevant daily sub-task appears in the user's **Task Page**, marked as a Challenge Task (🔥).
    7.  User completes the sub-task daily and marks it off in the Task Page, earning daily rewards and Timely Rewards if applicable.
    8.  User checks progress on the **Challenge Page**.
    9.  Upon completing the final sub-task, the Challenge is marked complete, and the user claims the main Challenge reward.
*   **2.4. Using the Reflection Module:**
    1.  User consistently skips a core habit task for several days OR reports a low mood during check-in.
    2.  Panda **gently** offers the option to reflect ("Things seem tough with [Task Name] lately. Want to explore that?").
    3.  User accepts and enters the Reflection Module.
    4.  Panda asks simple, non-judgmental questions ("What felt like the biggest barrier today?").
    5.  User provides input (optional text or multiple choice).
    6.  Panda offers empathetic validation ("It's okay to find things difficult sometimes.") and suggests **small, actionable positive steps** ("Maybe tomorrow we try just 2 minutes of it? Or try [alternative simple task] instead?").
    7.  User feels supported and less discouraged.
*   **2.5. Upgrading to VIP:**
    1.  User interacts with a feature locked behind VIP (e.g., creating a Custom Goal, trying to claim extra reward bonus).
    2.  A prompt appears explaining the benefits of VIP related to that feature and others.
    3.  User navigates to the **Shop Page** or a dedicated VIP section.
    4.  User reviews VIP tiers, benefits (increased rewards, custom goals, exclusive items), and pricing.
    5.  User selects a subscription plan and completes the purchase via the App Store.
    6.  App UI updates immediately to reflect VIP status (e.g., VIP badge, unlocked features).
*   **2.6. Using the Lucky Draw:**
    1.  User accumulates sufficient **Luck Points** by completing tasks on time.
    2.  User navigates to the **Lucky Draw Page** (accessible from Home HUD or Rewards page).
    3.  User sees their current Luck Point balance and the "Draw x1" / "Draw x10" buttons with costs.
    4.  User views the potential prize pool highlights.
    5.  User taps a Draw button.
    6.  An engaging animation plays (e.g., spinning wheel, opening bamboo chest).
    7.  The awarded prize is revealed (e.g., "+50 Coins", "Rare Panda Hat").
    8.  The prize is automatically added to the user's inventory/balance.

**3. Functional Requirements**

*   **3.1. Core Gameplay Loop: "Panda Nurturing Lifestyle System"**
    *   **3.1.1. Panda Companion:**
        *   Visual representation of a Panda that grows and evolves.
        *   Displays emotional states (happy, neutral, concerned) based on user actions and inputs.
        *   Reacts to user interactions (feeding, petting).
        *   Possesses unlockable abilities tied to growth stages (see 3.2.2).
    *   **3.1.2. Resource System:**
        *   Core resources (e.g., Bamboo, Water, Coins) earned primarily through Task completion.
        *   Resources used for feeding the Panda and facilitating Panda Growth/Upgrades.
        *   Premium currency (e.g., Diamonds) potentially used for cosmetics, speeding up timers (if any), or specific VIP features.
    *   **3.1.3. Interconnected Loop:** User completes Tasks -> Earns Resources & Timely Rewards -> Feeds/Grows Panda -> Panda Unlocks Abilities/Provides Support -> User is Motivated to Complete More Tasks.
*   **3.2. Panda Growth & Customization**
    *   **3.2.1. Growth Stages:** Defined stages (e.g., Infant, Youth, Adult, Perfect Form) reached by spending resources and meeting level requirements. Each stage unlocks new visual appearances.
    *   **3.2.2. Capability Unlock (Meaningful Progression):** Panda growth unlocks functional benefits:
        *   New supportive dialogue options and emotional responses.
        *   Enhanced ability to help break down User-Defined Goals (VIP).
        *   Access to advanced guided exercises (meditation, breathing).
        *   Potentially offer small passive bonuses (e.g., slightly increased Luck Point gain).
    *   **3.2.3. Customization:** Users can personalize Panda appearance (skins, hats, accessories) and its environment (decorations) using items earned or purchased.
*   **3.3. Tasks System**
    *   **3.3.1. Task Types:**
        *   **Daily Tasks:** Simple, repeatable tasks for daily engagement and basic resource generation (e.g., Login, Feed Panda, Quick Mood Check). Contribute to Timely Rewards.
        *   **Mainline Tasks:** Core habit-building tasks related to user's goals (e.g., Drink Water, Meditate, Exercise, Journal, Health Record). Contribute to Timely Rewards. Can be broken down into smaller steps.
        *   **Side Tasks:** Varied tasks including Positive Psychology prompts (Affirmation, Gratitude), Guided Practices, Event Tasks, and potentially social tasks. Time-sensitive ones contribute to Timely Rewards.
    *   **3.3.2. Task Management:**
        *   Users can select from predefined task suggestions or create basic custom tasks (advanced custom goals are VIP).
        *   Tasks appear on a daily Task List.
        *   Users mark tasks as complete.
        *   Ability to set task recurrence (daily, specific days, weekly).
    *   **3.3.3. Task Decomposition:** System/Panda offers assistance in breaking down larger Mainline tasks or User-Defined Goals into smaller, manageable daily actions.
    *   **3.3.4. Gentle Reminders:** Optional, customizable, Panda-themed push notifications for specific tasks.
*   **3.4. Challenge System**
    *   **3.4.1. Challenge Definition:** Longer-term objectives composed of multiple steps or requiring sustained effort over time (See Section 4.1 for definition).
    *   **3.4.2. Challenge Types:** Daily Login Streaks, Task Completion Streaks, Resource Collection Goals, Event-Specific Challenges, Cooperative Social Challenges. Categorized by duration (Daily, 7-Day, 30-Day, etc.) and source (System, Event).
    *   **3.4.3. Challenge Lifecycle Tagging:** Challenges tagged for user lifecycle stages (Newbie, Growing, Mature) for appropriate presentation.
    *   **3.4.4. Sub-Task Integration:** Challenge sub-tasks appear in the daily Task List, clearly marked. Completing sub-tasks (on time) contributes to the Timely Reward System. Challenge completion grants a separate, larger reward.
*   **3.5. Progression Systems**
    *   **3.5.1. Achievements:** Awarded for specific, one-off accomplishments across all game areas (Pet Growth, Tasks, Challenges, Resources, Social, Timeliness). Provide small-medium rewards (Coins, basic items). (See Appendix A for detailed list).
    *   **3.5.2. Milestones:** Mark major user journey progression points, often tied to account age or significant achievements. Provide substantial rewards (Large Coins, Rare Cosmetics, Materials). Tailored to user lifecycle stages. (See Appendix B for detailed list).
*   **3.6. Timely Reward System (Scheme C)**
    *   **3.6.1. Eligibility:** Clearly marked Tasks (Daily, Mainline, applicable Side/Challenge sub-tasks) are eligible.
    *   **3.6.2. Time Windows:** Defined windows for "on-time" completion (daily cutoff, specific times, task deadlines). "Early Bird" bonus potential.
    *   **3.6.3. Rewards:**
        *   **Timeliness Bar:** Fills progressively with each on-time completion. Visible on Home HUD. Reaching the end grants a **guaranteed significant reward** (e.g., rare seasonal cosmetic, large resource bundle). Bar resets upon claiming. Reward preview visible.
        *   **Luck Points:** Awarded for each on-time completion. Amount varies by task type/difficulty and VIP status. Displayed on HUD.
    *   **3.6.4. Lucky Draw:** Dedicated feature where users spend Luck Points for a chance to win random rewards from a tiered pool (Common to Legendary). Clear UI for drawing and viewing potential prizes.
*   **3.7. Deep Reflection & Psychological Support**
    *   **3.7.1. Reflection Module ("Take a Break"):** Non-intrusive module offered when user struggles (skipping tasks, low mood). Uses gentle, non-judgmental dialogue (Panda-led) to explore barriers and suggest small, positive, actionable steps. Focuses on self-compassion.
    *   **3.7.2. Proactive Support:** Panda provides context-aware, actionable, positive tips based on mood check-ins or detected patterns (e.g., suggesting hydration if mood is low and water task incomplete).
    *   **3.7.3. Avoidance of Negative Reinforcement:** No punitive mechanics for skipping tasks. Mood tracking focuses on providing support, not reinforcing negative feelings. No potentially inaccurate diagnostic quizzes.
*   **3.8. Social & Community Features**
    *   **3.8.1. Friends System:** Add friends, send encouragement messages, small resource gifts.
    *   **3.8.2. Sharing (Optional):** Share Panda growth, Milestone achievements, rare Lucky Draw wins.
    *   **3.8.3. Cooperative Challenges:** Team-based challenges encouraging collaboration.
    *   **3.8.4. Community Forum/Space:** Moderated area for sharing positive stories, tips, and encouragement.
*   **3.9. Monetization (VIP Subscription & Shop)**
    *   **3.9.1. VIP Subscription:** Tiered subscription offering benefits:
        *   Increased Luck Point earnings.
        *   Faster Timeliness Bar progression.
        *   Free daily/weekly Lucky Draws.
        *   Access to create User-Defined Goals (with Panda assistance).
        *   Higher reward caps/better potential rewards for Custom Goals.
        *   Exclusive cosmetic items (accessible only via VIP or VIP shop).
        *   VIP badge/identifier.
        *   Potential ad removal (if ads exist for free tier).
    *   **3.9.2. Shop:** In-app store selling:
        *   Cosmetic items (Panda skins, accessories, environment decorations) for Coins or potentially Diamonds.
        *   Potentially resource bundles or enhancement materials (use with caution to avoid pay-to-win feel).
        *   VIP-exclusive items.

**4. UI/UX Design (Page Descriptions)**

*   **4.1. Home Page**
    *   **Purpose:** Main dashboard, quick overview, access to core interactions.
    *   **Layout:**
        *   *Top:* User info (profile, name), Currency (Coins, Diamonds, **Luck Points** ✨), quick access icons (Pet, Achievements, Events, Tasks, VIP, Settings).
        *   *Center:* Large interactive Panda visual, reflecting current state/growth. **Timeliness Bar** 进度条 prominently displayed below or near Panda, showing progress and target reward icon.
        *   *Bottom:* Key active Task display/button area. Recent reward notifications/log.
    *   **Navigation:** Fixed bottom navigation bar (Home, Rewards/Draw, Journey, Shop, Task List).
    *   **Key Interactions:** Tapping Panda (petting), feeding shortcut, claiming task rewards, accessing other sections via icons/nav bar, checking Timeliness Bar.
*   **4.2. Task Page**
    *   **Purpose:** View and manage daily/current tasks.
    *   **Layout:**
        *   *Top:* Date, overall daily progress ("X/Y tasks complete"). Filter/Sort options.
        *   *Main:* Vertical scrollable list of tasks. Each task item shows:
            *   Name/Description.
            *   Associated icon (habit type).
            *   Reward preview (base resources).
            *   **Timeliness Icon (⏰/✨)** if eligible.
            *   **Time Window/Deadline** clearly stated.
            *   **Challenge/Custom Goal Indicator (🔥/👤)** if applicable.
            *   Checkbox/button/swipe to complete.
    *   **Key Interactions:** Marking tasks complete (triggers reward/timeliness feedback), filtering list, potentially adding new tasks (VIP).
*   **4.3. Challenge Page**
    *   **Purpose:** Track progress on long-term goals and special events.
    *   **Layout:**
        *   *Top:* Tabs or filters for challenge categories (Active, Continuous, Event, Completed).
        *   *Main:* Card-based view of Challenges. Each card shows Title, Key Reward, Progress Bar, Time Limit, potentially list of sub-tasks.
    *   **Key Interactions:** Viewing challenge details, accepting new challenges, tracking progress, claiming final challenge rewards.
*   **4.4. Journey Page (Panda Growth & Milestones)**
    *   **Purpose:** Visualize Panda's growth path and user's major achievements.
    *   **Layout:**
        *   *Top/Main:* Visual representation of Panda's evolution path (timeline, tree, etc.). Nodes mark key levels and Milestones. Each node shows requirement and reward. Clear indication of completed/current/locked status.
        *   *Bottom/Tab:* Log of achieved Milestones and potentially significant past accomplishments.
    *   **Key Interactions:** Exploring the growth path, seeing future rewards, reviewing past achievements.
*   **4.5. Shop Page**
    *   **Purpose:** Browse and purchase cosmetic items, resources, or VIP subscription.
    *   **Layout:**
        *   *Top:* Search bar, scrollable category filters (Decorations, Skins, Resources, VIP).
        *   *Main:* Grid/list of items with image, name, price. Highlighted section for Sales/Featured/VIP items.
        *   *Item Detail View:* Larger image/preview, description, purchase button.
    *   **Key Interactions:** Browsing categories, searching, viewing item details, making purchases.
*   **4.6. Pet Interaction Page**
    *   **Purpose:** Direct interaction with the Panda, feeding, accessing skills.
    *   **Layout:**
        *   *Top:* Panda status indicators (Mood, Health, Energy).
        *   *Center:* Large interactive Panda view.
        *   *Bottom:* Interaction buttons (Feed, Play, Train, Reflect). Section showing unlocked skills/abilities.
    *   **Key Interactions:** Feeding Panda (uses resources), playing mini-games (if any), triggering reflection, viewing/upgrading skills.
*   **4.7. Lucky Draw Page**
    *   **Purpose:** Spend Luck Points for random rewards.
    *   **Layout:**
        *   *Top:* Current Luck Point balance (⭐).
        *   *Center:* Visually engaging draw mechanism (wheel, chest, gacha machine). "Draw x1" and "Draw x10" buttons showing point costs.
        *   *Bottom/Side:* Display of potential prize pool highlights (especially rare items). Link to view probabilities/full pool. History log of recent wins.
    *   **Key Interactions:** Spending points to initiate draws, viewing results, checking prize pool.
*   **4.8. Reflection Module (Modal/Separate Screen)**
    *   **Purpose:** Guided self-reflection when struggling.
    *   **Layout:** Calm, simple interface. Text-based dialogue with Panda avatar. Options for user input (buttons, simple text entry). Clear display of Panda's questions and supportive statements.
    *   **Key Interactions:** Reading prompts, selecting responses or typing brief reflections, receiving actionable suggestions.

**5. API Endpoint Structure Analysis (High-Level)**

*(Assuming a standard RESTful API structure for communication between the mobile app and backend server)*

*   **User:**
    *   `POST /auth/register`
    *   `POST /auth/login`
    *   `GET /user/profile`
    *   `PUT /user/profile`
    *   `GET /user/vip_status`
*   **Panda:**
    *   `GET /panda/status` (Level, evolution, mood, health)
    *   `POST /panda/feed` (Body: {resource_type, amount})
    *   `POST /panda/interact` (Body: {interaction_type})
    *   `GET /panda/customization`
    *   `PUT /panda/customization`
*   **Tasks:**
    *   `GET /tasks?date={YYYY-MM-DD}` (Fetch tasks for a specific day)
    *   `POST /tasks` (Create custom task - basic)
    *   `PUT /tasks/{taskId}` (Update task - e.g., recurrence)
    *   `POST /tasks/{taskId}/complete` (Crucially includes timestamp for timely check)
    *   `DELETE /tasks/{taskId}`
*   **Challenges:**
    *   `GET /challenges?status=active|completed`
    *   `GET /challenges/{challengeId}`
    *   `POST /challenges/{challengeId}/accept`
    *   `POST /challenges/{challengeId}/claim_reward`
*   **User-Defined Goals (VIP):**
    *   `POST /goals` (VIP only - create Goal and sub-tasks)
    *   `GET /goals` (VIP only - list user's custom goals)
    *   `GET /goals/{goalId}`
    *   `PUT /goals/{goalId}`
    *   `DELETE /goals/{goalId}`
*   **Timely Rewards:**
    *   `GET /timely_rewards/status` (Current Luck Points, Timeliness Bar progress & target reward)
    *   `POST /lucky_draw/draw` (Body: {draw_count}) -> Returns awarded items
    *   `GET /lucky_draw/pool` (Info about potential prizes)
    *   `POST /timely_rewards/claim_bar_reward`
*   **Progression:**
    *   `GET /achievements`
    *   `GET /milestones`
*   **Shop & Monetization:**
    *   `GET /shop/items?category={category}`
    *   `POST /shop/purchase/{itemId}`
    *   `POST /vip/subscribe` (Handles App Store receipt validation)
*   **Social:**
    *   `GET /friends`
    *   `POST /friends/add`
    *   `POST /friends/{friendId}/send_encouragement`
    *   `GET /community/feed` (For shared stories)

**6. Non-Functional Requirements**

*   **6.1. Performance:** Smooth animations, fast load times, responsive UI. Backend API responses should be quick (<500ms target).
*   **6.2. Reliability:** Stable app with minimal crashes. Accurate tracking of tasks, resources, and progression. No loss of rewards due to technical issues (addressing Finch complaint). Robust data synchronization.
*   **6.3. Scalability:** Backend infrastructure capable of handling a growing user base.
*   **6.4. Security:** Secure handling of user authentication and personal data (including mood/reflection data if stored). Compliance with privacy regulations (GDPR, CCPA, etc.). Secure payment processing integration.
*   **6.5. Usability:** Intuitive navigation, clear visual hierarchy. Features should be discoverable. Onboarding should effectively teach core mechanics.
*   **6.6. Accessibility:** Adherence to platform accessibility guidelines (e.g., font sizes, color contrast, screen reader support) where feasible.

**7. Future Considerations / Roadmap Ideas**

*   Advanced Panda interactions and mini-games.
*   More sophisticated habit analytics and insights for users.
*   Deeper social features (e.g., forming accountability groups).
*   Integration with wearable devices (e.g., step tracking).
*   Expanded range of guided exercises (mindfulness, fitness).
*   Themed seasonal events with unique mechanics and rewards.

**8. Appendix**

*(Note: This section assumes the detailed tables provided in earlier prompts are available as appendices.)*

*   **Appendix A:** Detailed Task Lists (Daily, Mainline, Side - including 0-7 Day User Behavior Expectation Table)
*   **Appendix B:** Detailed Achievement List & Descriptions (Including Timeliness Achievements)
*   **Appendix C:** Detailed Milestone List & Descriptions (Lifecycle-based, including Timeliness Milestones)
*   **Appendix D:** Detailed Challenge List & Descriptions (Categorized by duration/type)
*   **Appendix E:** Reward Coefficient Tables (Task Type vs. VIP Level, Timely Reward Coefficients)
*   **Appendix F:** Data Models (JSON examples for Goal, Task, Achievement, Milestone, etc.)
*   **Appendix G:** Lucky Draw Pool Itemization (Example list of items and tiers)

---

This PRD provides a comprehensive guide for the development of PandaHabit, focusing on creating a supportive, engaging, and effective self-care and habit-building application that learns from and improves upon existing market offerings.
</file>

<file path="prompt.md">
好的，这是一个独立的、简明扼要且不失细节的 Prompt 版本，用于生成游戏化 App 原型及其设计文档。

**(Start of Independent & Concise Gamified App Prototype Prompt)**

**Prompt: 游戏化 App 原型与设计文档生成 (用户聚焦与功能实现)**

**任务：** AI 作为首席策划与设计师，需构思并创建一个功能丰富、用户体验卓越的游戏化 App 原型 (`app.html`) 及其详尽的设计文档 (`app-design-brief.md`)。核心目标是最大化用户参与度，驱动订阅转化，并体现产品价值。

**核心交付物：**

1.  **`app** 可交互的 App 原型，采用统一的游戏 UI 风格，包含下述核心功能。
2.  **`app-design-brief.md`:** 详细的设计文档，阐述所有研究、策略、设计决策及技术建议。

**关键要求与 AI 职责：**

*   **AI 自主性：** 即使产品需求 (`prd.md`) 不完整，AI 也需主动进行市场调研、用户分析 (聚焦游戏玩家)、竞品分析 (游戏 App UI/UX)，补充信息并自主优化/拓展功能。
*   **核心功能 (原型必备)：**
    1.  **语言选择：** 在设置内提供，JSON驱动，`data-i18n` 属性支持。
    2.  **排行榜：** 若 PRD 未提及，AI 需判断是否添加以增强游戏性。
    3.  **订阅引导优化：** 实现有效的订阅 UI/UX 策略 (如下文详述)。
*   **游戏 UI 风格：** AI 将根据用户输入或自主选择并论证一种特定游戏 UI 风格 (例如：魔幻、科技、二次元、休闲、复古等，具体风格列表可参考之前的详细版本)，并确保其在 App 原型中的一致性与沉浸感。
*   **清晰导航：** 基于用户提供的“App 结构与导航”或 AI 的最佳实践研究，构建直观易用的导航系统。

**用户需提供：**

1.  **`prd.md` (产品需求文档)：** 即使不完整。
2.  **游戏 App 核心信息：** 名称、主要卖点、目标用户特征、品牌调性等。
3.  **App 结构与导航蓝图 (强烈建议)：**
    *   **主要导航页面列表：** (例如：首页、游戏中心、任务、个人资料、设置、商店)。
    *   **次要页面列表及其入口：** (例如：从游戏中心 -> 游戏详情页；从设置 -> 语言选择页)。
    *   **关键流程页面：** (例如：新手引导、付费墙、分享流程)。
    *   *若用户未提供，AI 将基于研究进行假设并说明。*

**AI 研究与规划 (`app-design-brief.md` 中体现)：**

*   **市场与用户洞察：** 分析市场趋势、用户需求与痛点、游戏习惯、UI/导航偏好。
*   **竞品分析：** 学习成功竞品的 UI/UX、功能、导航架构。
*   **最佳实践应用：** 融入移动端 UX、游戏化设计、多语言支持、排行榜设计、导航设计及订阅转化策略。
*   **设计决策论证：** 详细说明各项设计选择 (颜色、布局、交互、功能等) 的理由，并与研究结果和最佳实践关联。

**`app.html` 原型构建要点：**

*   **用户体验优先：** 界面直观，操作流畅，核心流程清晰。
*   **响应式设计：** 适配主流移动设备屏幕。
*   **交互反馈：** 包含按钮点击、页面切换等基本交互。
*   **订阅 UI/UX 实现：**
    *   **分层提示：** 在不同用户阶段提供订阅入口。
    *   **“PRO”专区：** 集中展示高级功能价值。
    *   **视觉强化：** 突出订阅按钮和核心价值。
    *   **情境触发：** 在用户最需要高级功能时提示。
    *   **挽留机制：** 用户尝试取消订阅时提供优惠或重申价值。
    *   **社交证明：** (可选) 展示用户评价。
*   **导航实现：** 根据规划的结构和导航模式 (如底部Tab、抽屉式等) 实现，确保所有页面可达且流程顺畅。

**`app-design-brief.md` 文档结构：**

1.  **引言与研究总结：** PRD分析、AI自主研究发现 (市场、用户、竞品)。
2.  **App 整体设计策略：** 功能拓展理由、核心设计原则。
3.  **详细设计规划：**
    *   **信息架构与导航设计：** 架构图、导航模式选择及理由、页面跳转流程、关键页面设计分析 (含截图/线框图)。
    *   **游戏 UI 风格选择与应用：** 理由、具体视觉元素规划。
    *   **核心功能设计详解：** 语言选择、排行榜 (若添加)、订阅引导 UI/UX (各策略点实现方案、A/B测试建议)。
    *   **其他设计要素：** 文案风格、视觉素材、颜色方案、CTA、响应式策略。
4.  **技术与合规性建议：** 性能优化、技术选型参考、合规性提示。

**评估重点：**

*   **用户体验与导航：** 是否直观易用？流程是否顺畅？
*   **核心功能完整性：** 语言选择、排行榜、订阅引导是否按要求实现并有效？
*   **游戏 UI 沉浸感：** UI 风格是否统一且吸引人？
*   **设计文档质量：** AI 的研究、决策和规划是否清晰、详尽且合理？

**指示 AI：** 严格遵循上述要求，特别是核心功能的实现、清晰导航的构建、指定或选定游戏 UI 风格的深度融合，以及详尽设计文档的产出。

**(End of Independent & Concise Gamified App Prototype Prompt)**
</file>

<file path="public/assets/abilities/bamboo-focus.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Bamboo Focus</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="focusGradient">
            <stop stop-color="#4A90E2" offset="0%"></stop>
            <stop stop-color="#1A5F4A" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Target/Focus symbol -->
        <circle cx="50" cy="50" r="30" stroke="url(#focusGradient)" stroke-width="3" fill="none"></circle>
        <circle cx="50" cy="50" r="20" stroke="url(#focusGradient)" stroke-width="2" fill="none"></circle>
        <circle cx="50" cy="50" r="10" stroke="url(#focusGradient)" stroke-width="1" fill="url(#focusGradient)"></circle>
        
        <!-- Crosshair lines -->
        <path d="M50,10 L50,30" stroke="url(#focusGradient)" stroke-width="2"></path>
        <path d="M50,70 L50,90" stroke="url(#focusGradient)" stroke-width="2"></path>
        <path d="M10,50 L30,50" stroke="url(#focusGradient)" stroke-width="2"></path>
        <path d="M70,50 L90,50" stroke="url(#focusGradient)" stroke-width="2"></path>
        
        <!-- Bamboo elements -->
        <path d="M20,20 L25,25" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M75,75 L80,80" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M20,80 L25,75" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M75,25 L80,20" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#4A90E2" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/bamboo-heart.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Bamboo Heart</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="bambooGradient">
            <stop stop-color="#88B04B" offset="0%"></stop>
            <stop stop-color="#1A5F4A" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Heart shape made of bamboo -->
        <path d="M50,75 C50,75 25,55 25,40 C25,30 35,25 45,30 C48,32 50,35 50,35 C50,35 52,32 55,30 C65,25 75,30 75,40 C75,55 50,75 50,75 Z" fill="url(#bambooGradient)" stroke="#1A5F4A" stroke-width="2"></path>
        
        <!-- Bamboo details -->
        <path d="M40,35 L40,65" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        <path d="M50,35 L50,65" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        <path d="M60,35 L60,65" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        
        <path d="M35,45 L65,45" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        <path d="M30,55 L70,55" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#88B04B" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/bamboo-master.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Bamboo Master</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="masterGradient">
            <stop stop-color="#FFD700" offset="0%"></stop>
            <stop stop-color="#D4AF37" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="4" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Golden bamboo stalks -->
        <path d="M30,20 L30,80" stroke="url(#masterGradient)" stroke-width="4" stroke-linecap="round"></path>
        <path d="M50,20 L50,80" stroke="url(#masterGradient)" stroke-width="4" stroke-linecap="round"></path>
        <path d="M70,20 L70,80" stroke="url(#masterGradient)" stroke-width="4" stroke-linecap="round"></path>
        
        <!-- Bamboo nodes -->
        <path d="M25,30 L35,30" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M25,50 L35,50" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M25,70 L35,70" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M45,40 L55,40" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M45,60 L55,60" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M65,30 L75,30" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M65,50 L75,50" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M65,70 L75,70" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Bamboo leaves -->
        <path d="M30,25 C25,20 20,25 25,30" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M30,75 C25,80 20,75 25,70" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M50,35 C45,30 40,35 45,40" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M50,65 C45,70 40,65 45,60" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M70,25 C75,20 80,25 75,30" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M70,75 C75,80 80,75 75,70" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Master symbol -->
        <circle cx="50" cy="50" r="35" stroke="url(#masterGradient)" stroke-width="2" stroke-dasharray="3,2"></circle>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#D4AF37" stroke-width="3" stroke-opacity="0.9"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/default-ability.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Default Ability</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="defaultGradient">
            <stop stop-color="#9E9E9E" offset="0%"></stop>
            <stop stop-color="#616161" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Question mark -->
        <circle cx="50" cy="50" r="30" fill="url(#defaultGradient)"></circle>
        <text x="50" y="62" font-family="Arial" font-size="40" fill="#FFFFFF" text-anchor="middle">?</text>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#9E9E9E" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/panda-vitality.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Panda Vitality</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="energyGradient">
            <stop stop-color="#FFD700" offset="0%"></stop>
            <stop stop-color="#FFA500" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Panda face -->
        <circle cx="50" cy="50" r="30" fill="white" stroke="black" stroke-width="2"></circle>
        
        <!-- Panda ears -->
        <circle cx="30" cy="30" r="10" fill="black"></circle>
        <circle cx="70" cy="30" r="10" fill="black"></circle>
        
        <!-- Panda eyes -->
        <ellipse cx="40" cy="45" rx="8" ry="7" fill="black"></ellipse>
        <ellipse cx="60" cy="45" rx="8" ry="7" fill="black"></ellipse>
        
        <!-- Panda nose -->
        <ellipse cx="50" cy="55" rx="5" ry="4" fill="black"></ellipse>
        
        <!-- Energy aura -->
        <circle cx="50" cy="50" r="38" stroke="url(#energyGradient)" stroke-width="3" stroke-dasharray="5,3"></circle>
        
        <!-- Energy rays -->
        <path d="M50,12 L50,20" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M50,80 L50,88" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M12,50 L20,50" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M80,50 L88,50" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M25,25 L31,31" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M69,69 L75,75" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M25,75 L31,69" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M69,31 L75,25" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#FFA500" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/panda-wisdom.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Panda Wisdom</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="wisdomGradient">
            <stop stop-color="#9C27B0" offset="0%"></stop>
            <stop stop-color="#673AB7" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Panda face -->
        <circle cx="50" cy="45" r="25" fill="white" stroke="black" stroke-width="2"></circle>
        
        <!-- Panda ears -->
        <circle cx="35" cy="30" r="8" fill="black"></circle>
        <circle cx="65" cy="30" r="8" fill="black"></circle>
        
        <!-- Panda eyes -->
        <ellipse cx="42" cy="42" rx="6" ry="5" fill="black"></ellipse>
        <ellipse cx="58" cy="42" rx="6" ry="5" fill="black"></ellipse>
        
        <!-- Panda nose -->
        <ellipse cx="50" cy="50" rx="4" ry="3" fill="black"></ellipse>
        
        <!-- Wisdom scroll -->
        <path d="M30,65 L70,65 L70,80 C65,75 60,78 55,80 C50,82 45,82 40,80 C35,78 30,75 30,80 L30,65 Z" fill="#F8F0D8" stroke="#9C27B0" stroke-width="2"></path>
        
        <!-- Scroll lines -->
        <path d="M35,70 L65,70" stroke="#9C27B0" stroke-width="1" stroke-opacity="0.5"></path>
        <path d="M35,75 L65,75" stroke="#9C27B0" stroke-width="1" stroke-opacity="0.5"></path>
        
        <!-- Wisdom aura -->
        <path d="M30,20 L35,15 L40,20 L45,15 L50,20 L55,15 L60,20 L65,15 L70,20" stroke="url(#wisdomGradient)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"></path>
        
        <!-- Stars -->
        <path d="M25,35 L27,30 L29,35 L34,35 L30,38 L32,43 L27,40 L22,43 L24,38 L20,35 Z" fill="url(#wisdomGradient)" opacity="0.7"></path>
        <path d="M75,35 L77,30 L79,35 L84,35 L80,38 L82,43 L77,40 L72,43 L74,38 L70,35 Z" fill="url(#wisdomGradient)" opacity="0.7"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#9C27B0" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/accessories/bamboo-hat.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 竹叶帽 -->
  <defs>
    <radialGradient id="bambooHatGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
      <stop offset="0%" stop-color="#A8C66C" />
      <stop offset="100%" stop-color="#88B04B" />
    </radialGradient>
  </defs>
  
  <!-- 帽子主体 -->
  <ellipse cx="100" cy="40" rx="80" ry="25" fill="url(#bambooHatGradient)" />
  
  <!-- 帽子顶部 -->
  <path d="M100,15 Q130,30 160,40 Q130,50 100,65 Q70,50 40,40 Q70,30 100,15" fill="#88B04B" />
  
  <!-- 帽子装饰 - 竹叶 -->
  <path d="M70,30 Q60,20 50,25 Q55,30 60,35 Q65,33 70,30" fill="#A8C66C" />
  <path d="M130,30 Q140,20 150,25 Q145,30 140,35 Q135,33 130,30" fill="#A8C66C" />
  
  <!-- 帽子绳子 -->
  <path d="M40,40 Q70,45 100,40 Q130,45 160,40" stroke="#5D4037" stroke-width="1" fill="none" />
  <path d="M100,40 L100,65" stroke="#5D4037" stroke-width="1" fill="none" />
</svg>
</file>

<file path="public/assets/accessories/default.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 默认装饰图标 -->
  <rect x="50" y="50" width="100" height="100" rx="10" ry="10" fill="#f0f0f0" stroke="#cccccc" stroke-width="2" />
  <text x="100" y="110" font-family="Arial" font-size="24" text-anchor="middle" fill="#888888">装饰</text>
</svg>
</file>

<file path="public/assets/accessories/gold-frame.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 金框 -->
  <defs>
    <linearGradient id="goldGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" stop-color="#FFD700" />
      <stop offset="50%" stop-color="#D4AF37" />
      <stop offset="100%" stop-color="#FFD700" />
    </linearGradient>
  </defs>
  
  <!-- 外圆框 -->
  <circle cx="100" cy="100" r="95" stroke="url(#goldGradient)" stroke-width="10" fill="none" />
  
  <!-- 装饰元素 - 上 -->
  <path d="M100,5 L100,15 M90,7 L110,7" stroke="url(#goldGradient)" stroke-width="5" />
  
  <!-- 装饰元素 - 下 -->
  <path d="M100,185 L100,195 M90,193 L110,193" stroke="url(#goldGradient)" stroke-width="5" />
  
  <!-- 装饰元素 - 左 -->
  <path d="M5,100 L15,100 M7,90 L7,110" stroke="url(#goldGradient)" stroke-width="5" />
  
  <!-- 装饰元素 - 右 -->
  <path d="M185,100 L195,100 M193,90 L193,110" stroke="url(#goldGradient)" stroke-width="5" />
  
  <!-- 角落装饰 - 左上 -->
  <path d="M30,30 Q40,20 50,30" stroke="url(#goldGradient)" stroke-width="5" fill="none" />
  
  <!-- 角落装饰 - 右上 -->
  <path d="M150,30 Q160,20 170,30" stroke="url(#goldGradient)" stroke-width="5" fill="none" />
  
  <!-- 角落装饰 - 左下 -->
  <path d="M30,170 Q40,180 50,170" stroke="url(#goldGradient)" stroke-width="5" fill="none" />
  
  <!-- 角落装饰 - 右下 -->
  <path d="M150,170 Q160,180 170,170" stroke="url(#goldGradient)" stroke-width="5" fill="none" />
</svg>
</file>

<file path="public/assets/accessories/red-ribbon.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 红丝带 -->
  <defs>
    <linearGradient id="ribbonGradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" stop-color="#D73E35" />
      <stop offset="50%" stop-color="#FF5252" />
      <stop offset="100%" stop-color="#D73E35" />
    </linearGradient>
  </defs>
  
  <!-- 丝带主体 -->
  <path d="M60,90 Q80,85 100,90 Q120,85 140,90 Q120,95 100,100 Q80,95 60,90" fill="url(#ribbonGradient)" />
  
  <!-- 丝带左侧 -->
  <path d="M60,90 Q50,100 40,120 Q45,115 50,110 Q55,105 60,90" fill="#D73E35" />
  
  <!-- 丝带右侧 -->
  <path d="M140,90 Q150,100 160,120 Q155,115 150,110 Q145,105 140,90" fill="#D73E35" />
  
  <!-- 丝带装饰 -->
  <circle cx="100" cy="95" r="5" fill="#FFD700" />
</svg>
</file>

<file path="public/assets/bamboo-bg-pattern.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- Bamboo pattern background -->
  <defs>
    <pattern id="bamboo-pattern" x="0" y="0" width="50" height="50" patternUnits="userSpaceOnUse">
      <!-- Bamboo stalk -->
      <path d="M25,0 L25,50" stroke="#88B04B" stroke-width="3" opacity="0.1"/>
      <!-- Bamboo joints -->
      <path d="M20,10 L30,10" stroke="#88B04B" stroke-width="2" opacity="0.1"/>
      <path d="M20,25 L30,25" stroke="#88B04B" stroke-width="2" opacity="0.1"/>
      <path d="M20,40 L30,40" stroke="#88B04B" stroke-width="2" opacity="0.1"/>
      <!-- Bamboo leaves -->
      <path d="M25,10 C30,5 35,8 38,12" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,25 C30,20 35,23 38,27" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,40 C30,35 35,38 38,42" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,10 C20,5 15,8 12,12" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,25 C20,20 15,23 12,27" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,40 C20,35 15,38 12,42" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
    </pattern>
  </defs>
  <rect width="100%" height="100%" fill="url(#bamboo-pattern)" />
</svg>
</file>

<file path="public/assets/bamboo-leaves.svg">
<svg width="250" height="250" viewBox="0 0 250 250" xmlns="http://www.w3.org/2000/svg">
  <!-- Bamboo stalk -->
  <path d="M50,250 L50,100" stroke="#88B04B" stroke-width="8" stroke-linecap="round"/>
  <path d="M50,100 L50,50" stroke="#88B04B" stroke-width="6" stroke-linecap="round"/>
  
  <!-- Bamboo joints -->
  <path d="M40,220 L60,220" stroke="#1A5F4A" stroke-width="3"/>
  <path d="M40,180 L60,180" stroke="#1A5F4A" stroke-width="3"/>
  <path d="M40,140 L60,140" stroke="#1A5F4A" stroke-width="3"/>
  <path d="M40,100 L60,100" stroke="#1A5F4A" stroke-width="3"/>
  <path d="M40,60 L60,60" stroke="#1A5F4A" stroke-width="3"/>
  
  <!-- Bamboo leaves -->
  <path d="M50,60 C80,30 120,40 140,20" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,60 C90,50 110,70 130,60" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,100 C70,80 100,90 120,70" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,100 C80,110 100,90 120,100" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,140 C30,120 20,100 10,90" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,140 C30,150 20,130 10,140" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,180 C70,160 90,170 110,150" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,180 C70,190 90,170 110,180" stroke="#88B04B" stroke-width="3" fill="none"/>
  
  <!-- Leaf details -->
  <path d="M140,20 C150,15 160,25 140,30" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M130,60 C140,55 150,65 130,70" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M120,70 C130,65 140,75 120,80" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M120,100 C130,95 140,105 120,110" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M10,90 C0,85 -5,95 15,100" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M10,140 C0,135 -5,145 15,150" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M110,150 C120,145 130,155 110,160" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M110,180 C120,175 130,185 110,190" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
</svg>
</file>

<file path="public/assets/chinese-cloud.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="200px" height="100px" viewBox="0 0 200 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Chinese Cloud</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="cloudGradient">
            <stop stop-color="#F7F9F9" offset="0%"></stop>
            <stop stop-color="#E0E0E0" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M20,60 C10,60 5,50 10,40 C15,30 30,30 35,40 C40,20 60,10 80,20 C100,30 110,20 130,20 C150,20 170,40 160,60 C180,60 190,80 170,90 C150,100 130,90 120,80 C110,90 90,100 70,90 C50,80 40,90 30,80 C20,70 10,60 20,60 Z" 
              fill="url(#cloudGradient)" 
              stroke="#CCCCCC" 
              stroke-width="1">
        </path>
    </g>
</svg>
</file>

<file path="public/assets/chinese-knot.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="150px" viewBox="0 0 100 150" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Chinese Knot</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="knotGradient">
            <stop stop-color="#D73E35" offset="0%"></stop>
            <stop stop-color="#9E1A1A" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Main knot structure -->
        <path d="M50,10 C60,10 70,20 70,30 C70,40 60,45 50,45 C40,45 30,40 30,30 C30,20 40,10 50,10 Z" 
              fill="url(#knotGradient)" 
              stroke="#7A0000" 
              stroke-width="2">
        </path>
        
        <path d="M50,45 C60,45 70,50 70,60 C70,70 60,75 50,75 C40,75 30,70 30,60 C30,50 40,45 50,45 Z" 
              fill="url(#knotGradient)" 
              stroke="#7A0000" 
              stroke-width="2">
        </path>
        
        <path d="M50,75 C60,75 70,80 70,90 C70,100 60,105 50,105 C40,105 30,100 30,90 C30,80 40,75 50,75 Z" 
              fill="url(#knotGradient)" 
              stroke="#7A0000" 
              stroke-width="2">
        </path>
        
        <!-- Decorative elements -->
        <circle cx="50" cy="30" r="5" fill="#FFD700" stroke="#7A0000" stroke-width="1"></circle>
        <circle cx="50" cy="60" r="5" fill="#FFD700" stroke="#7A0000" stroke-width="1"></circle>
        <circle cx="50" cy="90" r="5" fill="#FFD700" stroke="#7A0000" stroke-width="1"></circle>
        
        <!-- Tassels -->
        <path d="M45,105 L40,140" stroke="#7A0000" stroke-width="2" stroke-linecap="round"></path>
        <path d="M55,105 L60,140" stroke="#7A0000" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M40,120 L35,130" stroke="#7A0000" stroke-width="1" stroke-linecap="round"></path>
        <path d="M40,130 L35,140" stroke="#7A0000" stroke-width="1" stroke-linecap="round"></path>
        
        <path d="M60,120 L65,130" stroke="#7A0000" stroke-width="1" stroke-linecap="round"></path>
        <path d="M60,130 L65,140" stroke="#7A0000" stroke-width="1" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/chinese-lantern.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="150px" viewBox="0 0 100 150" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Chinese Lantern</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="lanternGradient">
            <stop stop-color="#D73E35" offset="0%"></stop>
            <stop stop-color="#9E1A1A" offset="100%"></stop>
        </linearGradient>
        <filter id="lanternGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Lantern top -->
        <path d="M40,20 L60,20 L55,30 L45,30 Z" 
              fill="#D4AF37" 
              stroke="#7A0000" 
              stroke-width="1">
        </path>
        
        <!-- Lantern body -->
        <path d="M45,30 C25,40 25,90 45,100 L55,100 C75,90 75,40 55,30 Z" 
              fill="url(#lanternGradient)" 
              stroke="#7A0000" 
              stroke-width="2"
              filter="url(#lanternGlow)">
        </path>
        
        <!-- Lantern bottom -->
        <path d="M45,100 L55,100 L60,110 L40,110 Z" 
              fill="#D4AF37" 
              stroke="#7A0000" 
              stroke-width="1">
        </path>
        
        <!-- Decorative lines -->
        <path d="M45,30 L45,100" stroke="#7A0000" stroke-width="1" stroke-dasharray="5,5"></path>
        <path d="M55,30 L55,100" stroke="#7A0000" stroke-width="1" stroke-dasharray="5,5"></path>
        <path d="M35,50 L65,50" stroke="#7A0000" stroke-width="1" stroke-dasharray="5,5"></path>
        <path d="M35,70 L65,70" stroke="#7A0000" stroke-width="1" stroke-dasharray="5,5"></path>
        
        <!-- Chinese character for "福" (Fortune) -->
        <text x="50" y="65" font-family="Ma Shan Zheng, cursive" font-size="24" fill="#FFD700" text-anchor="middle">福</text>
        
        <!-- Tassel -->
        <path d="M50,110 L50,130" stroke="#D4AF37" stroke-width="2" stroke-linecap="round"></path>
        <path d="M45,130 L55,130" stroke="#D4AF37" stroke-width="2" stroke-linecap="round"></path>
        <path d="M45,130 L40,140" stroke="#D4AF37" stroke-width="1" stroke-linecap="round"></path>
        <path d="M50,130 L50,140" stroke="#D4AF37" stroke-width="1" stroke-linecap="round"></path>
        <path d="M55,130 L60,140" stroke="#D4AF37" stroke-width="1" stroke-linecap="round"></path>
        
        <!-- String -->
        <path d="M50,10 L50,20" stroke="#7A0000" stroke-width="1"></path>
    </g>
</svg>
</file>

<file path="public/assets/chinese-pattern.svg">
<svg width="100" height="8" viewBox="0 0 100 8" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <pattern id="chinese-border" x="0" y="0" width="20" height="8" patternUnits="userSpaceOnUse">
      <!-- Traditional Chinese border pattern -->
      <path d="M0,4 L5,4 L5,0 L10,0 L10,4 L15,4 L15,0 L20,0 L20,4" 
            stroke="#D4AF37" stroke-width="1" fill="none"/>
      <path d="M0,8 L5,8 L5,4 L10,4 L10,8 L15,8 L15,4 L20,4 L20,8" 
            stroke="#D4AF37" stroke-width="1" fill="none"/>
      <!-- Decorative elements -->
      <circle cx="5" cy="2" r="0.8" fill="#D73E35"/>
      <circle cx="15" cy="2" r="0.8" fill="#D73E35"/>
      <circle cx="5" cy="6" r="0.8" fill="#D73E35"/>
      <circle cx="15" cy="6" r="0.8" fill="#D73E35"/>
    </pattern>
  </defs>
  <rect width="100" height="8" fill="url(#chinese-border)"/>
</svg>
</file>

<file path="public/assets/environments/bamboo-path.svg">
<svg width="800" height="400" viewBox="0 0 800 400" xmlns="http://www.w3.org/2000/svg">
  <!-- 竹林小径背景 -->
  <defs>
    <linearGradient id="skyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#87CEEB" />
      <stop offset="100%" stop-color="#E0F7FA" />
    </linearGradient>
    <linearGradient id="groundGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#A8C66C" />
      <stop offset="100%" stop-color="#88B04B" />
    </linearGradient>
    <linearGradient id="pathGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#D7CCC8" />
      <stop offset="100%" stop-color="#BCAAA4" />
    </linearGradient>
    <linearGradient id="bambooGradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" stop-color="#7CB342" />
      <stop offset="100%" stop-color="#558B2F" />
    </linearGradient>
  </defs>
  
  <!-- 天空 -->
  <rect x="0" y="0" width="800" height="200" fill="url(#skyGradient)" />
  
  <!-- 远处的山 -->
  <path d="M0,200 Q200,100 400,180 Q600,100 800,200" fill="#A5D6A7" />
  
  <!-- 地面 -->
  <rect x="0" y="200" width="800" height="200" fill="url(#groundGradient)" />
  
  <!-- 小径 -->
  <path d="M300,400 Q400,350 500,400" fill="url(#pathGradient)" />
  <path d="M320,400 Q400,360 480,400" fill="#E0E0E0" />
  
  <!-- 竹子群 - 左侧 -->
  <g transform="translate(100, 150)">
    <!-- 竹竿 -->
    <rect x="0" y="0" width="10" height="250" fill="url(#bambooGradient)" />
    <rect x="20" y="-30" width="8" height="280" fill="url(#bambooGradient)" />
    <rect x="40" y="-10" width="12" height="260" fill="url(#bambooGradient)" />
    
    <!-- 竹节 -->
    <rect x="0" y="50" width="10" height="2" fill="#33691E" />
    <rect x="0" y="100" width="10" height="2" fill="#33691E" />
    <rect x="0" y="150" width="10" height="2" fill="#33691E" />
    <rect x="0" y="200" width="10" height="2" fill="#33691E" />
    
    <rect x="20" y="40" width="8" height="2" fill="#33691E" />
    <rect x="20" y="90" width="8" height="2" fill="#33691E" />
    <rect x="20" y="140" width="8" height="2" fill="#33691E" />
    <rect x="20" y="190" width="8" height="2" fill="#33691E" />
    
    <rect x="40" y="60" width="12" height="2" fill="#33691E" />
    <rect x="40" y="110" width="12" height="2" fill="#33691E" />
    <rect x="40" y="160" width="12" height="2" fill="#33691E" />
    <rect x="40" y="210" width="12" height="2" fill="#33691E" />
    
    <!-- 竹叶 -->
    <path d="M5,0 Q15,-20 25,-10 Q15,0 5,0" fill="#A5D6A7" />
    <path d="M5,10 Q25,0 30,15 Q15,20 5,10" fill="#A5D6A7" />
    <path d="M25,-30 Q40,-40 45,-25 Q35,-20 25,-30" fill="#A5D6A7" />
    <path d="M45,-10 Q60,-25 70,-15 Q55,0 45,-10" fill="#A5D6A7" />
  </g>
  
  <!-- 竹子群 - 右侧 -->
  <g transform="translate(600, 170)">
    <!-- 竹竿 -->
    <rect x="0" y="0" width="10" height="230" fill="url(#bambooGradient)" />
    <rect x="20" y="-20" width="8" height="250" fill="url(#bambooGradient)" />
    <rect x="40" y="10" width="12" height="220" fill="url(#bambooGradient)" />
    
    <!-- 竹节 -->
    <rect x="0" y="50" width="10" height="2" fill="#33691E" />
    <rect x="0" y="100" width="10" height="2" fill="#33691E" />
    <rect x="0" y="150" width="10" height="2" fill="#33691E" />
    <rect x="0" y="200" width="10" height="2" fill="#33691E" />
    
    <rect x="20" y="40" width="8" height="2" fill="#33691E" />
    <rect x="20" y="90" width="8" height="2" fill="#33691E" />
    <rect x="20" y="140" width="8" height="2" fill="#33691E" />
    <rect x="20" y="190" width="8" height="2" fill="#33691E" />
    
    <rect x="40" y="60" width="12" height="2" fill="#33691E" />
    <rect x="40" y="110" width="12" height="2" fill="#33691E" />
    <rect x="40" y="160" width="12" height="2" fill="#33691E" />
    <rect x="40" y="210" width="12" height="2" fill="#33691E" />
    
    <!-- 竹叶 -->
    <path d="M5,0 Q15,-20 25,-10 Q15,0 5,0" fill="#A5D6A7" />
    <path d="M5,10 Q25,0 30,15 Q15,20 5,10" fill="#A5D6A7" />
    <path d="M25,-20 Q40,-30 45,-15 Q35,-10 25,-20" fill="#A5D6A7" />
    <path d="M45,10 Q60,-5 70,5 Q55,15 45,10" fill="#A5D6A7" />
  </g>
  
  <!-- 竹子群 - 中间远处 -->
  <g transform="translate(350, 100) scale(0.7)">
    <!-- 竹竿 -->
    <rect x="0" y="0" width="10" height="300" fill="url(#bambooGradient)" />
    <rect x="20" y="-30" width="8" height="330" fill="url(#bambooGradient)" />
    <rect x="40" y="-10" width="12" height="310" fill="url(#bambooGradient)" />
    
    <!-- 竹节 -->
    <rect x="0" y="50" width="10" height="2" fill="#33691E" />
    <rect x="0" y="100" width="10" height="2" fill="#33691E" />
    <rect x="0" y="150" width="10" height="2" fill="#33691E" />
    <rect x="0" y="200" width="10" height="2" fill="#33691E" />
    <rect x="0" y="250" width="10" height="2" fill="#33691E" />
    
    <rect x="20" y="40" width="8" height="2" fill="#33691E" />
    <rect x="20" y="90" width="8" height="2" fill="#33691E" />
    <rect x="20" y="140" width="8" height="2" fill="#33691E" />
    <rect x="20" y="190" width="8" height="2" fill="#33691E" />
    <rect x="20" y="240" width="8" height="2" fill="#33691E" />
    
    <rect x="40" y="60" width="12" height="2" fill="#33691E" />
    <rect x="40" y="110" width="12" height="2" fill="#33691E" />
    <rect x="40" y="160" width="12" height="2" fill="#33691E" />
    <rect x="40" y="210" width="12" height="2" fill="#33691E" />
    <rect x="40" y="260" width="12" height="2" fill="#33691E" />
    
    <!-- 竹叶 -->
    <path d="M5,0 Q15,-20 25,-10 Q15,0 5,0" fill="#A5D6A7" />
    <path d="M5,10 Q25,0 30,15 Q15,20 5,10" fill="#A5D6A7" />
    <path d="M25,-30 Q40,-40 45,-25 Q35,-20 25,-30" fill="#A5D6A7" />
    <path d="M45,-10 Q60,-25 70,-15 Q55,0 45,-10" fill="#A5D6A7" />
  </g>
  
  <!-- 云朵 -->
  <path d="M100,100 Q120,80 140,90 Q160,70 180,90 Q200,80 220,100 Q200,120 180,110 Q160,130 140,110 Q120,120 100,100" fill="white" opacity="0.8" />
  <path d="M500,70 Q520,50 540,60 Q560,40 580,60 Q600,50 620,70 Q600,90 580,80 Q560,100 540,80 Q520,90 500,70" fill="white" opacity="0.8" />
</svg>
</file>

<file path="public/assets/environments/chinese-garden.svg">
<svg width="800" height="400" viewBox="0 0 800 400" xmlns="http://www.w3.org/2000/svg">
  <!-- 中式园林背景 -->
  <defs>
    <linearGradient id="skyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#B3E5FC" />
      <stop offset="100%" stop-color="#E1F5FE" />
    </linearGradient>
    <linearGradient id="waterGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#0288D1" />
      <stop offset="100%" stop-color="#03A9F4" />
    </linearGradient>
    <linearGradient id="roofGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#D32F2F" />
      <stop offset="100%" stop-color="#B71C1C" />
    </linearGradient>
    <linearGradient id="woodGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#795548" />
      <stop offset="100%" stop-color="#5D4037" />
    </linearGradient>
    <linearGradient id="stoneGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#9E9E9E" />
      <stop offset="100%" stop-color="#757575" />
    </linearGradient>
  </defs>
  
  <!-- 天空 -->
  <rect x="0" y="0" width="800" height="200" fill="url(#skyGradient)" />
  
  <!-- 远山 -->
  <path d="M0,200 Q100,150 200,180 Q300,130 400,170 Q500,120 600,160 Q700,140 800,200" fill="#A5D6A7" opacity="0.7" />
  
  <!-- 水面 -->
  <rect x="0" y="200" width="800" height="200" fill="url(#waterGradient)" />
  
  <!-- 水中倒影 -->
  <rect x="350" y="250" width="100" height="100" fill="#5D4037" opacity="0.5" />
  <path d="M350,250 L450,250 L400,200 Z" fill="#B71C1C" opacity="0.5" />
  
  <!-- 石桥 -->
  <path d="M100,250 Q400,300 700,250" stroke="url(#stoneGradient)" stroke-width="20" fill="none" />
  <rect x="100" y="240" width="20" height="160" fill="url(#stoneGradient)" />
  <rect x="700" y="240" width="20" height="160" fill="url(#stoneGradient)" />
  <rect x="250" y="245" width="15" height="155" fill="url(#stoneGradient)" />
  <rect x="550" y="245" width="15" height="155" fill="url(#stoneGradient)" />
  
  <!-- 亭子 -->
  <g transform="translate(350, 150)">
    <!-- 亭子底座 -->
    <rect x="0" y="50" width="100" height="10" fill="url(#stoneGradient)" />
    
    <!-- 亭子柱子 -->
    <rect x="10" y="10" width="10" height="40" fill="url(#woodGradient)" />
    <rect x="80" y="10" width="10" height="40" fill="url(#woodGradient)" />
    <rect x="10" y="0" width="80" height="10" fill="url(#woodGradient)" />
    
    <!-- 亭子屋顶 -->
    <path d="M0,0 L100,0 L50,-50 Z" fill="url(#roofGradient)" />
    <path d="M10,0 L90,0 L50,-40 Z" fill="#D50000" />
    
    <!-- 亭子装饰 -->
    <circle cx="50" cy="-25" r="5" fill="#FFD700" />
  </g>
  
  <!-- 荷花 -->
  <g transform="translate(200, 300)">
    <circle cx="0" cy="0" r="15" fill="#E91E63" />
    <circle cx="0" cy="0" r="8" fill="#FFC107" />
    <path d="M-20,-5 Q-10,-15 0,-5 Q10,-15 20,-5" fill="#4CAF50" />
  </g>
  
  <g transform="translate(600, 320)">
    <circle cx="0" cy="0" r="12" fill="#E91E63" />
    <circle cx="0" cy="0" r="6" fill="#FFC107" />
    <path d="M-15,-5 Q-8,-12 0,-5 Q8,-12 15,-5" fill="#4CAF50" />
  </g>
  
  <!-- 柳树 -->
  <g transform="translate(150, 200)">
    <rect x="-5" y="0" width="10" height="80" fill="#795548" />
    <path d="M0,0 Q-30,40 -60,100" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q-20,50 -40,120" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q-10,60 -20,130" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q10,60 20,130" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q20,50 40,120" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q30,40 60,100" stroke="#7CB342" stroke-width="2" fill="none" />
  </g>
  
  <g transform="translate(650, 200)">
    <rect x="-5" y="0" width="10" height="80" fill="#795548" />
    <path d="M0,0 Q-30,40 -60,100" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q-20,50 -40,120" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q-10,60 -20,130" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q10,60 20,130" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q20,50 40,120" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q30,40 60,100" stroke="#7CB342" stroke-width="2" fill="none" />
  </g>
  
  <!-- 云朵 -->
  <path d="M100,100 Q120,80 140,90 Q160,70 180,90 Q200,80 220,100 Q200,120 180,110 Q160,130 140,110 Q120,120 100,100" fill="white" opacity="0.8" />
  <path d="M500,70 Q520,50 540,60 Q560,40 580,60 Q600,50 620,70 Q600,90 580,80 Q560,100 540,80 Q520,90 500,70" fill="white" opacity="0.8" />
</svg>
</file>

<file path="public/assets/environments/default.svg">
<svg width="800" height="400" viewBox="0 0 800 400" xmlns="http://www.w3.org/2000/svg">
  <!-- 默认环境背景 -->
  <rect x="0" y="0" width="800" height="400" fill="#f0f0f0" />
  <text x="400" y="200" font-family="Arial" font-size="36" text-anchor="middle" fill="#888888">默认环境</text>
</svg>
</file>

<file path="public/assets/ink-splash.svg">
<svg width="300" height="300" viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
  <!-- Ink splash effect -->
  <path d="M150,50 
           C180,30 220,40 240,70 
           C260,100 250,140 230,160 
           C210,180 190,200 170,220 
           C150,240 130,250 110,230 
           C90,210 70,190 60,160 
           C50,130 60,100 80,80 
           C100,60 130,60 150,50 Z" 
        fill="#1A5F4A" opacity="0.8"/>
  <!-- Additional ink splatters -->
  <circle cx="200" cy="100" r="15" fill="#1A5F4A" opacity="0.6"/>
  <circle cx="80" cy="150" r="20" fill="#1A5F4A" opacity="0.5"/>
  <circle cx="180" cy="220" r="12" fill="#1A5F4A" opacity="0.7"/>
  <circle cx="120" cy="80" r="10" fill="#1A5F4A" opacity="0.6"/>
</svg>
</file>

<file path="public/assets/lattice-pattern.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Lattice Pattern</title>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Horizontal lines -->
        <line x1="0" y1="0" x2="100" y2="0" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="0" y1="25" x2="100" y2="25" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="0" y1="50" x2="100" y2="50" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="0" y1="75" x2="100" y2="75" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="0" y1="100" x2="100" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        
        <!-- Vertical lines -->
        <line x1="0" y1="0" x2="0" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="25" y1="0" x2="25" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="50" y1="0" x2="50" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="75" y1="0" x2="75" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="100" y1="0" x2="100" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        
        <!-- Decorative elements at intersections -->
        <circle cx="0" cy="0" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="0" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="0" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="0" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="0" r="3" fill="#D4AF37"></circle>
        
        <circle cx="0" cy="25" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="25" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="25" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="25" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="25" r="3" fill="#D4AF37"></circle>
        
        <circle cx="0" cy="50" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="50" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="50" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="50" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="50" r="3" fill="#D4AF37"></circle>
        
        <circle cx="0" cy="75" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="75" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="75" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="75" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="75" r="3" fill="#D4AF37"></circle>
        
        <circle cx="0" cy="100" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="100" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="100" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="100" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="100" r="3" fill="#D4AF37"></circle>
        
        <!-- Decorative elements in cells -->
        <path d="M12.5,12.5 L18.75,6.25 L12.5,6.25 L12.5,12.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M37.5,12.5 L43.75,6.25 L37.5,6.25 L37.5,12.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M62.5,12.5 L68.75,6.25 L62.5,6.25 L62.5,12.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M87.5,12.5 L93.75,6.25 L87.5,6.25 L87.5,12.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        
        <path d="M12.5,37.5 L18.75,31.25 L12.5,31.25 L12.5,37.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M37.5,37.5 L43.75,31.25 L37.5,31.25 L37.5,37.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M62.5,37.5 L68.75,31.25 L62.5,31.25 L62.5,37.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M87.5,37.5 L93.75,31.25 L87.5,31.25 L87.5,37.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        
        <path d="M12.5,62.5 L18.75,56.25 L12.5,56.25 L12.5,62.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M37.5,62.5 L43.75,56.25 L37.5,56.25 L37.5,62.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M62.5,62.5 L68.75,56.25 L62.5,56.25 L62.5,62.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M87.5,62.5 L93.75,56.25 L87.5,56.25 L87.5,62.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        
        <path d="M12.5,87.5 L18.75,81.25 L12.5,81.25 L12.5,87.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M37.5,87.5 L43.75,81.25 L37.5,81.25 L37.5,87.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M62.5,87.5 L68.75,81.25 L62.5,81.25 L62.5,87.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M87.5,87.5 L93.75,81.25 L87.5,81.25 L87.5,87.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
    </g>
</svg>
</file>

<file path="public/assets/lotus-flower.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="150px" height="150px" viewBox="0 0 150 150" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Lotus Flower</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="petalGradient">
            <stop stop-color="#F8C8DC" offset="0%"></stop>
            <stop stop-color="#E57373" offset="100%"></stop>
        </linearGradient>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="centerGradient">
            <stop stop-color="#FFD700" offset="0%"></stop>
            <stop stop-color="#FFA000" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Outer petals -->
        <path d="M75,20 C85,30 95,50 75,70 C55,50 65,30 75,20 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M75,20 C65,30 55,50 75,70 C95,50 85,30 75,20 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M40,40 C50,50 60,70 75,70 C60,50 50,30 40,40 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M110,40 C100,50 90,70 75,70 C90,50 100,30 110,40 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M30,75 C50,65 70,65 75,70 C60,80 40,85 30,75 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M120,75 C100,65 80,65 75,70 C90,80 110,85 120,75 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M40,110 C50,90 70,80 75,70 C60,90 50,110 40,110 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M110,110 C100,90 80,80 75,70 C90,90 100,110 110,110 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <!-- Inner petals -->
        <path d="M75,40 C80,45 85,55 75,65 C65,55 70,45 75,40 Z" 
              fill="#F8C8DC" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M75,40 C70,45 65,55 75,65 C85,55 80,45 75,40 Z" 
              fill="#F8C8DC" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M55,50 C60,55 65,65 75,65 C65,55 60,45 55,50 Z" 
              fill="#F8C8DC" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M95,50 C90,55 85,65 75,65 C85,55 90,45 95,50 Z" 
              fill="#F8C8DC" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <!-- Center -->
        <circle cx="75" cy="65" r="10" fill="url(#centerGradient)" stroke="#FFA000" stroke-width="1"></circle>
        
        <!-- Stem -->
        <path d="M75,70 L75,130" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        
        <!-- Leaves -->
        <path d="M75,100 C60,90 40,100 30,120" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M75,100 C90,90 110,100 120,120" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/mountain-landscape.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="300px" height="150px" viewBox="0 0 300 150" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Mountain Landscape</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="mountainGradient1">
            <stop stop-color="#1A5F4A" offset="0%"></stop>
            <stop stop-color="#0D2F25" offset="100%"></stop>
        </linearGradient>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="mountainGradient2">
            <stop stop-color="#88B04B" offset="0%"></stop>
            <stop stop-color="#1A5F4A" offset="100%"></stop>
        </linearGradient>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="waterGradient">
            <stop stop-color="#1A6DB0" offset="0%"></stop>
            <stop stop-color="#0D3658" offset="100%"></stop>
        </linearGradient>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="0%" id="skyGradient">
            <stop stop-color="#F7F9F9" offset="0%"></stop>
            <stop stop-color="#E0E0E0" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Sky -->
        <rect x="0" y="0" width="300" height="150" fill="url(#skyGradient)"></rect>
        
        <!-- Far mountains -->
        <path d="M0,70 L50,40 L100,60 L150,30 L200,50 L250,35 L300,60 L300,150 L0,150 Z" 
              fill="url(#mountainGradient1)" 
              opacity="0.7">
        </path>
        
        <!-- Near mountains -->
        <path d="M0,90 L30,70 L60,85 L90,60 L120,80 L150,50 L180,75 L210,55 L240,70 L270,60 L300,80 L300,150 L0,150 Z" 
              fill="url(#mountainGradient2)" 
              opacity="0.9">
        </path>
        
        <!-- Water -->
        <path d="M0,120 C30,115 60,125 90,120 C120,115 150,125 180,120 C210,115 240,125 270,120 C300,115 300,150 300,150 L0,150 Z" 
              fill="url(#waterGradient)" 
              opacity="0.6">
        </path>
        
        <!-- Sun -->
        <circle cx="250" cy="30" r="15" fill="#FFD700" opacity="0.8"></circle>
        
        <!-- Clouds -->
        <path d="M50,40 C40,40 35,35 40,30 C45,25 55,25 60,30 C65,20 75,15 85,20 C95,25 100,20 110,20 C120,20 130,30 125,40 C135,40 140,50 130,55 C120,60 110,55 105,50 C100,55 90,60 80,55 C70,50 65,55 60,50 C55,45 50,40 50,40 Z" 
              fill="#FFFFFF" 
              opacity="0.7">
        </path>
        
        <path d="M180,50 C170,50 165,45 170,40 C175,35 185,35 190,40 C195,30 205,25 215,30 C225,35 230,30 240,30 C250,30 260,40 255,50 C265,50 270,60 260,65 C250,70 240,65 235,60 C230,65 220,70 210,65 C200,60 195,65 190,60 C185,55 180,50 180,50 Z" 
              fill="#FFFFFF" 
              opacity="0.5">
        </path>
        
        <!-- Trees -->
        <path d="M60,100 L60,120 L55,120 L65,130 L75,120 L70,120 L70,100 Z" 
              fill="#88B04B">
        </path>
        
        <path d="M240,100 L240,120 L235,120 L245,130 L255,120 L250,120 L250,100 Z" 
              fill="#88B04B">
        </path>
        
        <!-- Bamboo -->
        <path d="M100,90 L100,130" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M110,95 L110,130" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M120,100 L120,130" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        
        <path d="M95,100 L105,100" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M95,110 L105,110" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M95,120 L105,120" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        
        <path d="M105,105 L115,105" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M105,115 L115,115" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M105,125 L115,125" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        
        <path d="M115,110 L125,110" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M115,120 L125,120" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        
        <!-- Birds -->
        <path d="M160,40 C165,35 170,40 175,35" stroke="#333333" stroke-width="1" stroke-linecap="round"></path>
        <path d="M180,30 C185,25 190,30 195,25" stroke="#333333" stroke-width="1" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/panda-focused.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 熊猫头部 - 专注状态 -->
  
  <!-- 头部轮廓 -->
  <circle cx="100" cy="100" r="90" fill="white" stroke="black" stroke-width="2"/>
  
  <!-- 左耳朵 -->
  <ellipse cx="40" cy="40" rx="25" ry="25" fill="black" transform="rotate(-15 40 40)"/>
  
  <!-- 右耳朵 -->
  <ellipse cx="160" cy="40" rx="25" ry="25" fill="black" transform="rotate(15 160 40)"/>
  
  <!-- 左眼眶 -->
  <ellipse cx="70" cy="85" rx="25" ry="23" fill="black" transform="rotate(-10 70 85)"/>
  
  <!-- 右眼眶 -->
  <ellipse cx="130" cy="85" rx="25" ry="23" fill="black" transform="rotate(10 130 85)"/>
  
  <!-- 左眼 - 专注 -->
  <ellipse cx="70" cy="85" rx="8" ry="10" fill="white" transform="rotate(-10 70 85)"/>
  <circle cx="70" cy="85" r="5" fill="black"/>
  <circle cx="68" cy="83" r="2" fill="white"/>
  
  <!-- 右眼 - 专注 -->
  <ellipse cx="130" cy="85" rx="8" ry="10" fill="white" transform="rotate(10 130 85)"/>
  <circle cx="130" cy="85" r="5" fill="black"/>
  <circle cx="128" cy="83" r="2" fill="white"/>
  
  <!-- 眉毛 - 专注 -->
  <path d="M55,65 L85,70" stroke="black" stroke-width="3" fill="none"/>
  <path d="M145,65 L115,70" stroke="black" stroke-width="3" fill="none"/>
  
  <!-- 鼻子 -->
  <ellipse cx="100" cy="110" rx="15" ry="10" fill="black"/>
  
  <!-- 嘴巴 - 抿嘴 -->
  <path d="M85,125 L115,125" stroke="black" stroke-width="2" fill="none"/>
  
  <!-- 装饰 - 竹叶 -->
  <path d="M30,160 C20,150 25,140 35,145" stroke="#88B04B" stroke-width="2" fill="none"/>
  <path d="M30,160 C40,150 45,140 35,135" stroke="#88B04B" stroke-width="2" fill="none"/>
</svg>
</file>

<file path="public/assets/panda-happy.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 熊猫头部 - 开心状态 -->
  
  <!-- 头部轮廓 -->
  <circle cx="100" cy="100" r="90" fill="white" stroke="black" stroke-width="2"/>
  
  <!-- 左耳朵 -->
  <ellipse cx="40" cy="40" rx="25" ry="25" fill="black" transform="rotate(-15 40 40)"/>
  
  <!-- 右耳朵 -->
  <ellipse cx="160" cy="40" rx="25" ry="25" fill="black" transform="rotate(15 160 40)"/>
  
  <!-- 左眼眶 -->
  <ellipse cx="70" cy="85" rx="25" ry="23" fill="black" transform="rotate(-10 70 85)"/>
  
  <!-- 右眼眶 -->
  <ellipse cx="130" cy="85" rx="25" ry="23" fill="black" transform="rotate(10 130 85)"/>
  
  <!-- 左眼 - 眯眼笑 -->
  <path d="M60,85 Q70,75 80,85" stroke="white" stroke-width="3" fill="none"/>
  <circle cx="70" cy="82" r="2" fill="white"/>
  
  <!-- 右眼 - 眯眼笑 -->
  <path d="M120,85 Q130,75 140,85" stroke="white" stroke-width="3" fill="none"/>
  <circle cx="130" cy="82" r="2" fill="white"/>
  
  <!-- 鼻子 -->
  <ellipse cx="100" cy="110" rx="15" ry="10" fill="black"/>
  
  <!-- 嘴巴 - 笑容 -->
  <path d="M75,125 Q100,145 125,125" stroke="black" stroke-width="3" fill="none"/>
  
  <!-- 脸颊 - 更红 -->
  <circle cx="60" cy="115" r="15" fill="#ff9999" opacity="0.6"/>
  <circle cx="140" cy="115" r="15" fill="#ff9999" opacity="0.6"/>
  
  <!-- 装饰 - 竹子 -->
  <path d="M180,160 L190,140" stroke="#88B04B" stroke-width="4" stroke-linecap="round"/>
  <path d="M180,160 L185,150" stroke="#88B04B" stroke-width="2" stroke-linecap="round"/>
  <path d="M185,150 L190,145" stroke="#88B04B" stroke-width="2" stroke-linecap="round"/>
  <ellipse cx="180" cy="160" rx="5" ry="3" fill="#1A5F4A" transform="rotate(-30 180 160)"/>
</svg>
</file>

<file path="public/assets/panda-normal.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 熊猫头部 - 基本状态 -->
  
  <!-- 头部轮廓 -->
  <circle cx="100" cy="100" r="90" fill="white" stroke="black" stroke-width="2"/>
  
  <!-- 左耳朵 -->
  <ellipse cx="40" cy="40" rx="25" ry="25" fill="black" transform="rotate(-15 40 40)"/>
  
  <!-- 右耳朵 -->
  <ellipse cx="160" cy="40" rx="25" ry="25" fill="black" transform="rotate(15 160 40)"/>
  
  <!-- 左眼眶 -->
  <ellipse cx="70" cy="85" rx="25" ry="23" fill="black" transform="rotate(-10 70 85)"/>
  
  <!-- 右眼眶 -->
  <ellipse cx="130" cy="85" rx="25" ry="23" fill="black" transform="rotate(10 130 85)"/>
  
  <!-- 左眼 -->
  <ellipse cx="70" cy="85" rx="8" ry="10" fill="white" transform="rotate(-10 70 85)"/>
  <circle cx="70" cy="85" r="4" fill="black"/>
  <circle cx="68" cy="83" r="2" fill="white"/>
  
  <!-- 右眼 -->
  <ellipse cx="130" cy="85" rx="8" ry="10" fill="white" transform="rotate(10 130 85)"/>
  <circle cx="130" cy="85" r="4" fill="black"/>
  <circle cx="128" cy="83" r="2" fill="white"/>
  
  <!-- 鼻子 -->
  <ellipse cx="100" cy="110" rx="15" ry="10" fill="black"/>
  
  <!-- 嘴巴 -->
  <path d="M85,120 Q100,130 115,120" stroke="black" stroke-width="2" fill="none"/>
  
  <!-- 脸颊 -->
  <circle cx="60" cy="115" r="10" fill="#ffcccc" opacity="0.5"/>
  <circle cx="140" cy="115" r="10" fill="#ffcccc" opacity="0.5"/>
</svg>
</file>

<file path="public/assets/panda-tired.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 熊猫头部 - 疲惫状态 -->
  
  <!-- 头部轮廓 -->
  <circle cx="100" cy="100" r="90" fill="white" stroke="black" stroke-width="2"/>
  
  <!-- 左耳朵 -->
  <ellipse cx="40" cy="40" rx="25" ry="25" fill="black" transform="rotate(-15 40 40)"/>
  
  <!-- 右耳朵 -->
  <ellipse cx="160" cy="40" rx="25" ry="25" fill="black" transform="rotate(15 160 40)"/>
  
  <!-- 左眼眶 -->
  <ellipse cx="70" cy="85" rx="25" ry="23" fill="black" transform="rotate(-10 70 85)"/>
  
  <!-- 右眼眶 -->
  <ellipse cx="130" cy="85" rx="25" ry="23" fill="black" transform="rotate(10 130 85)"/>
  
  <!-- 左眼 - 疲惫 -->
  <ellipse cx="70" cy="85" rx="8" ry="5" fill="white" transform="rotate(-10 70 85)"/>
  <path d="M62,85 L78,85" stroke="black" stroke-width="1.5" fill="none"/>
  
  <!-- 右眼 - 疲惫 -->
  <ellipse cx="130" cy="85" rx="8" ry="5" fill="white" transform="rotate(10 130 85)"/>
  <path d="M122,85 L138,85" stroke="black" stroke-width="1.5" fill="none"/>
  
  <!-- 黑眼圈 -->
  <path d="M50,95 Q70,105 90,95" stroke="#666" stroke-width="2" fill="none" opacity="0.5"/>
  <path d="M110,95 Q130,105 150,95" stroke="#666" stroke-width="2" fill="none" opacity="0.5"/>
  
  <!-- 鼻子 -->
  <ellipse cx="100" cy="110" rx="15" ry="10" fill="black"/>
  
  <!-- 嘴巴 - 疲惫 -->
  <path d="M85,125 Q100,115 115,125" stroke="black" stroke-width="2" fill="none"/>
  
  <!-- 汗滴 -->
  <path d="M40,60 L35,70" stroke="#89CFF0" stroke-width="2" fill="none"/>
  <circle cx="33" cy="73" r="3" fill="#89CFF0"/>
</svg>
</file>

<file path="public/assets/paper-texture.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="200px" height="200px" viewBox="0 0 200 200" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Paper Texture</title>
    <defs>
        <filter id="noise" x="0%" y="0%" width="100%" height="100%">
            <feTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" stitchTiles="stitch" result="noise"/>
            <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.05 0" in="noise" result="coloredNoise"/>
            <feComposite operator="in" in="coloredNoise" in2="SourceGraphic" result="monoNoise"/>
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <rect id="background" fill="#f8f0d8" x="0" y="0" width="200" height="200" filter="url(#noise)"></rect>
        
        <!-- Subtle lines -->
        <line x1="0" y1="20" x2="200" y2="20" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        <line x1="0" y1="60" x2="200" y2="60" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        <line x1="0" y1="100" x2="200" y2="100" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        <line x1="0" y1="140" x2="200" y2="140" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        <line x1="0" y1="180" x2="200" y2="180" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        
        <!-- Subtle spots -->
        <circle cx="30" cy="30" r="2" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="70" cy="90" r="1.5" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="150" cy="50" r="2" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="120" cy="120" r="1.5" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="40" cy="170" r="2" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="180" cy="140" r="1.5" fill="#d0c0a0" fill-opacity="0.1"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/coin.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Coin</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="coinGradient">
            <stop stop-color="#FFD700" offset="0%"></stop>
            <stop stop-color="#D4AF37" offset="100%"></stop>
        </linearGradient>
        <filter id="coinGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Coin base -->
        <circle cx="50" cy="50" r="40" fill="url(#coinGradient)" filter="url(#coinGlow)"></circle>
        
        <!-- Bamboo symbol -->
        <path d="M45,30 C45,30 40,35 40,40 C40,45 45,50 45,50 C45,50 50,45 50,40 C50,35 45,30 45,30 Z" fill="#1A5F4A" fill-opacity="0.8"></path>
        <path d="M55,30 C55,30 50,35 50,40 C50,45 55,50 55,50 C55,50 60,45 60,40 C60,35 55,30 55,30 Z" fill="#1A5F4A" fill-opacity="0.8"></path>
        <path d="M50,40 C50,40 45,45 45,50 C45,55 50,60 50,60 C50,60 55,55 55,50 C55,45 50,40 50,40 Z" fill="#1A5F4A" fill-opacity="0.8"></path>
        
        <!-- Coin edge -->
        <circle cx="50" cy="50" r="40" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7"></circle>
        
        <!-- Coin shine -->
        <path d="M30,40 Q40,30 50,35 Q60,40 70,35" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.8" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/rewards/decoration_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Decoration - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="decorationGradient">
            <stop stop-color="#A0D468" offset="0%"></stop>
            <stop stop-color="#88B04B" offset="100%"></stop>
        </linearGradient>
        <filter id="decorationGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#decorationGlow)"></circle>
        
        <!-- Bamboo hat -->
        <path d="M30,50 C30,35 50,25 70,50" stroke="url(#decorationGradient)" stroke-width="4" stroke-linecap="round"></path>
        <path d="M35,45 L65,45" stroke="url(#decorationGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M40,40 L60,40" stroke="url(#decorationGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M45,35 L55,35" stroke="url(#decorationGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Decorative strings -->
        <path d="M40,50 L40,65" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M60,50 L60,65" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#88B04B" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/experience.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Experience</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="experienceGradient">
            <stop stop-color="#88B04B" offset="0%"></stop>
            <stop stop-color="#1A5F4A" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <circle cx="50" cy="50" r="45" fill="url(#experienceGradient)" filter="url(#glow)"></circle>
        <path d="M50,20 L55,35 L70,35 L60,45 L65,60 L50,50 L35,60 L40,45 L30,35 L45,35 Z" fill="#FFFFFF" fill-opacity="0.9"></path>
        <circle cx="50" cy="50" r="45" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.5"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/food_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Food - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="bambooGradient">
            <stop stop-color="#A0D468" offset="0%"></stop>
            <stop stop-color="#88B04B" offset="100%"></stop>
        </linearGradient>
        <filter id="foodGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#foodGlow)"></circle>
        
        <!-- Bamboo shoots -->
        <path d="M30,30 L40,70 L50,30 L60,70 L70,30" stroke="url(#bambooGradient)" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"></path>
        
        <!-- Bamboo leaves -->
        <path d="M30,35 C20,30 25,20 35,25" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M50,35 C40,30 45,20 55,25" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M70,35 C60,30 65,20 75,25" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#88B04B" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/food_uncommon.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Food - Uncommon</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="bambooGradient">
            <stop stop-color="#4CAF50" offset="0%"></stop>
            <stop stop-color="#2E7D32" offset="100%"></stop>
        </linearGradient>
        <filter id="foodGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#foodGlow)"></circle>
        
        <!-- Bamboo shoots -->
        <path d="M30,30 L40,70 L50,30 L60,70 L70,30" stroke="url(#bambooGradient)" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"></path>
        
        <!-- Bamboo leaves -->
        <path d="M30,35 C20,30 25,20 35,25" stroke="#2E7D32" stroke-width="2" stroke-linecap="round"></path>
        <path d="M50,35 C40,30 45,20 55,25" stroke="#2E7D32" stroke-width="2" stroke-linecap="round"></path>
        <path d="M70,35 C60,30 65,20 75,25" stroke="#2E7D32" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Sparkles -->
        <circle cx="35" cy="40" r="2" fill="#FFFFFF"></circle>
        <circle cx="55" cy="35" r="2" fill="#FFFFFF"></circle>
        <circle cx="65" cy="45" r="2" fill="#FFFFFF"></circle>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#4CAF50" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/item_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Item - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="itemGradient">
            <stop stop-color="#FFC107" offset="0%"></stop>
            <stop stop-color="#FF9800" offset="100%"></stop>
        </linearGradient>
        <filter id="itemGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#itemGlow)"></circle>
        
        <!-- Item box -->
        <rect x="30" y="30" width="40" height="40" rx="5" fill="#FFFFFF" stroke="#FF9800" stroke-width="2"></rect>
        
        <!-- Box decoration -->
        <rect x="35" y="35" width="30" height="30" rx="3" fill="url(#itemGradient)" fill-opacity="0.3"></rect>
        
        <!-- Question mark -->
        <text x="50" y="60" font-family="Arial" font-size="30" fill="#FF9800" text-anchor="middle">?</text>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#FF9800" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/potion_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Potion - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="potionGradient">
            <stop stop-color="#42A5F5" offset="0%"></stop>
            <stop stop-color="#1976D2" offset="100%"></stop>
        </linearGradient>
        <filter id="potionGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#potionGlow)"></circle>
        
        <!-- Potion bottle -->
        <path d="M45,30 L55,30 L55,40 C60,45 65,55 60,65 C55,70 45,70 40,65 C35,55 40,45 45,40 L45,30 Z" fill="#FFFFFF" stroke="#1976D2" stroke-width="2"></path>
        
        <!-- Potion liquid -->
        <path d="M45,45 C40,50 35,60 40,65 C45,70 55,70 60,65 C65,60 60,50 55,45 L45,45 Z" fill="url(#potionGradient)"></path>
        
        <!-- Bottle cap -->
        <rect x="45" y="27" width="10" height="5" rx="2" fill="#1976D2"></rect>
        
        <!-- Bubbles -->
        <circle cx="45" cy="55" r="2" fill="#FFFFFF" fill-opacity="0.7"></circle>
        <circle cx="55" cy="60" r="1.5" fill="#FFFFFF" fill-opacity="0.7"></circle>
        <circle cx="50" cy="50" r="1" fill="#FFFFFF" fill-opacity="0.7"></circle>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#1976D2" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/scroll_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Scroll - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="scrollGradient">
            <stop stop-color="#D4AF37" offset="0%"></stop>
            <stop stop-color="#FFA000" offset="100%"></stop>
        </linearGradient>
        <filter id="scrollGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#scrollGlow)"></circle>
        
        <!-- Scroll -->
        <rect x="30" y="35" width="40" height="30" rx="2" fill="#F8F0D8"></rect>
        <path d="M30,35 C25,35 25,40 25,45 C25,50 25,55 30,55" stroke="#D4AF37" stroke-width="2" stroke-linecap="round"></path>
        <path d="M70,35 C75,35 75,40 75,45 C75,50 75,55 70,55" stroke="#D4AF37" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Scroll lines -->
        <path d="M35,42 L65,42" stroke="#D4AF37" stroke-width="1" stroke-opacity="0.5"></path>
        <path d="M35,47 L65,47" stroke="#D4AF37" stroke-width="1" stroke-opacity="0.5"></path>
        <path d="M35,52 L65,52" stroke="#D4AF37" stroke-width="1" stroke-opacity="0.5"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#D4AF37" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/toy_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Toy - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="toyGradient">
            <stop stop-color="#8CC152" offset="0%"></stop>
            <stop stop-color="#A0D468" offset="100%"></stop>
        </linearGradient>
        <filter id="toyGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#toyGlow)"></circle>
        
        <!-- Bamboo ball -->
        <circle cx="50" cy="50" r="25" fill="url(#toyGradient)"></circle>
        <circle cx="50" cy="50" r="25" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7"></circle>
        
        <!-- Decorative patterns -->
        <path d="M35,40 L65,40" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        <path d="M35,50 L65,50" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        <path d="M35,60 L65,60" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#8CC152" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/toy_uncommon.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Toy - Uncommon</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="toyGradient">
            <stop stop-color="#4CAF50" offset="0%"></stop>
            <stop stop-color="#2E7D32" offset="100%"></stop>
        </linearGradient>
        <filter id="toyGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#toyGlow)"></circle>
        
        <!-- Bamboo ball -->
        <circle cx="50" cy="50" r="25" fill="url(#toyGradient)"></circle>
        <circle cx="50" cy="50" r="25" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7"></circle>
        
        <!-- Decorative patterns -->
        <path d="M35,40 L65,40" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        <path d="M35,50 L65,50" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        <path d="M35,60 L65,60" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Sparkles -->
        <circle cx="35" cy="35" r="2" fill="#FFFFFF"></circle>
        <circle cx="65" cy="35" r="2" fill="#FFFFFF"></circle>
        <circle cx="65" cy="65" r="2" fill="#FFFFFF"></circle>
        <circle cx="35" cy="65" r="2" fill="#FFFFFF"></circle>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#4CAF50" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/scroll-edge.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="800px" height="30px" viewBox="0 0 800 30" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Scroll Edge</title>
    <defs>
        <linearGradient x1="0%" y1="50%" x2="100%" y2="50%" id="scrollGradient">
            <stop stop-color="#D4AF37" offset="0%"></stop>
            <stop stop-color="#FFA000" offset="50%"></stop>
            <stop stop-color="#D4AF37" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M0,0 L800,0 L800,5 C750,8 700,15 650,20 C600,25 550,28 500,29 C450,30 400,30 350,29 C300,28 250,25 200,20 C150,15 100,8 50,5 L0,5 L0,0 Z" fill="#f8f0d8"></path>
        <path d="M0,5 C50,8 100,15 150,20 C200,25 250,28 300,29 C350,30 400,30 450,29 C500,28 550,25 600,20 C650,15 700,8 750,5 L800,5 L800,30 L0,30 L0,5 Z" fill="#e8d8b8"></path>
        <path d="M0,5 C50,8 100,15 150,20 C200,25 250,28 300,29 C350,30 400,30 450,29 C500,28 550,25 600,20 C650,15 700,8 750,5" stroke="url(#scrollGradient)" stroke-width="1.5" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/sounds/README.md">
# 音效文件目录

此目录用于存放游戏中使用的各种音效文件。

## 奖励音效

以下是奖励系统使用的音效文件：

- `reward_common.mp3` - 普通奖励音效
- `reward_uncommon.mp3` - 不常见奖励音效
- `reward_rare.mp3` - 稀有奖励音效
- `reward_epic.mp3` - 史诗奖励音效
- `reward_legendary.mp3` - 传说奖励音效

## 任务相关音效

- `task_complete.mp3` - 普通任务完成音效
- `task_complete_high.mp3` - 高优先级任务完成音效
- `task_complete_main.mp3` - 主线任务完成音效
- `task_failed.mp3` - 任务失败音效
- `task_created.mp3` - 任务创建音效

## 挑战相关音效

- `challenge_complete.mp3` - 普通挑战完成音效
- `challenge_complete_epic.mp3` - 史诗挑战完成音效
- `challenge_complete_legendary.mp3` - 传说挑战完成音效
- `challenge_failed.mp3` - 挑战失败音效
- `challenge_unlocked.mp3` - 挑战解锁音效

## 系统音效

- `level_up.mp3` - 等级提升音效
- `ability_unlocked.mp3` - 能力解锁音效
- `ability_activated.mp3` - 能力激活音效
- `button_click.mp3` - 按钮点击音效
- `error.mp3` - 错误提示音效
- `success.mp3` - 成功提示音效
- `notification.mp3` - 通知提示音效

## 音效格式

- 推荐使用 MP3 格式，文件大小应尽量小（建议小于 100KB）
- 音效时长应简短（通常 1-3 秒）
- 音量应适中，避免过大或过小

## 使用方法

在代码中使用 `sound.ts` 工具类播放音效：

```typescript
import { playSound, SoundType } from '@/utils/sound';

// 播放奖励音效
playSound(SoundType.REWARD_LEGENDARY);

// 控制音量（0-1）
playSound(SoundType.BUTTON_CLICK, 0.3);
```

## 注意事项

1. 添加新音效后，需要在 `sound.ts` 中更新 `SoundType` 枚举和 `soundPaths` 映射
2. 音效文件命名应与 `soundPaths` 中的路径一致
3. 考虑为用户提供音效开关和音量控制选项
</file>

<file path="README.md">
好的，这是 Minimal Demo V3 Final 的独立完整代码。我已经将所有部分整合在一起，并确保了命名和结构的一致性。

**项目结构 (回顾):**

```
minimal-dexie-i18n-v3-final/
├── README.md
├── index.html
├── package.json
├── tsconfig.json
├── tsconfig.node.json
├── vite.config.ts
└── src/
    ├── App.tsx
    ├── main.tsx
    ├── index.css
    ├── vite-env.d.ts
    ├── types/
    │   └── index.ts
    ├── context/
    │   └── LanguageProvider.tsx
    ├── db.ts
    ├── services/
    │   └── index.ts
    │   └── localizedContentService.ts
    ├── hooks/
    │   └── useInternationalizedQuery.ts
    │   └── useLocalizedView.ts
    ├── components/
    │   ├── common/
    │   │   ├── Button.tsx
    │   │   ├── LoadingSpinner.tsx
    │   │   └── ErrorDisplay.tsx
    │   └── layout/
    │       ├── AppShell.tsx
    │       ├── Header.tsx
    │       └── Navigation.tsx
    ├── features/
    │   ├── home/
    │   │   ├── WelcomeSection.tsx
    │   │   └── MoodsSection.tsx
    │   └── settings/
    │       └── LanguageSettingsSection.tsx
    ├── pages/
    │   ├── HomePage.tsx
    │   └── SettingsPage.tsx
    └── router.tsx
```

---

**1. `README.md`**

```markdown
# Minimal Dexie I18n Demo (V3 - Finalized Structure)

This project demonstrates a type-safe, API-driven (simulated with Dexie.js) internationalization architecture for React applications, emphasizing clear naming, page-level content fetching, and component-based design for optimal team collaboration.

## Core Architecture & Data Flow:

1.  **Language Management (`LanguageProvider`):**
    *   Manages and persists the global `language` state (`en` | `zh`).
    *   Provides `language` and `setLanguage` via `useLanguage` hook.
    *   Does **not** handle translations directly.

2.  **Dexie.js as Mock Backend (`db.ts`):**
    *   Simulates an API data source using IndexedDB.
    *   The `uiLabels` store holds all translatable text records.
    *   `UILabelRecord` includes `scopeKey`, `labelKey`, `languageCode`, `translatedText`.
    *   **Scope Keys:** Organize labels hierarchically:
        *   `globalLayout`: For app shell (header, footer, nav).
        *   `[viewName]View`: For page-level titles and direct content (e.g., `homeView`, `settingsView`).
        *   `[viewName]View.[sectionName]`: For labels specific to a section within a view.

3.  **Services (`localizedContentService.ts`):**
    *   Functions like `fetchHomePageView`, `fetchSettingsPageView`, `fetchGlobalLayoutView`.
    *   Interact with Dexie to retrieve `labels` and `data` for a given `language` and `scopeKey`.
    *   Return a `Promise<LocalizedContent<TDataPayload, TLabelsBundle>>`.
    *   `buildLabelsObject` helper reconstructs nested label objects from flat Dexie records.

4.  **Custom Hook (`useLocalizedView.ts`):**
    *   Built on `useInternationalizedQuery` (generic React Query wrapper).
    *   Simplifies fetching localized content for a view.
    *   Takes a `viewQueryKey` (e.g., "homeViewContent") and the corresponding `fetchViewFn`.
    *   Automatically manages `language` in the React Query `queryKey`.
    *   Returns typed `{ labels, data, isPending, isError, ... }`.

5.  **Type Definitions (`types/index.ts`):**
    *   Centralized, clearly named types.
    *   `LocalizedContent<TData, TLabels>`: Standard service response.
    *   `[PageName]ViewLabelsBundle`, `[PageName]ViewDataPayload`: For view-specific content.
    *   `[FeatureName][SectionName]Labels`: For section-specific labels.

6.  **Page-Level Data Ownership & Props Delegation:**
    *   **Page/View Components (`src/pages/`):**
        *   Act as containers. Use `useLocalizedView` to fetch all content for their view.
    *   **Data Downflow:** Pages pass relevant slices of `labels` and `data` as props to child "Section" components (`src/features/`) and common components.
    *   **Presentational Children:** Section and common components receive all text and data via props.

7.  **Componentization:**
    *   **Layout (`AppShell`, `Header`, `Navigation`):** `AppShell` fetches `GlobalLayoutLabelsBundle`.
    *   **Features/Sections:** Encapsulate distinct UI parts.
    *   **Common:** Reusable, prop-driven components.

## Running the Demo:

1.  `npm install`
    *   Note: If `vite.config.ts` shows type errors for `path` or `__dirname`, you may need to install Node.js types: `npm install --save-dev @types/node`.
    *   The `package.json` includes necessary type definitions like `@types/react`, but ensure your TypeScript server has recognized them after installation. Sometimes a reload of your editor or TS server might be needed if "Cannot find module" errors persist initially for installed packages.
2.  `npm run dev`
3.  Open in browser (usually `http://localhost:5173`).

**Important Notes for Development:**

*   **`index.html`:** This project uses Vite, which requires an `index.html` file in the project root as the entry point.
*   **Dexie DB Population:** The `src/db.ts` includes a mechanism to populate the IndexedDB with sample data. In development, React's `StrictMode` might cause the population function to be called twice. The provided code has a safeguard to prevent duplicate data errors (`ConstraintError`) in this scenario. If you modify this, be mindful of potential re-entrancy.
*   **Favicon:** You might see a 404 error for `favicon.ico` in the browser console. This is harmless and can be resolved by adding a favicon to your project and linking it in `index.html`.
```

---

**2. `package.json`**

```json
{
  "name": "minimal-dexie-i18n-v3-final",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.32.0",
    "dexie": "^3.2.7",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.23.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@types/react-router-dom": "^5.3.3",
    "@typescript-eslint/eslint-plugin": "^7.2.0",
    "@typescript-eslint/parser": "^7.2.0",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "typescript": "^5.2.2",
    "vite": "^5.2.0"
  }
}
```

---

**3. `vite.config.ts`**

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})
```

---

**4. `tsconfig.json`**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src", "vite.config.ts"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

---

**5. `tsconfig.node.json`**

```json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts"]
}
```

---

**6. `src/vite-env.d.ts`**

```typescript
/// <reference types="vite/client" />
```

---

**7. `src/index.css`**

```css
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
    Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f0f2f5;
  color: #333;
  line-height: 1.6;
}

#root {
  max-width: 960px;
  margin: 20px auto;
  padding: 15px;
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

header {
  padding-bottom: 15px;
  border-bottom: 1px solid #e8e8e8;
  margin-bottom: 20px;
}

h1, h2, h3, h4 {
  color: #2c3e50;
  margin-top: 0;
}
h1 { font-size: 1.8em; }
h2 { font-size: 1.5em; margin-bottom: 0.8em; }
h3 { font-size: 1.3em; margin-bottom: 0.6em; color: #34495e; }
h4 { font-size: 1.1em; margin-bottom: 0.5em; color: #7f8c8d; }


nav {
  margin-bottom: 20px;
  display: flex;
  gap: 10px;
}

nav a {
  padding: 8px 15px;
  text-decoration: none;
  color: #3498db;
  border-radius: 4px;
  transition: background-color 0.2s, color 0.2s;
}

nav a:hover {
  background-color: #ecf0f1;
  color: #2980b9;
}

nav a.active {
  background-color: #3498db;
  color: white;
  font-weight: bold;
}

.page-content, section.page-content { /* Allow section to also use page-content style */
  background-color: #fff;
  padding: 15px;
  border-radius: 5px;
  margin-bottom: 20px;
  /* box-shadow: 0 1px 3px rgba(0,0,0,0.05); */
}
section + section { margin-top: 25px; }


hr {
  border: 0;
  height: 1px;
  background-color: #e8e8e8;
  margin: 25px 0;
}

footer {
  text-align: center;
  margin-top: 30px;
  padding-top: 15px;
  border-top: 1px solid #e8e8e8;
  font-size: 0.9em;
  color: #7f8c8d;
}

ul {
  list-style-type: disc;
  padding-left: 20px;
}
li { margin-bottom: 5px; }


/* Common Components */
.button-common {
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1em;
  font-weight: 500;
  transition: background-color 0.2s, opacity 0.2s;
  margin-right: 10px; /* Default spacing for buttons */
}
.button-common:last-child { margin-right: 0; }

.button-common:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.button-primary {
  background-color: #3498db;
  color: white;
}
.button-primary:hover:not(:disabled) {
  background-color: #2980b9;
}
.button-secondary {
  background-color: #95a5a6;
  color: white;
}
.button-secondary:hover:not(:disabled) {
  background-color: #7f8c8d;
}


select {
  padding: 10px;
  border-radius: 4px;
  border: 1px solid #bdc3c7;
  margin-right: 10px;
  font-size: 1em;
  background-color: white;
}

.loading-spinner-overlay {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  min-height: 100px;
}
.loading-spinner {
  border: 4px solid #ecf0f1; /* Light grey */
  border-top: 4px solid #3498db; /* Blue */
  border-radius: 50%;
  width: 30px;
  height: 30px;
  animation: spin 0.8s linear infinite;
}
.loading-spinner-text { margin-top: 10px; font-style: italic; color: #555; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.error-container {
  border: 1px solid #e74c3c; /* Red */
  padding: 15px;
  border-radius: 5px;
  background-color: #fdedec; /* Light red */
  margin-bottom: 15px;
}
.error-container h3 { color: #c0392b; margin-bottom: 8px;}
.error-text { color: #c0392b; }
.error-code-text { font-size: 0.85em; color: #7f8c8d; margin-top: 5px; }
```

---

**8. `src/types/index.ts`**

```typescript
// src/types/index.ts
export type Language = "en" | "zh";

export interface LanguageContextType {
  language: Language;
  setLanguage: (lang: Language) => void;
}

export interface ApiError extends Error { errorCode?: string; statusCode?: number; }

// Structure for Dexie uiLabels store
export interface UILabelRecord {
  id?: number;
  scopeKey: string; // e.g., "globalLayout", "homeView", "homeView.welcomeSection", "components.button"
  labelKey: string; // e.g., "appTitle", "welcomeMessage", "confirmText"
  languageCode: Language;
  translatedText: string;
}

// --- Generic Localized Content Structure (from services) ---
export interface LocalizedContent<TDataPayload, TLabelsBundle> {
  labels: TLabelsBundle;
  data: TDataPayload | null;
}

// --- Global / Layout Content Types ---
export interface GlobalLayoutLabelsBundle {
  appTitle: string;
  navHome: string;
  navSettings: string;
  footerText: string;
  loadingGeneric: string;
  errorGeneric: string;
}
export type FetchGlobalLayoutViewResult = LocalizedContent<null, GlobalLayoutLabelsBundle>;

// --- Home Page/View Specific Types ---
export interface HomeWelcomeSectionLabels {
  welcomeMessage: string;
}
export interface MoodItem { readonly id: number; readonly name: string; readonly feeling: string; }
export interface HomeMoodsSectionLabels {
  sectionTitle: string;
  noMoodsMessage: string;
  refreshButtonText: string;
}
export interface HomePageViewLabelsBundle {
  pageTitle: string;
  welcomeSection: HomeWelcomeSectionLabels;
  moodsSection: HomeMoodsSectionLabels;
  someActionText: string; // Example of a page-level label for a generic action
}
export interface HomePageViewDataPayload {
  username: string;
  moods: readonly MoodItem[];
}
export type FetchHomePageViewResult = LocalizedContent<HomePageViewDataPayload, HomePageViewLabelsBundle>;

// --- Settings Page/View Specific Types ---
export interface SettingsLanguageSectionLabels {
  sectionTitle: string;
  selectLanguagePrompt: string;
  currentLanguageIs: string;
  langNameEn: string;
  langNameZh: string;
  saveButtonText: string;
  successMessage: string;
}
export interface SettingsPageViewLabelsBundle {
  pageTitle: string;
  languageSection: SettingsLanguageSectionLabels;
}
export type FetchSettingsPageViewResult = LocalizedContent<null, SettingsPageViewLabelsBundle>;
```

---

**9. `src/context/LanguageProvider.tsx`**

```tsx
// src/context/LanguageProvider.tsx
import React, { createContext, useState, useContext, useEffect, ReactNode, useCallback } from "react";
import type { Language, LanguageContextType } from "@/types";

const DEFAULT_LANGUAGE: Language = "en";
const LOCAL_STORAGE_KEY = "app_lang_v3_final";

const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

export const LanguageProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [language, setLanguageState] = useState<Language>(() => {
    try {
      const saved = localStorage.getItem(LOCAL_STORAGE_KEY) as Language | null;
      return (saved === "en" || saved === "zh") ? saved : DEFAULT_LANGUAGE;
    } catch (e) { console.warn("localStorage access error for language", e); return DEFAULT_LANGUAGE; }
  });

  useEffect(() => {
    try {
      localStorage.setItem(LOCAL_STORAGE_KEY, language);
      document.documentElement.lang = language;
    } catch (e) { console.warn("localStorage write error for language", e); }
  }, [language]);

  const setLanguage = useCallback((lang: Language) => setLanguageState(lang), []);
  const value = { language, setLanguage };

  return <LanguageContext.Provider value={value}>{children}</LanguageContext.Provider>;
};

export const useLanguage = (): LanguageContextType => {
  const context = useContext(LanguageContext);
  if (!context) throw new Error("useLanguage must be used within LanguageProvider");
  return context;
};
```

---

**10. `src/db.ts`**

```typescript
// src/db.ts
import Dexie, { Table } from 'dexie';
import type { UILabelRecord } from '@/types';

export class AppDB extends Dexie {
  uiLabels!: Table<UILabelRecord, number>;
  constructor() {
    super('FinalMinimalI18nDB_V3'); // Unique DB name for this version
    this.version(1).stores({
      uiLabels: '++id, scopeKey, labelKey, languageCode, &[scopeKey+labelKey+languageCode]',
    });
  }
}
export const db = new AppDB();

export async function populateDB() {
  const count = await db.uiLabels.count();
  if (count > 0) { /* console.log("DB V3 already populated."); */ return; }
  console.log("Populating Final V3 Dexie DB...");

  const labels: UILabelRecord[] = [
    // GlobalLayout scope
    { scopeKey: 'globalLayout', labelKey: 'appTitle', languageCode: 'en', translatedText: 'App V3 - Consistent' },
    { scopeKey: 'globalLayout', labelKey: 'appTitle', languageCode: 'zh', translatedText: '应用 V3 - 一致性' },
    { scopeKey: 'globalLayout', labelKey: 'navHome', languageCode: 'en', translatedText: 'Home' },
    { scopeKey: 'globalLayout', labelKey: 'navHome', languageCode: 'zh', translatedText: '主页' },
    { scopeKey: 'globalLayout', labelKey: 'navSettings', languageCode: 'en', translatedText: 'Settings' },
    { scopeKey: 'globalLayout', labelKey: 'navSettings', languageCode: 'zh', translatedText: '设定' },
    { scopeKey: 'globalLayout', labelKey: 'footerText', languageCode: 'en', translatedText: '© 2024 Final Demo App' },
    { scopeKey: 'globalLayout', labelKey: 'footerText', languageCode: 'zh', translatedText: '© 2024 最终演示应用' },
    { scopeKey: 'globalLayout', labelKey: 'loadingGeneric', languageCode: 'en', translatedText: 'Loading, one moment...' },
    { scopeKey: 'globalLayout', labelKey: 'loadingGeneric', languageCode: 'zh', translatedText: '加载中，请稍候...' },
    { scopeKey: 'globalLayout', labelKey: 'errorGeneric', languageCode: 'en', translatedText: 'An unexpected error occurred.' },
    { scopeKey: 'globalLayout', labelKey: 'errorGeneric', languageCode: 'zh', translatedText: '发生了一个意外错误。' },

    // homeView scope
    { scopeKey: 'homeView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'My Dashboard' },
    { scopeKey: 'homeView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '我的仪表板' },
    { scopeKey: 'homeView.welcomeSection', labelKey: 'welcomeMessage', languageCode: 'en', translatedText: 'Greetings, {user}! Have a productive day.' },
    { scopeKey: 'homeView.welcomeSection', labelKey: 'welcomeMessage', languageCode: 'zh', translatedText: '你好 {user}，祝你拥有高效的一天！' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Recent Mood Entries' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: '近期心情记录' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'noMoodsMessage', languageCode: 'en', translatedText: 'No moods logged. Why not add one?' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'noMoodsMessage', languageCode: 'zh', translatedText: '暂无心情记录。要不要添加一条？' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'refreshButtonText', languageCode: 'en', translatedText: 'Refresh Moods' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'refreshButtonText', languageCode: 'zh', translatedText: '刷新心情' },
    { scopeKey: 'homeView', labelKey: 'someActionText', languageCode: 'en', translatedText: 'Perform Action' },
    { scopeKey: 'homeView', labelKey: 'someActionText', languageCode: 'zh', translatedText: '执行操作' },

    // settingsView scope
    { scopeKey: 'settingsView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Configuration Panel' },
    { scopeKey: 'settingsView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '配置面板' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Display Language' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: '显示语言' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'selectLanguagePrompt', languageCode: 'en', translatedText: 'Select your preferred language:' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'selectLanguagePrompt', languageCode: 'zh', translatedText: '请选择您的偏好语言：' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'currentLanguageIs', languageCode: 'en', translatedText: 'Currently using: {lang}' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'currentLanguageIs', languageCode: 'zh', translatedText: '当前使用：{lang}' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameEn', languageCode: 'en', translatedText: 'English (US)' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameEn', languageCode: 'zh', translatedText: '美式英语' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameZh', languageCode: 'en', translatedText: 'Chinese (Simplified)' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameZh', languageCode: 'zh', translatedText: '简体中文' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'saveButtonText', languageCode: 'en', translatedText: 'Save Preferences' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'saveButtonText', languageCode: 'zh', translatedText: '保存偏好' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'successMessage', languageCode: 'en', translatedText: 'Preferences have been updated!' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'successMessage', languageCode: 'zh', translatedText: '偏好设置已更新！' },
  ];
  await db.uiLabels.bulkAdd(labels);
  console.log("Final V3 DB populated.");
}
```

---

**11. `src/services/index.ts`**

```typescript
// src/services/index.ts
export * from './localizedContentService';
```

---

**12. `src/services/localizedContentService.ts`**

```typescript
// src/services/localizedContentService.ts
import { db } from '@/db';
import type {
  Language, LocalizedContent,
  HomePageViewLabelsBundle, HomePageViewDataPayload, MoodItem,
  SettingsPageViewLabelsBundle,
  GlobalLayoutLabelsBundle,
  UILabelRecord, ApiError,
  FetchHomePageViewResult, FetchSettingsPageViewResult, FetchGlobalLayoutViewResult
} from '@/types';

const SIMULATED_DELAY_MS = 150;

function buildLabelsObject<TLabelsBundle>(records: UILabelRecord[], baseScope: string): TLabelsBundle {
  const labels = {} as any;
  records.forEach(record => {
    let keyPath = record.labelKey;
    if (record.scopeKey.startsWith(baseScope + '.') && record.scopeKey.length > baseScope.length) {
        const sectionPath = record.scopeKey.substring(baseScope.length + 1);
        keyPath = `${sectionPath}.${record.labelKey}`;
    } else if (record.scopeKey !== baseScope) {
        // This label is not directly under baseScope or a direct sub-scope path, might be an issue or intended for a different structure.
        // For this demo, we'll assume labels fetched by getScopedLabels are correctly targeted.
        // console.warn(`Label with key ${record.labelKey} has scope ${record.scopeKey} which is not directly under or part of ${baseScope}`);
    }

    const keys = keyPath.split('.');
    let current = labels;
    keys.forEach((key, index) => {
      if (index === keys.length - 1) {
        current[key] = record.translatedText;
      } else {
        current[key] = current[key] || {};
        current = current[key];
      }
    });
  });
  return labels as TLabelsBundle;
}

async function getScopedLabels<TLabelsBundle>(baseScopeKey: string, lang: Language): Promise<TLabelsBundle> {
  let labelRecords = await db.uiLabels
    .where('languageCode').equals(lang)
    .and(record => record.scopeKey.startsWith(baseScopeKey))
    .toArray();

  if (!labelRecords.length && lang !== 'en') {
    console.warn(`No '${lang}' labels for scope ${baseScopeKey}, falling back to 'en'`);
    labelRecords = await db.uiLabels
      .where('languageCode').equals('en')
      .and(record => record.scopeKey.startsWith(baseScopeKey))
      .toArray();
  }

  if (!labelRecords.length) {
    const errorMessage = `CRITICAL: No labels found for essential scope ${baseScopeKey} (lang: ${lang} or fallback 'en').`;
    console.error(errorMessage);
    // In a real app, you might throw an error or have a more robust fallback
    return {} as TLabelsBundle;
  }
  return buildLabelsObject<TLabelsBundle>(labelRecords, baseScopeKey);
}

export async function fetchGlobalLayoutView(lang: Language): Promise<FetchGlobalLayoutViewResult> {
  console.log(`SVC_DEXIE: Fetching GLOBAL LAYOUT VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<GlobalLayoutLabelsBundle>('globalLayout', lang);
  return { labels, data: null };
}

export async function fetchHomePageView(lang: Language): Promise<FetchHomePageViewResult> {
  console.log(`SVC_DEXIE: Fetching HOME PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS));
  const labels = await getScopedLabels<HomePageViewLabelsBundle>('homeView', lang);

  const moods: MoodItem[] = [
    { id: 1, name: labels.moodsSection?.sectionTitle || (lang === 'zh' ? '心情' : 'Moods'), feeling: lang === 'zh' ? '专注的' : 'Focused' },
    { id: 2, name: lang === 'zh' ? '锻炼会议' : 'Workout Session', feeling: lang === 'zh' ? '精力充沛的' : 'Energized' },
  ];
  const data: HomePageViewDataPayload = { username: "DevUser", moods };
  return { labels, data };
}

export async function fetchSettingsPageView(lang: Language): Promise<FetchSettingsPageViewResult> {
  console.log(`SVC_DEXIE: Fetching SETTINGS PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<SettingsPageViewLabelsBundle>('settingsView', lang);
  return { labels, data: null };
}
```

---

**13. `src/hooks/useInternationalizedQuery.ts`**

```typescript
// src/hooks/useInternationalizedQuery.ts
import {
  useQuery,
  type UseQueryOptions,
  type QueryKey,
  type UseQueryResult,
} from '@tanstack/react-query';
import type { ApiError, LocalizedContent } from '@/types';

interface UseInternationalizedQueryResult<TDataPayload, TLabelsBundle, TErrorResponse> {
  data: TDataPayload | undefined | null; // Data can be TDataPayload OR null
  labels: TLabelsBundle | undefined;
  isPending: boolean;
  isLoading: boolean;
  isFetching: boolean;
  isError: boolean;
  error: TErrorResponse | null;
  refetch: UseQueryResult<LocalizedContent<TDataPayload, TLabelsBundle>, TErrorResponse>['refetch'];
  status: UseQueryResult<LocalizedContent<TDataPayload, TLabelsBundle>, TErrorResponse>['status'];
  isSuccess: boolean;
}

export function useInternationalizedQuery<
  TLocalizedContent extends LocalizedContent<TDataPayload, TLabelsBundle>,
  TErrorResponse extends Error = ApiError,
  TDataPayload = TLocalizedContent['data'],
  TLabelsBundle = TLocalizedContent['labels'],
  TQueryKey extends QueryKey = QueryKey
>(
  options: UseQueryOptions<TLocalizedContent, TErrorResponse, TLocalizedContent, TQueryKey>
): UseInternationalizedQueryResult<TDataPayload, TLabelsBundle, TErrorResponse> {
  const {
    data: queryResult,
    isPending,
    isLoading,
    isFetching,
    isError,
    error,
    refetch,
    status,
    isSuccess,
  } = useQuery<TLocalizedContent, TErrorResponse, TLocalizedContent, TQueryKey>(options);

  return {
    data: queryResult?.data, // queryResult can be undefined during initial fetch
    labels: queryResult?.labels,
    isPending,
    isLoading,
    isFetching,
    isError,
    error,
    refetch,
    status,
    isSuccess,
  };
}
```

---

**14. `src/hooks/useLocalizedView.ts`**

```typescript
// src/hooks/useLocalizedView.ts
import { useLanguage } from '@/context/LanguageProvider';
import { useInternationalizedQuery } from './useInternationalizedQuery';
import type { ApiError, Language, LocalizedContent } from '@/types';
import { QueryKey, UseQueryOptions } from '@tanstack/react-query';

export function useLocalizedView<
  TDataPayload,
  TLabelsBundle
>(
  viewQueryKey: QueryKey,
  fetchViewFn: (lang: Language) => Promise<LocalizedContent<TDataPayload, TLabelsBundle>>,
  options?: Omit<UseQueryOptions<LocalizedContent<TDataPayload, TLabelsBundle>, ApiError, LocalizedContent<TDataPayload, TLabelsBundle>, QueryKey>, 'queryKey' | 'queryFn'>
) {
  const { language } = useLanguage();
  const fullQueryKeyWithLang: QueryKey = Array.isArray(viewQueryKey)
    ? [...viewQueryKey, language]
    : [viewQueryKey, language];

  return useInternationalizedQuery<
    LocalizedContent<TDataPayload, TLabelsBundle>,
    ApiError,
    TDataPayload,
    TLabelsBundle
  >({
    queryKey: fullQueryKeyWithLang,
    queryFn: () => fetchViewFn(language),
    enabled: !!language && (options?.enabled === undefined || options.enabled),
    ...options,
  });
}
```

---

**15. `src/components/common/Button.tsx`**

```tsx
// src/components/common/Button.tsx
import React from 'react';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary';
  isLoading?: boolean;
  loadingText?: string;
}

const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'primary',
  isLoading = false,
  loadingText = "Loading...",
  ...props
}) => {
  const baseStyle = "button-common";
  const variantStyle = variant === 'primary' ? "button-primary" : "button-secondary";
  return (
    <button className={`${baseStyle} ${variantStyle}`} disabled={isLoading || props.disabled} {...props}>
      {isLoading ? loadingText : children}
    </button>
  );
};
export default Button;
```

---

**16. `src/components/common/LoadingSpinner.tsx`**

```tsx
// src/components/common/LoadingSpinner.tsx
import React from 'react';
// CSS for this will be in src/index.css

const LoadingSpinner: React.FC<{ text?: string }> = ({ text }) => {
  return (
    <div className="loading-spinner-overlay">
      <div className="loading-spinner"></div>
      {text && <p className="loading-spinner-text">{text}</p>}
    </div>
  );
};
export default LoadingSpinner;
```

---

**17. `src/components/common/ErrorDisplay.tsx`**

```tsx
// src/components/common/ErrorDisplay.tsx
import React from 'react';
import type { ApiError } from '@/types';
import Button from './Button'; // Use our common Button

interface ErrorDisplayProps {
  error: ApiError | Error | null;
  title?: string;
  messageTemplate?: string;
  onRetry?: () => void;
  retryButtonText?: string;
}

const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  title = "Error", // Fallback title
  messageTemplate = "Details: {message}",
  onRetry,
  retryButtonText = "Try Again",
}) => {
  if (!error) return null;

  const errorMessage = error.message || "An unknown error occurred.";
  const finalMessage = messageTemplate.replace('{message}', errorMessage);
  const errorCode = (error as ApiError)?.errorCode;
  const statusCode = (error as ApiError)?.statusCode;

  return (
    <div className="error-container" role="alert">
      <h3>{title}</h3>
      <p className="error-text">{finalMessage}</p>
      {errorCode && <p className="error-code-text">Error Code: {errorCode}</p>}
      {statusCode && <p className="error-code-text">Status Code: {statusCode}</p>}
      {onRetry && (
        <Button onClick={onRetry} variant="secondary" style={{ marginTop: '10px' }}>
          {retryButtonText}
        </Button>
      )}
    </div>
  );
};
export default ErrorDisplay;
```

---

**18. `src/components/layout/Header.tsx`**

```tsx
// src/components/layout/Header.tsx
import React from 'react';
import type { GlobalLayoutLabelsBundle } from '@/types';

interface HeaderProps {
  labels: GlobalLayoutLabelsBundle | undefined;
  isFetching?: boolean;
}

const Header: React.FC<HeaderProps> = ({ labels, isFetching }) => {
  // Provide a minimal fallback if labels are still undefined during initial render pass
  const title = labels?.appTitle || "App Loading...";

  return (
    <header style={{ opacity: isFetching ? 0.7 : 1 }}>
      <h1>
        {title}
        {isFetching && labels && <small style={{ marginLeft: '10px', fontStyle: 'italic', color: '#555' }}>(syncing layout...)</small>}
      </h1>
    </header>
  );
};
export default Header;
```

---

**19. `src/components/layout/Navigation.tsx`**

```tsx
// src/components/layout/Navigation.tsx
import React from 'react';
import { NavLink } from 'react-router-dom';
import type { GlobalLayoutLabelsBundle } from '@/types';

interface NavigationProps {
  labels: GlobalLayoutLabelsBundle | undefined;
}

const Navigation: React.FC<NavigationProps> = ({ labels }) => {
  // Provide fallbacks for label properties
  const navHomeText = labels?.navHome || "Home";
  const navSettingsText = labels?.navSettings || "Settings";

  if (!labels) { // Can show a minimal loading state or just render with fallbacks
    return <nav>Loading navigation...</nav>;
  }

  return (
    <nav>
      <NavLink to="/" className={({isActive}) => isActive ? 'active' : ''}>{navHomeText}</NavLink>
      <NavLink to="/settings" className={({isActive}) => isActive ? 'active' : ''}>{navSettingsText}</NavLink>
    </nav>
  );
};
export default Navigation;
```

---

**20. `src/components/layout/AppShell.tsx`**

```tsx
// src/components/layout/AppShell.tsx
import React, { ReactNode } from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchGlobalLayoutView } from '@/services';
import Header from './Header';
import Navigation from './Navigation';
import LoadingSpinner from '../common/LoadingSpinner';
import ErrorDisplay from '../common/ErrorDisplay';
import type { GlobalLayoutLabelsBundle, ApiError } from '@/types';

interface AppShellProps { children: ReactNode; }

const AppShell: React.FC<AppShellProps> = ({ children }) => {
  const {
    labels: globalLabels, isPending, isError, error, isFetching, refetch
  } = useLocalizedView<null, GlobalLayoutLabelsBundle>(
    'globalLayoutViewContent', // Unique query key for this "view"
    fetchGlobalLayoutView
  );

  if (isPending && !globalLabels) {
    // Use a very generic loading text if global labels themselves are not available
    return <LoadingSpinner text={globalLabels?.loadingGeneric || "Initializing Application..."} />;
  }

  if (isError || !globalLabels) { // Critical error if global labels fail
    return (
      <div style={{ padding: '20px' }}>
        <ErrorDisplay
          error={error} // Error from the hook
          title={globalLabels?.appErrorHeading || "Application Shell Error"}
          messageTemplate={globalLabels?.appErrorGeneralMessage || "Core UI failed. Details: {message}"}
          onRetry={refetch}
          retryButtonText="Retry Loading Shell"
        />
      </div>
    );
  }

  return (
    <div className="app-shell">
      <Header labels={globalLabels} isFetching={isFetching && !!globalLabels}/> {/* Pass fetching only if labels are loaded */}
      <Navigation labels={globalLabels} />
      <hr />
      <main>{children}</main>
      <hr />
      <footer style={{ textAlign: 'center', marginTop: '20px', fontSize: '0.9em', color: '#7f8c8d' }}>
        <p>{globalLabels.footerText || "App Footer"}</p>
      </footer>
    </div>
  );
};
export default AppShell;
```

---

**21. `src/features/home/WelcomeSection.tsx`**

```tsx
// src/features/home/WelcomeSection.tsx
import React from 'react';
import type { HomeWelcomeSectionLabels } from '@/types';

interface WelcomeSectionProps {
  labels: HomeWelcomeSectionLabels | undefined;
  username: string | undefined;
}

const WelcomeSection: React.FC<WelcomeSectionProps> = ({ labels, username }) => {
  if (!labels || username === undefined) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Initializing welcome message...</p>;
  }
  const welcomeText = labels.welcomeMessage.replace('{user}', username);
  return <p>{welcomeText}</p>;
};
export default WelcomeSection;
```

---

**22. `src/features/home/MoodsSection.tsx`**

```tsx
// src/features/home/MoodsSection.tsx
import React from 'react';
import type { HomeMoodsSectionLabels, MoodItem } from '@/types';
import Button from '@/components/common/Button';

interface MoodsSectionProps {
  labels: HomeMoodsSectionLabels | undefined;
  moods: readonly MoodItem[] | undefined; // Made readonly in type
  onRefresh: () => void;
  isFetching?: boolean;
}

const MoodsSection: React.FC<MoodsSectionProps> = ({ labels, moods, onRefresh, isFetching }) => {
  if (!labels) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Loading moods section...</p>;
  }

  return (
    <section className="page-content" style={{marginTop: '20px'}}> {/* Use class for styling */}
      <h4>{labels.sectionTitle}</h4> {/* Use h4 for sections within a page normally */}
      {moods && moods.length > 0 ? (
        <ul>
          {moods.map(mood => (
            <li key={mood.id}>{mood.name}: <strong>{mood.feeling}</strong></li>
          ))}
        </ul>
      ) : (
        <p>{labels.noMoodsMessage}</p>
      )}
      <Button onClick={onRefresh} isLoading={isFetching} loadingText="Refreshing...">
        {labels.refreshButtonText}
      </Button>
    </section>
  );
};
export default MoodsSection;
```

---

**23. `src/features/settings/LanguageSettingsSection.tsx`**

```tsx
// src/features/settings/LanguageSettingsSection.tsx
import React, { useState, useEffect } from 'react';
import { useLanguage } from '@/context/LanguageProvider';
import type { Language, SettingsLanguageSectionLabels } from '@/types';
import Button from '@/components/common/Button';

interface LanguageSettingsSectionProps {
  labels: SettingsLanguageSectionLabels | undefined;
  isUpdatingPage?: boolean; // Indicates if the parent page is fetching new labels
}

const LanguageSettingsSection: React.FC<LanguageSettingsSectionProps> = ({ labels, isUpdatingPage }) => {
  const { language, setLanguage } = useLanguage();
  const [selectedLocalLang, setSelectedLocalLang] = useState<Language>(language);
  const [showSuccess, setShowSuccess] = useState(false);

  useEffect(() => {
    setSelectedLocalLang(language); // Sync with global changes
    if (showSuccess) setShowSuccess(false); // Hide success if global lang changes elsewhere
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [language]); // Only re-sync local if global language changes

  if (!labels) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Loading language settings...</p>;
  }

  const handleSave = () => {
    if (selectedLocalLang !== language) {
      setLanguage(selectedLocalLang); // This will trigger page label refetch
      setShowSuccess(true);
      setTimeout(() => setShowSuccess(false), 2500);
    }
  };

  const currentLangDisplay = labels.currentLanguageIs.replace('{lang}', language.toUpperCase());

  return (
    <section> {/* Sections could also use page-content class if desired */}
      <h4>{labels.sectionTitle}</h4>
      <p>{currentLangDisplay}</p>
      <div>
        <label htmlFor="lang-select-component" style={{ marginRight: '8px' }}>{labels.selectLanguagePrompt}</label>
        <select
          id="lang-select-component"
          value={selectedLocalLang}
          onChange={e => {
            setSelectedLocalLang(e.target.value as Language);
            if (showSuccess) setShowSuccess(false);
          }}
          disabled={isUpdatingPage}
        >
          <option value="en">{labels.langNameEn}</option>
          <option value="zh">{labels.langNameZh}</option>
        </select>
      </div>
      <Button
        onClick={handleSave}
        disabled={isUpdatingPage || selectedLocalLang === language}
        style={{marginTop: '15px'}}
        variant="primary"
      >
        {labels.saveButtonText}
      </Button>
      {showSuccess && <p style={{ color: 'green', marginTop: '10px', fontStyle:'italic' }}>{labels.successMessage}</p>}
    </section>
  );
};
export default LanguageSettingsSection;
```

---

**24. `src/pages/HomePage.tsx`**

```tsx
// src/pages/HomePage.tsx
import React from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchHomePageView } from '@/services';
import WelcomeSection from '@/features/home/WelcomeSection';
import MoodsSection from '@/features/home/MoodsSection';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import Button from '@/components/common/Button'; // Example of using common button
import type { HomePageViewDataPayload, HomePageViewLabelsBundle, ApiError } from '@/types';

const HomePage: React.FC = () => {
  const {
    data: pageData, labels: pageLabels, isPending, isError, error, refetch, isFetching
  } = useLocalizedView<HomePageViewDataPayload, HomePageViewLabelsBundle>(
    'homePageViewContent',
    fetchHomePageView
  );

  if (isPending && !pageLabels) { // Full page initial load
    return <LoadingSpinner text="Loading Home Page Content..." />;
  }

  if (isError && !pageLabels) { // Critical: Page labels failed
    return (
      <div className="page-content">
        <ErrorDisplay error={error} title="Home Page Error" onRetry={refetch} />
      </div>
    );
  }

  // If labels are partially/fully loaded, but an error occurred or still pending data
  // We can render the page shell with what we have.
  const isLoadingData = isPending || (isFetching && !pageData); // True if data is still being fetched/refetched

  return (
    <div className="page-container"> {/* Optional container for page styling */}
      <h2>{pageLabels?.pageTitle || "Dashboard"}</h2>

      <WelcomeSection labels={pageLabels?.welcomeSection} username={pageData?.username} />

      <MoodsSection
        labels={pageLabels?.moodsSection}
        moods={pageData?.moods}
        onRefresh={refetch}
        isFetching={isFetching}
      />

      {/* Example of a page-level button using a page-level label */}
      {pageLabels?.someActionText && (
        <Button onClick={() => alert('Action Confirmed!')} style={{marginTop: '20px'}}>
          {pageLabels.someActionText}
        </Button>
      )}

      {/* Show specific data error if labels loaded but data part failed */}
      {isError && pageData === undefined && pageLabels && (
         <ErrorDisplay
            error={error}
            title={pageLabels.moodsSection?.sectionTitle || "Data Fetch Error"}
            messageTemplate="Could not load mood data. Details: {message}"
            onRetry={refetch}
         />
       )}
       {isLoadingData && pageLabels && ( // Show spinner for data if labels are present
           <LoadingSpinner text="Fetching latest data..." />
       )}
    </div>
  );
};
export default HomePage;
```

---

**25. `src/pages/SettingsPage.tsx`**

```tsx
// src/pages/SettingsPage.tsx
import React from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchSettingsPageView } from '@/services';
import LanguageSettingsSection from '@/features/settings/LanguageSettingsSection';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import type { SettingsPageViewLabelsBundle, ApiError } from '@/types';

const SettingsPage: React.FC = () => {
  const {
    labels: pageLabels, isPending, isError, error, refetch, isFetching
  } = useLocalizedView<null, SettingsPageViewLabelsBundle>(
    'settingsPageViewContent',
    fetchSettingsPageView
  );

  if (isPending && !pageLabels) { // Full page initial load
    return <LoadingSpinner text="Loading Settings Page Content..." />;
  }

  if (isError || !pageLabels) { // Critical: Page labels failed
     return (
      <div className="page-content">
        <ErrorDisplay
          error={error}
          title={pageLabels?.pageTitle || "Settings Load Error"}
          messageTemplate="Could not load settings. Details: {message}"
          onRetry={refetch}
        />
      </div>
    );
  }

  return (
    <div className="page-content"> {/* Using class for consistent page styling */}
      <h2>{pageLabels.pageTitle || "Settings"}</h2>
      <LanguageSettingsSection
        labels={pageLabels.languageSection}
        isUpdatingPage={isFetching && !!pageLabels} // Page is fetching if labels are present but still fetching
      />
      {/* Other settings sections would be added here */}
    </div>
  );
};
export default SettingsPage;
```

---

**26. `src/router.tsx`**

```tsx
// src/router.tsx
import React, { Suspense, lazy } from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// Lazy load page components
const HomePage = lazy(() => import('@/pages/HomePage'));
const SettingsPage = lazy(() => import('@/pages/SettingsPage'));

const AppRouter: React.FC = () => {
  return (
    <Suspense fallback={<LoadingSpinner text="Loading view..." />}>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/settings" element={<SettingsPage />} />
        <Route path="*" element={<Navigate to="/" replace />} /> {/* Fallback route */}
      </Routes>
    </Suspense>
  );
};
export default AppRouter;
```

---

**27. `src/App.tsx`**

```tsx
// src/App.tsx
import React, { useEffect } from 'react';
import { BrowserRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
// import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { LanguageProvider } from '@/context/LanguageProvider';
import { populateDB } from '@/db';
import AppShell from '@/components/layout/AppShell';
import AppRouter from '@/router';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 2, // 2 minutes
      refetchOnWindowFocus: false, // Personal preference for demos
      retry: 1, // Retry failed queries once
    },
  },
});

const App: React.FC = () => {
  useEffect(() => {
    // Populate Dexie DB on app start for development
    if (import.meta.env.DEV) { // Vite specific dev check
      populateDB().catch(err => {
        console.error("Failed to populate Dexie DB:", err);
      });
    }
  }, []);

  return (
    <QueryClientProvider client={queryClient}>
      <LanguageProvider>
        <BrowserRouter>
          <AppShell> {/* AppShell fetches global layout labels and provides overall structure */}
            <AppRouter /> {/* AppRouter handles page-specific content and routing */}
          </AppShell>
        </BrowserRouter>
      </LanguageProvider>
      {/* <ReactQueryDevtools initialIsOpen={false} /> */}
    </QueryClientProvider>
  );
};
export default App;
```

---

**28. `src/main.tsx`**

```tsx
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';
import './index.css'; // Global styles

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
```

---

This V3 Final version provides a clean, well-structured, and type-safe foundation. The README clearly outlines the architecture, making it suitable for team collaboration. Key improvements include refined naming, a dedicated `useLocalizedView` hook, and clearer separation of concerns with page components fetching all necessary content and delegating rendering to feature-specific sections.
</file>

<file path="src/components/animation/AnimatedButton.tsx">
// src/components/animation/AnimatedButton.tsx
import React from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import Button from '@/components/common/Button';

interface AnimatedButtonProps extends HTMLMotionProps<'button'> {
  variant?: 'primary' | 'secondary' | 'jade' | 'gold';
  isLoading?: boolean;
  loadingText?: string;
  children: React.ReactNode;
  whileHover?: object;
  whileTap?: object;
  className?: string;
  onClick?: () => void;
}

/**
 * 动画按钮组件，为Button组件添加动画效果
 * 
 * @param variant - 按钮变体
 * @param isLoading - 是否显示加载状态
 * @param loadingText - 加载状态文本
 * @param children - 子元素
 * @param whileHover - 悬停动画
 * @param whileTap - 点击动画
 * @param className - CSS类名
 * @param onClick - 点击事件处理函数
 */
const AnimatedButton: React.FC<AnimatedButtonProps> = ({
  variant = 'primary',
  isLoading = false,
  loadingText,
  children,
  whileHover = { scale: 1.05 },
  whileTap = { scale: 0.95 },
  className = '',
  onClick,
  ...props
}) => {
  // 根据变体设置不同的动画效果
  const getAnimationProps = () => {
    switch (variant) {
      case 'jade':
        return {
          whileHover: { 
            scale: 1.05, 
            boxShadow: '0 0 15px rgba(136, 176, 75, 0.5)' 
          },
          whileTap: { 
            scale: 0.95 
          }
        };
      case 'gold':
        return {
          whileHover: { 
            scale: 1.05, 
            boxShadow: '0 0 15px rgba(212, 175, 55, 0.5)' 
          },
          whileTap: { 
            scale: 0.95 
          }
        };
      default:
        return {
          whileHover,
          whileTap
        };
    }
  };

  const animationProps = getAnimationProps();

  return (
    <motion.div
      className={`animated-button-container ${className}`}
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: 10 }}
      {...animationProps}
      {...props}
    >
      <Button
        variant={variant}
        isLoading={isLoading}
        loadingText={loadingText}
        onClick={onClick}
        style={{ width: '100%', height: '100%' }}
      >
        {children}
      </Button>
    </motion.div>
  );
};

export default AnimatedButton;
</file>

<file path="src/components/animation/AnimatedContainer.tsx">
// src/components/animation/AnimatedContainer.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { createContainerVariants } from '@/utils/animation';

interface AnimatedContainerProps extends HTMLMotionProps<'div'> {
  children: ReactNode;
  variants?: Variants;
  staggerChildren?: number;
  delayChildren?: number;
  className?: string;
  initial?: string | object;
  animate?: string | object;
  exit?: string | object;
}

/**
 * 动画容器组件，用于为子元素添加交错动画效果
 * 
 * @param children - 子元素
 * @param variants - 动画变体
 * @param staggerChildren - 子元素之间的延迟时间
 * @param delayChildren - 所有子元素的初始延迟
 * @param className - CSS类名
 * @param initial - 初始动画状态
 * @param animate - 动画状态
 * @param exit - 退出动画状态
 */
const AnimatedContainer: React.FC<AnimatedContainerProps> = ({
  children,
  variants,
  staggerChildren = 0.1,
  delayChildren = 0,
  className = '',
  initial = 'hidden',
  animate = 'visible',
  exit = 'exit',
  ...props
}) => {
  // 如果没有提供变体，则使用默认的容器变体
  const containerVariants = variants || createContainerVariants(staggerChildren, delayChildren);

  return (
    <motion.div
      className={className}
      variants={containerVariants}
      initial={initial}
      animate={animate}
      exit={exit}
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default AnimatedContainer;
</file>

<file path="src/components/animation/AnimatedItem.tsx">
// src/components/animation/AnimatedItem.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { listItem } from '@/utils/animation';

interface AnimatedItemProps extends HTMLMotionProps<'div'> {
  children: ReactNode;
  variants?: Variants;
  index?: number;
  className?: string;
  initial?: string | object;
  animate?: string | object;
  exit?: string | object;
}

/**
 * 动画项组件，用于为列表项添加动画效果
 * 
 * @param children - 子元素
 * @param variants - 动画变体
 * @param index - 项目索引，用于计算延迟
 * @param className - CSS类名
 * @param initial - 初始动画状态
 * @param animate - 动画状态
 * @param exit - 退出动画状态
 */
const AnimatedItem: React.FC<AnimatedItemProps> = ({
  children,
  variants = listItem,
  index = 0,
  className = '',
  initial = 'hidden',
  animate = 'visible',
  exit = 'exit',
  ...props
}) => {
  return (
    <motion.div
      className={className}
      variants={variants}
      initial={initial}
      animate={animate}
      exit={exit}
      custom={index}
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default AnimatedItem;
</file>

<file path="src/components/animation/ChallengeCompletionAnimation.tsx">
// src/components/animation/ChallengeCompletionAnimation.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { playChallengeCompletionSound } from '@/utils/sound';

interface ChallengeCompletionAnimationProps {
  challengeTitle: string;
  challengeDescription?: string;
  onAnimationComplete?: () => void;
  style?: 'default' | 'epic' | 'legendary';
  playSound?: boolean;
  soundVolume?: number;
}

/**
 * 挑战完成动画组件
 * 在挑战完成时显示动画效果
 */
const ChallengeCompletionAnimation: React.FC<ChallengeCompletionAnimationProps> = ({
  challengeTitle,
  challengeDescription,
  onAnimationComplete,
  style = 'default',
  playSound = true,
  soundVolume = 0.5
}) => {
  const [isAnimating, setIsAnimating] = useState(true);
  const [particles, setParticles] = useState<React.ReactNode[]>([]);

  // 播放音效
  useEffect(() => {
    if (playSound) {
      // 根据动画样式确定挑战难度
      const difficulty = style === 'legendary' ? 'legendary' :
                         style === 'epic' ? 'epic' : 'normal';
      playChallengeCompletionSound(difficulty, soundVolume);
    }
  }, [playSound, style, soundVolume]);

  // 生成粒子效果
  useEffect(() => {
    const particleCount = style === 'legendary' ? 100 : style === 'epic' ? 70 : 40;
    const newParticles = [];

    for (let i = 0; i < particleCount; i++) {
      newParticles.push(generateParticle(i, style));
    }

    setParticles(newParticles);
  }, [style]);

  // 生成单个粒子
  const generateParticle = (index: number, style: string) => {
    // 传说级挑战完成动画
    if (style === 'legendary') {
      // 彩虹色粒子
      const colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];

      // 随机选择粒子类型
      const particleType = Math.random() > 0.7 ? 'star' : Math.random() > 0.5 ? 'circle' : 'square';

      if (particleType === 'star') {
        const size = Math.random() * 20 + 10;
        const angle = Math.random() * 360;
        const distance = Math.random() * 150 + 100;
        const delay = Math.random() * 1;
        const duration = Math.random() * 2 + 2;

        return (
          <motion.div
            key={`star-${index}`}
            style={{
              position: 'absolute',
              width: size,
              height: size,
              top: '50%',
              left: '50%',
              margin: `-${size / 2}px 0 0 -${size / 2}px`,
              clipPath: 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
              backgroundColor: randomColor,
              boxShadow: `0 0 10px ${randomColor}`,
              zIndex: 10
            }}
            initial={{
              x: 0,
              y: 0,
              opacity: 0,
              rotate: 0,
              scale: 0
            }}
            animate={{
              x: Math.cos(angle * Math.PI / 180) * distance,
              y: Math.sin(angle * Math.PI / 180) * distance,
              opacity: [0, 1, 1, 0.8, 0],
              rotate: 360,
              scale: [0, 1.5, 1, 1.2, 0]
            }}
            transition={{
              duration: duration,
              delay: delay,
              ease: 'easeInOut',
              times: [0, 0.2, 0.4, 0.8, 1]
            }}
          />
        );
      } else if (particleType === 'circle') {
        const size = Math.random() * 15 + 5;
        const angle = Math.random() * 360;
        const distance = Math.random() * 200 + 50;
        const delay = Math.random() * 0.8;
        const duration = Math.random() * 2 + 1.5;

        return (
          <motion.div
            key={`circle-${index}`}
            style={{
              position: 'absolute',
              width: size,
              height: size,
              borderRadius: '50%',
              backgroundColor: randomColor,
              boxShadow: `0 0 10px ${randomColor}`,
              top: '50%',
              left: '50%',
              margin: `-${size / 2}px 0 0 -${size / 2}px`,
              zIndex: 10
            }}
            initial={{
              x: 0,
              y: 0,
              opacity: 0,
              scale: 0.5
            }}
            animate={{
              x: Math.cos(angle * Math.PI / 180) * distance,
              y: Math.sin(angle * Math.PI / 180) * distance,
              opacity: [0, 1, 0.8, 0],
              scale: [0.5, 1.5, 1, 0]
            }}
            transition={{
              duration: duration,
              delay: delay,
              ease: 'easeOut',
              times: [0, 0.3, 0.7, 1]
            }}
          />
        );
      } else {
        const size = Math.random() * 12 + 8;
        const angle = Math.random() * 360;
        const distance = Math.random() * 180 + 80;
        const delay = Math.random() * 0.5;
        const duration = Math.random() * 1.5 + 1;
        const rotation = Math.random() * 720 - 360;

        return (
          <motion.div
            key={`square-${index}`}
            style={{
              position: 'absolute',
              width: size,
              height: size,
              backgroundColor: randomColor,
              boxShadow: `0 0 8px ${randomColor}`,
              top: '50%',
              left: '50%',
              margin: `-${size / 2}px 0 0 -${size / 2}px`,
              zIndex: 10
            }}
            initial={{
              x: 0,
              y: 0,
              opacity: 0,
              rotate: 0,
              scale: 0.5
            }}
            animate={{
              x: Math.cos(angle * Math.PI / 180) * distance,
              y: Math.sin(angle * Math.PI / 180) * distance,
              opacity: [0, 1, 0.7, 0],
              rotate: rotation,
              scale: [0.5, 1.2, 0.8, 0]
            }}
            transition={{
              duration: duration,
              delay: delay,
              ease: 'easeOut',
              times: [0, 0.3, 0.7, 1]
            }}
          />
        );
      }
    }
    // 史诗级挑战完成动画
    else if (style === 'epic') {
      const colors = ['#a335ee', '#9370DB', '#8A2BE2', '#9932CC', '#BA55D3'];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];

      const size = Math.random() * 15 + 5;
      const angle = Math.random() * 360;
      const distance = Math.random() * 150 + 50;
      const delay = Math.random() * 0.5;
      const duration = Math.random() * 1.5 + 1;

      return (
        <motion.div
          key={`epic-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            borderRadius: Math.random() > 0.5 ? '50%' : '0%',
            backgroundColor: randomColor,
            boxShadow: `0 0 8px ${randomColor}`,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0,
            rotate: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0],
            rotate: Math.random() > 0.5 ? 360 : 0
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    }
    // 默认挑战完成动画
    else {
      const colors = ['#FFD700', '#FFA500', '#FF8C00', '#FF7F50', '#FF6347'];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];

      const size = Math.random() * 10 + 5;
      const angle = Math.random() * 360;
      const distance = Math.random() * 100 + 50;
      const delay = Math.random() * 0.3;
      const duration = Math.random() * 1 + 0.8;

      return (
        <motion.div
          key={`default-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            borderRadius: '50%',
            backgroundColor: randomColor,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    }
  };

  // 处理动画完成
  const handleAnimationComplete = () => {
    setIsAnimating(false);
    if (onAnimationComplete) {
      onAnimationComplete();
    }
  };

  return (
    <AnimatePresence>
      {isAnimating && (
        <motion.div
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            zIndex: 1000,
            pointerEvents: 'none'
          }}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.3 }}
        >
          {/* 粒子效果 */}
          {particles}

          {/* 中心文本 */}
          <motion.div
            style={{
              backgroundColor: style === 'legendary' ? 'rgba(0, 0, 0, 0.8)' :
                              style === 'epic' ? 'rgba(50, 0, 80, 0.8)' :
                              'rgba(50, 30, 0, 0.8)',
              color: '#fff',
              padding: '30px 50px',
              borderRadius: '15px',
              textAlign: 'center',
              zIndex: 20,
              border: style === 'legendary' ? '3px solid gold' :
                      style === 'epic' ? '2px solid #a335ee' :
                      '1px solid #FFA500',
              boxShadow: style === 'legendary' ? '0 0 20px gold' :
                         style === 'epic' ? '0 0 15px #a335ee' :
                         '0 0 10px #FFA500'
            }}
            initial={{ scale: 0, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0, opacity: 0 }}
            transition={{ duration: 0.5, delay: 0.2 }}
            onAnimationComplete={handleAnimationComplete}
          >
            <motion.h2
              style={{
                fontSize: '2rem',
                marginBottom: '1rem',
                color: style === 'legendary' ? 'gold' :
                       style === 'epic' ? '#a335ee' :
                       '#FFA500'
              }}
              initial={{ y: -20, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ duration: 0.3, delay: 0.3 }}
            >
              挑战完成！
            </motion.h2>
            <motion.h3
              initial={{ y: -10, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ duration: 0.3, delay: 0.5 }}
            >
              {challengeTitle}
            </motion.h3>
            {challengeDescription && (
              <motion.p
                initial={{ y: 20, opacity: 0 }}
                animate={{ y: 0, opacity: 1 }}
                transition={{ duration: 0.3, delay: 0.7 }}
              >
                {challengeDescription}
              </motion.p>
            )}
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default ChallengeCompletionAnimation;
</file>

<file path="src/components/animation/GoldenGlow.tsx">
// src/components/animation/GoldenGlow.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { goldenGlow } from '@/utils/animation';

interface GoldenGlowProps extends HTMLMotionProps<'div'> {
  children: ReactNode;
  variants?: Variants;
  className?: string;
  intensity?: 'low' | 'medium' | 'high';
  onClick?: () => void;
}

/**
 * 金光效果动画组件，用于创建中国风金光动画效果
 * 
 * @param children - 子元素
 * @param variants - 动画变体
 * @param className - CSS类名
 * @param intensity - 强度
 * @param onClick - 点击事件处理函数
 */
const GoldenGlow: React.FC<GoldenGlowProps> = ({
  children,
  variants = goldenGlow,
  className = '',
  intensity = 'medium',
  onClick,
  ...props
}) => {
  // 根据强度设置样式
  const intensityStyles = {
    low: { 
      boxShadow: '0 0 10px 2px rgba(212, 175, 55, 0.3)',
      filter: 'brightness(1.1) saturate(1.1)'
    },
    medium: { 
      boxShadow: '0 0 15px 5px rgba(212, 175, 55, 0.5)',
      filter: 'brightness(1.2) saturate(1.2)'
    },
    high: { 
      boxShadow: '0 0 20px 10px rgba(212, 175, 55, 0.7)',
      filter: 'brightness(1.3) saturate(1.3)'
    }
  };

  return (
    <motion.div
      className={`golden-glow ${className}`}
      variants={variants}
      initial="hidden"
      animate="visible"
      exit="exit"
      style={{
        position: 'relative',
        ...intensityStyles[intensity],
        ...props.style
      }}
      onClick={onClick}
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default GoldenGlow;
</file>

<file path="src/components/animation/InkSplash.tsx">
// src/components/animation/InkSplash.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { inkSplash } from '@/utils/animation';

interface InkSplashProps extends HTMLMotionProps<'div'> {
  children?: ReactNode;
  variants?: Variants;
  className?: string;
  size?: 'small' | 'medium' | 'large';
  color?: string;
  onClick?: () => void;
}

/**
 * 水墨效果动画组件，用于创建中国风水墨动画效果
 * 
 * @param children - 子元素
 * @param variants - 动画变体
 * @param className - CSS类名
 * @param size - 大小
 * @param color - 颜色
 * @param onClick - 点击事件处理函数
 */
const InkSplash: React.FC<InkSplashProps> = ({
  children,
  variants = inkSplash,
  className = '',
  size = 'medium',
  color = 'var(--royal-jade)',
  onClick,
  ...props
}) => {
  // 根据大小设置样式
  const sizeStyles = {
    small: { width: '50px', height: '50px' },
    medium: { width: '100px', height: '100px' },
    large: { width: '150px', height: '150px' }
  };

  return (
    <motion.div
      className={`ink-splash ${className}`}
      variants={variants}
      initial="hidden"
      animate="visible"
      exit="exit"
      style={{
        ...sizeStyles[size],
        backgroundColor: color,
        borderRadius: '50%',
        filter: 'blur(5px)',
        position: 'relative',
        overflow: 'hidden',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        ...props.style
      }}
      onClick={onClick}
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default InkSplash;
</file>

<file path="src/components/animation/PageTransition.tsx">
// src/components/animation/PageTransition.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { pageTransition } from '@/utils/animation';

interface PageTransitionProps extends HTMLMotionProps<'div'> {
  children: ReactNode;
  variants?: Variants;
  className?: string;
}

/**
 * 页面过渡组件，用于为页面添加进入和退出动画
 * 
 * @param children - 子元素
 * @param variants - 动画变体
 * @param className - CSS类名
 */
const PageTransition: React.FC<PageTransitionProps> = ({
  children,
  variants = pageTransition,
  className = '',
  ...props
}) => {
  return (
    <motion.div
      className={className}
      variants={variants}
      initial="hidden"
      animate="visible"
      exit="exit"
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default PageTransition;
</file>

<file path="src/components/animation/README.md">
# 动画组件文档

## RewardAnimation 组件

`RewardAnimation` 是一个用于展示奖励获取动画的组件，支持多种动画效果和音效，根据奖励的稀有度提供不同的视觉效果。

## TaskCompletionAnimation 组件

`TaskCompletionAnimation` 是一个用于展示任务完成动画的组件，支持多种动画效果和音效，根据任务的优先级和类型提供不同的视觉效果。

## ChallengeCompletionAnimation 组件

`ChallengeCompletionAnimation` 是一个用于展示挑战完成动画的组件，支持多种动画效果和音效，根据挑战的难度提供不同的视觉效果。

### 使用方法

```tsx
import RewardAnimation from '@/components/animation/RewardAnimation';
import { RewardType, RewardRarity } from '@/services/rewardService';

// 基本用法
<RewardAnimation
  type={RewardType.COIN}
  rarity={RewardRarity.COMMON}
  iconPath="/assets/rewards/coin.svg"
  amount={10}
  size={100}
/>

// 高级用法
<RewardAnimation
  type={RewardType.ITEM}
  rarity={RewardRarity.LEGENDARY}
  iconPath="/assets/rewards/legendary_item.svg"
  amount={1}
  size={150}
  animationStyle="burst"
  playSound={true}
  soundVolume={0.7}
  onAnimationComplete={() => console.log('动画播放完成')}
/>
```

### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| type | RewardType | 必填 | 奖励类型 |
| rarity | RewardRarity | 必填 | 奖励稀有度 |
| iconPath | string | 必填 | 奖励图标路径 |
| amount | number | 1 | 奖励数量 |
| size | number | 100 | 动画容器大小（像素） |
| animationStyle | 'default' \| 'burst' \| 'float' \| 'spin' \| 'pulse' | 'default' | 动画样式 |
| playSound | boolean | true | 是否播放音效 |
| soundVolume | number | 0.5 | 音效音量（0-1） |
| onAnimationComplete | () => void | undefined | 动画完成回调函数 |

### 动画样式说明

1. **default**: 默认动画，适用于普通奖励
2. **burst**: 爆发式动画，适用于传说级奖励
3. **spin**: 旋转动画，适用于史诗级奖励
4. **pulse**: 脉冲动画，适用于稀有奖励
5. **float**: 浮动动画，适用于不常见奖励

### 稀有度特效

- **传说级 (Legendary)**: 彩虹边框、星星粒子、金色光晕
- **史诗级 (Epic)**: 紫色边框、强烈光晕效果
- **稀有级 (Rare)**: 蓝色边框、中等光晕效果
- **不常见 (Uncommon)**: 绿色光晕
- **普通 (Common)**: 基础光晕

### 音效系统

组件使用 `sound.ts` 工具类播放音效，根据奖励稀有度播放不同的音效。音效文件应放置在 `/public/assets/sounds/` 目录下。

### 示例代码

```tsx
// 在奖励模态框中使用
const getAnimationStyleForRarity = (rarity: string): 'default' | 'burst' | 'float' | 'spin' | 'pulse' => {
  switch (rarity) {
    case 'legendary': return 'burst';
    case 'epic': return 'spin';
    case 'rare': return 'pulse';
    case 'uncommon': return 'float';
    default: return 'default';
  }
};

<RewardAnimation
  type={reward.type}
  rarity={reward.rarity}
  iconPath={reward.iconPath}
  amount={reward.amount}
  size={120}
  onAnimationComplete={handleAnimationComplete}
  animationStyle={getAnimationStyleForRarity(reward.rarity)}
  playSound={true}
  soundVolume={0.6}
/>
```

## TaskCompletionAnimation 使用方法

```tsx
import TaskCompletionAnimation from '@/components/animation/TaskCompletionAnimation';
import { TaskRecord, TaskPriority, TaskType } from '@/services/taskService';

// 基本用法
<TaskCompletionAnimation
  task={completedTask}
  onAnimationComplete={() => console.log('任务完成动画结束')}
/>

// 高级用法
<TaskCompletionAnimation
  task={completedTask}
  style={completedTask.priority === TaskPriority.HIGH ? 'fireworks' :
         completedTask.type === TaskType.MAIN ? 'stars' : 'confetti'}
  playSound={true}
  soundVolume={0.7}
  onAnimationComplete={handleAnimationComplete}
/>
```

### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| task | TaskRecord | 必填 | 完成的任务 |
| onAnimationComplete | () => void | undefined | 动画完成回调函数 |
| style | 'default' \| 'confetti' \| 'fireworks' \| 'stars' | 'default' | 动画样式 |
| playSound | boolean | true | 是否播放音效 |
| soundVolume | number | 0.5 | 音效音量（0-1） |

## ChallengeCompletionAnimation 使用方法

```tsx
import ChallengeCompletionAnimation from '@/components/animation/ChallengeCompletionAnimation';

// 基本用法
<ChallengeCompletionAnimation
  challengeTitle="每周挑战：竹林探险"
  onAnimationComplete={() => console.log('挑战完成动画结束')}
/>

// 高级用法
<ChallengeCompletionAnimation
  challengeTitle="传说挑战：熊猫大师"
  challengeDescription="完成所有熊猫训练课程"
  style="legendary"
  playSound={true}
  soundVolume={0.8}
  onAnimationComplete={handleAnimationComplete}
/>
```

### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| challengeTitle | string | 必填 | 挑战标题 |
| challengeDescription | string | undefined | 挑战描述 |
| onAnimationComplete | () => void | undefined | 动画完成回调函数 |
| style | 'default' \| 'epic' \| 'legendary' | 'default' | 动画样式 |
| playSound | boolean | true | 是否播放音效 |
| soundVolume | number | 0.5 | 音效音量（0-1） |

## 注意事项

1. 确保音效文件已正确放置在 `/public/assets/sounds/` 目录下
2. 对于高频率触发的动画，考虑设置 `playSound={false}` 以避免音效重叠
3. 动画完成后会调用 `onAnimationComplete` 回调函数，可用于触发后续操作
4. 组件内部使用 `AnimatePresence` 处理动画的进入和退出，确保在父组件中正确处理组件的挂载和卸载
5. 任务和挑战完成动画会根据任务/挑战的重要性自动选择不同的动画效果
6. 所有动画组件都支持自定义样式和音效
</file>

<file path="src/components/animation/TaskCompletionAnimation.tsx">
// src/components/animation/TaskCompletionAnimation.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { TaskRecord } from '@/services/taskService';
import { playTaskCompletionSound } from '@/utils/sound';

interface TaskCompletionAnimationProps {
  task: TaskRecord;
  onAnimationComplete?: () => void;
  style?: 'default' | 'confetti' | 'fireworks' | 'stars';
  playSound?: boolean;
  soundVolume?: number;
}

/**
 * 任务完成动画组件
 * 在任务完成时显示动画效果
 */
const TaskCompletionAnimation: React.FC<TaskCompletionAnimationProps> = ({
  task,
  onAnimationComplete,
  style = 'default',
  playSound = true,
  soundVolume = 0.5
}) => {
  const [isAnimating, setIsAnimating] = useState(true);
  const [particles, setParticles] = useState<React.ReactNode[]>([]);

  // 播放音效
  useEffect(() => {
    if (playSound) {
      playTaskCompletionSound(task.type, task.priority, soundVolume);
    }
  }, [playSound, task.type, task.priority, soundVolume]);

  // 生成粒子效果
  useEffect(() => {
    const particleCount = style === 'confetti' ? 50 : style === 'fireworks' ? 30 : style === 'stars' ? 20 : 10;
    const newParticles = [];

    for (let i = 0; i < particleCount; i++) {
      newParticles.push(generateParticle(i, style));
    }

    setParticles(newParticles);
  }, [style]);

  // 生成单个粒子
  const generateParticle = (index: number, style: string) => {
    const colors = ['#FFD700', '#FF6347', '#7CFC00', '#00BFFF', '#FF69B4', '#9370DB'];
    const randomColor = colors[Math.floor(Math.random() * colors.length)];

    // 根据样式生成不同的粒子
    if (style === 'confetti') {
      const angle = Math.random() * 360;
      const distance = Math.random() * 100 + 50;
      const size = Math.random() * 10 + 5;
      const delay = Math.random() * 0.3;
      const duration = Math.random() * 1 + 1;
      const rotation = Math.random() * 720 - 360;

      return (
        <motion.div
          key={`confetti-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size / 2,
            backgroundColor: randomColor,
            top: '50%',
            left: '50%',
            margin: `-${size / 4}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0,
            rotate: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 1, 0],
            rotate: rotation,
            scale: [1, 1.2, 0.8, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    } else if (style === 'fireworks') {
      const angle = (index / 30) * 360;
      const distance = Math.random() * 50 + 100;
      const size = Math.random() * 6 + 2;
      const delay = Math.random() * 0.2;
      const duration = Math.random() * 0.8 + 0.6;

      return (
        <motion.div
          key={`firework-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            borderRadius: '50%',
            backgroundColor: randomColor,
            boxShadow: `0 0 ${size * 2}px ${randomColor}`,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0,
            scale: 0.5
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0],
            scale: [0.5, 1.5, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    } else if (style === 'stars') {
      const angle = Math.random() * 360;
      const distance = Math.random() * 80 + 40;
      const size = Math.random() * 15 + 10;
      const delay = Math.random() * 0.5;
      const duration = Math.random() * 1 + 1;

      return (
        <motion.div
          key={`star-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            clipPath: 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
            backgroundColor: randomColor,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0,
            rotate: 0,
            scale: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0],
            rotate: 360,
            scale: [0, 1, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    } else {
      // 默认样式
      const angle = Math.random() * 360;
      const distance = Math.random() * 60 + 30;
      const size = Math.random() * 8 + 4;
      const delay = Math.random() * 0.3;
      const duration = Math.random() * 0.7 + 0.5;

      return (
        <motion.div
          key={`default-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            borderRadius: '50%',
            backgroundColor: randomColor,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    }
  };

  // 处理动画完成
  const handleAnimationComplete = () => {
    setIsAnimating(false);
    if (onAnimationComplete) {
      onAnimationComplete();
    }
  };

  return (
    <AnimatePresence>
      {isAnimating && (
        <motion.div
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            zIndex: 1000,
            pointerEvents: 'none'
          }}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.3 }}
        >
          {/* 粒子效果 */}
          {particles}

          {/* 中心文本 */}
          <motion.div
            style={{
              backgroundColor: 'rgba(0, 0, 0, 0.7)',
              color: '#fff',
              padding: '20px 40px',
              borderRadius: '10px',
              textAlign: 'center',
              zIndex: 20
            }}
            initial={{ scale: 0, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0, opacity: 0 }}
            transition={{ duration: 0.5, delay: 0.2 }}
            onAnimationComplete={handleAnimationComplete}
          >
            <motion.h2
              initial={{ y: -20, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ duration: 0.3, delay: 0.3 }}
            >
              任务完成！
            </motion.h2>
            <motion.p
              initial={{ y: 20, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ duration: 0.3, delay: 0.5 }}
            >
              {task.title}
            </motion.p>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default TaskCompletionAnimation;
</file>

<file path="src/components/common/Button.tsx">
// src/components/common/Button.tsx
import React from 'react';
import { useComponentLabels } from '@/hooks/useComponentLabels';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'jade' | 'gold';
  isLoading?: boolean;
  loadingText?: string;
}

/**
 * Button component with support for different styles including game-themed variants
 *
 * @param variant - 'primary' (default), 'secondary', 'jade' (game-themed green), 'gold' (premium)
 * @param isLoading - Whether to show loading state
 * @param loadingText - Text to display when loading (overrides default localized text)
 */
const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'primary',
  isLoading = false,
  loadingText,
  ...props
}) => {
  // Get localized labels
  const { labels } = useComponentLabels();
  // Use provided loadingText or fall back to localized label
  const finalLoadingText = loadingText || labels.button.loading;
  // Determine the appropriate CSS class based on variant
  let variantStyle = '';

  switch (variant) {
    case 'jade':
      variantStyle = 'jade-button';
      break;
    case 'gold':
      variantStyle = 'gold-button';
      break;
    case 'secondary':
      variantStyle = 'button-secondary';
      break;
    case 'primary':
    default:
      variantStyle = 'button-primary';
  }

  // Only add button-common class for non-game-themed buttons
  const baseStyle = !['jade', 'gold'].includes(variant) ? 'button-common' : '';

  return (
    <button
      className={`${baseStyle} ${variantStyle}`.trim()}
      disabled={isLoading || props.disabled}
      {...props}
    >
      {isLoading ? finalLoadingText : children}
    </button>
  );
};

export default Button;
</file>

<file path="src/components/common/DataLoader.tsx">
// src/components/common/DataLoader.tsx
import React, { ReactNode } from 'react';
import { motion } from 'framer-motion';
import LoadingSpinner from './LoadingSpinner';
import ErrorDisplay from './ErrorDisplay';
import { useComponentLabels } from '@/hooks/useComponentLabels';

interface DataLoaderProps<T> {
  isLoading: boolean;
  isError: boolean;
  error: Error | null;
  data: T | undefined | null;
  loadingText?: string;
  errorTitle?: string;
  onRetry?: () => void;
  emptyState?: ReactNode;
  children: (data: T) => ReactNode;
  loadingComponent?: ReactNode;
  errorComponent?: ReactNode;
}

/**
 * Generic data loading component
 * Handles loading, error, and empty data states with localized text support
 *
 * @param isLoading - Whether data is currently loading
 * @param isError - Whether an error occurred
 * @param error - Error object
 * @param data - Data to render
 * @param loadingText - Optional custom loading text (overrides localized text)
 * @param errorTitle - Optional custom error title (overrides localized text)
 * @param onRetry - Optional retry callback
 * @param emptyState - Optional custom empty state component
 * @param children - Function to render data
 * @param loadingComponent - Optional custom loading component
 * @param errorComponent - Optional custom error component
 */
function DataLoader<T>({
  isLoading,
  isError,
  error,
  data,
  loadingText,
  errorTitle,
  onRetry,
  emptyState,
  children,
  loadingComponent,
  errorComponent
}: DataLoaderProps<T>) {
  // Get localized labels
  const { labels } = useComponentLabels();

  // Loading state
  if (isLoading && !data) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="data-loader-container"
      >
        {loadingComponent || <LoadingSpinner variant="jade" text={loadingText} type="data" />}
      </motion.div>
    );
  }

  // Error state
  if (isError && !data) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="data-loader-container"
      >
        {errorComponent || (
          <ErrorDisplay
            error={error}
            title={errorTitle}
            onRetry={onRetry}
          />
        )}
      </motion.div>
    );
  }

  // Empty data state
  if (!data) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="data-loader-container"
      >
        {emptyState || (
          <div className="empty-state">
            <p>{labels.emptyState.noData}</p>
          </div>
        )}
      </motion.div>
    );
  }

  // Render data
  return <>{children(data)}</>;
}

export default DataLoader;
</file>

<file path="src/components/common/ErrorDisplay.tsx">
// src/components/common/ErrorDisplay.tsx
import React from 'react';
import type { ApiError } from '@/types';
import Button from './Button'; // Use our common Button
import { useComponentLabels } from '@/hooks/useComponentLabels';

interface ErrorDisplayProps {
  error: ApiError | Error | null;
  title?: string;
  messageTemplate?: string;
  onRetry?: () => void;
  retryButtonText?: string;
  errorType?: 'generic' | 'network' | 'server' | 'unknown';
}

/**
 * Error display component with localized text support
 *
 * @param error - The error object to display
 * @param title - Optional custom title (overrides localized title)
 * @param messageTemplate - Optional custom message template (overrides localized template)
 * @param onRetry - Optional retry callback function
 * @param retryButtonText - Optional custom retry button text (overrides localized text)
 * @param errorType - Type of error, used to select appropriate localized text if no custom text is provided
 */
const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  title,
  messageTemplate,
  onRetry,
  retryButtonText,
  errorType = 'generic',
}) => {
  const { labels } = useComponentLabels();

  // Use provided values or fall back to localized labels
  const displayTitle = title || labels.error.title;
  const displayMessageTemplate = messageTemplate || labels.error.details;
  const displayRetryButtonText = retryButtonText || labels.error.retry;
  if (!error) return null;

  const errorMessage = error.message || labels.error.unknownError;
  const finalMessage = displayMessageTemplate.replace('{message}', errorMessage);
  const errorCode = (error as ApiError)?.errorCode;
  const statusCode = (error as ApiError)?.statusCode;

  return (
    <div className="error-container" role="alert">
      <h3>{displayTitle}</h3>
      <p className="error-text">{finalMessage}</p>
      {errorCode && <p className="error-code-text">Error Code: {errorCode}</p>}
      {statusCode && <p className="error-code-text">Status Code: {statusCode}</p>}
      {onRetry && (
        <Button onClick={onRetry} variant="secondary" style={{ marginTop: '10px' }}>
          {displayRetryButtonText}
        </Button>
      )}
    </div>
  );
};
export default ErrorDisplay;
</file>

<file path="src/components/common/LoadingSpinner.tsx">
// src/components/common/LoadingSpinner.tsx
import React from 'react';
import { useComponentLabels } from '@/hooks/useComponentLabels';

interface LoadingSpinnerProps {
  text?: string;
  variant?: 'default' | 'jade';
  type?: 'generic' | 'data' | 'content' | 'saving' | 'processing';
}

/**
 * Loading spinner component with support for game-themed style
 *
 * @param text - Optional text to display below the spinner (overrides default localized text)
 * @param variant - 'default' or 'jade' (game-themed)
 * @param type - Type of loading operation, used to select appropriate localized text if no text is provided
 */
const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  text,
  variant = 'default',
  type = 'generic'
}) => {
  const { labels } = useComponentLabels();
  const spinnerClass = variant === 'jade' ? 'jade-spinner' : 'loading-spinner';

  // Use provided text or fall back to localized label based on type
  const displayText = text || labels.loading[type];

  return (
    <div className="loading-spinner-overlay">
      <div className={spinnerClass}></div>
      {displayText && <p className="loading-spinner-text">{displayText}</p>}
    </div>
  );
};

export default LoadingSpinner;
</file>

<file path="src/components/common/Modal.tsx">
// src/components/common/Modal.tsx
import React, { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { useComponentLabels } from '@/hooks/useComponentLabels';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
  closeOnOutsideClick?: boolean;
  closeOnEsc?: boolean;
  className?: string;
  overlayClassName?: string;
  contentClassName?: string;
  title?: string;
  ariaLabelledBy?: string;
  ariaDescribedBy?: string;
}

/**
 * Basic modal component
 * Provides reusable modal functionality with animation and customizable styles
 *
 * @param isOpen - Controls whether the modal is displayed
 * @param onClose - Callback function to close the modal
 * @param children - Modal content
 * @param closeOnOutsideClick - Whether to close the modal when clicking outside, defaults to true
 * @param closeOnEsc - Whether to close the modal when pressing ESC, defaults to true
 * @param className - Custom class name for the modal container
 * @param overlayClassName - Custom class name for the overlay
 * @param contentClassName - Custom class name for the content area
 * @param title - Optional title for accessibility
 * @param ariaLabelledBy - Optional ID of element that labels the modal
 * @param ariaDescribedBy - Optional ID of element that describes the modal
 */
const Modal: React.FC<ModalProps> = ({
  isOpen,
  onClose,
  children,
  closeOnOutsideClick = true,
  closeOnEsc = true,
  className = '',
  overlayClassName = '',
  contentClassName = '',
  title,
  ariaLabelledBy,
  ariaDescribedBy,
}) => {
  // Get localized labels
  const { labels } = useComponentLabels();
  const contentRef = useRef<HTMLDivElement>(null);

  // Handle ESC key to close
  useEffect(() => {
    const handleEscKey = (event: KeyboardEvent) => {
      if (closeOnEsc && event.key === 'Escape' && isOpen) {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscKey);
      // Prevent background scrolling
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscKey);
      // Restore background scrolling
      document.body.style.overflow = '';
    };
  }, [isOpen, onClose, closeOnEsc]);

  // Handle clicking outside to close
  const handleOverlayClick = (e: React.MouseEvent) => {
    if (closeOnOutsideClick && e.target === e.currentTarget) {
      onClose();
    }
  };

  // Animation variants
  const overlayVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { duration: 0.3 } },
    exit: { opacity: 0, transition: { duration: 0.2 } }
  };

  const contentVariants = {
    hidden: { opacity: 0, scale: 0.9, y: -20 },
    visible: {
      opacity: 1,
      scale: 1,
      y: 0,
      transition: {
        type: 'spring',
        damping: 25,
        stiffness: 300,
        delay: 0.1
      }
    },
    exit: {
      opacity: 0,
      scale: 0.95,
      y: 10,
      transition: {
        duration: 0.2
      }
    }
  };

  // Use Portal to render the modal to the body
  return createPortal(
    <AnimatePresence>
      {isOpen && (
        <motion.div
          className={`modal-overlay ${overlayClassName}`}
          variants={overlayVariants}
          initial="hidden"
          animate="visible"
          exit="exit"
          onClick={handleOverlayClick}
          role="dialog"
          aria-modal="true"
          aria-label={title || labels.modal.close}
          aria-labelledby={ariaLabelledBy}
          aria-describedby={ariaDescribedBy}
        >
          <motion.div
            ref={contentRef}
            className={`modal-content ${contentClassName}`}
            variants={contentVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
            onClick={(e) => e.stopPropagation()}
          >
            <div className={`modal-container ${className}`}>
              {children}
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>,
    document.body
  );
};

export default Modal;
</file>

<file path="src/components/common/ProgressBar.tsx">
// src/components/common/ProgressBar.tsx
import React from 'react';
import { motion } from 'framer-motion';

interface ProgressBarProps {
  progress: number;
  total?: number;
  showPercentage?: boolean;
  className?: string;
  height?: number;
  color?: string;
  backgroundColor?: string;
  radius?: number;
  animate?: boolean;
}

/**
 * 进度条组件
 * 显示任务或奖励的完成进度
 * 
 * @param progress 当前进度值
 * @param total 总进度值，默认为100
 * @param showPercentage 是否显示百分比文本
 * @param className 自定义CSS类名
 * @param height 进度条高度，默认为10px
 * @param color 进度条颜色，默认为主题色
 * @param backgroundColor 进度条背景色，默认为半透明灰色
 * @param radius 进度条圆角半径，默认为4px
 * @param animate 是否启用动画效果，默认为true
 */
const ProgressBar: React.FC<ProgressBarProps> = ({
  progress,
  total = 100,
  showPercentage = false,
  className = '',
  height = 10,
  color,
  backgroundColor,
  radius = 4,
  animate = true
}) => {
  // 计算百分比
  const percentage = Math.min(Math.max(0, Math.round((progress / total) * 100)), 100);
  
  // 动画变体
  const variants = {
    initial: { width: '0%' },
    animate: { width: `${percentage}%` }
  };

  return (
    <div 
      className={`progress-bar-container ${className}`}
      style={{
        height: `${height}px`,
        backgroundColor: backgroundColor || 'rgba(0, 0, 0, 0.1)',
        borderRadius: `${radius}px`,
        overflow: 'hidden',
        position: 'relative'
      }}
    >
      <motion.div
        className="progress-bar-fill"
        style={{
          height: '100%',
          backgroundColor: color || 'var(--primary-color, #4caf50)',
          borderRadius: `${radius}px`
        }}
        initial={animate ? "initial" : false}
        animate={animate ? "animate" : false}
        variants={variants}
        transition={{ duration: 0.5, ease: "easeOut" }}
      />
      
      {showPercentage && (
        <div 
          className="progress-bar-text"
          style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: percentage > 50 ? '#fff' : '#000',
            fontSize: `${height < 20 ? 10 : 14}px`,
            fontWeight: 'bold',
            textShadow: percentage > 50 ? '0 0 2px rgba(0,0,0,0.5)' : 'none'
          }}
        >
          {percentage}%
        </div>
      )}
    </div>
  );
};

export default ProgressBar;
</file>

<file path="src/components/common/SyncStatusIndicator.tsx">
// src/components/common/SyncStatusIndicator.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { SyncStatus, getCurrentSyncStatus, getPendingSyncCount, manualSync } from '@/services/dataSyncService';

interface SyncStatusIndicatorProps {
  showCount?: boolean;
  showLabel?: boolean;
  variant?: 'minimal' | 'standard' | 'detailed';
}

/**
 * 数据同步状态指示器组件
 * 显示当前同步状态和待同步项目数量
 *
 * @param showCount - 是否显示待同步项目数量
 * @param showLabel - 是否显示状态标签
 * @param variant - 显示变体
 */
const SyncStatusIndicator: React.FC<SyncStatusIndicatorProps> = ({
  showCount = true,
  showLabel = true,
  variant = 'standard'
}) => {
  const [syncStatus, setSyncStatus] = useState<SyncStatus>(SyncStatus.IDLE);
  const [pendingCount, setPendingCount] = useState<number>(0);
  const [isVisible, setIsVisible] = useState<boolean>(false);

  // 更新同步状态和待同步项目数量
  useEffect(() => {
    const updateStatus = async () => {
      try {
        const status = getCurrentSyncStatus();
        let count = 0;

        try {
          count = await getPendingSyncCount();
        } catch (countErr) {
          console.error('Failed to get pending sync count:', countErr);
        }

        setSyncStatus(status);
        setPendingCount(count);

        // 如果有待同步项目或正在同步，则显示指示器
        setIsVisible(count > 0 || status === SyncStatus.SYNCING);
      } catch (err) {
        console.error('Failed to update sync status:', err);
      }
    };

    // 初始更新
    updateStatus();

    // 定期更新，更频繁地检查
    const interval = setInterval(updateStatus, 1000);

    // 添加事件监听器，在网络状态变化时更新
    window.addEventListener('online', updateStatus);
    window.addEventListener('offline', updateStatus);

    // 添加自定义事件监听器，在添加同步项目时更新
    const handleSyncItemAdded = () => updateStatus();
    window.addEventListener('syncItemAdded', handleSyncItemAdded);

    // 添加自定义事件监听器，在同步状态变化时更新
    const handleSyncStatusChanged = (event: Event) => {
      const customEvent = event as CustomEvent<SyncStatus>;
      setSyncStatus(customEvent.detail);
      updateStatus();
    };
    window.addEventListener('syncStatusChanged', handleSyncStatusChanged);

    return () => {
      clearInterval(interval);
      window.removeEventListener('online', updateStatus);
      window.removeEventListener('offline', updateStatus);
      window.removeEventListener('syncItemAdded', handleSyncItemAdded);
      window.removeEventListener('syncStatusChanged', handleSyncStatusChanged);
    };
  }, []);

  // 手动触发同步
  const handleManualSync = async () => {
    try {
      await manualSync();
    } catch (err) {
      console.error('Manual sync failed:', err);
    }
  };

  // 获取状态图标
  const getStatusIcon = () => {
    switch (syncStatus) {
      case SyncStatus.SYNCING:
        return (
          <motion.div
            animate={{ rotate: 360 }}
            transition={{ repeat: Infinity, duration: 1, ease: 'linear' }}
            className="sync-icon syncing"
          >
            ↻
          </motion.div>
        );
      case SyncStatus.SUCCESS:
        return <div className="sync-icon success">✓</div>;
      case SyncStatus.ERROR:
        return <div className="sync-icon error">✗</div>;
      default:
        return <div className="sync-icon idle">⟳</div>;
    }
  };

  // 获取状态标签
  const getStatusLabel = () => {
    switch (syncStatus) {
      case SyncStatus.SYNCING:
        return '同步中...';
      case SyncStatus.SUCCESS:
        return '同步成功';
      case SyncStatus.ERROR:
        return '同步失败';
      default:
        return '待同步';
    }
  };

  // 始终显示同步状态指示器，除非是最小变体且没有待同步项目
  if (!isVisible && variant === 'minimal') {
    return null;
  }

  // 最小变体
  if (variant === 'minimal') {
    return (
      <motion.div
        className="sync-status-indicator minimal"
        initial={{ opacity: 0, scale: 0.8 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.8 }}
        onClick={handleManualSync}
      >
        {getStatusIcon()}
      </motion.div>
    );
  }

  // 获取状态类名
  const getStatusClassName = () => {
    switch (syncStatus) {
      case SyncStatus.SYNCING:
        return 'syncing';
      case SyncStatus.SUCCESS:
        return 'success';
      case SyncStatus.ERROR:
        return 'error';
      default:
        return 'idle';
    }
  };

  // 标准变体
  return (
    <AnimatePresence>
      <motion.div
        className={`sync-status-indicator ${variant} ${getStatusClassName()}`}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: 20 }}
        onClick={handleManualSync}
      >
        {getStatusIcon()}

        {showLabel && (
          <span className="sync-label">{getStatusLabel()}</span>
        )}

        {showCount && pendingCount > 0 && (
          <span className="sync-count">{pendingCount}</span>
        )}
      </motion.div>
    </AnimatePresence>
  );
};

export default SyncStatusIndicator;
</file>

<file path="src/components/decoration/ChineseDecoration.tsx">
// src/components/decoration/ChineseDecoration.tsx
import React from 'react';

/**
 * 中国风装饰组件
 * 添加各种中国风装饰元素到应用程序中
 */
const ChineseDecoration: React.FC = () => {
  return (
    <>
      {/* 云朵装饰 */}
      <div className="chinese-cloud top-right" />
      <div className="chinese-cloud top-left" />
      
      {/* 中国结装饰 */}
      <div className="chinese-knot top-right" />
      
      {/* 荷花装饰 */}
      <div className="lotus-flower bottom-left" />
      
      {/* 山水画装饰 */}
      <div className="mountain-landscape bottom" />
    </>
  );
};

export default ChineseDecoration;
</file>

<file path="src/components/decoration/InkAnimation.tsx">
// src/components/decoration/InkAnimation.tsx
import React, { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

interface InkAnimationProps {
  text: string;
  duration?: number;
  fontSize?: number;
  color?: string;
  onComplete?: () => void;
}

/**
 * 中国风水墨动画组件
 * 用于文字的水墨渲染效果
 * 
 * @param text - 要显示的文字
 * @param duration - 动画持续时间（毫秒）
 * @param fontSize - 字体大小
 * @param color - 文字颜色
 * @param onComplete - 动画完成回调
 */
const InkAnimation: React.FC<InkAnimationProps> = ({
  text,
  duration = 2000,
  fontSize = 36,
  color = 'var(--royal-jade)',
  onComplete
}) => {
  const [isVisible, setIsVisible] = useState(true);
  const characters = text.split('');
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsVisible(false);
      if (onComplete) {
        onComplete();
      }
    }, duration + characters.length * 200);
    
    return () => clearTimeout(timer);
  }, [duration, characters.length, onComplete]);
  
  // 字符动画变体
  const characterVariants = {
    hidden: { 
      opacity: 0,
      scale: 0.5,
      filter: 'blur(10px)'
    },
    visible: (i: number) => ({
      opacity: 1,
      scale: 1,
      filter: 'blur(0px)',
      transition: {
        delay: i * 0.1,
        duration: 0.5,
        ease: [0.17, 0.67, 0.83, 0.67] // 模拟水墨扩散效果
      }
    }),
    exit: (i: number) => ({
      opacity: 0,
      scale: 1.2,
      filter: 'blur(5px)',
      transition: {
        delay: i * 0.05,
        duration: 0.3,
        ease: 'easeOut'
      }
    })
  };
  
  // 墨滴动画变体
  const inkDropVariants = {
    hidden: { 
      opacity: 0,
      scale: 0
    },
    visible: (i: number) => ({
      opacity: [0, 0.7, 0.3],
      scale: [0, 1.5, 1],
      transition: {
        delay: i * 0.1,
        duration: 0.8,
        ease: 'easeOut'
      }
    }),
    exit: (i: number) => ({
      opacity: 0,
      scale: 1.5,
      transition: {
        delay: i * 0.05,
        duration: 0.3,
        ease: 'easeOut'
      }
    })
  };
  
  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          style={{
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            position: 'relative',
            padding: '20px'
          }}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          {characters.map((char, index) => (
            <motion.div
              key={`${char}-${index}`}
              style={{
                position: 'relative',
                margin: '0 2px'
              }}
              custom={index}
              variants={characterVariants}
              initial="hidden"
              animate="visible"
              exit="exit"
            >
              {/* 墨滴效果 */}
              <motion.div
                style={{
                  position: 'absolute',
                  top: '50%',
                  left: '50%',
                  width: `${fontSize * 1.5}px`,
                  height: `${fontSize * 1.5}px`,
                  borderRadius: '50%',
                  backgroundColor: color,
                  transform: 'translate(-50%, -50%)',
                  zIndex: -1,
                  opacity: 0.2
                }}
                custom={index}
                variants={inkDropVariants}
                initial="hidden"
                animate="visible"
                exit="exit"
              />
              
              {/* 文字 */}
              <motion.span
                style={{
                  fontFamily: 'var(--font-title)',
                  fontSize: `${fontSize}px`,
                  color: color,
                  position: 'relative',
                  zIndex: 1
                }}
              >
                {char}
              </motion.span>
            </motion.div>
          ))}
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default InkAnimation;
</file>

<file path="src/components/decoration/LanternDecoration.tsx">
// src/components/decoration/LanternDecoration.tsx
import React from 'react';
import { motion } from 'framer-motion';

interface LanternDecorationProps {
  count?: number;
  character?: string;
  position?: 'top' | 'left' | 'right' | 'bottom';
}

/**
 * 中国风灯笼装饰组件
 * 用于特殊场合的装饰，如节日、成就解锁等
 * 
 * @param count - 灯笼数量
 * @param character - 灯笼上的汉字
 * @param position - 灯笼位置
 */
const LanternDecoration: React.FC<LanternDecorationProps> = ({
  count = 2,
  character = '福',
  position = 'top'
}) => {
  // 根据位置确定灯笼的样式
  const getPositionStyle = (index: number) => {
    const baseStyle = {
      position: 'fixed' as const,
      zIndex: 10,
      pointerEvents: 'none' as const
    };
    
    const totalWidth = count * 60; // 每个灯笼宽度约60px
    const startPosition = `calc(50% - ${totalWidth / 2}px)`;
    
    switch (position) {
      case 'top':
        return {
          ...baseStyle,
          top: '10px',
          left: `calc(${startPosition} + ${index * 60}px)`
        };
      case 'bottom':
        return {
          ...baseStyle,
          bottom: '80px', // 为底部导航留出空间
          left: `calc(${startPosition} + ${index * 60}px)`
        };
      case 'left':
        return {
          ...baseStyle,
          left: '10px',
          top: `calc(50% - ${totalWidth / 2}px + ${index * 60}px)`
        };
      case 'right':
        return {
          ...baseStyle,
          right: '10px',
          top: `calc(50% - ${totalWidth / 2}px + ${index * 60}px)`
        };
      default:
        return baseStyle;
    }
  };
  
  // 灯笼动画变体
  const lanternVariants = {
    initial: { y: -10, opacity: 0 },
    animate: (i: number) => ({
      y: 0,
      opacity: 1,
      transition: {
        delay: i * 0.2,
        duration: 0.5,
        ease: 'easeOut'
      }
    }),
    swing: (i: number) => ({
      rotate: [0, 3, 0, -3, 0],
      transition: {
        delay: i * 0.1,
        duration: 2,
        ease: 'easeInOut',
        repeat: Infinity,
        repeatType: 'reverse'
      }
    })
  };
  
  return (
    <>
      {Array.from({ length: count }).map((_, index) => (
        <motion.div
          key={index}
          style={{
            ...getPositionStyle(index),
            width: '50px',
            height: '75px',
            backgroundImage: "url('/assets/chinese-lantern.svg')",
            backgroundSize: 'contain',
            backgroundRepeat: 'no-repeat',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center'
          }}
          custom={index}
          variants={lanternVariants}
          initial="initial"
          animate={['animate', 'swing']}
        >
          <motion.span
            style={{
              fontFamily: 'var(--font-title)',
              color: '#FFD700',
              fontSize: '18px',
              marginTop: '-5px'
            }}
            animate={{
              scale: [1, 1.1, 1],
              transition: {
                duration: 2,
                ease: 'easeInOut',
                repeat: Infinity,
                repeatType: 'reverse'
              }
            }}
          >
            {character}
          </motion.span>
        </motion.div>
      ))}
    </>
  );
};

export default LanternDecoration;
</file>

<file path="src/components/game/AbilityCard.tsx">
// src/components/game/AbilityCard.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { PandaAbilityRecord, AbilityType, getAbilityKeyFromName, getLocalizedAbilityName, getLocalizedAbilityDescription } from '@/services/pandaAbilityService';
import { RewardRarity } from '@/services/rewardService';
import { AbilityCardLabels } from '@/types';

interface AbilityCardProps {
  ability: PandaAbilityRecord;
  isUnlocked: boolean;
  onActivate?: () => void;
  className?: string;
  labels?: AbilityCardLabels;
}

/**
 * Panda ability card component
 * Displays detailed information about a panda ability
 *
 * @param ability - Ability data
 * @param isUnlocked - Whether the ability is unlocked
 * @param onActivate - Callback function to activate the ability
 * @param className - Custom class name
 * @param labels - Localized labels for the component
 */
const AbilityCard: React.FC<AbilityCardProps> = ({
  ability,
  isUnlocked,
  onActivate,
  className = '',
  labels
}) => {
  const [localizedName, setLocalizedName] = useState<string>(ability.name);
  const [localizedDescription, setLocalizedDescription] = useState<string>(ability.description);

  // Load localized name and description
  useEffect(() => {
    const abilityKey = getAbilityKeyFromName(ability.name);
    if (abilityKey) {
      // Load localized name
      getLocalizedAbilityName(abilityKey, ability.name)
        .then(name => setLocalizedName(name))
        .catch(err => console.error('Error loading localized ability name:', err));

      // Load localized description
      getLocalizedAbilityDescription(abilityKey, ability.description)
        .then(desc => setLocalizedDescription(desc))
        .catch(err => console.error('Error loading localized ability description:', err));
    }
  }, [ability.name, ability.description]);
  // Get ability type name with localization
  const getAbilityTypeName = (type: AbilityType): string => {
    switch (type) {
      case AbilityType.PASSIVE:
        return labels?.typePassive || 'Passive';
      case AbilityType.ACTIVE:
        return labels?.typeActive || 'Active';
      case AbilityType.ULTIMATE:
        return labels?.typeUltimate || 'Ultimate';
      default:
        return labels?.typeUnknown || 'Unknown';
    }
  };

  // Get rarity name with localization
  const getRarityName = (rarity: RewardRarity): string => {
    switch (rarity) {
      case RewardRarity.COMMON:
        return labels?.rarityCommon || 'Common';
      case RewardRarity.UNCOMMON:
        return labels?.rarityUncommon || 'Uncommon';
      case RewardRarity.RARE:
        return labels?.rarityRare || 'Rare';
      case RewardRarity.EPIC:
        return labels?.rarityEpic || 'Epic';
      case RewardRarity.LEGENDARY:
        return labels?.rarityLegendary || 'Legendary';
      default:
        return labels?.rarityCommon || 'Common';
    }
  };

  // Get rarity color
  const getRarityColor = (rarity: RewardRarity): string => {
    switch (rarity) {
      case RewardRarity.COMMON:
        return 'var(--text-primary)';
      case RewardRarity.UNCOMMON:
        return 'var(--jade-green)';
      case RewardRarity.RARE:
        return 'var(--imperial-blue)';
      case RewardRarity.EPIC:
        return 'var(--imperial-purple)';
      case RewardRarity.LEGENDARY:
        return 'var(--imperial-gold)';
      default:
        return 'var(--text-primary)';
    }
  };

  // Check if ability is available (unlocked and not on cooldown)
  const isAvailable = (): boolean => {
    if (!isUnlocked) {
      return false;
    }

    // Passive abilities are always available
    if (ability.type === AbilityType.PASSIVE) {
      return true;
    }

    // Check cooldown time
    if (ability.lastUsedAt && ability.cooldownMinutes) {
      const now = new Date();
      const cooldownEndTime = new Date(ability.lastUsedAt);
      cooldownEndTime.setMinutes(cooldownEndTime.getMinutes() + ability.cooldownMinutes);

      return now >= cooldownEndTime;
    }

    return true;
  };

  // Get remaining cooldown time with localization
  const getCooldownRemaining = (): string => {
    if (!ability.lastUsedAt || !ability.cooldownMinutes) {
      return '';
    }

    const now = new Date();
    const cooldownEndTime = new Date(ability.lastUsedAt);
    cooldownEndTime.setMinutes(cooldownEndTime.getMinutes() + ability.cooldownMinutes);

    if (now >= cooldownEndTime) {
      return '';
    }

    const remainingMs = cooldownEndTime.getTime() - now.getTime();
    const remainingMinutes = Math.ceil(remainingMs / (1000 * 60));

    const minutesUnit = labels?.minutesUnit || 'min';
    const hourUnit = 'h'; // We could add this to labels if needed

    if (remainingMinutes < 60) {
      return `${remainingMinutes} ${minutesUnit}`;
    } else {
      const hours = Math.floor(remainingMinutes / 60);
      const minutes = remainingMinutes % 60;
      return `${hours}${hourUnit}${minutes > 0 ? ` ${minutes}${minutesUnit}` : ''}`;
    }
  };

  return (
    <motion.div
      className={`ability-card ${className} ${isUnlocked ? 'unlocked' : 'locked'} ${ability.type.toLowerCase()}-ability`}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
    >
      <div className="ability-card-header">
        <div className="ability-icon">
          <img
            src={ability.iconPath}
            alt={ability.name}
            onError={(e) => {
              const target = e.target as HTMLImageElement;
              target.onerror = null;
              target.src = '/assets/abilities/default-ability.svg';
            }}
          />
        </div>
        <div className="ability-info">
          <h3 className="ability-name" style={{ color: getRarityColor(ability.rarity) }}>
            {localizedName}
          </h3>
          <div className="ability-meta">
            <span className="ability-type">{getAbilityTypeName(ability.type)}</span>
            <span className="ability-rarity">{getRarityName(ability.rarity)}</span>
          </div>
        </div>
      </div>

      <div className="ability-card-body">
        <p className="ability-description">{localizedDescription}</p>

        {!isUnlocked && (
          <div className="ability-unlock-info">
            <span className="ability-lock-icon">🔒</span>
            <span>{labels?.requiredLevelLabel || 'Required Level'} {ability.requiredLevel}</span>
          </div>
        )}

        {isUnlocked && ability.type !== AbilityType.PASSIVE && (
          <div className="ability-cooldown">
            {getCooldownRemaining() ? (
              <span className="cooldown-remaining">{labels?.cooldownRemainingLabel || 'Cooling down'}: {getCooldownRemaining()}</span>
            ) : (
              <span className="cooldown-info">{labels?.cooldownLabel || 'Cooldown'}: {ability.cooldownMinutes} {labels?.minutesUnit || 'min'}</span>
            )}
          </div>
        )}
      </div>

      {isUnlocked && ability.type !== AbilityType.PASSIVE && (
        <div className="ability-card-footer">
          <button
            className={`activate-button ${isAvailable() ? 'available' : 'unavailable'}`}
            onClick={onActivate}
            disabled={!isAvailable()}
          >
            {ability.isActive
              ? (labels?.alreadyActivatedText || 'Already Activated')
              : (labels?.activateButtonText || 'Activate Ability')}
          </button>
        </div>
      )}
    </motion.div>
  );
};

export default AbilityCard;
</file>

<file path="src/components/game/AbilityUnlockNotification.tsx">
// src/components/game/AbilityUnlockNotification.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { PandaAbilityRecord } from '@/services/pandaAbilityService';
import ScrollDialog from './ScrollDialog';
import Button from '@/components/common/Button';
import { AbilityUnlockNotificationLabels } from '@/types';

interface AbilityUnlockNotificationProps {
  newlyUnlockedAbilities: PandaAbilityRecord[];
  onClose: () => void;
  labels?: AbilityUnlockNotificationLabels;
}

/**
 * Panda ability unlock notification component
 * Displays a notification when new abilities are unlocked
 *
 * @param newlyUnlockedAbilities - List of newly unlocked abilities
 * @param onClose - Callback function to close the notification
 * @param labels - Localized labels for the component
 */
const AbilityUnlockNotification: React.FC<AbilityUnlockNotificationProps> = ({
  newlyUnlockedAbilities,
  onClose,
  labels
}) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [showAll, setShowAll] = useState(false);

  // Currently displayed ability
  const currentAbility = newlyUnlockedAbilities[currentIndex];

  // Whether there are abilities to display
  const hasAbilities = newlyUnlockedAbilities.length > 0;

  // Whether there is a next ability
  const hasNextAbility = currentIndex < newlyUnlockedAbilities.length - 1;

  // Show next ability
  const showNextAbility = () => {
    if (hasNextAbility) {
      setCurrentIndex(prev => prev + 1);
    } else {
      setShowAll(true);
    }
  };

  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0, scale: 0.9 },
    visible: {
      opacity: 1,
      scale: 1,
      transition: {
        duration: 0.5,
        delayChildren: 0.3,
        staggerChildren: 0.2
      }
    },
    exit: {
      opacity: 0,
      scale: 0.9,
      transition: { duration: 0.3 }
    }
  };

  const itemVariants = {
    hidden: { y: 20, opacity: 0 },
    visible: {
      y: 0,
      opacity: 1,
      transition: { duration: 0.5 }
    }
  };

  // Render single ability unlock notification
  const renderSingleAbility = () => {
    if (!currentAbility) return null;

    return (
      <motion.div
        className="ability-unlock-single"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <motion.div className="ability-unlock-icon" variants={itemVariants}>
          <img
            src={currentAbility.iconPath}
            alt={currentAbility.name}
            onError={(e) => {
              const target = e.target as HTMLImageElement;
              target.onerror = null;
              target.src = '/assets/abilities/default-ability.svg';
            }}
          />
        </motion.div>

        <motion.h3 className="ability-unlock-title" variants={itemVariants}>
          {labels?.newAbilityTitle || 'New Ability Unlocked!'}
        </motion.h3>

        <motion.h4 className="ability-unlock-name" variants={itemVariants}>
          {currentAbility.name}
        </motion.h4>

        <motion.p className="ability-unlock-description" variants={itemVariants}>
          {currentAbility.description}
        </motion.p>

        <motion.div className="ability-unlock-actions" variants={itemVariants}>
          {hasNextAbility ? (
            <Button variant="jade" onClick={showNextAbility}>
              {labels?.nextButtonText || 'Next Ability'}
            </Button>
          ) : (
            <Button variant="jade" onClick={() => setShowAll(true)}>
              {labels?.viewAllButtonText || 'View All Abilities'}
            </Button>
          )}
        </motion.div>
      </motion.div>
    );
  };

  // Render list of all unlocked abilities
  const renderAllAbilities = () => {
    return (
      <motion.div
        className="ability-unlock-all"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <motion.h3 className="ability-unlock-title" variants={itemVariants}>
          {labels?.allUnlockedTitle || 'Newly Unlocked Abilities'}
        </motion.h3>

        <motion.div className="ability-unlock-list" variants={itemVariants}>
          {newlyUnlockedAbilities.map((ability, index) => (
            <div key={index} className="ability-unlock-item">
              <div className="ability-unlock-item-icon">
                <img
                  src={ability.iconPath}
                  alt={ability.name}
                  onError={(e) => {
                    const target = e.target as HTMLImageElement;
                    target.onerror = null;
                    target.src = '/assets/abilities/default-ability.svg';
                  }}
                />
              </div>
              <div className="ability-unlock-item-info">
                <h4 className="ability-unlock-item-name">{ability.name}</h4>
                <p className="ability-unlock-item-description">{ability.description}</p>
              </div>
            </div>
          ))}
        </motion.div>

        <motion.div className="ability-unlock-actions" variants={itemVariants}>
          <Button variant="gold" onClick={onClose}>
            {labels?.closeButtonText || 'Close'}
          </Button>
        </motion.div>
      </motion.div>
    );
  };

  // If no abilities, don't show notification
  if (!hasAbilities) {
    return null;
  }

  return (
    <ScrollDialog
      isOpen={true}
      onClose={onClose}
      title={labels?.title || 'Ability Unlocked'}
      closeOnOutsideClick={false}
      closeOnEsc={false}
      showCloseButton={showAll}
      footer={null}
    >
      <div className="ability-unlock-content">
        <AnimatePresence mode="wait">
          {!showAll ? (
            <motion.div key="single" className="ability-unlock-view">
              {renderSingleAbility()}
            </motion.div>
          ) : (
            <motion.div key="all" className="ability-unlock-view">
              {renderAllAbilities()}
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </ScrollDialog>
  );
};

export default AbilityUnlockNotification;
</file>

<file path="src/components/game/ChallengeCard.tsx">
// src/components/game/ChallengeCard.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { ChallengeRecord, ChallengeStatus, ChallengeDifficulty } from '@/services/challengeService';
import ProgressBar from '@/components/common/ProgressBar';
import { formatTime } from '@/utils/dateUtils';

interface ChallengeCardProps {
  challenge: ChallengeRecord;
  onClick?: (challenge: ChallengeRecord) => void;
  onComplete?: (challengeId: number) => void;
  labels?: {
    statusActive?: string;
    statusCompleted?: string;
    statusExpired?: string;
    statusUpcoming?: string;
    difficultyEasy?: string;
    difficultyMedium?: string;
    difficultyHard?: string;
    difficultyExpert?: string;
    startLabel?: string;
    endLabel?: string;
    completedOnLabel?: string;
    completeButtonText?: string;
    inProgressText?: string;
  };
}

/**
 * 挑战卡片组件
 * 显示挑战的基本信息和进度
 */
const ChallengeCard: React.FC<ChallengeCardProps> = ({ challenge, onClick, onComplete, labels }) => {
  // 获取挑战状态对应的样式类
  const getStatusClass = () => {
    switch (challenge.status) {
      case ChallengeStatus.ACTIVE:
        return 'challenge-active';
      case ChallengeStatus.COMPLETED:
        return 'challenge-completed';
      case ChallengeStatus.EXPIRED:
        return 'challenge-expired';
      case ChallengeStatus.UPCOMING:
        return 'challenge-upcoming';
      default:
        return '';
    }
  };

  // 获取挑战难度对应的样式类
  const getDifficultyClass = () => {
    switch (challenge.difficulty) {
      case ChallengeDifficulty.EASY:
        return 'difficulty-easy';
      case ChallengeDifficulty.MEDIUM:
        return 'difficulty-medium';
      case ChallengeDifficulty.HARD:
        return 'difficulty-hard';
      case ChallengeDifficulty.EXPERT:
        return 'difficulty-expert';
      default:
        return '';
    }
  };

  // 获取挑战难度对应的文本
  const getDifficultyText = () => {
    switch (challenge.difficulty) {
      case ChallengeDifficulty.EASY:
        return labels?.difficultyEasy || 'Easy';
      case ChallengeDifficulty.MEDIUM:
        return labels?.difficultyMedium || 'Medium';
      case ChallengeDifficulty.HARD:
        return labels?.difficultyHard || 'Hard';
      case ChallengeDifficulty.EXPERT:
        return labels?.difficultyExpert || 'Expert';
      default:
        return '';
    }
  };

  // 获取挑战状态对应的文本
  const getStatusText = () => {
    switch (challenge.status) {
      case ChallengeStatus.ACTIVE:
        return labels?.statusActive || 'Active';
      case ChallengeStatus.COMPLETED:
        return labels?.statusCompleted || 'Completed';
      case ChallengeStatus.EXPIRED:
        return labels?.statusExpired || 'Expired';
      case ChallengeStatus.UPCOMING:
        return labels?.statusUpcoming || 'Upcoming';
      default:
        return '';
    }
  };

  // 处理点击事件
  const handleClick = () => {
    if (onClick) {
      onClick(challenge);
    }
  };

  // 处理完成挑战事件
  const handleComplete = (e: React.MouseEvent) => {
    e.stopPropagation(); // 阻止事件冒泡
    if (onComplete && challenge.status === ChallengeStatus.ACTIVE) {
      onComplete(challenge.id!);
    }
  };

  return (
    <motion.div
      className={`challenge-card ${getStatusClass()} ${getDifficultyClass()}`}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={handleClick}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      transition={{ duration: 0.3 }}
    >
      <div className="challenge-card-header">
        <div className="challenge-icon">
          <img src={challenge.iconPath} alt={challenge.title} />
        </div>
        <div className="challenge-title-section">
          <h3 className="challenge-title">{challenge.title}</h3>
          <div className="challenge-meta">
            <span className={`challenge-difficulty ${getDifficultyClass()}`}>
              {getDifficultyText()}
            </span>
            <span className={`challenge-status ${getStatusClass()}`}>
              {getStatusText()}
            </span>
          </div>
        </div>
      </div>

      <div className="challenge-card-body">
        <p className="challenge-description">{challenge.description}</p>

        <div className="challenge-progress-section">
          <ProgressBar
            progress={challenge.progress}
            total={100}
            showPercentage
            className={getStatusClass()}
          />
          <div className="challenge-dates">
            <span>{labels?.startLabel || 'Start'}: {formatTime(challenge.startDate, false)}</span>
            {challenge.endDate && (
              <span>{labels?.endLabel || 'End'}: {formatTime(challenge.endDate, false)}</span>
            )}
          </div>
        </div>
      </div>

      <div className="challenge-card-footer">
        {challenge.status === ChallengeStatus.ACTIVE && (
          <button
            className="complete-challenge-button"
            onClick={handleComplete}
            disabled={challenge.progress < 100}
          >
            {challenge.progress >= 100 ? (labels?.completeButtonText || 'Complete Challenge') : (labels?.inProgressText || 'In Progress...')}
          </button>
        )}
        {challenge.status === ChallengeStatus.COMPLETED && (
          <div className="challenge-completed-info">
            <span className="completion-date">
              {labels?.completedOnLabel || 'Completed on'}: {formatTime(challenge.completedDate!, false)}
            </span>
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default ChallengeCard;
</file>

<file path="src/components/game/ChallengeDiscoveryCard.tsx">
// src/components/game/ChallengeDiscoveryCard.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { ChallengeDiscovery, markDiscoveryAsViewed, acceptChallenge } from '@/services/challengeDiscoveryService';
import { ChallengeRecord, getChallenge, ChallengeDifficulty } from '@/services/challengeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import { ChallengeDiscoveryCardLabels } from '@/types';

interface ChallengeDiscoveryCardProps {
  discovery: ChallengeDiscovery;
  onAccept?: () => void;
  onDecline?: () => void;
  onClose?: () => void;
  labels?: ChallengeDiscoveryCardLabels;
}

/**
 * Challenge discovery card component
 * Used to display discovered challenges and related actions
 *
 * @param discovery - Challenge discovery data
 * @param onAccept - Callback function when challenge is accepted
 * @param onDecline - Callback function when challenge is declined
 * @param onClose - Callback function when card is closed
 * @param labels - Localized labels for the component
 */
const ChallengeDiscoveryCard: React.FC<ChallengeDiscoveryCardProps> = ({
  discovery,
  onAccept,
  onDecline,
  onClose,
  labels
}) => {
  // Add console log to check labels
  console.log('ChallengeDiscoveryCard labels:', labels);
  const [challenge, setChallenge] = useState<ChallengeRecord | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isAccepting, setIsAccepting] = useState(false);
  const [isVisible, setIsVisible] = useState(true);

  // 加载挑战数据
  useEffect(() => {
    const loadChallenge = async () => {
      try {
        setIsLoading(true);
        setError(null);

        // 获取挑战数据
        const challengeData = await getChallenge(discovery.challengeId);
        if (challengeData) {
          setChallenge(challengeData);

          // 标记为已查看
          if (!discovery.isViewed) {
            await markDiscoveryAsViewed(discovery.id!);
          }
        } else {
          setError(labels?.cannotLoadChallenge || 'Unable to load challenge data');
        }
      } catch (err) {
        console.error('Failed to load challenge:', err);
        setError(labels?.errorLoadingChallenge || 'Failed to load challenge, please try again');
      } finally {
        setIsLoading(false);
      }
    };

    loadChallenge();
  }, [discovery]);

  // 处理接受挑战
  const handleAccept = async () => {
    try {
      setIsAccepting(true);

      // 接受挑战
      await acceptChallenge(discovery.id!);

      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);

      // 触发关闭动画
      setIsVisible(false);

      // 通知父组件
      if (onAccept) {
        setTimeout(() => {
          onAccept();
        }, 300); // 等待关闭动画完成
      }
    } catch (err) {
      console.error('Failed to accept challenge:', err);
      setError('接受挑战失败，请重试');
    } finally {
      setIsAccepting(false);
    }
  };

  // 处理拒绝挑战
  const handleDecline = () => {
    // 播放点击音效
    playSound(SoundType.BUTTON_CLICK, 0.3);

    // 触发关闭动画
    setIsVisible(false);

    // 通知父组件
    if (onDecline) {
      setTimeout(() => {
        onDecline();
      }, 300); // 等待关闭动画完成
    }
  };

  // 处理关闭卡片
  const handleClose = () => {
    // 播放点击音效
    playSound(SoundType.BUTTON_CLICK, 0.3);

    // 触发关闭动画
    setIsVisible(false);

    // 通知父组件
    if (onClose) {
      setTimeout(() => {
        onClose();
      }, 300); // 等待关闭动画完成
    }
  };

  // 获取难度标签和样式
  const getDifficultyInfo = (difficulty: ChallengeDifficulty) => {
    switch (difficulty) {
      case ChallengeDifficulty.EASY:
        return { label: '简单', className: 'bg-green-100 text-green-800' };
      case ChallengeDifficulty.MEDIUM:
        return { label: '中等', className: 'bg-blue-100 text-blue-800' };
      case ChallengeDifficulty.HARD:
        return { label: '困难', className: 'bg-orange-100 text-orange-800' };
      case ChallengeDifficulty.EXPERT:
        return { label: '专家', className: 'bg-red-100 text-red-800' };
      default:
        return { label: '未知', className: 'bg-gray-100 text-gray-800' };
    }
  };

  // 计算剩余时间
  const getRemainingTime = () => {
    if (!discovery.expiresAt) return '永不过期';

    const now = new Date();
    const expiresAt = new Date(discovery.expiresAt);
    const diffMs = expiresAt.getTime() - now.getTime();

    if (diffMs <= 0) return '已过期';

    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    const diffHours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));

    if (diffDays > 0) {
      return `${diffDays}天${diffHours}小时`;
    } else {
      return `${diffHours}小时`;
    }
  };

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          className="challenge-discovery-card border-2 border-gold rounded-lg overflow-hidden bg-white shadow-lg"
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.9 }}
          transition={{ duration: 0.3 }}
        >
          {/* 卡片头部 */}
          <div className="card-header bg-amber-50 p-4 border-b border-amber-200 relative">
            <div className="absolute top-2 right-2">
              <button
                onClick={handleClose}
                className="text-gray-500 hover:text-gray-700"
                aria-label={labels?.closeButtonAriaLabel || "Close"}
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                </svg>
              </button>
            </div>
            <h3 className="text-xl font-bold text-amber-800">发现新挑战！</h3>
            <p className="text-sm text-amber-600">
              剩余时间: {getRemainingTime()}
            </p>
          </div>

          {/* 卡片内容 */}
          <div className="card-content p-4">
            {isLoading ? (
              <div className="flex justify-center items-center h-32">
                <LoadingSpinner variant="jade" size="medium" />
              </div>
            ) : error ? (
              <div className="error-message text-red-500 text-center p-4">
                {error}
              </div>
            ) : challenge ? (
              <div className="challenge-info">
                <div className="challenge-header flex items-center mb-3">
                  <div className="challenge-icon mr-3">
                    <img
                      src={challenge.iconPath}
                      alt={challenge.title}
                      className="w-12 h-12 object-contain"
                      onError={(e) => {
                        const target = e.target as HTMLImageElement;
                        target.onerror = null;
                        target.src = '/assets/challenges/default.svg';
                      }}
                    />
                  </div>
                  <div className="challenge-title-container">
                    <h4 className="text-lg font-bold">{challenge.title}</h4>
                    <div className="challenge-meta flex flex-wrap gap-2 mt-1">
                      {challenge.difficulty && (
                        <span className={`px-2 py-1 rounded-full text-xs ${getDifficultyInfo(challenge.difficulty).className}`}>
                          {getDifficultyInfo(challenge.difficulty).label}
                        </span>
                      )}
                    </div>
                  </div>
                </div>

                <div className="challenge-description mb-4">
                  <p className="text-gray-700">{challenge.description}</p>
                </div>

                <div className="challenge-dates text-sm text-gray-600 mb-4">
                  <p>{labels?.startDateLabel || 'Start Date'}: {new Date(challenge.startDate).toLocaleDateString()}</p>
                  {challenge.endDate && (
                    <p>{labels?.endDateLabel || 'End Date'}: {new Date(challenge.endDate).toLocaleDateString()}</p>
                  )}
                </div>
              </div>
            ) : (
              <div className="text-center p-4">
                {labels?.cannotLoadChallenge || 'Unable to load challenge information'}
              </div>
            )}
          </div>

          {/* 卡片底部 */}
          <div className="card-footer bg-gray-50 p-4 border-t border-gray-200 flex justify-end gap-2">
            <Button
              variant="secondary"
              onClick={handleDecline}
              disabled={isAccepting}
            >
              {labels?.laterButton || 'Maybe Later'}
            </Button>
            <Button
              variant="jade"
              onClick={handleAccept}
              disabled={isAccepting || !challenge}
            >
              {isAccepting ? (
                <LoadingSpinner variant="white" size="small" />
              ) : (
                labels?.acceptButton || 'Accept Challenge'
              )}
            </Button>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default ChallengeDiscoveryCard;
</file>

<file path="src/components/game/ChallengeDiscoverySection.tsx">
// src/components/game/ChallengeDiscoverySection.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  getRecommendedChallenges,
  getUnviewedDiscoveries,
  ChallengeRecommendation,
  ChallengeDiscovery
} from '@/services/challengeDiscoveryService';
import { updateChallenge, ChallengeStatus } from '@/services/challengeService';
import ChallengeRecommendationCard from './ChallengeRecommendationCard';
import ChallengeDiscoveryCard from './ChallengeDiscoveryCard';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import { ChallengeDiscoveryCardLabels, ChallengeRecommendationCardLabels } from '@/types';

interface ChallengeDiscoverySectionProps {
  onChallengeAccepted?: () => void;
  onChallengeViewed?: (challengeId: number) => void;
  labels?: {
    challengeDiscoveryCard?: ChallengeDiscoveryCardLabels;
    challengeRecommendationCard?: ChallengeRecommendationCardLabels;
  };
}

/**
 * Challenge discovery section component
 * Used to display challenge discoveries and recommendations
 *
 * @param onChallengeAccepted - Callback function when a challenge is accepted
 * @param onChallengeViewed - Callback function when a challenge is viewed
 * @param labels - Localized labels for the component
 */
const ChallengeDiscoverySection: React.FC<ChallengeDiscoverySectionProps> = ({
  onChallengeAccepted,
  onChallengeViewed,
  labels
}) => {
  // Add console log to check labels
  console.log('ChallengeDiscoverySection labels:', labels);
  const [recommendations, setRecommendations] = useState<ChallengeRecommendation[]>([]);
  const [discoveries, setDiscoveries] = useState<ChallengeDiscovery[]>([]);
  const [currentDiscoveryIndex, setCurrentDiscoveryIndex] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showRecommendations, setShowRecommendations] = useState(false);

  // 加载推荐和发现
  const loadData = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // 获取未查看的挑战发现
      const unviewedDiscoveries = await getUnviewedDiscoveries();
      setDiscoveries(unviewedDiscoveries);

      // 获取推荐的挑战
      const recommendedChallenges = await getRecommendedChallenges(3);
      setRecommendations(recommendedChallenges);
    } catch (err) {
      console.error('Failed to load challenge discoveries:', err);
      setError('加载挑战发现失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadData();
  }, []);

  // 注册数据刷新监听
  useRegisterTableRefresh('challengeDiscoveries', loadData);
  useRegisterTableRefresh('challenges', loadData);

  // 处理接受挑战
  const handleAcceptChallenge = async (challengeId: number) => {
    try {
      // 更新挑战状态为活跃
      await updateChallenge(challengeId, {
        status: ChallengeStatus.ACTIVE
      });

      // 重新加载数据
      await loadData();

      // 通知父组件
      if (onChallengeAccepted) {
        onChallengeAccepted();
      }
    } catch (err) {
      console.error('Failed to accept challenge:', err);
      setError('接受挑战失败，请重试');
    }
  };

  // 处理查看挑战详情
  const handleViewChallengeDetails = (challengeId: number) => {
    // 通知父组件
    if (onChallengeViewed) {
      onChallengeViewed(challengeId);
    }
  };

  // 处理接受发现的挑战
  const handleAcceptDiscovery = () => {
    // 移除当前发现
    setDiscoveries(prevDiscoveries =>
      prevDiscoveries.filter((_, index) => index !== currentDiscoveryIndex)
    );

    // 重置索引
    setCurrentDiscoveryIndex(0);

    // 通知父组件
    if (onChallengeAccepted) {
      onChallengeAccepted();
    }
  };

  // 处理拒绝发现的挑战
  const handleDeclineDiscovery = () => {
    // 移除当前发现
    setDiscoveries(prevDiscoveries =>
      prevDiscoveries.filter((_, index) => index !== currentDiscoveryIndex)
    );

    // 重置索引
    setCurrentDiscoveryIndex(0);
  };

  // 处理关闭发现卡片
  const handleCloseDiscovery = () => {
    // 移除当前发现
    setDiscoveries(prevDiscoveries =>
      prevDiscoveries.filter((_, index) => index !== currentDiscoveryIndex)
    );

    // 重置索引
    setCurrentDiscoveryIndex(0);
  };

  // 切换显示推荐
  const toggleRecommendations = () => {
    setShowRecommendations(prev => !prev);
  };

  // 当前发现
  const currentDiscovery = discoveries.length > 0 ? discoveries[currentDiscoveryIndex] : null;

  // 容器变体
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // 项目变体
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  if (isLoading) {
    return (
      <div className="challenge-discovery-section p-4">
        <LoadingSpinner variant="jade" size="medium" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="challenge-discovery-section p-4">
        <div className="error-message text-red-500 mb-2">{error}</div>
        <Button variant="jade" onClick={loadData}>
          重试
        </Button>
      </div>
    );
  }

  return (
    <div className="challenge-discovery-section">
      {/* 挑战发现卡片 */}
      {currentDiscovery && (
        <div className="challenge-discovery-container mb-6">
          <ChallengeDiscoveryCard
            discovery={currentDiscovery}
            onAccept={handleAcceptDiscovery}
            onDecline={handleDeclineDiscovery}
            onClose={handleCloseDiscovery}
            labels={labels?.challengeDiscoveryCard}
          />
        </div>
      )}

      {/* 挑战推荐区域 */}
      <div className="challenge-recommendations-container">
        <div className="section-header flex justify-between items-center mb-4">
          <h3 className="text-lg font-bold">推荐挑战</h3>
          <Button
            variant="secondary"
            size="small"
            onClick={toggleRecommendations}
          >
            {showRecommendations ? '隐藏推荐' : '查看推荐'}
          </Button>
        </div>

        <AnimatePresence>
          {showRecommendations && (
            <motion.div
              className="recommendations-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
              variants={containerVariants}
              initial="hidden"
              animate="visible"
              exit={{ opacity: 0 }}
            >
              {recommendations.length > 0 ? (
                recommendations.map((recommendation, index) => (
                  <motion.div
                    key={`recommendation-${recommendation.challenge.id}`}
                    variants={itemVariants}
                  >
                    <ChallengeRecommendationCard
                      recommendation={recommendation}
                      onAccept={handleAcceptChallenge}
                      onViewDetails={handleViewChallengeDetails}
                      labels={labels?.challengeRecommendationCard}
                    />
                  </motion.div>
                ))
              ) : (
                <motion.div
                  className="no-recommendations col-span-full text-center p-4 text-gray-500"
                  variants={itemVariants}
                >
                  暂无推荐挑战
                </motion.div>
              )}
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );
};

export default ChallengeDiscoverySection;
</file>

<file path="src/components/game/ChallengeList.tsx">
// src/components/game/ChallengeList.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  ChallengeRecord,
  ChallengeStatus,
  ChallengeType,
  ChallengeDifficulty,
  getAllChallenges,
  completeChallenge
} from '@/services/challengeService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import ChallengeCard from './ChallengeCard';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import RewardModal from '@/components/game/RewardModal';
import { RewardRecord } from '@/services/rewardService';
import ScrollDialog from './ScrollDialog';

interface ChallengeListProps {
  filter?: {
    status?: ChallengeStatus;
    type?: ChallengeType;
    difficulty?: ChallengeDifficulty;
  };
  onSelectChallenge?: (challenge: ChallengeRecord) => void;
  labels?: {
    statusLabel?: string;
    typeLabel?: string;
    difficultyLabel?: string;
    progressLabel?: string;
    statusActive?: string;
    statusCompleted?: string;
    statusExpired?: string;
    statusUpcoming?: string;
    difficultyEasy?: string;
    difficultyMedium?: string;
    difficultyHard?: string;
    difficultyExpert?: string;
    startLabel?: string;
    endLabel?: string;
    completedOnLabel?: string;
    completeButtonText?: string;
    inProgressText?: string;
    noItemsMessage?: string;
  };
}

/**
 * Challenge List Component
 * Displays a list of challenges with filtering and selection support
 */
const ChallengeList: React.FC<ChallengeListProps> = ({ filter, onSelectChallenge, labels }) => {
  const [challenges, setChallenges] = useState<ChallengeRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [showRewardModal, setShowRewardModal] = useState(false);
  const [selectedChallenge, setSelectedChallenge] = useState<ChallengeRecord | null>(null);
  const [showChallengeDetails, setShowChallengeDetails] = useState(false);

  // Load challenges
  const loadChallenges = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const challengeList = await getAllChallenges(filter);
      setChallenges(challengeList);
    } catch (err) {
      console.error('Failed to load challenges:', err);
      setError('Failed to load challenges. Please try again.');
    } finally {
      setIsLoading(false);
    }
  }, [filter]);

  // Initial loading
  useEffect(() => {
    loadChallenges();
  }, [loadChallenges]);

  // Define challenge data update handler
  const handleChallengeDataUpdate = useCallback((challengeData: any) => {
    // If there is specific challenge data, update that challenge
    if (challengeData && challengeData.id) {
      setChallenges(prevChallenges => {
        // Check if challenge already exists
        const challengeExists = prevChallenges.some(challenge => challenge.id === challengeData.id);

        if (challengeExists) {
          // Update existing challenge
          return prevChallenges.map(challenge =>
            challenge.id === challengeData.id ? { ...challenge, ...challengeData } : challenge
          );
        } else {
          // Add new challenge (if it matches filter criteria)
          if (!filter ||
              ((!filter.status || challengeData.status === filter.status) &&
               (!filter.type || challengeData.type === filter.type) &&
               (!filter.difficulty || challengeData.difficulty === filter.difficulty))) {
            return [...prevChallenges, challengeData];
          }
          return prevChallenges;
        }
      });
    } else {
      // If no specific challenge data, reload all challenges
      loadChallenges();
    }
  }, [loadChallenges, filter]);

  // Use useRegisterTableRefresh hook to listen for changes in the challenges table
  useRegisterTableRefresh('challenges', handleChallengeDataUpdate);

  // Handle challenge selection
  const handleSelectChallenge = (challenge: ChallengeRecord) => {
    setSelectedChallenge(challenge);
    setShowChallengeDetails(true);

    if (onSelectChallenge) {
      onSelectChallenge(challenge);
    }
  };

  // Handle challenge completion
  const handleCompleteChallenge = async (challengeId: number) => {
    try {
      setIsLoading(true);

      // Complete challenge and get rewards
      const challengeRewards = await completeChallenge(challengeId);

      // Update challenge list
      setChallenges(prevChallenges =>
        prevChallenges.map(challenge =>
          challenge.id === challengeId
            ? {
                ...challenge,
                status: ChallengeStatus.COMPLETED,
                progress: 100,
                completedDate: new Date()
              }
            : challenge
        )
      );

      // Show rewards
      if (challengeRewards && challengeRewards.length > 0) {
        setRewards(challengeRewards);
        setShowRewardModal(true);
      }
    } catch (err) {
      console.error('Failed to complete challenge:', err);
      setError('Failed to complete challenge. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  // Close reward modal
  const handleCloseRewardModal = () => {
    setShowRewardModal(false);
  };

  // Close challenge details
  const handleCloseChallengeDetails = () => {
    setShowChallengeDetails(false);
    setSelectedChallenge(null);
  };

  // If loading, show loading spinner
  if (isLoading && challenges.length === 0) {
    return <LoadingSpinner />;
  }

  // If error, show error message
  if (error && challenges.length === 0) {
    return <div className="error-message">{error}</div>;
  }

  // If no challenges, show message
  if (challenges.length === 0) {
    return <div className="no-challenges-message">{labels?.noItemsMessage || 'No challenges available'}</div>;
  }

  return (
    <div className="challenge-list">
      <AnimatePresence>
        {challenges.map(challenge => (
          <ChallengeCard
            key={challenge.id}
            challenge={challenge}
            onClick={handleSelectChallenge}
            onComplete={handleCompleteChallenge}
            labels={labels}
          />
        ))}
      </AnimatePresence>

      {/* Reward modal */}
      {showRewardModal && (
        <RewardModal
          rewards={rewards}
          onClose={handleCloseRewardModal}
        />
      )}

      {/* Challenge details */}
      {showChallengeDetails && selectedChallenge && (
        <ScrollDialog
          title={selectedChallenge.title}
          onClose={handleCloseChallengeDetails}
        >
          <div className="challenge-details">
            <div className="challenge-header">
              <img
                src={selectedChallenge.iconPath}
                alt={selectedChallenge.title}
                className="challenge-icon-large"
              />
              <div className="challenge-meta-details">
                <div className="challenge-difficulty">
                  {labels?.difficultyLabel || 'Difficulty'}: {
                    selectedChallenge.difficulty === ChallengeDifficulty.EASY ? (labels?.difficultyEasy || 'Easy') :
                    selectedChallenge.difficulty === ChallengeDifficulty.MEDIUM ? (labels?.difficultyMedium || 'Medium') :
                    selectedChallenge.difficulty === ChallengeDifficulty.HARD ? (labels?.difficultyHard || 'Hard') :
                    selectedChallenge.difficulty === ChallengeDifficulty.EXPERT ? (labels?.difficultyExpert || 'Expert') :
                    selectedChallenge.difficulty
                  }
                </div>
                <div className="challenge-type">
                  {labels?.typeLabel || 'Type'}: {selectedChallenge.type}
                </div>
                <div className="challenge-status">
                  {labels?.statusLabel || 'Status'}: {
                    selectedChallenge.status === ChallengeStatus.ACTIVE ? (labels?.statusActive || 'Active') :
                    selectedChallenge.status === ChallengeStatus.COMPLETED ? (labels?.statusCompleted || 'Completed') :
                    selectedChallenge.status === ChallengeStatus.UPCOMING ? (labels?.statusUpcoming || 'Upcoming') :
                    selectedChallenge.status
                  }
                </div>
              </div>
            </div>

            <div className="challenge-description-full">
              {selectedChallenge.description}
            </div>

            <div className="challenge-progress-details">
              <h4>{labels?.progressLabel || 'Progress'}: {selectedChallenge.progress}%</h4>
              <div className="progress-bar-container">
                <div
                  className="progress-bar-fill"
                  style={{ width: `${selectedChallenge.progress}%` }}
                ></div>
              </div>
            </div>

            <div className="challenge-dates-details">
              <div>{labels?.startLabel || 'Start Date'}: {selectedChallenge.startDate.toLocaleDateString()}</div>
              {selectedChallenge.endDate && (
                <div>{labels?.endLabel || 'End Date'}: {selectedChallenge.endDate.toLocaleDateString()}</div>
              )}
              {selectedChallenge.completedDate && (
                <div>{labels?.completedOnLabel || 'Completed On'}: {selectedChallenge.completedDate.toLocaleDateString()}</div>
              )}
            </div>

            {selectedChallenge.status === ChallengeStatus.ACTIVE && (
              <button
                className="complete-challenge-button-large"
                onClick={() => handleCompleteChallenge(selectedChallenge.id!)}
                disabled={selectedChallenge.progress < 100}
              >
                {selectedChallenge.progress >= 100 ? (labels?.completeButtonText || 'Complete Challenge') : (labels?.inProgressText || 'Keep Going')}
              </button>
            )}
          </div>
        </ScrollDialog>
      )}
    </div>
  );
};

export default ChallengeList;
</file>

<file path="src/components/game/ChallengeRecommendationCard.tsx">
// src/components/game/ChallengeRecommendationCard.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { ChallengeRecommendation } from '@/services/challengeDiscoveryService';
import { ChallengeDifficulty } from '@/services/challengeService';
import Button from '@/components/common/Button';
import { playSound, SoundType } from '@/utils/sound';
import { ChallengeRecommendationCardLabels } from '@/types';

interface ChallengeRecommendationCardProps {
  recommendation: ChallengeRecommendation;
  onAccept?: (challengeId: number) => void;
  onViewDetails?: (challengeId: number) => void;
  labels?: ChallengeRecommendationCardLabels;
}

/**
 * Challenge recommendation card component
 * Used to display recommended challenges and related actions
 *
 * @param recommendation - Challenge recommendation data
 * @param onAccept - Callback function when challenge is accepted
 * @param onViewDetails - Callback function when challenge details are viewed
 * @param labels - Localized labels for the component
 */
const ChallengeRecommendationCard: React.FC<ChallengeRecommendationCardProps> = ({
  recommendation,
  onAccept,
  onViewDetails,
  labels
}) => {
  // Add console log to check labels
  console.log('ChallengeRecommendationCard labels:', labels);
  const { challenge, score, reason } = recommendation;

  // 处理接受挑战
  const handleAccept = () => {
    // 播放成功音效
    playSound(SoundType.SUCCESS, 0.5);

    // 通知父组件
    if (onAccept) {
      onAccept(challenge.id!);
    }
  };

  // 处理查看详情
  const handleViewDetails = () => {
    // 播放点击音效
    playSound(SoundType.BUTTON_CLICK, 0.3);

    // 通知父组件
    if (onViewDetails) {
      onViewDetails(challenge.id!);
    }
  };

  // Get difficulty label and style with localization
  const getDifficultyInfo = (difficulty: ChallengeDifficulty) => {
    switch (difficulty) {
      case ChallengeDifficulty.EASY:
        return {
          label: labels?.difficultyEasy || 'Easy',
          className: 'bg-green-100 text-green-800'
        };
      case ChallengeDifficulty.MEDIUM:
        return {
          label: labels?.difficultyMedium || 'Medium',
          className: 'bg-blue-100 text-blue-800'
        };
      case ChallengeDifficulty.HARD:
        return {
          label: labels?.difficultyHard || 'Hard',
          className: 'bg-orange-100 text-orange-800'
        };
      case ChallengeDifficulty.EXPERT:
        return {
          label: labels?.difficultyExpert || 'Expert',
          className: 'bg-red-100 text-red-800'
        };
      default:
        return {
          label: labels?.difficultyUnknown || 'Unknown',
          className: 'bg-gray-100 text-gray-800'
        };
    }
  };

  // 获取推荐分数样式
  const getScoreStyle = (score: number) => {
    if (score >= 30) {
      return 'text-green-600';
    } else if (score >= 20) {
      return 'text-blue-600';
    } else if (score >= 10) {
      return 'text-amber-600';
    } else {
      return 'text-gray-600';
    }
  };

  return (
    <motion.div
      className="challenge-recommendation-card border rounded-lg overflow-hidden bg-white shadow-md hover:shadow-lg transition-shadow"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
    >
      {/* 卡片头部 */}
      <div className="card-header bg-gray-50 p-3 border-b border-gray-200 flex justify-between items-center">
        <h3 className="text-md font-bold">{challenge.title}</h3>
        <div className="recommendation-score">
          <span className={`text-sm font-bold ${getScoreStyle(score)}`}>
            {labels?.matchScoreLabel || 'Match Score'}: {Math.min(100, Math.round(score * 2))}%
          </span>
        </div>
      </div>

      {/* 卡片内容 */}
      <div className="card-content p-3">
        <div className="challenge-meta flex flex-wrap gap-2 mb-2">
          {challenge.difficulty && (
            <span className={`px-2 py-1 rounded-full text-xs ${getDifficultyInfo(challenge.difficulty).className}`}>
              {getDifficultyInfo(challenge.difficulty).label}
            </span>
          )}
          <span className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800">
            {challenge.type.charAt(0).toUpperCase() + challenge.type.slice(1)}
          </span>
        </div>

        <div className="challenge-description mb-2">
          <p className="text-sm text-gray-700 line-clamp-2">{challenge.description}</p>
        </div>

        <div className="recommendation-reason mb-3">
          <p className="text-xs text-gray-600 italic">{reason}</p>
        </div>

        <div className="challenge-dates text-xs text-gray-500 mb-2">
          <p>{labels?.startDateLabel || 'Start Date'}: {new Date(challenge.startDate).toLocaleDateString()}</p>
          {challenge.endDate && (
            <p>{labels?.endDateLabel || 'End Date'}: {new Date(challenge.endDate).toLocaleDateString()}</p>
          )}
        </div>
      </div>

      {/* 卡片底部 */}
      <div className="card-footer bg-gray-50 p-2 border-t border-gray-200 flex justify-end gap-2">
        <Button
          variant="secondary"
          size="small"
          onClick={handleViewDetails}
        >
          {labels?.viewDetailsButton || 'View Details'}
        </Button>
        <Button
          variant="jade"
          size="small"
          onClick={handleAccept}
        >
          {labels?.acceptButton || 'Accept Challenge'}
        </Button>
      </div>
    </motion.div>
  );
};

export default ChallengeRecommendationCard;
</file>

<file path="src/components/game/DialogDemo.tsx">
// src/components/game/DialogDemo.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import ScrollDialog from './ScrollDialog';
import LatticeDialog from './LatticeDialog';
import Button from '@/components/common/Button';

/**
 * 对话框演示组件
 * 用于展示不同风格的对话框组件
 */
const DialogDemo: React.FC = () => {
  const [isScrollDialogOpen, setIsScrollDialogOpen] = useState(false);
  const [isLatticeDialogOpen, setIsLatticeDialogOpen] = useState(false);
  const [isConfirmDialogOpen, setIsConfirmDialogOpen] = useState(false);

  // 打开卷轴对话框
  const openScrollDialog = () => {
    setIsScrollDialogOpen(true);
  };

  // 关闭卷轴对话框
  const closeScrollDialog = () => {
    setIsScrollDialogOpen(false);
  };

  // 打开窗棂对话框
  const openLatticeDialog = () => {
    setIsLatticeDialogOpen(true);
  };

  // 关闭窗棂对话框
  const closeLatticeDialog = () => {
    setIsLatticeDialogOpen(false);
  };

  // 打开确认对话框
  const openConfirmDialog = () => {
    setIsConfirmDialogOpen(true);
  };

  // 关闭确认对话框
  const closeConfirmDialog = () => {
    setIsConfirmDialogOpen(false);
  };

  // 确认操作
  const handleConfirm = () => {
    alert('操作已确认！');
    closeConfirmDialog();
  };

  // 确认对话框的底部按钮
  const confirmDialogFooter = (
    <>
      <Button variant="secondary" onClick={closeConfirmDialog}>
        取消
      </Button>
      <Button variant="jade" onClick={handleConfirm}>
        确认
      </Button>
    </>
  );

  return (
    <div className="dialog-demo">
      <h2>对话框演示</h2>
      
      <div style={{ display: 'flex', gap: '16px', marginBottom: '24px' }}>
        <Button variant="jade" onClick={openScrollDialog}>
          打开卷轴对话框
        </Button>
        
        <Button variant="gold" onClick={openLatticeDialog}>
          打开窗棂对话框
        </Button>
        
        <Button variant="primary" onClick={openConfirmDialog}>
          打开确认对话框
        </Button>
      </div>

      {/* 卷轴风格对话框 */}
      <ScrollDialog
        isOpen={isScrollDialogOpen}
        onClose={closeScrollDialog}
        title="熊猫传说"
      >
        <div style={{ padding: '0 16px' }}>
          <p>
            很久很久以前，在一个被竹林环绕的山谷里，生活着一群神奇的熊猫。它们不仅会说人类的语言，还掌握着古老的智慧。
          </p>
          <p>
            传说中，这些熊猫是天上的星辰化身，它们来到人间是为了指引人们找到内心的平静与坚持。每当有人迷失方向或放弃自己的目标时，熊猫就会出现，用它们的智慧和耐心帮助人们重新找回前进的道路。
          </p>
          <p>
            这些熊猫会教导人们如何像竹子一样坚韧不拔，在风雨中依然挺立；如何像流水一样灵活应变，绕过生活中的障碍；如何像山石一样沉稳坚定，不被外界的喧嚣所动摇。
          </p>
          <p>
            据说，只要你真心相信并坚持不懈地追求自己的目标，熊猫的智慧就会在你的心中显现，指引你走向成功和幸福。
          </p>
        </div>
      </ScrollDialog>

      {/* 窗棂风格对话框 */}
      <LatticeDialog
        isOpen={isLatticeDialogOpen}
        onClose={closeLatticeDialog}
        title="熊猫伙伴设置"
      >
        <div>
          <div className="form-group">
            <label htmlFor="panda-name">熊猫名称</label>
            <input
              id="panda-name"
              type="text"
              placeholder="给你的熊猫伙伴起个名字"
              defaultValue="竹竹"
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="panda-color">熊猫颜色主题</label>
            <select id="panda-color" defaultValue="classic">
              <option value="classic">经典黑白</option>
              <option value="golden">金色传说</option>
              <option value="jade">翡翠绿</option>
              <option value="blue">青花蓝</option>
            </select>
          </div>
          
          <div className="form-group">
            <label>熊猫互动提醒</label>
            <div style={{ display: 'flex', gap: '16px' }}>
              <label>
                <input type="checkbox" defaultChecked /> 喂食提醒
              </label>
              <label>
                <input type="checkbox" defaultChecked /> 玩耍提醒
              </label>
              <label>
                <input type="checkbox" defaultChecked /> 训练提醒
              </label>
            </div>
          </div>
        </div>
      </LatticeDialog>

      {/* 确认对话框 */}
      <LatticeDialog
        isOpen={isConfirmDialogOpen}
        onClose={closeConfirmDialog}
        title="操作确认"
        footer={confirmDialogFooter}
      >
        <div style={{ textAlign: 'center', padding: '16px 0' }}>
          <p>您确定要执行此操作吗？</p>
          <p style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>
            此操作无法撤销，请谨慎确认。
          </p>
        </div>
      </LatticeDialog>
    </div>
  );
};

export default DialogDemo;
</file>

<file path="src/components/game/LatticeDialog.tsx">
// src/components/game/LatticeDialog.tsx
import React from 'react';
import { motion } from 'framer-motion';
import Modal from '@/components/common/Modal';
import Button from '@/components/common/Button';

interface LatticeDialogProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
  footer?: React.ReactNode;
  closeOnOutsideClick?: boolean;
  closeOnEsc?: boolean;
  showCloseButton?: boolean;
}

/**
 * 窗棂风格对话框组件
 * 设计为中国传统窗棂样式，适合展示操作确认、设置或表单
 * 
 * @param isOpen - 控制对话框是否显示
 * @param onClose - 关闭对话框的回调函数
 * @param title - 对话框标题
 * @param children - 对话框内容
 * @param footer - 对话框底部内容，通常是按钮
 * @param closeOnOutsideClick - 是否在点击外部区域时关闭，默认为true
 * @param closeOnEsc - 是否在按下ESC键时关闭，默认为true
 * @param showCloseButton - 是否显示关闭按钮，默认为true
 */
const LatticeDialog: React.FC<LatticeDialogProps> = ({
  isOpen,
  onClose,
  title,
  children,
  footer,
  closeOnOutsideClick = true,
  closeOnEsc = true,
  showCloseButton = true,
}) => {
  // 默认底部内容
  const defaultFooter = (
    <Button variant="jade" onClick={onClose}>
      确认
    </Button>
  );

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      closeOnOutsideClick={closeOnOutsideClick}
      closeOnEsc={closeOnEsc}
      className="lattice-modal"
    >
      <div className="lattice-modal-header">
        <h3 className="lattice-modal-title">{title}</h3>
        {showCloseButton && (
          <motion.button
            className="lattice-modal-close"
            onClick={onClose}
            whileHover={{ scale: 1.1 }}
            whileTap={{ scale: 0.9 }}
            aria-label="关闭"
          >
            ×
          </motion.button>
        )}
      </div>

      <div className="lattice-modal-content">
        {children}
      </div>

      {(footer || defaultFooter) && (
        <div className="lattice-modal-footer">
          {footer || defaultFooter}
        </div>
      )}
    </Modal>
  );
};

export default LatticeDialog;
</file>

<file path="src/components/game/LuckyDrawWheel.tsx">
// src/components/game/LuckyDrawWheel.tsx
import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Button from '@/components/common/Button';
import { RewardRecord, RewardRarity } from '@/services/rewardService';
import { playSound, SoundType } from '@/utils/sound';
import RewardAnimation from '@/components/animation/RewardAnimation';
import ScrollDialog from './ScrollDialog';
import { getLuckyPointsTotal, performLuckyDraw } from '@/services/timelyRewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import LuckyPointsDisplay from './LuckyPointsDisplay';

interface LuckyDrawWheelProps {
  isOpen: boolean;
  onClose: () => void;
  onRewardEarned?: (rewards: RewardRecord[]) => void;
}

/**
 * 幸运抽奖轮盘组件
 * 用于实现带有旋转轮盘的幸运抽奖功能
 */
const LuckyDrawWheel: React.FC<LuckyDrawWheelProps> = ({
  isOpen,
  onClose,
  onRewardEarned
}) => {
  const [isDrawing, setIsDrawing] = useState(false);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [points, setPoints] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showReward, setShowReward] = useState(false);
  const [currentRewardIndex, setCurrentRewardIndex] = useState(0);
  const [selectedPoints, setSelectedPoints] = useState(10); // 默认使用10点
  const wheelRef = useRef<HTMLDivElement>(null);
  const [wheelRotation, setWheelRotation] = useState(0);
  const [isWheelSpinning, setIsWheelSpinning] = useState(false);

  // 抽奖选项
  const drawOptions = [
    { points: 10, label: '基础抽奖', description: '获得普通奖励的机会' },
    { points: 30, label: '高级抽奖', description: '获得稀有奖励的更高机会' },
    { points: 50, label: '豪华抽奖', description: '获得史诗和传说奖励的最高机会' }
  ];

  // 加载幸运点数量
  const loadPoints = async () => {
    try {
      setIsLoading(true);
      const total = await getLuckyPointsTotal();
      setPoints(total);
    } catch (err) {
      console.error('Failed to load lucky points:', err);
      setError('加载幸运点失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    if (isOpen) {
      loadPoints();
    }
  }, [isOpen]);

  // 定义幸运点数据更新处理函数
  const handleLuckyPointsUpdate = () => {
    loadPoints();
  };

  // 使用 useRegisterTableRefresh hook 监听幸运点表的变化
  useRegisterTableRefresh('luckyPoints', handleLuckyPointsUpdate);

  // 处理抽奖
  const handleDraw = async () => {
    if (points < selectedPoints) {
      setError('幸运点不足');
      return;
    }

    try {
      setIsDrawing(true);
      setError(null);
      
      // 播放抽奖音效
      playSound(SoundType.BUTTON_CLICK, 0.5);
      
      // 旋转抽奖轮盘
      setIsWheelSpinning(true);
      const randomRotation = 1080 + Math.random() * 360; // 至少旋转3圈
      setWheelRotation(prevRotation => prevRotation + randomRotation);
      
      // 延迟获取奖励，模拟抽奖过程
      setTimeout(async () => {
        // 执行抽奖
        const result = await performLuckyDraw(selectedPoints);
        
        // 更新幸运点
        setPoints(prev => prev - selectedPoints);
        
        // 设置奖励
        setRewards(result.rewards);
        
        // 停止轮盘旋转
        setIsWheelSpinning(false);
        
        // 显示奖励
        setTimeout(() => {
          setShowReward(true);
          setCurrentRewardIndex(0);
          
          // 播放奖励音效（根据稀有度）
          if (result.rewards.length > 0) {
            const rarity = result.rewards[0].rarity;
            switch (rarity) {
              case RewardRarity.LEGENDARY:
                playSound(SoundType.REWARD_LEGENDARY, 0.7);
                break;
              case RewardRarity.EPIC:
                playSound(SoundType.REWARD_EPIC, 0.7);
                break;
              case RewardRarity.RARE:
                playSound(SoundType.REWARD_RARE, 0.7);
                break;
              case RewardRarity.UNCOMMON:
                playSound(SoundType.REWARD_UNCOMMON, 0.7);
                break;
              default:
                playSound(SoundType.REWARD_COMMON, 0.7);
                break;
            }
          }
          
          // 通知父组件
          if (onRewardEarned) {
            onRewardEarned(result.rewards);
          }
        }, 500);
      }, 3000); // 3秒后显示结果
    } catch (err) {
      console.error('Failed to perform lucky draw:', err);
      setError('抽奖失败，请重试');
      setIsWheelSpinning(false);
    } finally {
      setIsDrawing(false);
    }
  };

  // 处理下一个奖励
  const handleNextReward = () => {
    if (currentRewardIndex < rewards.length - 1) {
      setCurrentRewardIndex(prevIndex => prevIndex + 1);
      
      // 播放奖励音效（根据稀有度）
      const rarity = rewards[currentRewardIndex + 1].rarity;
      switch (rarity) {
        case RewardRarity.LEGENDARY:
          playSound(SoundType.REWARD_LEGENDARY, 0.7);
          break;
        case RewardRarity.EPIC:
          playSound(SoundType.REWARD_EPIC, 0.7);
          break;
        case RewardRarity.RARE:
          playSound(SoundType.REWARD_RARE, 0.7);
          break;
        case RewardRarity.UNCOMMON:
          playSound(SoundType.REWARD_UNCOMMON, 0.7);
          break;
        default:
          playSound(SoundType.REWARD_COMMON, 0.7);
          break;
      }
    } else {
      setShowReward(false);
      setRewards([]);
    }
  };

  // 处理选择抽奖选项
  const handleSelectOption = (points: number) => {
    setSelectedPoints(points);
  };

  // 处理继续抽奖
  const handleContinue = () => {
    setShowReward(false);
    setRewards([]);
  };

  // 渲染抽奖轮盘
  const renderWheel = () => {
    // 轮盘上的奖励类型
    const wheelItems = [
      { type: RewardRarity.COMMON, color: '#cccccc', label: '普通' },
      { type: RewardRarity.UNCOMMON, color: '#4caf50', label: '不常见' },
      { type: RewardRarity.RARE, color: '#2196f3', label: '稀有' },
      { type: RewardRarity.EPIC, color: '#9c27b0', label: '史诗' },
      { type: RewardRarity.LEGENDARY, color: '#ffc107', label: '传说' },
      { type: RewardRarity.COMMON, color: '#cccccc', label: '普通' },
      { type: RewardRarity.UNCOMMON, color: '#4caf50', label: '不常见' },
      { type: RewardRarity.RARE, color: '#2196f3', label: '稀有' }
    ];

    return (
      <div className="lucky-draw-wheel-container relative w-64 h-64 mx-auto my-4">
        {/* 轮盘指针 */}
        <div className="wheel-pointer absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-10">
          <svg width="30" height="30" viewBox="0 0 30 30">
            <polygon points="15,0 30,15 15,30 0,15" fill="#e53935" />
          </svg>
        </div>
        
        {/* 轮盘 */}
        <motion.div
          ref={wheelRef}
          className="lucky-draw-wheel w-full h-full rounded-full border-4 border-gold overflow-hidden relative"
          style={{
            boxShadow: '0 0 20px rgba(255, 215, 0, 0.5)',
            transform: `rotate(${wheelRotation}deg)`,
            transition: isWheelSpinning ? 'transform 3s cubic-bezier(0.2, 0.8, 0.2, 1)' : 'none'
          }}
        >
          {wheelItems.map((item, index) => {
            const angle = (index / wheelItems.length) * 360;
            return (
              <div
                key={`wheel-item-${index}`}
                className="wheel-item absolute w-full h-full"
                style={{
                  transform: `rotate(${angle}deg)`,
                  transformOrigin: 'center',
                  clipPath: `polygon(50% 50%, 50% 0%, ${50 + 50 * Math.cos((angle + 45) * Math.PI / 180)}% ${50 + 50 * Math.sin((angle + 45) * Math.PI / 180)}%)`
                }}
              >
                <div
                  className="w-full h-full flex items-center justify-center"
                  style={{ backgroundColor: item.color }}
                >
                  <span
                    className="text-white font-bold transform rotate-180"
                    style={{
                      position: 'absolute',
                      top: '25%',
                      left: '50%',
                      transform: `translate(-50%, -50%) rotate(${-angle}deg)`,
                      textShadow: '1px 1px 2px rgba(0, 0, 0, 0.5)'
                    }}
                  >
                    {item.label}
                  </span>
                </div>
              </div>
            );
          })}
        </motion.div>
      </div>
    );
  };

  // 渲染奖励展示
  const renderRewardDisplay = () => {
    if (!showReward || rewards.length === 0) return null;

    const currentReward = rewards[currentRewardIndex];

    return (
      <div className="lucky-draw-reward-display flex flex-col items-center justify-center p-4">
        <h3 className="text-xl font-bold mb-4">恭喜获得奖励！</h3>
        
        <div className="reward-animation-container mb-4">
          <RewardAnimation
            type={currentReward.type}
            rarity={currentReward.rarity}
            iconPath={currentReward.iconPath}
            amount={currentReward.amount}
            size={120}
            animationStyle={
              currentReward.rarity === RewardRarity.LEGENDARY ? 'burst' :
              currentReward.rarity === RewardRarity.EPIC ? 'spin' :
              currentReward.rarity === RewardRarity.RARE ? 'pulse' :
              currentReward.rarity === RewardRarity.UNCOMMON ? 'float' : 'default'
            }
            playSound={false}
          />
        </div>
        
        <div className="reward-details text-center mb-4">
          <h4 className="text-lg font-bold">{currentReward.name}</h4>
          <p className="text-sm text-gray-600">{currentReward.description}</p>
          {currentReward.amount > 1 && (
            <p className="text-sm">数量: {currentReward.amount}</p>
          )}
        </div>
        
        <div className="reward-navigation">
          {currentRewardIndex < rewards.length - 1 ? (
            <Button variant="jade" onClick={handleNextReward}>
              下一个奖励
            </Button>
          ) : (
            <Button variant="gold" onClick={handleContinue}>
              继续抽奖
            </Button>
          )}
        </div>
      </div>
    );
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="幸运抽奖"
      closeOnOutsideClick={!isDrawing && !showReward}
      closeOnEsc={!isDrawing && !showReward}
      showCloseButton={!isDrawing && !showReward}
    >
      <div className="lucky-draw-content p-4">
        <AnimatePresence mode="wait">
          {!showReward ? (
            <motion.div
              key="lucky-draw-main"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.3 }}
            >
              <div className="lucky-points-display text-center mb-4">
                <LuckyPointsDisplay variant="large" />
                <p className="text-lg font-bold mt-2">当前幸运点数: <span className="text-gold">{points}</span></p>
              </div>
              
              {renderWheel()}
              
              <div className="lucky-draw-options flex justify-center gap-4 mt-4">
                {drawOptions.map(option => (
                  <motion.div
                    key={option.points}
                    className={`draw-option p-2 border-2 rounded-lg cursor-pointer ${selectedPoints === option.points ? 'border-gold bg-amber-50' : 'border-gray-300'} ${points < option.points ? 'opacity-50 cursor-not-allowed' : ''}`}
                    onClick={() => points >= option.points && handleSelectOption(option.points)}
                    whileHover={{ scale: points >= option.points ? 1.05 : 1 }}
                    whileTap={{ scale: points >= option.points ? 0.95 : 1 }}
                  >
                    <div className="draw-option-header flex items-center justify-between">
                      <div className="draw-option-points flex items-center">
                        <span className="lucky-points-icon mr-1">🍀</span>
                        <span>{option.points}</span>
                      </div>
                      <h3 className="draw-option-label font-bold">{option.label}</h3>
                    </div>
                    <p className="draw-option-description text-xs text-gray-600 mt-1">{option.description}</p>
                  </motion.div>
                ))}
              </div>
              
              <div className="lucky-draw-controls text-center mt-4">
                {error && (
                  <p className="text-red-500 text-sm mb-2">{error}</p>
                )}
                
                <Button
                  variant="gold"
                  onClick={handleDraw}
                  disabled={isDrawing || points < selectedPoints}
                  className="px-8 py-2"
                >
                  {isDrawing ? '抽奖中...' : '抽 奖'}
                </Button>
              </div>
            </motion.div>
          ) : (
            <motion.div
              key="lucky-draw-reward"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.3 }}
            >
              {renderRewardDisplay()}
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </ScrollDialog>
  );
};

export default LuckyDrawWheel;
</file>

<file path="src/components/game/README.md">
# 游戏组件文档

本文档记录了PandaHabit应用中的游戏组件，包括它们的功能、属性和使用方法。

## 奖励和资源组件

### RewardModal

`RewardModal` 是一个用于展示任务完成后获得的奖励的模态框组件。它以卷轴风格展示奖励，并支持多个奖励的展示。

#### 属性

| 属性名 | 类型 | 描述 |
|--------|------|------|
| isOpen | boolean | 控制模态框是否显示 |
| onClose | () => void | 关闭模态框的回调函数 |
| rewards | RewardRecord[] | 要展示的奖励列表 |

#### 使用示例

```tsx
<RewardModal
  isOpen={showRewardModal}
  onClose={handleCloseRewardModal}
  rewards={rewards}
/>
```

### ResourceDisplay

`ResourceDisplay` 是一个用于显示各种类型资源（经验、金币、物品等）的组件。它支持不同的尺寸、动画效果和点击交互。

#### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| type | RewardType | 必填 | 资源类型 |
| amount | number | 必填 | 资源数量 |
| rarity | RewardRarity | COMMON | 资源稀有度 |
| iconPath | string | 根据类型自动选择 | 资源图标路径 |
| size | 'small' \| 'medium' \| 'large' | 'medium' | 组件尺寸 |
| showLabel | boolean | true | 是否显示资源类型标签 |
| showAnimation | boolean | false | 是否显示数量变化动画 |
| onClick | () => void | undefined | 点击回调函数 |
| className | string | '' | 自定义CSS类名 |

#### 使用示例

```tsx
<ResourceDisplay
  type={RewardType.COIN}
  amount={100}
  rarity={RewardRarity.RARE}
  size="large"
  showAnimation={true}
  onClick={() => console.log('Clicked on coins')}
/>
```

### ResourceList

`ResourceList` 是一个用于显示多种资源的列表组件。它可以水平或垂直排列多个ResourceDisplay组件。

#### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| resources | ResourceItem[] | 必填 | 资源列表 |
| size | 'small' \| 'medium' \| 'large' | 'medium' | 资源显示尺寸 |
| showLabels | boolean | true | 是否显示资源类型标签 |
| showAnimation | boolean | false | 是否显示数量变化动画 |
| onResourceClick | (resource: ResourceItem) => void | undefined | 资源点击回调函数 |
| orientation | 'horizontal' \| 'vertical' | 'horizontal' | 列表排列方向 |
| className | string | '' | 自定义CSS类名 |

#### 使用示例

```tsx
<ResourceList
  resources={[
    { id: 1, type: RewardType.EXPERIENCE, amount: 100 },
    { id: 2, type: RewardType.COIN, amount: 50 }
  ]}
  size="medium"
  showAnimation={true}
  onResourceClick={(resource) => console.log('Clicked on', resource)}
/>
```

### ResourceInventory

`ResourceInventory` 是一个用于显示玩家资源库存的组件。它自动从服务中获取最新的资源数据并显示。

#### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| showExperience | boolean | true | 是否显示经验值 |
| showCoins | boolean | true | 是否显示金币 |
| showItems | boolean | false | 是否显示物品 |
| showBadges | boolean | false | 是否显示徽章 |
| showAnimation | boolean | true | 是否显示数量变化动画 |
| size | 'small' \| 'medium' \| 'large' | 'medium' | 资源显示尺寸 |
| className | string | '' | 自定义CSS类名 |

#### 使用示例

```tsx
<ResourceInventory
  showExperience={true}
  showCoins={true}
  size="medium"
  showAnimation={true}
/>
```

## 抽奖和反思组件

### LuckyDraw

`LuckyDraw` 是一个用于实现幸运抽奖功能的组件。它允许用户使用幸运点进行抽奖，并显示抽奖结果。

#### 属性

| 属性名 | 类型 | 描述 |
|--------|------|------|
| onClose | () => void | 关闭抽奖组件的回调函数 |
| onRewardEarned | (rewards: RewardRecord[]) => void | 获得奖励后的回调函数 |

#### 使用示例

```tsx
<LuckyDraw
  onClose={handleCloseLuckyDraw}
  onRewardEarned={handleRewardEarned}
/>
```

### LuckyDrawWheel

`LuckyDrawWheel` 是一个带有旋转轮盘的幸运抽奖组件。它提供了更华丽的抽奖体验，包括轮盘旋转动画和奖励展示。

#### 属性

| 属性名 | 类型 | 描述 |
|--------|------|------|
| isOpen | boolean | 控制抽奖组件是否显示 |
| onClose | () => void | 关闭抽奖组件的回调函数 |
| onRewardEarned | (rewards: RewardRecord[]) => void | 获得奖励后的回调函数 |

#### 使用示例

```tsx
<LuckyDrawWheel
  isOpen={showLuckyDrawWheel}
  onClose={handleCloseLuckyDrawWheel}
  onRewardEarned={handleRewardEarned}
/>
```

### ReflectionModule

`ReflectionModule` 是一个用于帮助用户反思任务完成情况和情绪状态的组件。它提供了一个温和、非判断性的对话系统，帮助用户探索困难并提供支持。

#### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| isOpen | boolean | 必填 | 控制反思模块是否显示 |
| onClose | () => void | 必填 | 关闭反思模块的回调函数 |
| taskName | string | undefined | 相关任务名称 |
| taskId | number | undefined | 相关任务ID |
| mood | 'happy' \| 'neutral' \| 'sad' \| 'concerned' | undefined | 初始心情状态 |
| onReflectionComplete | (reflectionData) => void | undefined | 反思完成后的回调函数 |

#### 使用示例

```tsx
<ReflectionModule
  isOpen={showReflectionModule}
  onClose={handleCloseReflectionModule}
  taskName="每日冥想"
  taskId={123}
  mood="concerned"
  onReflectionComplete={handleReflectionComplete}
/>
```

## 注意事项

1. 所有组件都遵循华丽游戏风格设计，包括中国风元素、动画效果和音效。
2. 组件使用Framer Motion实现动画效果，确保流畅的用户体验。
3. 组件与数据服务集成，自动更新和同步数据。
4. 所有组件都支持自定义样式和行为，可以根据需要进行定制。
5. 组件使用TypeScript编写，提供类型安全和代码提示。
</file>

<file path="src/components/game/ReflectionModule.tsx">
// src/components/game/ReflectionModule.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Button from '@/components/common/Button';
import ScrollDialog from './ScrollDialog';
import { playSound, SoundType } from '@/utils/sound';
import { TaskRecord } from '@/services/taskService';
import { getPandaMood, updatePandaMood } from '@/services/pandaStateService';

interface ReflectionModuleProps {
  isOpen: boolean;
  onClose: () => void;
  taskName?: string;
  taskId?: number;
  mood?: 'happy' | 'neutral' | 'sad' | 'concerned';
  onReflectionComplete?: (reflectionData: {
    taskId?: number;
    mood?: string;
    reflection: string;
    action: string;
  }) => void;
}

/**
 * 反思模块组件
 * 用于帮助用户反思任务完成情况和情绪状态
 */
const ReflectionModule: React.FC<ReflectionModuleProps> = ({
  isOpen,
  onClose,
  taskName,
  taskId,
  mood: initialMood,
  onReflectionComplete
}) => {
  const [step, setStep] = useState(1);
  const [mood, setMood] = useState<string>(initialMood || 'neutral');
  const [reflection, setReflection] = useState('');
  const [action, setAction] = useState('');
  const [suggestedActions, setSuggestedActions] = useState<string[]>([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [pandaMessage, setPandaMessage] = useState('');

  // 根据任务名称和心情设置熊猫消息
  useEffect(() => {
    if (taskName) {
      if (mood === 'sad' || mood === 'concerned') {
        setPandaMessage(`我注意到你最近在"${taskName}"这个任务上遇到了一些困难。想聊聊吗？`);
      } else {
        setPandaMessage('今天感觉如何？想花点时间反思一下吗？');
      }
    } else if (mood === 'sad' || mood === 'concerned') {
      setPandaMessage('我注意到你最近心情不太好。想聊聊吗？');
    } else {
      setPandaMessage('今天感觉如何？想花点时间反思一下吗？');
    }
  }, [taskName, mood]);

  // 根据反思内容生成建议行动
  useEffect(() => {
    if (reflection && step === 2) {
      // 这里可以根据反思内容生成建议行动
      // 在实际应用中，可以使用更复杂的算法或API来生成建议
      const lowerReflection = reflection.toLowerCase();
      
      if (lowerReflection.includes('压力') || lowerReflection.includes('焦虑') || lowerReflection.includes('紧张')) {
        setSuggestedActions([
          '尝试5分钟的深呼吸冥想',
          '出去散步15分钟',
          '与朋友聊天分享感受',
          '写下三件让你感到感激的事情'
        ]);
      } else if (lowerReflection.includes('疲惫') || lowerReflection.includes('累') || lowerReflection.includes('没精力')) {
        setSuggestedActions([
          '确保今晚早点休息',
          '尝试20分钟的午休',
          '减少今天的任务量',
          '喝足够的水，吃些健康的食物'
        ]);
      } else if (lowerReflection.includes('拖延') || lowerReflection.includes('专注') || lowerReflection.includes('分心')) {
        setSuggestedActions([
          '使用番茄工作法，专注25分钟',
          '将大任务分解成小步骤',
          '创建一个无干扰的工作环境',
          '设置一个小的、可实现的目标'
        ]);
      } else {
        setSuggestedActions([
          '花5分钟进行深呼吸冥想',
          '写下三件让你感到感激的事情',
          '设定一个小的、可实现的目标',
          '与朋友或家人分享你的感受'
        ]);
      }
    }
  }, [reflection, step]);

  // 处理提交反思
  const handleSubmit = async () => {
    try {
      setIsSubmitting(true);
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 如果心情不好，尝试更新为中性
      if (mood === 'sad' || mood === 'concerned') {
        await updatePandaMood('neutral');
      }
      
      // 通知父组件
      if (onReflectionComplete) {
        onReflectionComplete({
          taskId,
          mood,
          reflection,
          action
        });
      }
      
      // 重置状态
      setStep(1);
      setReflection('');
      setAction('');
      
      // 关闭对话框
      onClose();
    } catch (error) {
      console.error('Failed to submit reflection:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  // 处理选择建议行动
  const handleSelectAction = (selectedAction: string) => {
    setAction(selectedAction);
  };

  // 渲染步骤1：反思输入
  const renderStep1 = () => (
    <div className="reflection-step">
      <div className="panda-message mb-4 p-3 bg-amber-50 rounded-lg border border-amber-200">
        <div className="flex items-start">
          <div className="panda-avatar mr-2">
            <span className="text-2xl">🐼</span>
          </div>
          <div className="panda-text">
            <p>{pandaMessage}</p>
          </div>
        </div>
      </div>
      
      <div className="reflection-input mb-4">
        <label htmlFor="reflection" className="block text-sm font-medium text-gray-700 mb-1">
          分享你的想法（可以是任何感受、困难或成就）
        </label>
        <textarea
          id="reflection"
          className="w-full h-32 p-2 border border-gray-300 rounded-md focus:ring-jade focus:border-jade"
          value={reflection}
          onChange={(e) => setReflection(e.target.value)}
          placeholder="今天我感觉..."
        />
      </div>
      
      <div className="reflection-actions flex justify-end">
        <Button variant="jade" onClick={() => setStep(2)} disabled={!reflection.trim()}>
          继续
        </Button>
      </div>
    </div>
  );

  // 渲染步骤2：行动选择
  const renderStep2 = () => (
    <div className="reflection-step">
      <div className="panda-message mb-4 p-3 bg-amber-50 rounded-lg border border-amber-200">
        <div className="flex items-start">
          <div className="panda-avatar mr-2">
            <span className="text-2xl">🐼</span>
          </div>
          <div className="panda-text">
            <p>谢谢你的分享。以下是一些可能对你有帮助的小行动，你可以选择一个尝试，或者创建自己的行动。</p>
          </div>
        </div>
      </div>
      
      <div className="suggested-actions mb-4">
        <h3 className="text-sm font-medium text-gray-700 mb-2">建议的行动</h3>
        <div className="grid grid-cols-1 gap-2">
          {suggestedActions.map((suggestedAction, index) => (
            <motion.div
              key={index}
              className={`p-2 border rounded-md cursor-pointer ${action === suggestedAction ? 'border-jade bg-jade-50' : 'border-gray-300'}`}
              onClick={() => handleSelectAction(suggestedAction)}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
            >
              {suggestedAction}
            </motion.div>
          ))}
        </div>
      </div>
      
      <div className="custom-action mb-4">
        <label htmlFor="custom-action" className="block text-sm font-medium text-gray-700 mb-1">
          或者，创建你自己的行动
        </label>
        <input
          id="custom-action"
          type="text"
          className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade focus:border-jade"
          value={action}
          onChange={(e) => setAction(e.target.value)}
          placeholder="我将..."
        />
      </div>
      
      <div className="reflection-actions flex justify-between">
        <Button variant="secondary" onClick={() => setStep(1)}>
          返回
        </Button>
        <Button variant="gold" onClick={handleSubmit} disabled={!action.trim() || isSubmitting}>
          {isSubmitting ? '提交中...' : '完成反思'}
        </Button>
      </div>
    </div>
  );

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="静心茶室"
      closeOnOutsideClick={false}
      closeOnEsc={true}
      showCloseButton={true}
    >
      <div className="reflection-module p-4">
        <AnimatePresence mode="wait">
          <motion.div
            key={`step-${step}`}
            initial={{ opacity: 0, x: step === 1 ? -20 : 20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: step === 1 ? 20 : -20 }}
            transition={{ duration: 0.3 }}
          >
            {step === 1 ? renderStep1() : renderStep2()}
          </motion.div>
        </AnimatePresence>
      </div>
    </ScrollDialog>
  );
};

export default ReflectionModule;
</file>

<file path="src/components/game/ResourceDisplay.tsx">
// src/components/game/ResourceDisplay.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { RewardType, RewardRarity } from '@/services/rewardService';
import { playSound, SoundType } from '@/utils/sound';

interface ResourceDisplayProps {
  type: RewardType;
  amount: number;
  rarity?: RewardRarity;
  iconPath?: string;
  size?: 'small' | 'medium' | 'large';
  showLabel?: boolean;
  showAnimation?: boolean;
  onClick?: () => void;
  className?: string;
}

/**
 * 资源显示组件
 * 用于显示各种类型的资源（经验、金币、物品等）
 */
const ResourceDisplay: React.FC<ResourceDisplayProps> = ({
  type,
  amount,
  rarity = RewardRarity.COMMON,
  iconPath,
  size = 'medium',
  showLabel = true,
  showAnimation = false,
  onClick,
  className = ''
}) => {
  const [isAnimating, setIsAnimating] = useState(false);
  const [displayAmount, setDisplayAmount] = useState(amount);
  const [prevAmount, setPrevAmount] = useState(amount);

  // 当金额变化时触发动画
  useEffect(() => {
    if (amount !== prevAmount && showAnimation) {
      // 播放音效
      if (amount > prevAmount) {
        // 增加资源时播放获得音效
        playSound(SoundType.SUCCESS, 0.3);
      } else if (amount < prevAmount) {
        // 减少资源时播放消耗音效
        playSound(SoundType.BUTTON_CLICK, 0.3);
      }

      // 触发动画
      setIsAnimating(true);
      
      // 更新显示金额
      const diff = amount - prevAmount;
      const duration = 1000; // 动画持续时间（毫秒）
      const steps = 20; // 动画步数
      const stepTime = duration / steps;
      const stepAmount = diff / steps;
      
      let currentStep = 0;
      const interval = setInterval(() => {
        currentStep++;
        setDisplayAmount(prevAmount + stepAmount * currentStep);
        
        if (currentStep >= steps) {
          clearInterval(interval);
          setDisplayAmount(amount);
          setIsAnimating(false);
        }
      }, stepTime);
      
      // 更新前一个金额
      setPrevAmount(amount);
      
      // 清理函数
      return () => {
        clearInterval(interval);
      };
    } else if (amount !== prevAmount) {
      // 如果不显示动画，直接更新金额
      setDisplayAmount(amount);
      setPrevAmount(amount);
    }
  }, [amount, prevAmount, showAnimation]);

  // 获取资源类型的中文名称
  const getTypeName = (): string => {
    switch (type) {
      case RewardType.EXPERIENCE:
        return '经验';
      case RewardType.COIN:
        return '竹币';
      case RewardType.ITEM:
        return '物品';
      case RewardType.BADGE:
        return '徽章';
      default:
        return '资源';
    }
  };

  // 获取默认图标路径
  const getDefaultIconPath = (): string => {
    switch (type) {
      case RewardType.EXPERIENCE:
        return '/assets/rewards/experience.svg';
      case RewardType.COIN:
        return '/assets/rewards/coin.svg';
      case RewardType.ITEM:
        return `/assets/rewards/item_${rarity.toLowerCase()}.svg`;
      case RewardType.BADGE:
        return `/assets/rewards/badge_${rarity.toLowerCase()}.svg`;
      default:
        return '/assets/rewards/item_common.svg';
    }
  };

  // 获取尺寸样式
  const getSizeStyle = (): { containerSize: string, iconSize: string, fontSize: string } => {
    switch (size) {
      case 'small':
        return {
          containerSize: 'w-16 h-8',
          iconSize: 'w-6 h-6',
          fontSize: 'text-xs'
        };
      case 'large':
        return {
          containerSize: 'w-32 h-16',
          iconSize: 'w-12 h-12',
          fontSize: 'text-lg'
        };
      default: // medium
        return {
          containerSize: 'w-24 h-12',
          iconSize: 'w-8 h-8',
          fontSize: 'text-sm'
        };
    }
  };

  // 获取稀有度样式
  const getRarityStyle = (): { borderColor: string, glowColor: string, textColor: string } => {
    switch (rarity) {
      case RewardRarity.LEGENDARY:
        return {
          borderColor: 'border-gold',
          glowColor: 'shadow-gold',
          textColor: 'text-gold'
        };
      case RewardRarity.EPIC:
        return {
          borderColor: 'border-purple-500',
          glowColor: 'shadow-purple',
          textColor: 'text-purple-500'
        };
      case RewardRarity.RARE:
        return {
          borderColor: 'border-blue-500',
          glowColor: 'shadow-blue',
          textColor: 'text-blue-500'
        };
      case RewardRarity.UNCOMMON:
        return {
          borderColor: 'border-green-500',
          glowColor: 'shadow-green',
          textColor: 'text-green-500'
        };
      default:
        return {
          borderColor: 'border-gray-300',
          glowColor: 'shadow-sm',
          textColor: 'text-gray-700'
        };
    }
  };

  const { containerSize, iconSize, fontSize } = getSizeStyle();
  const { borderColor, glowColor, textColor } = getRarityStyle();

  return (
    <motion.div
      className={`resource-display flex items-center ${containerSize} ${borderColor} border rounded-full bg-white ${glowColor} ${className}`}
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
      onClick={onClick}
      style={{ cursor: onClick ? 'pointer' : 'default' }}
    >
      {/* 资源图标 */}
      <div className={`resource-icon ${iconSize} flex-shrink-0 ml-1`}>
        <img
          src={iconPath || getDefaultIconPath()}
          alt={getTypeName()}
          className="w-full h-full object-contain"
          onError={(e) => {
            const target = e.target as HTMLImageElement;
            target.onerror = null;
            target.src = getDefaultIconPath();
          }}
        />
      </div>

      {/* 资源数量 */}
      <div className="resource-amount flex flex-col justify-center ml-1 flex-grow">
        <AnimatePresence mode="wait">
          <motion.div
            key={`amount-${displayAmount}`}
            initial={isAnimating ? { y: -10, opacity: 0 } : { y: 0, opacity: 1 }}
            animate={{ y: 0, opacity: 1 }}
            exit={{ y: 10, opacity: 0 }}
            transition={{ duration: 0.2 }}
            className={`${fontSize} font-bold ${textColor} text-center`}
          >
            {Math.round(displayAmount)}
          </motion.div>
        </AnimatePresence>
        
        {/* 资源类型标签 */}
        {showLabel && (
          <div className={`resource-label text-xs text-gray-500 text-center`}>
            {getTypeName()}
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default ResourceDisplay;
</file>

<file path="src/components/game/ResourceInventory.tsx">
// src/components/game/ResourceInventory.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ResourceList from './ResourceList';
import ResourceDisplay from './ResourceDisplay';
import { RewardType, RewardRarity, getPlayerCoins } from '@/services/rewardService';
import { getPandaExperience } from '@/services/pandaStateService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import LoadingSpinner from '@/components/common/LoadingSpinner';

interface ResourceInventoryProps {
  showExperience?: boolean;
  showCoins?: boolean;
  showItems?: boolean;
  showBadges?: boolean;
  showAnimation?: boolean;
  size?: 'small' | 'medium' | 'large';
  className?: string;
}

/**
 * 资源库存组件
 * 用于显示玩家的资源库存
 */
const ResourceInventory: React.FC<ResourceInventoryProps> = ({
  showExperience = true,
  showCoins = true,
  showItems = false,
  showBadges = false,
  showAnimation = true,
  size = 'medium',
  className = ''
}) => {
  const [experience, setExperience] = useState<number>(0);
  const [coins, setCoins] = useState<number>(0);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // 加载资源数据
  const loadResourceData = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // 获取经验值
      if (showExperience) {
        const exp = await getPandaExperience();
        setExperience(exp);
      }

      // 获取金币
      if (showCoins) {
        const playerCoins = await getPlayerCoins();
        setCoins(playerCoins);
      }

      // 获取物品和徽章的逻辑可以在这里添加

    } catch (err) {
      console.error('Failed to load resource data:', err);
      setError('加载资源数据失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadResourceData();
  }, [showExperience, showCoins, showItems, showBadges]);

  // 注册数据刷新监听
  const handleResourceDataUpdate = () => {
    loadResourceData();
  };

  // 监听奖励表的变化
  useRegisterTableRefresh('rewards', handleResourceDataUpdate);

  // 监听熊猫状态表的变化
  useRegisterTableRefresh('pandaState', handleResourceDataUpdate);

  // 创建资源列表
  const resources = [];

  if (showExperience) {
    resources.push({
      id: 1,
      type: RewardType.EXPERIENCE,
      amount: experience,
      rarity: RewardRarity.COMMON,
      iconPath: '/assets/rewards/experience.svg',
      name: '经验值'
    });
  }

  if (showCoins) {
    resources.push({
      id: 2,
      type: RewardType.COIN,
      amount: coins,
      rarity: RewardRarity.COMMON,
      iconPath: '/assets/rewards/coin.svg',
      name: '竹币'
    });
  }

  // 容器变体
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        duration: 0.3
      }
    },
    exit: {
      opacity: 0,
      transition: {
        duration: 0.2
      }
    }
  };

  if (isLoading) {
    return (
      <div className={`resource-inventory-loading flex justify-center items-center p-4 ${className}`}>
        <LoadingSpinner variant="jade" size="small" />
      </div>
    );
  }

  if (error) {
    return (
      <div className={`resource-inventory-error text-red-500 text-center p-4 ${className}`}>
        {error}
      </div>
    );
  }

  return (
    <AnimatePresence mode="wait">
      <motion.div
        key="resource-inventory"
        className={`resource-inventory ${className}`}
        variants={containerVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <ResourceList
          resources={resources}
          size={size}
          showLabels={true}
          showAnimation={showAnimation}
          orientation="horizontal"
        />
      </motion.div>
    </AnimatePresence>
  );
};

export default ResourceInventory;
</file>

<file path="src/components/game/ResourceList.tsx">
// src/components/game/ResourceList.tsx
import React from 'react';
import { motion } from 'framer-motion';
import ResourceDisplay from './ResourceDisplay';
import { RewardType, RewardRarity } from '@/services/rewardService';

interface ResourceItem {
  id?: number;
  type: RewardType;
  amount: number;
  rarity?: RewardRarity;
  iconPath?: string;
  name?: string;
}

interface ResourceListProps {
  resources: ResourceItem[];
  size?: 'small' | 'medium' | 'large';
  showLabels?: boolean;
  showAnimation?: boolean;
  onResourceClick?: (resource: ResourceItem) => void;
  orientation?: 'horizontal' | 'vertical';
  className?: string;
}

/**
 * 资源列表组件
 * 用于显示多种资源
 */
const ResourceList: React.FC<ResourceListProps> = ({
  resources,
  size = 'medium',
  showLabels = true,
  showAnimation = false,
  onResourceClick,
  orientation = 'horizontal',
  className = ''
}) => {
  // 容器变体
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // 项目变体
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  // 处理资源点击
  const handleResourceClick = (resource: ResourceItem) => {
    if (onResourceClick) {
      onResourceClick(resource);
    }
  };

  return (
    <motion.div
      className={`resource-list ${orientation === 'horizontal' ? 'flex flex-row flex-wrap gap-2' : 'flex flex-col gap-2'} ${className}`}
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      {resources.map((resource, index) => (
        <motion.div
          key={`resource-${resource.id || index}`}
          variants={itemVariants}
          className="resource-list-item"
        >
          <ResourceDisplay
            type={resource.type}
            amount={resource.amount}
            rarity={resource.rarity}
            iconPath={resource.iconPath}
            size={size}
            showLabel={showLabels}
            showAnimation={showAnimation}
            onClick={() => handleResourceClick(resource)}
          />
        </motion.div>
      ))}
    </motion.div>
  );
};

export default ResourceList;
</file>

<file path="src/components/game/ScrollDialog.tsx">
// src/components/game/ScrollDialog.tsx
import React from 'react';
import { motion } from 'framer-motion';
import Modal from '@/components/common/Modal';
import Button from '@/components/common/Button';

interface ScrollDialogProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
  footer?: React.ReactNode;
  closeOnOutsideClick?: boolean;
  closeOnEsc?: boolean;
  showCloseButton?: boolean;
}

/**
 * 卷轴风格对话框组件
 * 设计为古代卷轴样式，适合展示重要信息、成就或故事内容
 * 
 * @param isOpen - 控制对话框是否显示
 * @param onClose - 关闭对话框的回调函数
 * @param title - 对话框标题
 * @param children - 对话框内容
 * @param footer - 对话框底部内容，通常是按钮
 * @param closeOnOutsideClick - 是否在点击外部区域时关闭，默认为true
 * @param closeOnEsc - 是否在按下ESC键时关闭，默认为true
 * @param showCloseButton - 是否显示关闭按钮，默认为true
 */
const ScrollDialog: React.FC<ScrollDialogProps> = ({
  isOpen,
  onClose,
  title,
  children,
  footer,
  closeOnOutsideClick = true,
  closeOnEsc = true,
  showCloseButton = true,
}) => {
  // 默认底部内容
  const defaultFooter = (
    <Button variant="gold" onClick={onClose}>
      关闭
    </Button>
  );

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      closeOnOutsideClick={closeOnOutsideClick}
      closeOnEsc={closeOnEsc}
      className="scroll-modal"
    >
      <div className="scroll-modal-header">
        <h3 className="scroll-modal-title">{title}</h3>
        {showCloseButton && (
          <motion.button
            className="scroll-modal-close"
            onClick={onClose}
            whileHover={{ scale: 1.1 }}
            whileTap={{ scale: 0.9 }}
            aria-label="关闭"
          >
            ×
          </motion.button>
        )}
      </div>

      <div className="scroll-modal-content">
        {children}
      </div>

      {(footer || defaultFooter) && (
        <div className="scroll-modal-footer">
          {footer || defaultFooter}
        </div>
      )}
    </Modal>
  );
};

export default ScrollDialog;
</file>

<file path="src/components/game/SocialChallengeCard.tsx">
// src/components/game/SocialChallengeCard.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { SocialChallengeRecord, SocialChallengeType } from '@/services/socialChallengeService';
import { ChallengeDifficulty, ChallengeStatus } from '@/services/challengeService';
import Button from '@/components/common/Button';
import { playSound, SoundType } from '@/utils/sound';

interface SocialChallengeCardProps {
  challenge: SocialChallengeRecord;
  isParticipant?: boolean;
  onJoin?: (challengeId: number) => void;
  onLeave?: (challengeId: number) => void;
  onViewDetails?: (challengeId: number) => void;
  onShare?: (challengeId: number, inviteCode: string) => void;
}

/**
 * 社交挑战卡片组件
 * 用于显示社交挑战和相关操作
 */
const SocialChallengeCard: React.FC<SocialChallengeCardProps> = ({
  challenge,
  isParticipant = false,
  onJoin,
  onLeave,
  onViewDetails,
  onShare
}) => {
  // 处理加入挑战
  const handleJoin = (e: React.MouseEvent) => {
    e.stopPropagation();
    // 播放点击音效
    playSound(SoundType.BUTTON_CLICK, 0.5);
    
    // 通知父组件
    if (onJoin) {
      onJoin(challenge.id!);
    }
  };

  // 处理离开挑战
  const handleLeave = (e: React.MouseEvent) => {
    e.stopPropagation();
    // 播放点击音效
    playSound(SoundType.BUTTON_CLICK, 0.5);
    
    // 通知父组件
    if (onLeave) {
      onLeave(challenge.id!);
    }
  };

  // 处理查看详情
  const handleViewDetails = () => {
    // 播放点击音效
    playSound(SoundType.BUTTON_CLICK, 0.3);
    
    // 通知父组件
    if (onViewDetails) {
      onViewDetails(challenge.id!);
    }
  };

  // 处理分享挑战
  const handleShare = (e: React.MouseEvent) => {
    e.stopPropagation();
    // 播放点击音效
    playSound(SoundType.BUTTON_CLICK, 0.5);
    
    // 通知父组件
    if (onShare && challenge.inviteCode) {
      onShare(challenge.id!, challenge.inviteCode);
    }
  };

  // 获取挑战类型标签和样式
  const getTypeInfo = (type: SocialChallengeType) => {
    switch (type) {
      case SocialChallengeType.COOPERATIVE:
        return { label: '合作', className: 'bg-green-100 text-green-800' };
      case SocialChallengeType.COMPETITIVE:
        return { label: '竞争', className: 'bg-red-100 text-red-800' };
      case SocialChallengeType.TEAM:
        return { label: '团队', className: 'bg-blue-100 text-blue-800' };
      default:
        return { label: '未知', className: 'bg-gray-100 text-gray-800' };
    }
  };

  // 获取难度标签和样式
  const getDifficultyInfo = (difficulty: ChallengeDifficulty) => {
    switch (difficulty) {
      case ChallengeDifficulty.EASY:
        return { label: '简单', className: 'bg-green-100 text-green-800' };
      case ChallengeDifficulty.MEDIUM:
        return { label: '中等', className: 'bg-blue-100 text-blue-800' };
      case ChallengeDifficulty.HARD:
        return { label: '困难', className: 'bg-orange-100 text-orange-800' };
      case ChallengeDifficulty.EXPERT:
        return { label: '专家', className: 'bg-red-100 text-red-800' };
      default:
        return { label: '未知', className: 'bg-gray-100 text-gray-800' };
    }
  };

  // 获取状态标签和样式
  const getStatusInfo = (status: ChallengeStatus) => {
    switch (status) {
      case ChallengeStatus.ACTIVE:
        return { label: '进行中', className: 'bg-green-100 text-green-800' };
      case ChallengeStatus.COMPLETED:
        return { label: '已完成', className: 'bg-blue-100 text-blue-800' };
      case ChallengeStatus.FAILED:
        return { label: '失败', className: 'bg-red-100 text-red-800' };
      case ChallengeStatus.UPCOMING:
        return { label: '即将开始', className: 'bg-amber-100 text-amber-800' };
      default:
        return { label: '未知', className: 'bg-gray-100 text-gray-800' };
    }
  };

  const typeInfo = getTypeInfo(challenge.type);
  const difficultyInfo = getDifficultyInfo(challenge.difficulty);
  const statusInfo = getStatusInfo(challenge.status);

  return (
    <motion.div
      className="social-challenge-card border rounded-lg overflow-hidden bg-white shadow-md hover:shadow-lg transition-shadow"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={handleViewDetails}
    >
      {/* 卡片头部 */}
      <div className="card-header p-4 border-b border-gray-200">
        <div className="flex justify-between items-start">
          <div className="challenge-icon-title flex items-center">
            <div className="challenge-icon mr-3">
              <img
                src={challenge.iconPath || '/assets/challenges/social_default.svg'}
                alt={challenge.title}
                className="w-10 h-10 object-contain"
                onError={(e) => {
                  const target = e.target as HTMLImageElement;
                  target.onerror = null;
                  target.src = '/assets/challenges/social_default.svg';
                }}
              />
            </div>
            <div>
              <h3 className="text-lg font-bold">{challenge.title}</h3>
              <div className="challenge-meta flex flex-wrap gap-2 mt-1">
                <span className={`px-2 py-1 rounded-full text-xs ${typeInfo.className}`}>
                  {typeInfo.label}
                </span>
                <span className={`px-2 py-1 rounded-full text-xs ${difficultyInfo.className}`}>
                  {difficultyInfo.label}
                </span>
                <span className={`px-2 py-1 rounded-full text-xs ${statusInfo.className}`}>
                  {statusInfo.label}
                </span>
                {challenge.isPublic ? (
                  <span className="px-2 py-1 rounded-full text-xs bg-blue-100 text-blue-800">
                    公开
                  </span>
                ) : (
                  <span className="px-2 py-1 rounded-full text-xs bg-purple-100 text-purple-800">
                    私密
                  </span>
                )}
              </div>
            </div>
          </div>
          <div className="challenge-participants">
            <span className="text-sm text-gray-600">
              {challenge.participantIds.length}/{challenge.maxParticipants} 参与者
            </span>
          </div>
        </div>
      </div>
      
      {/* 卡片内容 */}
      <div className="card-content p-4">
        <div className="challenge-description mb-4">
          <p className="text-sm text-gray-700 line-clamp-3">{challenge.description}</p>
        </div>
        
        <div className="challenge-progress mb-4">
          <div className="flex justify-between items-center mb-1">
            <span className="text-xs text-gray-600">进度</span>
            <span className="text-xs font-bold">{challenge.progress}%</span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-2.5">
            <div
              className="bg-jade-500 h-2.5 rounded-full"
              style={{ width: `${challenge.progress}%` }}
            ></div>
          </div>
        </div>
        
        <div className="challenge-dates text-xs text-gray-500 mb-2">
          <p>开始日期: {new Date(challenge.startDate).toLocaleDateString()}</p>
          {challenge.endDate && (
            <p>结束日期: {new Date(challenge.endDate).toLocaleDateString()}</p>
          )}
        </div>
      </div>
      
      {/* 卡片底部 */}
      <div className="card-footer bg-gray-50 p-3 border-t border-gray-200 flex justify-end gap-2">
        {isParticipant ? (
          <>
            {challenge.inviteCode && (
              <Button
                variant="secondary"
                size="small"
                onClick={handleShare}
              >
                分享
              </Button>
            )}
            {challenge.status === ChallengeStatus.ACTIVE && challenge.creatorId !== 'current-user' && (
              <Button
                variant="danger"
                size="small"
                onClick={handleLeave}
              >
                退出
              </Button>
            )}
          </>
        ) : (
          <Button
            variant="jade"
            size="small"
            onClick={handleJoin}
            disabled={
              challenge.status !== ChallengeStatus.ACTIVE ||
              challenge.participantIds.length >= challenge.maxParticipants
            }
          >
            加入
          </Button>
        )}
      </div>
    </motion.div>
  );
};

export default SocialChallengeCard;
</file>

<file path="src/components/game/SocialChallengeDetailDialog.tsx">
// src/components/game/SocialChallengeDetailDialog.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  SocialChallengeRecord, 
  SocialChallengeType,
  SocialChallengeParticipation,
  getSocialChallenge,
  getChallengeParticipations,
  joinSocialChallenge,
  leaveSocialChallenge,
  contributeToChallenge
} from '@/services/socialChallengeService';
import { ChallengeDifficulty, ChallengeStatus } from '@/services/challengeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from './ScrollDialog';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface SocialChallengeDetailDialogProps {
  isOpen: boolean;
  onClose: () => void;
  challengeId: number;
  onChallengeUpdated?: () => void;
}

/**
 * 社交挑战详情对话框组件
 * 用于显示社交挑战的详细信息和参与者列表
 */
const SocialChallengeDetailDialog: React.FC<SocialChallengeDetailDialogProps> = ({
  isOpen,
  onClose,
  challengeId,
  onChallengeUpdated
}) => {
  const [challenge, setChallenge] = useState<SocialChallengeRecord | null>(null);
  const [participations, setParticipations] = useState<SocialChallengeParticipation[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isJoining, setIsJoining] = useState(false);
  const [isLeaving, setIsLeaving] = useState(false);
  const [isContributing, setIsContributing] = useState(false);
  const [contributionAmount, setContributionAmount] = useState(10);
  const [inviteCode, setInviteCode] = useState('');
  const [showInviteCode, setShowInviteCode] = useState(false);
  
  // 当前用户ID（在实际应用中，这应该从用户会话中获取）
  const currentUserId = 'current-user';
  
  // 检查当前用户是否是参与者
  const isParticipant = challenge?.participantIds.includes(currentUserId) || false;
  
  // 检查当前用户是否是创建者
  const isCreator = challenge?.creatorId === currentUserId;

  // 加载挑战数据
  const loadChallengeData = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // 获取挑战数据
      const challengeData = await getSocialChallenge(challengeId);
      if (challengeData) {
        setChallenge(challengeData);
        setInviteCode(challengeData.inviteCode || '');
        
        // 获取参与记录
        const participationData = await getChallengeParticipations(challengeId);
        setParticipations(participationData);
      } else {
        setError('无法加载挑战数据');
      }
    } catch (err) {
      console.error('Failed to load challenge data:', err);
      setError('加载挑战数据失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    if (isOpen && challengeId) {
      loadChallengeData();
    }
  }, [isOpen, challengeId]);

  // 注册数据刷新监听
  useRegisterTableRefresh('socialChallenges', loadChallengeData);
  useRegisterTableRefresh('socialChallengeParticipations', loadChallengeData);

  // 处理加入挑战
  const handleJoin = async () => {
    if (!challenge) return;
    
    try {
      setIsJoining(true);
      setError(null);
      
      // 加入挑战
      await joinSocialChallenge(
        challengeId,
        currentUserId,
        challenge.isPublic ? undefined : inviteCode
      );
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 重新加载数据
      await loadChallengeData();
      
      // 通知父组件
      if (onChallengeUpdated) {
        onChallengeUpdated();
      }
    } catch (err) {
      console.error('Failed to join challenge:', err);
      setError('加入挑战失败，请重试');
    } finally {
      setIsJoining(false);
    }
  };

  // 处理离开挑战
  const handleLeave = async () => {
    try {
      setIsLeaving(true);
      setError(null);
      
      // 离开挑战
      await leaveSocialChallenge(challengeId, currentUserId);
      
      // 播放点击音效
      playSound(SoundType.BUTTON_CLICK, 0.5);
      
      // 重新加载数据
      await loadChallengeData();
      
      // 通知父组件
      if (onChallengeUpdated) {
        onChallengeUpdated();
      }
    } catch (err) {
      console.error('Failed to leave challenge:', err);
      setError('离开挑战失败，请重试');
    } finally {
      setIsLeaving(false);
    }
  };

  // 处理贡献进度
  const handleContribute = async () => {
    try {
      setIsContributing(true);
      setError(null);
      
      // 贡献进度
      await contributeToChallenge(challengeId, currentUserId, contributionAmount);
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 重新加载数据
      await loadChallengeData();
      
      // 通知父组件
      if (onChallengeUpdated) {
        onChallengeUpdated();
      }
    } catch (err) {
      console.error('Failed to contribute to challenge:', err);
      setError('贡献进度失败，请重试');
    } finally {
      setIsContributing(false);
    }
  };

  // 处理复制邀请码
  const handleCopyInviteCode = () => {
    if (!inviteCode) return;
    
    navigator.clipboard.writeText(inviteCode)
      .then(() => {
        // 播放成功音效
        playSound(SoundType.SUCCESS, 0.3);
        alert('邀请码已复制到剪贴板');
      })
      .catch(err => {
        console.error('Failed to copy invite code:', err);
        alert('复制邀请码失败，请手动复制');
      });
  };

  // 获取挑战类型标签
  const getTypeLabel = (type: SocialChallengeType): string => {
    switch (type) {
      case SocialChallengeType.COOPERATIVE:
        return '合作型';
      case SocialChallengeType.COMPETITIVE:
        return '竞争型';
      case SocialChallengeType.TEAM:
        return '团队型';
      default:
        return '未知';
    }
  };

  // 获取难度标签
  const getDifficultyLabel = (difficulty: ChallengeDifficulty): string => {
    switch (difficulty) {
      case ChallengeDifficulty.EASY:
        return '简单';
      case ChallengeDifficulty.MEDIUM:
        return '中等';
      case ChallengeDifficulty.HARD:
        return '困难';
      case ChallengeDifficulty.EXPERT:
        return '专家';
      default:
        return '未知';
    }
  };

  // 获取状态标签
  const getStatusLabel = (status: ChallengeStatus): string => {
    switch (status) {
      case ChallengeStatus.ACTIVE:
        return '进行中';
      case ChallengeStatus.COMPLETED:
        return '已完成';
      case ChallengeStatus.FAILED:
        return '失败';
      case ChallengeStatus.UPCOMING:
        return '即将开始';
      default:
        return '未知';
    }
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="社交挑战详情"
      closeOnOutsideClick={!isJoining && !isLeaving && !isContributing}
      closeOnEsc={!isJoining && !isLeaving && !isContributing}
      showCloseButton={!isJoining && !isLeaving && !isContributing}
    >
      <div className="social-challenge-detail p-4">
        {isLoading ? (
          <div className="loading-container flex justify-center items-center h-64">
            <LoadingSpinner variant="jade" size="medium" />
          </div>
        ) : error ? (
          <div className="error-container text-center p-4">
            <div className="error-message text-red-500 mb-4">{error}</div>
            <Button variant="jade" onClick={loadChallengeData}>
              重试
            </Button>
          </div>
        ) : challenge ? (
          <div className="challenge-content">
            {/* 挑战头部 */}
            <div className="challenge-header mb-6">
              <div className="flex items-center mb-3">
                <div className="challenge-icon mr-4">
                  <img
                    src={challenge.iconPath || '/assets/challenges/social_default.svg'}
                    alt={challenge.title}
                    className="w-16 h-16 object-contain"
                    onError={(e) => {
                      const target = e.target as HTMLImageElement;
                      target.onerror = null;
                      target.src = '/assets/challenges/social_default.svg';
                    }}
                  />
                </div>
                <div>
                  <h2 className="text-2xl font-bold">{challenge.title}</h2>
                  <div className="challenge-meta flex flex-wrap gap-2 mt-1">
                    <span className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800">
                      {getTypeLabel(challenge.type)}
                    </span>
                    <span className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800">
                      {getDifficultyLabel(challenge.difficulty)}
                    </span>
                    <span className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800">
                      {getStatusLabel(challenge.status)}
                    </span>
                    {challenge.isPublic ? (
                      <span className="px-2 py-1 rounded-full text-xs bg-blue-100 text-blue-800">
                        公开
                      </span>
                    ) : (
                      <span className="px-2 py-1 rounded-full text-xs bg-purple-100 text-purple-800">
                        私密
                      </span>
                    )}
                  </div>
                </div>
              </div>
              
              <div className="challenge-description mb-4">
                <p className="text-gray-700">{challenge.description}</p>
              </div>
              
              <div className="challenge-dates text-sm text-gray-600 mb-4">
                <p>开始日期: {new Date(challenge.startDate).toLocaleDateString()}</p>
                {challenge.endDate && (
                  <p>结束日期: {new Date(challenge.endDate).toLocaleDateString()}</p>
                )}
                <p>创建日期: {new Date(challenge.createdAt).toLocaleDateString()}</p>
              </div>
              
              <div className="challenge-progress mb-4">
                <div className="flex justify-between items-center mb-1">
                  <span className="text-sm text-gray-600">进度</span>
                  <span className="text-sm font-bold">{challenge.progress}%</span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2.5">
                  <div
                    className="bg-jade-500 h-2.5 rounded-full"
                    style={{ width: `${challenge.progress}%` }}
                  ></div>
                </div>
              </div>
              
              {/* 邀请码（仅对参与者显示） */}
              {isParticipant && !challenge.isPublic && (
                <div className="invite-code-section mb-4">
                  <div className="flex items-center justify-between">
                    <h3 className="text-md font-bold">邀请码</h3>
                    <Button
                      variant="secondary"
                      size="small"
                      onClick={() => setShowInviteCode(!showInviteCode)}
                    >
                      {showInviteCode ? '隐藏' : '显示'}
                    </Button>
                  </div>
                  {showInviteCode && (
                    <div className="invite-code-display mt-2 flex items-center">
                      <div className="invite-code bg-gray-100 p-2 rounded-md font-mono">
                        {inviteCode}
                      </div>
                      <Button
                        variant="secondary"
                        size="small"
                        className="ml-2"
                        onClick={handleCopyInviteCode}
                      >
                        复制
                      </Button>
                    </div>
                  )}
                </div>
              )}
            </div>
            
            {/* 参与者列表 */}
            <div className="participants-section mb-6">
              <h3 className="text-lg font-bold mb-2">参与者 ({challenge.participantIds.length}/{challenge.maxParticipants})</h3>
              <div className="participants-list bg-gray-50 p-3 rounded-md">
                {participations.length > 0 ? (
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                    {participations.map((participation) => (
                      <div
                        key={participation.id}
                        className="participant-item flex items-center justify-between p-2 border-b border-gray-200 last:border-b-0"
                      >
                        <div className="participant-info">
                          <div className="flex items-center">
                            <div className="participant-avatar mr-2">
                              <div className="w-8 h-8 bg-gray-300 rounded-full flex items-center justify-center">
                                <span className="text-gray-600">
                                  {participation.userId.charAt(0).toUpperCase()}
                                </span>
                              </div>
                            </div>
                            <div>
                              <p className="text-sm font-medium">
                                {participation.userId === challenge.creatorId ? (
                                  <span className="flex items-center">
                                    {participation.userId}
                                    <span className="ml-1 text-xs px-1 py-0.5 bg-amber-100 text-amber-800 rounded">创建者</span>
                                  </span>
                                ) : (
                                  participation.userId
                                )}
                              </p>
                              <p className="text-xs text-gray-500">
                                加入于 {new Date(participation.joinedAt).toLocaleDateString()}
                              </p>
                            </div>
                          </div>
                        </div>
                        <div className="participant-contribution">
                          <span className="text-sm font-bold">{participation.contribution}</span>
                          <span className="text-xs text-gray-500 ml-1">贡献</span>
                        </div>
                      </div>
                    ))}
                  </div>
                ) : (
                  <p className="text-center text-gray-500 py-2">暂无参与者</p>
                )}
              </div>
            </div>
            
            {/* 操作区域 */}
            <div className="actions-section">
              {isParticipant ? (
                <div className="participant-actions">
                  {/* 贡献进度（仅对活跃挑战显示） */}
                  {challenge.status === ChallengeStatus.ACTIVE && (
                    <div className="contribute-section mb-4">
                      <h3 className="text-lg font-bold mb-2">贡献进度</h3>
                      <div className="flex items-center">
                        <input
                          type="range"
                          min="1"
                          max="20"
                          value={contributionAmount}
                          onChange={(e) => setContributionAmount(parseInt(e.target.value))}
                          className="flex-grow mr-2"
                        />
                        <span className="text-lg font-bold w-8 text-center">{contributionAmount}</span>
                      </div>
                      <Button
                        variant="jade"
                        onClick={handleContribute}
                        disabled={isContributing || challenge.progress >= 100}
                        className="mt-2 w-full"
                      >
                        {isContributing ? (
                          <LoadingSpinner variant="white" size="small" />
                        ) : (
                          '贡献进度'
                        )}
                      </Button>
                    </div>
                  )}
                  
                  {/* 离开挑战按钮（非创建者可见） */}
                  {!isCreator && challenge.status === ChallengeStatus.ACTIVE && (
                    <Button
                      variant="danger"
                      onClick={handleLeave}
                      disabled={isLeaving}
                      className="w-full"
                    >
                      {isLeaving ? (
                        <LoadingSpinner variant="white" size="small" />
                      ) : (
                        '离开挑战'
                      )}
                    </Button>
                  )}
                </div>
              ) : (
                <div className="non-participant-actions">
                  {/* 加入挑战按钮 */}
                  {challenge.status === ChallengeStatus.ACTIVE && challenge.participantIds.length < challenge.maxParticipants && (
                    <div>
                      {!challenge.isPublic && (
                        <div className="invite-code-input mb-2">
                          <label htmlFor="inviteCode" className="block text-sm font-medium text-gray-700 mb-1">
                            邀请码
                          </label>
                          <input
                            type="text"
                            id="inviteCode"
                            value={inviteCode}
                            onChange={(e) => setInviteCode(e.target.value)}
                            className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
                            placeholder="输入邀请码"
                            required={!challenge.isPublic}
                          />
                        </div>
                      )}
                      <Button
                        variant="jade"
                        onClick={handleJoin}
                        disabled={isJoining || (!challenge.isPublic && !inviteCode)}
                        className="w-full"
                      >
                        {isJoining ? (
                          <LoadingSpinner variant="white" size="small" />
                        ) : (
                          '加入挑战'
                        )}
                      </Button>
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        ) : (
          <div className="not-found-container text-center p-4">
            <p className="text-gray-500">挑战不存在或已被删除</p>
          </div>
        )}
      </div>
    </ScrollDialog>
  );
};

export default SocialChallengeDetailDialog;
</file>

<file path="src/components/game/SocialChallengeForm.tsx">
// src/components/game/SocialChallengeForm.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { 
  SocialChallengeRecord, 
  SocialChallengeType,
  createSocialChallenge
} from '@/services/socialChallengeService';
import { ChallengeDifficulty, ChallengeStatus } from '@/services/challengeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from './ScrollDialog';

interface SocialChallengeFormProps {
  isOpen: boolean;
  onClose: () => void;
  onChallengeCreated?: (challenge: SocialChallengeRecord) => void;
}

/**
 * 社交挑战表单组件
 * 用于创建新的社交挑战
 */
const SocialChallengeForm: React.FC<SocialChallengeFormProps> = ({
  isOpen,
  onClose,
  onChallengeCreated
}) => {
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [type, setType] = useState<SocialChallengeType>(SocialChallengeType.COOPERATIVE);
  const [difficulty, setDifficulty] = useState<ChallengeDifficulty>(ChallengeDifficulty.MEDIUM);
  const [maxParticipants, setMaxParticipants] = useState(5);
  const [isPublic, setIsPublic] = useState(true);
  const [startDate, setStartDate] = useState<string>(new Date().toISOString().split('T')[0]);
  const [endDate, setEndDate] = useState<string>('');
  const [iconPath, setIconPath] = useState('');
  
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 处理提交表单
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!title.trim()) {
      setError('请输入挑战标题');
      return;
    }
    
    if (!description.trim()) {
      setError('请输入挑战描述');
      return;
    }
    
    if (!startDate) {
      setError('请选择开始日期');
      return;
    }
    
    try {
      setIsSubmitting(true);
      setError(null);
      
      // 创建社交挑战
      const challenge = await createSocialChallenge({
        title: title.trim(),
        description: description.trim(),
        type,
        difficulty,
        status: ChallengeStatus.ACTIVE,
        creatorId: 'current-user', // 在实际应用中，这应该是当前用户的ID
        maxParticipants,
        startDate: new Date(startDate),
        endDate: endDate ? new Date(endDate) : undefined,
        iconPath: iconPath || undefined,
        isPublic
      });
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 重置表单
      resetForm();
      
      // 通知父组件
      if (onChallengeCreated) {
        onChallengeCreated(challenge);
      }
      
      // 关闭对话框
      onClose();
    } catch (err) {
      console.error('Failed to create social challenge:', err);
      setError('创建挑战失败，请重试');
    } finally {
      setIsSubmitting(false);
    }
  };

  // 重置表单
  const resetForm = () => {
    setTitle('');
    setDescription('');
    setType(SocialChallengeType.COOPERATIVE);
    setDifficulty(ChallengeDifficulty.MEDIUM);
    setMaxParticipants(5);
    setIsPublic(true);
    setStartDate(new Date().toISOString().split('T')[0]);
    setEndDate('');
    setIconPath('');
    setError(null);
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="创建社交挑战"
      closeOnOutsideClick={!isSubmitting}
      closeOnEsc={!isSubmitting}
      showCloseButton={!isSubmitting}
    >
      <div className="social-challenge-form p-4">
        <form onSubmit={handleSubmit}>
          {error && (
            <div className="error-message text-red-500 mb-4 p-2 bg-red-50 rounded-md">
              {error}
            </div>
          )}
          
          {/* 挑战标题 */}
          <div className="form-group mb-4">
            <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-1">
              挑战标题 <span className="text-red-500">*</span>
            </label>
            <input
              type="text"
              id="title"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
              placeholder="输入挑战标题"
              required
            />
          </div>
          
          {/* 挑战描述 */}
          <div className="form-group mb-4">
            <label htmlFor="description" className="block text-sm font-medium text-gray-700 mb-1">
              挑战描述 <span className="text-red-500">*</span>
            </label>
            <textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500 h-24"
              placeholder="输入挑战描述"
              required
            />
          </div>
          
          {/* 挑战类型 */}
          <div className="form-group mb-4">
            <label htmlFor="type" className="block text-sm font-medium text-gray-700 mb-1">
              挑战类型 <span className="text-red-500">*</span>
            </label>
            <select
              id="type"
              value={type}
              onChange={(e) => setType(e.target.value as SocialChallengeType)}
              className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
              required
            >
              <option value={SocialChallengeType.COOPERATIVE}>合作型</option>
              <option value={SocialChallengeType.COMPETITIVE}>竞争型</option>
              <option value={SocialChallengeType.TEAM}>团队型</option>
            </select>
          </div>
          
          {/* 挑战难度 */}
          <div className="form-group mb-4">
            <label htmlFor="difficulty" className="block text-sm font-medium text-gray-700 mb-1">
              挑战难度 <span className="text-red-500">*</span>
            </label>
            <select
              id="difficulty"
              value={difficulty}
              onChange={(e) => setDifficulty(e.target.value as ChallengeDifficulty)}
              className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
              required
            >
              <option value={ChallengeDifficulty.EASY}>简单</option>
              <option value={ChallengeDifficulty.MEDIUM}>中等</option>
              <option value={ChallengeDifficulty.HARD}>困难</option>
              <option value={ChallengeDifficulty.EXPERT}>专家</option>
            </select>
          </div>
          
          {/* 最大参与人数 */}
          <div className="form-group mb-4">
            <label htmlFor="maxParticipants" className="block text-sm font-medium text-gray-700 mb-1">
              最大参与人数 <span className="text-red-500">*</span>
            </label>
            <input
              type="number"
              id="maxParticipants"
              value={maxParticipants}
              onChange={(e) => setMaxParticipants(parseInt(e.target.value))}
              min={2}
              max={20}
              className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
              required
            />
          </div>
          
          {/* 是否公开 */}
          <div className="form-group mb-4">
            <div className="flex items-center">
              <input
                type="checkbox"
                id="isPublic"
                checked={isPublic}
                onChange={(e) => setIsPublic(e.target.checked)}
                className="h-4 w-4 text-jade-600 focus:ring-jade-500 border-gray-300 rounded"
              />
              <label htmlFor="isPublic" className="ml-2 block text-sm text-gray-700">
                公开挑战（任何人都可以加入）
              </label>
            </div>
          </div>
          
          {/* 日期选择 */}
          <div className="form-group mb-4 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label htmlFor="startDate" className="block text-sm font-medium text-gray-700 mb-1">
                开始日期 <span className="text-red-500">*</span>
              </label>
              <input
                type="date"
                id="startDate"
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
                className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
                required
              />
            </div>
            <div>
              <label htmlFor="endDate" className="block text-sm font-medium text-gray-700 mb-1">
                结束日期
              </label>
              <input
                type="date"
                id="endDate"
                value={endDate}
                onChange={(e) => setEndDate(e.target.value)}
                min={startDate}
                className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
              />
            </div>
          </div>
          
          {/* 图标路径 */}
          <div className="form-group mb-4">
            <label htmlFor="iconPath" className="block text-sm font-medium text-gray-700 mb-1">
              图标路径
            </label>
            <input
              type="text"
              id="iconPath"
              value={iconPath}
              onChange={(e) => setIconPath(e.target.value)}
              className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
              placeholder="/assets/challenges/social_default.svg"
            />
          </div>
          
          {/* 提交按钮 */}
          <div className="form-actions flex justify-end gap-2 mt-6">
            <Button
              variant="secondary"
              type="button"
              onClick={onClose}
              disabled={isSubmitting}
            >
              取消
            </Button>
            <Button
              variant="jade"
              type="submit"
              disabled={isSubmitting}
            >
              {isSubmitting ? (
                <LoadingSpinner variant="white" size="small" />
              ) : (
                '创建挑战'
              )}
            </Button>
          </div>
        </form>
      </div>
    </ScrollDialog>
  );
};

export default SocialChallengeForm;
</file>

<file path="src/components/game/SocialChallengeList.tsx">
// src/components/game/SocialChallengeList.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  SocialChallengeRecord, 
  SocialChallengeType,
  getAllSocialChallenges,
  getUserSocialChallenges,
  getPublicSocialChallenges,
  joinSocialChallenge,
  leaveSocialChallenge
} from '@/services/socialChallengeService';
import { ChallengeStatus } from '@/services/challengeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import SocialChallengeCard from './SocialChallengeCard';
import SocialChallengeForm from './SocialChallengeForm';
import SocialChallengeDetailDialog from './SocialChallengeDetailDialog';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface SocialChallengeListProps {
  filter?: 'all' | 'my' | 'public';
  maxItems?: number;
  showCreateButton?: boolean;
  className?: string;
}

/**
 * 社交挑战列表组件
 * 用于显示社交挑战列表
 */
const SocialChallengeList: React.FC<SocialChallengeListProps> = ({
  filter = 'all',
  maxItems,
  showCreateButton = true,
  className = ''
}) => {
  const [challenges, setChallenges] = useState<SocialChallengeRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [selectedChallengeId, setSelectedChallengeId] = useState<number | null>(null);
  const [showDetailDialog, setShowDetailDialog] = useState(false);
  const [joinInviteCode, setJoinInviteCode] = useState('');
  
  // 当前用户ID（在实际应用中，这应该从用户会话中获取）
  const currentUserId = 'current-user';

  // 加载挑战数据
  const loadChallenges = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      let challengesList: SocialChallengeRecord[] = [];
      
      // 根据过滤条件获取挑战
      switch (filter) {
        case 'my':
          challengesList = await getUserSocialChallenges(currentUserId);
          break;
        case 'public':
          challengesList = await getPublicSocialChallenges();
          break;
        default:
          challengesList = await getAllSocialChallenges();
          break;
      }
      
      // 限制数量
      if (maxItems && challengesList.length > maxItems) {
        challengesList = challengesList.slice(0, maxItems);
      }
      
      setChallenges(challengesList);
    } catch (err) {
      console.error('Failed to load social challenges:', err);
      setError('加载社交挑战失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadChallenges();
  }, [filter, maxItems]);

  // 注册数据刷新监听
  useRegisterTableRefresh('socialChallenges', loadChallenges);
  useRegisterTableRefresh('socialChallengeParticipations', loadChallenges);

  // 处理创建挑战
  const handleCreateChallenge = () => {
    setShowCreateForm(true);
  };

  // 处理挑战创建完成
  const handleChallengeCreated = (challenge: SocialChallengeRecord) => {
    // 播放成功音效
    playSound(SoundType.SUCCESS, 0.5);
    
    // 重新加载挑战
    loadChallenges();
  };

  // 处理加入挑战
  const handleJoinChallenge = async (challengeId: number) => {
    try {
      // 获取挑战
      const challenge = challenges.find(c => c.id === challengeId);
      if (!challenge) return;
      
      // 如果是非公开挑战，需要邀请码
      if (!challenge.isPublic) {
        const code = prompt('请输入邀请码');
        if (!code) return;
        setJoinInviteCode(code);
      }
      
      // 加入挑战
      await joinSocialChallenge(
        challengeId,
        currentUserId,
        challenge.isPublic ? undefined : joinInviteCode
      );
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 重新加载挑战
      loadChallenges();
    } catch (err) {
      console.error('Failed to join challenge:', err);
      alert('加入挑战失败，请重试');
    }
  };

  // 处理离开挑战
  const handleLeaveChallenge = async (challengeId: number) => {
    try {
      // 确认离开
      if (!confirm('确定要离开这个挑战吗？')) return;
      
      // 离开挑战
      await leaveSocialChallenge(challengeId, currentUserId);
      
      // 播放点击音效
      playSound(SoundType.BUTTON_CLICK, 0.5);
      
      // 重新加载挑战
      loadChallenges();
    } catch (err) {
      console.error('Failed to leave challenge:', err);
      alert('离开挑战失败，请重试');
    }
  };

  // 处理查看挑战详情
  const handleViewChallengeDetails = (challengeId: number) => {
    setSelectedChallengeId(challengeId);
    setShowDetailDialog(true);
  };

  // 处理分享挑战
  const handleShareChallenge = (challengeId: number, inviteCode: string) => {
    // 复制邀请码到剪贴板
    navigator.clipboard.writeText(inviteCode)
      .then(() => {
        // 播放成功音效
        playSound(SoundType.SUCCESS, 0.3);
        alert('邀请码已复制到剪贴板');
      })
      .catch(err => {
        console.error('Failed to copy invite code:', err);
        alert('复制邀请码失败，请手动复制: ' + inviteCode);
      });
  };

  // 处理挑战更新
  const handleChallengeUpdated = () => {
    // 重新加载挑战
    loadChallenges();
  };

  // 容器变体
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // 项目变体
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  return (
    <div className={`social-challenge-list ${className}`}>
      {/* 头部 */}
      <div className="list-header flex justify-between items-center mb-4">
        <h2 className="text-xl font-bold">
          {filter === 'my' ? '我的社交挑战' : 
           filter === 'public' ? '公开社交挑战' : 
           '所有社交挑战'}
        </h2>
        {showCreateButton && (
          <Button
            variant="jade"
            onClick={handleCreateChallenge}
          >
            创建挑战
          </Button>
        )}
      </div>
      
      {/* 内容 */}
      <div className="list-content">
        {isLoading ? (
          <div className="loading-container flex justify-center items-center h-32">
            <LoadingSpinner variant="jade" size="medium" />
          </div>
        ) : error ? (
          <div className="error-container text-center p-4">
            <div className="error-message text-red-500 mb-4">{error}</div>
            <Button variant="jade" onClick={loadChallenges}>
              重试
            </Button>
          </div>
        ) : challenges.length > 0 ? (
          <motion.div
            className="challenges-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
            variants={containerVariants}
            initial="hidden"
            animate="visible"
          >
            {challenges.map((challenge) => (
              <motion.div
                key={challenge.id}
                variants={itemVariants}
              >
                <SocialChallengeCard
                  challenge={challenge}
                  isParticipant={challenge.participantIds.includes(currentUserId)}
                  onJoin={handleJoinChallenge}
                  onLeave={handleLeaveChallenge}
                  onViewDetails={handleViewChallengeDetails}
                  onShare={handleShareChallenge}
                />
              </motion.div>
            ))}
          </motion.div>
        ) : (
          <div className="empty-container text-center p-8 bg-gray-50 rounded-lg">
            <p className="text-gray-500 mb-4">
              {filter === 'my' ? '你还没有参与任何社交挑战' : 
               filter === 'public' ? '暂无公开的社交挑战' : 
               '暂无社交挑战'}
            </p>
            {filter !== 'my' && showCreateButton && (
              <Button variant="jade" onClick={handleCreateChallenge}>
                创建第一个挑战
              </Button>
            )}
          </div>
        )}
      </div>
      
      {/* 创建挑战表单 */}
      {showCreateForm && (
        <SocialChallengeForm
          isOpen={showCreateForm}
          onClose={() => setShowCreateForm(false)}
          onChallengeCreated={handleChallengeCreated}
        />
      )}
      
      {/* 挑战详情对话框 */}
      {showDetailDialog && selectedChallengeId !== null && (
        <SocialChallengeDetailDialog
          isOpen={showDetailDialog}
          onClose={() => setShowDetailDialog(false)}
          challengeId={selectedChallengeId}
          onChallengeUpdated={handleChallengeUpdated}
        />
      )}
    </div>
  );
};

export default SocialChallengeList;
</file>

<file path="src/components/game/TaskDetailDialog.tsx">
// src/components/game/TaskDetailDialog.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ScrollDialog from './ScrollDialog';
import Button from '@/components/common/Button';
import { TaskRecord, TaskStatus, TaskPriority, TaskType, updateTask, completeTask } from '@/services/taskService';
import { hasSubtasks, convertTaskToParentTask } from '@/services/subtaskService';
import SubtaskList from '@/components/tasks/SubtaskList';
import { playSound, SoundType } from '@/utils/sound';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { RewardRecord } from '@/services/rewardService';
import RewardModal from './RewardModal';

interface TaskDetailDialogProps {
  isOpen: boolean;
  onClose: () => void;
  task: TaskRecord;
  onTaskUpdated?: () => void;
}

/**
 * 任务详情对话框组件
 * 用于显示任务详情、管理子任务和完成任务
 */
const TaskDetailDialog: React.FC<TaskDetailDialogProps> = ({
  isOpen,
  onClose,
  task,
  onTaskUpdated
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasSubtasksList, setHasSubtasksList] = useState(false);
  const [isAddingSubtasks, setIsAddingSubtasks] = useState(false);
  const [subtaskTitles, setSubtaskTitles] = useState<string[]>([]);
  const [currentSubtaskTitle, setCurrentSubtaskTitle] = useState('');
  const [isCompletingTask, setIsCompletingTask] = useState(false);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [showRewardModal, setShowRewardModal] = useState(false);

  // 检查任务是否有子任务
  useEffect(() => {
    const checkSubtasks = async () => {
      if (task && task.id) {
        try {
          const hasSubtasksList = await hasSubtasks(task.id);
          setHasSubtasksList(hasSubtasksList);
        } catch (err) {
          console.error('Failed to check subtasks:', err);
        }
      }
    };

    if (isOpen) {
      checkSubtasks();
    }
  }, [task, isOpen]);

  // 处理添加子任务
  const handleAddSubtask = () => {
    if (!currentSubtaskTitle.trim()) return;
    
    setSubtaskTitles([...subtaskTitles, currentSubtaskTitle.trim()]);
    setCurrentSubtaskTitle('');
  };

  // 处理移除子任务
  const handleRemoveSubtask = (index: number) => {
    const newSubtaskTitles = [...subtaskTitles];
    newSubtaskTitles.splice(index, 1);
    setSubtaskTitles(newSubtaskTitles);
  };

  // 处理转换为带有子任务的任务
  const handleConvertToParentTask = async () => {
    if (subtaskTitles.length === 0) return;

    try {
      setIsAddingSubtasks(true);
      setError(null);
      
      await convertTaskToParentTask(task.id!, subtaskTitles);
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 重置状态
      setSubtaskTitles([]);
      setHasSubtasksList(true);
      
      // 通知父组件任务已更新
      if (onTaskUpdated) {
        onTaskUpdated();
      }
    } catch (err) {
      console.error('Failed to convert task to parent task:', err);
      setError('转换任务失败，请重试');
    } finally {
      setIsAddingSubtasks(false);
    }
  };

  // 处理完成任务
  const handleCompleteTask = async () => {
    try {
      setIsCompletingTask(true);
      setError(null);
      
      // 完成任务
      const result = await completeTask(task.id!);
      
      // 设置奖励
      setRewards(result.rewards);
      
      // 播放成功音效
      playSound(SoundType.TASK_COMPLETE, 0.5);
      
      // 显示奖励模态框
      setShowRewardModal(true);
      
      // 通知父组件任务已更新
      if (onTaskUpdated) {
        onTaskUpdated();
      }
    } catch (err) {
      console.error('Failed to complete task:', err);
      setError('完成任务失败，请重试');
    } finally {
      setIsCompletingTask(false);
    }
  };

  // 处理关闭奖励模态框
  const handleCloseRewardModal = () => {
    setShowRewardModal(false);
    onClose();
  };

  // 获取任务优先级标签
  const getPriorityLabel = (priority: TaskPriority): string => {
    switch (priority) {
      case TaskPriority.HIGH:
        return '高';
      case TaskPriority.MEDIUM:
        return '中';
      case TaskPriority.LOW:
        return '低';
      default:
        return '未知';
    }
  };

  // 获取任务类型标签
  const getTypeLabel = (type: TaskType): string => {
    switch (type) {
      case TaskType.MAIN:
        return '主线任务';
      case TaskType.DAILY:
        return '日常任务';
      case TaskType.SIDE:
        return '支线任务';
      default:
        return '未知';
    }
  };

  // 获取任务状态标签
  const getStatusLabel = (status: TaskStatus): string => {
    switch (status) {
      case TaskStatus.TODO:
        return '待办';
      case TaskStatus.IN_PROGRESS:
        return '进行中';
      case TaskStatus.COMPLETED:
        return '已完成';
      case TaskStatus.ARCHIVED:
        return '已归档';
      default:
        return '未知';
    }
  };

  return (
    <>
      <ScrollDialog
        isOpen={isOpen}
        onClose={onClose}
        title="任务详情"
        closeOnOutsideClick={!isCompletingTask}
        closeOnEsc={!isCompletingTask}
        showCloseButton={!isCompletingTask}
      >
        <div className="task-detail-content p-4">
          {error && (
            <div className="error-message text-red-500 mb-4">{error}</div>
          )}
          
          <div className="task-header mb-4">
            <h2 className="text-xl font-bold">{task.title}</h2>
            <div className="task-meta flex flex-wrap gap-2 mt-2">
              <span className="task-priority px-2 py-1 rounded-full text-xs bg-amber-100 text-amber-800">
                优先级: {getPriorityLabel(task.priority)}
              </span>
              <span className="task-type px-2 py-1 rounded-full text-xs bg-blue-100 text-blue-800">
                {getTypeLabel(task.type)}
              </span>
              <span className={`task-status px-2 py-1 rounded-full text-xs ${
                task.status === TaskStatus.COMPLETED
                  ? 'bg-green-100 text-green-800'
                  : task.status === TaskStatus.IN_PROGRESS
                  ? 'bg-blue-100 text-blue-800'
                  : 'bg-gray-100 text-gray-800'
              }`}>
                {getStatusLabel(task.status)}
              </span>
            </div>
          </div>
          
          {task.description && (
            <div className="task-description mb-4">
              <h3 className="text-lg font-bold mb-1">描述</h3>
              <p className="text-gray-700">{task.description}</p>
            </div>
          )}
          
          {task.dueDate && (
            <div className="task-due-date mb-4">
              <h3 className="text-lg font-bold mb-1">截止日期</h3>
              <p className="text-gray-700">{new Date(task.dueDate).toLocaleDateString()}</p>
            </div>
          )}
          
          {/* 子任务列表 */}
          {hasSubtasksList && (
            <SubtaskList
              parentTaskId={task.id!}
              onSubtasksChange={setHasSubtasksList}
            />
          )}
          
          {/* 添加子任务表单 */}
          {!hasSubtasksList && task.status !== TaskStatus.COMPLETED && (
            <div className="add-subtasks-section mt-4">
              <h3 className="text-lg font-bold mb-2">添加子任务</h3>
              
              <div className="subtask-input-container mb-2">
                <div className="flex">
                  <input
                    type="text"
                    value={currentSubtaskTitle}
                    onChange={(e) => setCurrentSubtaskTitle(e.target.value)}
                    placeholder="输入子任务标题..."
                    className="flex-grow p-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-2 focus:ring-jade-500"
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') {
                        handleAddSubtask();
                      }
                    }}
                  />
                  <Button
                    variant="jade"
                    onClick={handleAddSubtask}
                    disabled={!currentSubtaskTitle.trim()}
                    className="rounded-l-none"
                  >
                    添加
                  </Button>
                </div>
              </div>
              
              {subtaskTitles.length > 0 && (
                <div className="subtask-list-preview mb-4">
                  <h4 className="text-md font-bold mb-1">子任务列表预览</h4>
                  <ul className="list-disc pl-5">
                    {subtaskTitles.map((title, index) => (
                      <li key={index} className="flex items-center justify-between mb-1">
                        <span>{title}</span>
                        <button
                          onClick={() => handleRemoveSubtask(index)}
                          className="text-red-500 hover:text-red-700"
                          aria-label="移除子任务"
                        >
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                            <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                          </svg>
                        </button>
                      </li>
                    ))}
                  </ul>
                  
                  <Button
                    variant="gold"
                    onClick={handleConvertToParentTask}
                    disabled={isAddingSubtasks || subtaskTitles.length === 0}
                    className="mt-2"
                  >
                    {isAddingSubtasks ? (
                      <LoadingSpinner variant="white" size="small" />
                    ) : (
                      '创建子任务'
                    )}
                  </Button>
                </div>
              )}
            </div>
          )}
          
          {/* 任务操作按钮 */}
          <div className="task-actions mt-4 flex justify-end">
            {task.status !== TaskStatus.COMPLETED && (
              <Button
                variant="jade"
                onClick={handleCompleteTask}
                disabled={isCompletingTask}
                className="mr-2"
              >
                {isCompletingTask ? (
                  <LoadingSpinner variant="white" size="small" />
                ) : (
                  '完成任务'
                )}
              </Button>
            )}
            
            <Button variant="secondary" onClick={onClose}>
              关闭
            </Button>
          </div>
        </div>
      </ScrollDialog>
      
      {/* 奖励模态框 */}
      {showRewardModal && (
        <RewardModal
          isOpen={showRewardModal}
          onClose={handleCloseRewardModal}
          rewards={rewards}
        />
      )}
    </>
  );
};

export default TaskDetailDialog;
</file>

<file path="src/components/game/TaskForm.tsx">
// src/components/game/TaskForm.tsx
import React, { useState, useEffect } from 'react';
import { 
  TaskRecord, 
  TaskPriority, 
  TaskType, 
  TaskCategoryRecord,
  getAllTaskCategories
} from '@/services/taskService';
import Button from '@/components/common/Button';

interface TaskFormProps {
  initialTask?: Partial<TaskRecord>;
  onSubmit: (task: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'>) => void;
  onCancel: () => void;
}

/**
 * 任务表单组件，用于创建和编辑任务
 */
const TaskForm: React.FC<TaskFormProps> = ({
  initialTask = {},
  onSubmit,
  onCancel
}) => {
  // 表单状态
  const [title, setTitle] = useState(initialTask.title || '');
  const [description, setDescription] = useState(initialTask.description || '');
  const [categoryId, setCategoryId] = useState<number | undefined>(initialTask.categoryId);
  const [type, setType] = useState<TaskType>(initialTask.type || TaskType.DAILY);
  const [priority, setPriority] = useState<TaskPriority>(initialTask.priority || TaskPriority.MEDIUM);
  const [dueDate, setDueDate] = useState<string>(
    initialTask.dueDate 
      ? new Date(initialTask.dueDate).toISOString().split('T')[0] 
      : ''
  );
  const [estimatedMinutes, setEstimatedMinutes] = useState<number | undefined>(
    initialTask.estimatedMinutes
  );
  const [categories, setCategories] = useState<TaskCategoryRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});

  // 加载任务类别
  useEffect(() => {
    const loadCategories = async () => {
      try {
        setIsLoading(true);
        const allCategories = await getAllTaskCategories();
        setCategories(allCategories);
        
        // 如果没有选择类别，默认选择第一个
        if (!categoryId && allCategories.length > 0) {
          setCategoryId(allCategories[0].id);
        }
      } catch (error) {
        console.error('Failed to load task categories:', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    loadCategories();
  }, [categoryId]);

  // 验证表单
  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    if (!title.trim()) {
      newErrors.title = '请输入任务标题';
    }
    
    if (!categoryId) {
      newErrors.categoryId = '请选择任务类别';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // 处理表单提交
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }
    
    const taskData: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'> = {
      title,
      description: description || undefined,
      categoryId: categoryId!,
      type,
      priority,
      dueDate: dueDate ? new Date(dueDate) : undefined,
      estimatedMinutes: estimatedMinutes || undefined
    };
    
    onSubmit(taskData);
  };

  return (
    <form className="task-form bamboo-frame" onSubmit={handleSubmit}>
      <h2>{initialTask.id ? '编辑任务' : '创建新任务'}</h2>
      
      <div className="form-group">
        <label htmlFor="task-title">标题 *</label>
        <input
          id="task-title"
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          className={errors.title ? 'error' : ''}
          placeholder="输入任务标题"
        />
        {errors.title && <div className="error-message">{errors.title}</div>}
      </div>
      
      <div className="form-group">
        <label htmlFor="task-description">描述</label>
        <textarea
          id="task-description"
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          placeholder="输入任务描述（可选）"
          rows={3}
        />
      </div>
      
      <div className="form-group">
        <label htmlFor="task-category">类别 *</label>
        <select
          id="task-category"
          value={categoryId}
          onChange={(e) => setCategoryId(Number(e.target.value))}
          className={errors.categoryId ? 'error' : ''}
          disabled={isLoading}
        >
          <option value="">选择类别</option>
          {categories.map((category) => (
            <option key={category.id} value={category.id}>
              {category.name}
            </option>
          ))}
        </select>
        {errors.categoryId && <div className="error-message">{errors.categoryId}</div>}
      </div>
      
      <div className="form-group">
        <label htmlFor="task-type">任务类型</label>
        <select
          id="task-type"
          value={type}
          onChange={(e) => setType(e.target.value as TaskType)}
        >
          <option value={TaskType.DAILY}>日常任务</option>
          <option value={TaskType.MAIN}>主线任务</option>
          <option value={TaskType.SIDE}>支线任务</option>
        </select>
      </div>
      
      <div className="form-group">
        <label htmlFor="task-priority">优先级</label>
        <select
          id="task-priority"
          value={priority}
          onChange={(e) => setPriority(e.target.value as TaskPriority)}
        >
          <option value={TaskPriority.LOW}>低</option>
          <option value={TaskPriority.MEDIUM}>中</option>
          <option value={TaskPriority.HIGH}>高</option>
        </select>
      </div>
      
      <div className="form-group">
        <label htmlFor="task-due-date">截止日期</label>
        <input
          id="task-due-date"
          type="date"
          value={dueDate}
          onChange={(e) => setDueDate(e.target.value)}
        />
      </div>
      
      <div className="form-group">
        <label htmlFor="task-estimated-time">预计时间（分钟）</label>
        <input
          id="task-estimated-time"
          type="number"
          min="1"
          value={estimatedMinutes || ''}
          onChange={(e) => setEstimatedMinutes(e.target.value ? Number(e.target.value) : undefined)}
          placeholder="预计完成时间（可选）"
        />
      </div>
      
      <div className="form-actions">
        <Button variant="jade" type="submit">
          {initialTask.id ? '保存修改' : '创建任务'}
        </Button>
        <Button variant="secondary" type="button" onClick={onCancel}>
          取消
        </Button>
      </div>
    </form>
  );
};

export default TaskForm;
</file>

<file path="src/components/game/TimelyRewardCard.tsx">
// src/components/game/TimelyRewardCard.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { TimelyRewardRecord, TimelyRewardStatus, TimelyRewardType } from '@/services/timelyRewardService';
import ProgressBar from '@/components/common/ProgressBar';
import { formatTime } from '@/utils/dateUtils';
import { TimelyRewardCardLabels } from '@/types';

interface TimelyRewardCardProps {
  reward: TimelyRewardRecord;
  onClick?: (reward: TimelyRewardRecord) => void;
  onComplete?: (rewardId: number) => void;
  labels?: TimelyRewardCardLabels;
}

/**
 * Timely reward card component
 * Displays basic information and progress of a timely reward
 */
const TimelyRewardCard: React.FC<TimelyRewardCardProps> = ({ reward, onClick, onComplete, labels }) => {
  // Add console log to check labels
  console.log('TimelyRewardCard labels:', labels);
  // 获取奖励状态对应的样式类
  const getStatusClass = () => {
    switch (reward.status) {
      case TimelyRewardStatus.ACTIVE:
        return 'reward-active';
      case TimelyRewardStatus.COMPLETED:
        return 'reward-completed';
      case TimelyRewardStatus.EXPIRED:
        return 'reward-expired';
      case TimelyRewardStatus.UPCOMING:
        return 'reward-upcoming';
      default:
        return '';
    }
  };

  // Get reward type text with localization
  const getTypeText = () => {
    switch (reward.type) {
      case TimelyRewardType.DAILY:
        return labels?.typeDaily || 'Daily Reward';
      case TimelyRewardType.MORNING:
        return labels?.typeMorning || 'Early Bird Reward';
      case TimelyRewardType.STREAK:
        return labels?.typeStreak || 'Streak Reward';
      case TimelyRewardType.SPECIAL:
        return labels?.typeSpecial || 'Special Reward';
      default:
        return '';
    }
  };

  // Get reward status text with localization
  const getStatusText = () => {
    switch (reward.status) {
      case TimelyRewardStatus.ACTIVE:
        return labels?.statusActive || 'Active';
      case TimelyRewardStatus.COMPLETED:
        return labels?.statusCompleted || 'Completed';
      case TimelyRewardStatus.EXPIRED:
        return labels?.statusExpired || 'Expired';
      case TimelyRewardStatus.UPCOMING:
        return labels?.statusUpcoming || 'Upcoming';
      default:
        return '';
    }
  };

  // Calculate remaining time with localization
  const getRemainingTime = () => {
    const now = new Date();
    const endTime = new Date(reward.endTime);

    if (now > endTime) {
      return labels?.timeEnded || 'Ended';
    }

    const diffMs = endTime.getTime() - now.getTime();
    const diffHrs = Math.floor(diffMs / (1000 * 60 * 60));
    const diffMins = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));

    const hourUnit = labels?.hourUnit || 'h';
    const minuteUnit = labels?.minuteUnit || 'm';

    return `${diffHrs}${hourUnit} ${diffMins}${minuteUnit}`;
  };

  // 处理点击事件
  const handleClick = () => {
    if (onClick) {
      onClick(reward);
    }
  };

  // 处理完成奖励事件
  const handleComplete = (e: React.MouseEvent) => {
    e.stopPropagation(); // 阻止事件冒泡
    if (onComplete && reward.status === TimelyRewardStatus.ACTIVE && reward.progress >= 100) {
      onComplete(reward.id!);
    }
  };

  return (
    <motion.div
      className={`timely-reward-card ${getStatusClass()}`}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={handleClick}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      transition={{ duration: 0.3 }}
    >
      <div className="reward-card-header">
        <div className="reward-icon">
          <img src={reward.iconPath} alt={reward.title} />
        </div>
        <div className="reward-title-section">
          <h3 className="reward-title">{reward.title}</h3>
          <div className="reward-meta">
            <span className="reward-type">{getTypeText()}</span>
            <span className={`reward-status ${getStatusClass()}`}>
              {getStatusText()}
            </span>
          </div>
        </div>
      </div>

      <div className="reward-card-body">
        <p className="reward-description">{reward.description}</p>

        <div className="reward-progress-section">
          <ProgressBar
            progress={reward.progress}
            total={100}
            showPercentage
            className={getStatusClass()}
          />
          <div className="reward-time-info">
            <div className="reward-time-range">
              {formatTime(reward.startTime)} - {formatTime(reward.endTime)}
            </div>
            {reward.status === TimelyRewardStatus.ACTIVE && (
              <div className="reward-remaining-time">
                {labels?.remainingTimeLabel || 'Remaining time'}: {getRemainingTime()}
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="reward-card-footer">
        <div className="reward-points">
          <span className="lucky-points-icon">🍀</span>
          <span className="lucky-points-value">{reward.luckyPoints} {labels?.luckyPointsLabel || 'Lucky Points'}</span>
        </div>

        {reward.status === TimelyRewardStatus.ACTIVE && (
          <button
            className="complete-reward-button"
            onClick={handleComplete}
            disabled={reward.progress < 100}
          >
            {reward.progress >= 100 ? (labels?.claimRewardButton || 'Claim Reward') : (labels?.inProgressButton || 'In Progress...')}
          </button>
        )}
        {reward.status === TimelyRewardStatus.COMPLETED && (
          <div className="reward-completed-info">
            <span className="completion-date">
              {labels?.completedOnLabel || 'Completed on'}: {formatTime(reward.completedTime!)}
            </span>
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default TimelyRewardCard;
</file>

<file path="src/components/layout/Header.tsx">
// src/components/layout/Header.tsx
import React from 'react';
import type { GlobalLayoutLabelsBundle } from '@/types';

interface HeaderProps {
  labels: GlobalLayoutLabelsBundle | undefined;
  isFetching?: boolean;
}

const Header: React.FC<HeaderProps> = ({ labels, isFetching }) => {
  return (
    <header style={{
      opacity: isFetching ? 0.7 : 1,
      display: 'flex',
      justifyContent: 'center',
      padding: '10px 0'
    }}>
      {/* 移动应用通常不需要显示应用标题 */}
      {isFetching && labels &&
        <small style={{ fontStyle: 'italic', color: '#555' }}>(syncing...)</small>
      }
    </header>
  );
};
export default Header;
</file>

<file path="src/components/panda/PandaCustomizationPanel.tsx">
// src/components/panda/PandaCustomizationPanel.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  PandaAccessoryRecord, 
  PandaAccessoryType,
  getOwnedAccessories,
  getEquippedAccessories,
  equipAccessory,
  unequipAccessory
} from '@/services/pandaCustomizationService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from '@/components/game/ScrollDialog';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface PandaCustomizationPanelProps {
  isOpen: boolean;
  onClose: () => void;
  onCustomizationChanged?: () => void;
}

/**
 * 熊猫定制面板组件
 * 用于定制熊猫的外观，包括帽子、眼镜、围巾等装饰
 */
const PandaCustomizationPanel: React.FC<PandaCustomizationPanelProps> = ({
  isOpen,
  onClose,
  onCustomizationChanged
}) => {
  const [accessories, setAccessories] = useState<PandaAccessoryRecord[]>([]);
  const [equippedAccessories, setEquippedAccessories] = useState<PandaAccessoryRecord[]>([]);
  const [selectedType, setSelectedType] = useState<PandaAccessoryType | 'all'>('all');
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isUpdating, setIsUpdating] = useState(false);
  
  // 加载装饰数据
  const loadAccessories = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // 获取已拥有的装饰
      const ownedAccessories = await getOwnedAccessories();
      setAccessories(ownedAccessories);
      
      // 获取已装备的装饰
      const equipped = await getEquippedAccessories();
      setEquippedAccessories(equipped);
    } catch (err) {
      console.error('Failed to load accessories:', err);
      setError('加载装饰失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    if (isOpen) {
      loadAccessories();
    }
  }, [isOpen]);

  // 注册数据刷新监听
  useRegisterTableRefresh('pandaAccessories', loadAccessories);

  // 处理装备装饰
  const handleEquipAccessory = async (accessory: PandaAccessoryRecord) => {
    try {
      setIsUpdating(true);
      
      if (accessory.isEquipped) {
        // 取消装备
        await unequipAccessory(accessory.id!);
      } else {
        // 装备
        await equipAccessory(accessory.id!);
      }
      
      // 播放音效
      playSound(SoundType.BUTTON_CLICK, 0.5);
      
      // 重新加载数据
      await loadAccessories();
      
      // 通知父组件
      if (onCustomizationChanged) {
        onCustomizationChanged();
      }
    } catch (err) {
      console.error('Failed to update accessory:', err);
      setError('更新装饰失败，请重试');
    } finally {
      setIsUpdating(false);
    }
  };

  // 获取装饰类型标签
  const getAccessoryTypeLabel = (type: PandaAccessoryType): string => {
    switch (type) {
      case PandaAccessoryType.HAT:
        return '帽子';
      case PandaAccessoryType.GLASSES:
        return '眼镜';
      case PandaAccessoryType.SCARF:
        return '围巾';
      case PandaAccessoryType.PENDANT:
        return '挂饰';
      case PandaAccessoryType.BACKGROUND:
        return '背景';
      case PandaAccessoryType.FRAME:
        return '边框';
      case PandaAccessoryType.EFFECT:
        return '特效';
      default:
        return '未知';
    }
  };

  // 获取稀有度标签和样式
  const getRarityInfo = (rarity: string) => {
    switch (rarity) {
      case 'common':
        return { label: '普通', className: 'bg-gray-100 text-gray-800 border-gray-300' };
      case 'uncommon':
        return { label: '优秀', className: 'bg-green-100 text-green-800 border-green-300' };
      case 'rare':
        return { label: '稀有', className: 'bg-blue-100 text-blue-800 border-blue-300' };
      case 'epic':
        return { label: '史诗', className: 'bg-purple-100 text-purple-800 border-purple-300' };
      case 'legendary':
        return { label: '传说', className: 'bg-amber-100 text-amber-800 border-amber-300' };
      default:
        return { label: '未知', className: 'bg-gray-100 text-gray-800 border-gray-300' };
    }
  };

  // 过滤装饰
  const getFilteredAccessories = (): PandaAccessoryRecord[] => {
    if (selectedType === 'all') {
      return accessories;
    }
    
    return accessories.filter(accessory => accessory.type === selectedType);
  };

  // 获取已装备的装饰
  const getEquippedAccessory = (type: PandaAccessoryType): PandaAccessoryRecord | undefined => {
    return equippedAccessories.find(accessory => accessory.type === type);
  };

  // 容器变体
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // 项目变体
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  // 装饰类型选项
  const accessoryTypes: (PandaAccessoryType | 'all')[] = [
    'all',
    PandaAccessoryType.HAT,
    PandaAccessoryType.GLASSES,
    PandaAccessoryType.SCARF,
    PandaAccessoryType.PENDANT,
    PandaAccessoryType.BACKGROUND,
    PandaAccessoryType.FRAME,
    PandaAccessoryType.EFFECT
  ];

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="熊猫定制"
      closeOnOutsideClick={!isUpdating}
      closeOnEsc={!isUpdating}
      showCloseButton={!isUpdating}
    >
      <div className="panda-customization-panel p-4">
        {isLoading ? (
          <div className="loading-container flex justify-center items-center h-32">
            <LoadingSpinner variant="jade" size="medium" />
          </div>
        ) : error ? (
          <div className="error-container text-center p-4">
            <div className="error-message text-red-500 mb-4">{error}</div>
            <Button variant="jade" onClick={loadAccessories}>
              重试
            </Button>
          </div>
        ) : (
          <div className="customization-content">
            {/* 当前装备 */}
            <div className="current-equipment mb-6">
              <h3 className="text-lg font-bold mb-3">当前装备</h3>
              <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                {accessoryTypes.slice(1).map((type) => {
                  const equipped = getEquippedAccessory(type);
                  return (
                    <div key={type} className="equipped-item p-2 border border-gray-200 rounded-lg">
                      <div className="item-type text-sm font-medium mb-1">
                        {getAccessoryTypeLabel(type)}
                      </div>
                      {equipped ? (
                        <div className="item-info flex items-center">
                          <img
                            src={equipped.imagePath}
                            alt={equipped.name}
                            className="w-8 h-8 object-contain mr-2"
                            onError={(e) => {
                              const target = e.target as HTMLImageElement;
                              target.onerror = null;
                              target.src = '/assets/accessories/default.svg';
                            }}
                          />
                          <div className="item-name text-sm truncate">
                            {equipped.name}
                          </div>
                        </div>
                      ) : (
                        <div className="item-empty text-sm text-gray-500">
                          未装备
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
            
            {/* 装饰类型过滤器 */}
            <div className="accessory-type-filter mb-4">
              <h3 className="text-lg font-bold mb-2">装饰类型</h3>
              <div className="flex flex-wrap gap-2">
                {accessoryTypes.map((type) => (
                  <button
                    key={type}
                    className={`px-3 py-1 rounded-full text-sm ${
                      selectedType === type ? 'bg-jade-100 text-jade-800 border border-jade-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
                    }`}
                    onClick={() => setSelectedType(type)}
                  >
                    {type === 'all' ? '全部' : getAccessoryTypeLabel(type)}
                  </button>
                ))}
              </div>
            </div>
            
            {/* 装饰列表 */}
            <div className="accessories-list">
              <h3 className="text-lg font-bold mb-3">可用装饰</h3>
              {getFilteredAccessories().length === 0 ? (
                <div className="no-accessories text-center p-4 bg-gray-50 rounded-lg">
                  <p className="text-gray-500">暂无可用装饰</p>
                </div>
              ) : (
                <motion.div
                  className="accessories-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
                  variants={containerVariants}
                  initial="hidden"
                  animate="visible"
                >
                  {getFilteredAccessories().map((accessory) => {
                    const rarityInfo = getRarityInfo(accessory.rarity);
                    return (
                      <motion.div
                        key={accessory.id}
                        className={`accessory-item p-3 rounded-lg border ${
                          accessory.isEquipped ? 'border-jade-500 bg-jade-50' : 'border-gray-200 bg-white'
                        }`}
                        variants={itemVariants}
                      >
                        <div className="accessory-header flex justify-between items-start mb-2">
                          <div className="accessory-name font-medium">
                            {accessory.name}
                          </div>
                          <div className="accessory-meta flex gap-1">
                            <span className={`px-2 py-0.5 rounded-full text-xs ${rarityInfo.className}`}>
                              {rarityInfo.label}
                            </span>
                            <span className="px-2 py-0.5 rounded-full text-xs bg-gray-100 text-gray-800">
                              {getAccessoryTypeLabel(accessory.type)}
                            </span>
                          </div>
                        </div>
                        
                        <div className="accessory-image-container mb-2 flex justify-center">
                          <img
                            src={accessory.imagePath}
                            alt={accessory.name}
                            className="h-24 object-contain"
                            onError={(e) => {
                              const target = e.target as HTMLImageElement;
                              target.onerror = null;
                              target.src = '/assets/accessories/default.svg';
                            }}
                          />
                        </div>
                        
                        <div className="accessory-description text-sm text-gray-600 mb-3">
                          {accessory.description}
                        </div>
                        
                        <div className="accessory-actions">
                          <Button
                            variant={accessory.isEquipped ? 'secondary' : 'jade'}
                            onClick={() => handleEquipAccessory(accessory)}
                            disabled={isUpdating}
                            className="w-full"
                          >
                            {isUpdating ? (
                              <LoadingSpinner variant="white" size="small" />
                            ) : accessory.isEquipped ? (
                              '取消装备'
                            ) : (
                              '装备'
                            )}
                          </Button>
                        </div>
                      </motion.div>
                    );
                  })}
                </motion.div>
              )}
            </div>
          </div>
        )}
      </div>
    </ScrollDialog>
  );
};

export default PandaCustomizationPanel;
</file>

<file path="src/components/panda/PandaEnvironmentPanel.tsx">
// src/components/panda/PandaEnvironmentPanel.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  PandaEnvironmentRecord,
  getOwnedEnvironments,
  getActiveEnvironment,
  activateEnvironment
} from '@/services/pandaCustomizationService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from '@/components/game/ScrollDialog';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface PandaEnvironmentPanelProps {
  isOpen: boolean;
  onClose: () => void;
  onEnvironmentChanged?: () => void;
}

/**
 * 熊猫环境面板组件
 * 用于选择和定制熊猫的环境，包括背景、互动元素等
 */
const PandaEnvironmentPanel: React.FC<PandaEnvironmentPanelProps> = ({
  isOpen,
  onClose,
  onEnvironmentChanged
}) => {
  const [environments, setEnvironments] = useState<PandaEnvironmentRecord[]>([]);
  const [activeEnvironment, setActiveEnvironment] = useState<PandaEnvironmentRecord | null>(null);
  const [selectedTheme, setSelectedTheme] = useState<string>('all');
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isUpdating, setIsUpdating] = useState(false);
  const [previewEnvironment, setPreviewEnvironment] = useState<PandaEnvironmentRecord | null>(null);
  
  // 加载环境数据
  const loadEnvironments = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // 获取已拥有的环境
      const ownedEnvironments = await getOwnedEnvironments();
      setEnvironments(ownedEnvironments);
      
      // 获取当前激活的环境
      const active = await getActiveEnvironment();
      if (active) {
        setActiveEnvironment(active);
      }
    } catch (err) {
      console.error('Failed to load environments:', err);
      setError('加载环境失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    if (isOpen) {
      loadEnvironments();
    }
  }, [isOpen]);

  // 注册数据刷新监听
  useRegisterTableRefresh('pandaEnvironments', loadEnvironments);

  // 处理激活环境
  const handleActivateEnvironment = async (environment: PandaEnvironmentRecord) => {
    try {
      setIsUpdating(true);
      
      // 激活环境
      await activateEnvironment(environment.id!);
      
      // 播放音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 重新加载数据
      await loadEnvironments();
      
      // 通知父组件
      if (onEnvironmentChanged) {
        onEnvironmentChanged();
      }
    } catch (err) {
      console.error('Failed to activate environment:', err);
      setError('激活环境失败，请重试');
    } finally {
      setIsUpdating(false);
    }
  };

  // 处理预览环境
  const handlePreviewEnvironment = (environment: PandaEnvironmentRecord) => {
    setPreviewEnvironment(environment);
    
    // 播放音效
    playSound(SoundType.BUTTON_CLICK, 0.3);
  };

  // 获取稀有度标签和样式
  const getRarityInfo = (rarity: string) => {
    switch (rarity) {
      case 'common':
        return { label: '普通', className: 'bg-gray-100 text-gray-800 border-gray-300' };
      case 'uncommon':
        return { label: '优秀', className: 'bg-green-100 text-green-800 border-green-300' };
      case 'rare':
        return { label: '稀有', className: 'bg-blue-100 text-blue-800 border-blue-300' };
      case 'epic':
        return { label: '史诗', className: 'bg-purple-100 text-purple-800 border-purple-300' };
      case 'legendary':
        return { label: '传说', className: 'bg-amber-100 text-amber-800 border-amber-300' };
      default:
        return { label: '未知', className: 'bg-gray-100 text-gray-800 border-gray-300' };
    }
  };

  // 获取主题标签
  const getThemeLabel = (theme: string): string => {
    switch (theme) {
      case '竹林':
        return '竹林';
      case '园林':
        return '园林';
      case '山水':
        return '山水';
      case '城市':
        return '城市';
      case '节日':
        return '节日';
      default:
        return theme;
    }
  };

  // 过滤环境
  const getFilteredEnvironments = (): PandaEnvironmentRecord[] => {
    if (selectedTheme === 'all') {
      return environments;
    }
    
    return environments.filter(environment => environment.themeType === selectedTheme);
  };

  // 获取所有主题
  const getAllThemes = (): string[] => {
    const themes = new Set<string>();
    themes.add('all');
    
    environments.forEach(environment => {
      if (environment.themeType) {
        themes.add(environment.themeType);
      }
    });
    
    return Array.from(themes);
  };

  // 容器变体
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // 项目变体
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="环境定制"
      closeOnOutsideClick={!isUpdating}
      closeOnEsc={!isUpdating}
      showCloseButton={!isUpdating}
    >
      <div className="panda-environment-panel p-4">
        {isLoading ? (
          <div className="loading-container flex justify-center items-center h-32">
            <LoadingSpinner variant="jade" size="medium" />
          </div>
        ) : error ? (
          <div className="error-container text-center p-4">
            <div className="error-message text-red-500 mb-4">{error}</div>
            <Button variant="jade" onClick={loadEnvironments}>
              重试
            </Button>
          </div>
        ) : (
          <div className="environment-content">
            {/* 当前环境 */}
            {activeEnvironment && (
              <div className="current-environment mb-6">
                <h3 className="text-lg font-bold mb-3">当前环境</h3>
                <div className="active-environment p-3 border border-jade-300 rounded-lg bg-jade-50">
                  <div className="environment-header flex justify-between items-start mb-2">
                    <div className="environment-name font-medium">
                      {activeEnvironment.name}
                    </div>
                    <div className="environment-meta flex gap-1">
                      <span className={`px-2 py-0.5 rounded-full text-xs ${getRarityInfo(activeEnvironment.rarity).className}`}>
                        {getRarityInfo(activeEnvironment.rarity).label}
                      </span>
                      <span className="px-2 py-0.5 rounded-full text-xs bg-gray-100 text-gray-800">
                        {getThemeLabel(activeEnvironment.themeType)}
                      </span>
                    </div>
                  </div>
                  
                  <div className="environment-image-container mb-2 relative overflow-hidden rounded-lg">
                    <img
                      src={activeEnvironment.backgroundPath}
                      alt={activeEnvironment.name}
                      className="w-full h-40 object-cover"
                      onError={(e) => {
                        const target = e.target as HTMLImageElement;
                        target.onerror = null;
                        target.src = '/assets/environments/default.svg';
                      }}
                    />
                    {activeEnvironment.foregroundPath && (
                      <img
                        src={activeEnvironment.foregroundPath}
                        alt={`${activeEnvironment.name} foreground`}
                        className="absolute top-0 left-0 w-full h-40 object-cover pointer-events-none"
                        onError={(e) => {
                          const target = e.target as HTMLImageElement;
                          target.onerror = null;
                          target.style.display = 'none';
                        }}
                      />
                    )}
                  </div>
                  
                  <div className="environment-description text-sm text-gray-600">
                    {activeEnvironment.description}
                  </div>
                </div>
              </div>
            )}
            
            {/* 环境预览 */}
            {previewEnvironment && (
              <div className="environment-preview mb-6">
                <h3 className="text-lg font-bold mb-3">环境预览</h3>
                <div className="preview-environment p-3 border border-gray-200 rounded-lg">
                  <div className="environment-header flex justify-between items-start mb-2">
                    <div className="environment-name font-medium">
                      {previewEnvironment.name}
                    </div>
                    <div className="environment-meta flex gap-1">
                      <span className={`px-2 py-0.5 rounded-full text-xs ${getRarityInfo(previewEnvironment.rarity).className}`}>
                        {getRarityInfo(previewEnvironment.rarity).label}
                      </span>
                      <span className="px-2 py-0.5 rounded-full text-xs bg-gray-100 text-gray-800">
                        {getThemeLabel(previewEnvironment.themeType)}
                      </span>
                    </div>
                  </div>
                  
                  <div className="environment-image-container mb-2 relative overflow-hidden rounded-lg">
                    <img
                      src={previewEnvironment.backgroundPath}
                      alt={previewEnvironment.name}
                      className="w-full h-40 object-cover"
                      onError={(e) => {
                        const target = e.target as HTMLImageElement;
                        target.onerror = null;
                        target.src = '/assets/environments/default.svg';
                      }}
                    />
                    {previewEnvironment.foregroundPath && (
                      <img
                        src={previewEnvironment.foregroundPath}
                        alt={`${previewEnvironment.name} foreground`}
                        className="absolute top-0 left-0 w-full h-40 object-cover pointer-events-none"
                        onError={(e) => {
                          const target = e.target as HTMLImageElement;
                          target.onerror = null;
                          target.style.display = 'none';
                        }}
                      />
                    )}
                  </div>
                  
                  <div className="environment-description text-sm text-gray-600 mb-3">
                    {previewEnvironment.description}
                  </div>
                  
                  <div className="environment-actions flex justify-end">
                    <Button
                      variant="jade"
                      onClick={() => handleActivateEnvironment(previewEnvironment)}
                      disabled={isUpdating || (activeEnvironment && activeEnvironment.id === previewEnvironment.id)}
                    >
                      {isUpdating ? (
                        <LoadingSpinner variant="white" size="small" />
                      ) : activeEnvironment && activeEnvironment.id === previewEnvironment.id ? (
                        '当前环境'
                      ) : (
                        '激活环境'
                      )}
                    </Button>
                  </div>
                </div>
              </div>
            )}
            
            {/* 主题过滤器 */}
            <div className="theme-filter mb-4">
              <h3 className="text-lg font-bold mb-2">主题</h3>
              <div className="flex flex-wrap gap-2">
                {getAllThemes().map((theme) => (
                  <button
                    key={theme}
                    className={`px-3 py-1 rounded-full text-sm ${
                      selectedTheme === theme ? 'bg-jade-100 text-jade-800 border border-jade-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
                    }`}
                    onClick={() => setSelectedTheme(theme)}
                  >
                    {theme === 'all' ? '全部' : getThemeLabel(theme)}
                  </button>
                ))}
              </div>
            </div>
            
            {/* 环境列表 */}
            <div className="environments-list">
              <h3 className="text-lg font-bold mb-3">可用环境</h3>
              {getFilteredEnvironments().length === 0 ? (
                <div className="no-environments text-center p-4 bg-gray-50 rounded-lg">
                  <p className="text-gray-500">暂无可用环境</p>
                </div>
              ) : (
                <motion.div
                  className="environments-grid grid grid-cols-1 md:grid-cols-2 gap-4"
                  variants={containerVariants}
                  initial="hidden"
                  animate="visible"
                >
                  {getFilteredEnvironments().map((environment) => {
                    const rarityInfo = getRarityInfo(environment.rarity);
                    const isActive = activeEnvironment && activeEnvironment.id === environment.id;
                    
                    return (
                      <motion.div
                        key={environment.id}
                        className={`environment-item p-3 rounded-lg border cursor-pointer ${
                          isActive ? 'border-jade-500 bg-jade-50' : 'border-gray-200 bg-white'
                        }`}
                        variants={itemVariants}
                        onClick={() => handlePreviewEnvironment(environment)}
                      >
                        <div className="environment-header flex justify-between items-start mb-2">
                          <div className="environment-name font-medium">
                            {environment.name}
                          </div>
                          <div className="environment-meta flex gap-1">
                            <span className={`px-2 py-0.5 rounded-full text-xs ${rarityInfo.className}`}>
                              {rarityInfo.label}
                            </span>
                            <span className="px-2 py-0.5 rounded-full text-xs bg-gray-100 text-gray-800">
                              {getThemeLabel(environment.themeType)}
                            </span>
                          </div>
                        </div>
                        
                        <div className="environment-image-container mb-2 relative overflow-hidden rounded-lg">
                          <img
                            src={environment.backgroundPath}
                            alt={environment.name}
                            className="w-full h-32 object-cover"
                            onError={(e) => {
                              const target = e.target as HTMLImageElement;
                              target.onerror = null;
                              target.src = '/assets/environments/default.svg';
                            }}
                          />
                        </div>
                        
                        <div className="environment-description text-sm text-gray-600 line-clamp-2">
                          {environment.description}
                        </div>
                      </motion.div>
                    );
                  })}
                </motion.div>
              )}
            </div>
          </div>
        )}
      </div>
    </ScrollDialog>
  );
};

export default PandaEnvironmentPanel;
</file>

<file path="src/components/reflection/EnhancedReflectionModule.tsx">
// src/components/reflection/EnhancedReflectionModule.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Button from '@/components/common/Button';
import ScrollDialog from '@/components/game/ScrollDialog';
import { playSound, SoundType } from '@/utils/sound';
import { TaskRecord } from '@/services/taskService';
import { 
  ReflectionTriggerRecord, 
  ReflectionTriggerType,
  createReflection,
  completeReflection,
  markTriggerAsCompleted
} from '@/services/reflectionService';
import { getPandaMood, updatePandaMood } from '@/services/pandaStateService';
import MoodTracker from './MoodTracker';
import LoadingSpinner from '@/components/common/LoadingSpinner';

interface EnhancedReflectionModuleProps {
  isOpen: boolean;
  onClose: () => void;
  taskId?: number;
  taskName?: string;
  trigger?: ReflectionTriggerRecord;
  onReflectionComplete?: () => void;
}

/**
 * 增强版反思模块组件
 * 用于帮助用户反思任务完成情况和情绪状态
 */
const EnhancedReflectionModule: React.FC<EnhancedReflectionModuleProps> = ({
  isOpen,
  onClose,
  taskId,
  taskName,
  trigger,
  onReflectionComplete
}) => {
  const [step, setStep] = useState(1);
  const [mood, setMood] = useState<string>('neutral');
  const [reflection, setReflection] = useState('');
  const [action, setAction] = useState('');
  const [suggestedActions, setSuggestedActions] = useState<string[]>([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [pandaMessage, setPandaMessage] = useState('');
  const [reflectionId, setReflectionId] = useState<number | null>(null);
  const [tags, setTags] = useState<string[]>([]);
  const [selectedTag, setSelectedTag] = useState<string>('');
  const [customTag, setCustomTag] = useState('');
  const [showMoodTracker, setShowMoodTracker] = useState(false);
  
  // 当前用户ID（在实际应用中，这应该从用户会话中获取）
  const userId = 'current-user';

  // 根据触发类型设置初始状态
  useEffect(() => {
    if (trigger) {
      switch (trigger.type) {
        case ReflectionTriggerType.MOOD_CHANGE:
          if (trigger.data?.mood) {
            setMood(trigger.data.mood);
          }
          setPandaMessage('我注意到你的情绪有些波动。想聊聊吗？');
          break;
        case ReflectionTriggerType.TASK_FAILURE:
          setPandaMessage(
            trigger.data?.taskTitle
              ? `任务"${trigger.data.taskTitle}"未能按时完成。这没关系，我们可以一起反思一下。`
              : '有一个任务未能按时完成。这没关系，我们可以一起反思一下。'
          );
          setTaskId(trigger.data?.taskId);
          setTaskName(trigger.data?.taskTitle);
          break;
        case ReflectionTriggerType.DAILY_REFLECTION:
          setPandaMessage('今天过得如何？花点时间反思一下今天的经历吧。');
          break;
        case ReflectionTriggerType.WEEKLY_REVIEW:
          setPandaMessage('这周过得如何？让我们一起回顾一下这周的经历。');
          break;
        default:
          setPandaMessage('欢迎来到静心茶室。想聊聊你的感受吗？');
      }
    } else if (taskName) {
      setPandaMessage(`关于任务"${taskName}"，你有什么想分享的吗？`);
    } else {
      setPandaMessage('欢迎来到静心茶室。想聊聊你的感受吗？');
    }
  }, [trigger, taskName]);

  // 根据反思内容生成建议行动和标签
  useEffect(() => {
    if (reflection && step === 2) {
      // 生成标签
      const extractedTags = extractTags(reflection);
      setTags(extractedTags);
      
      // 生成建议行动
      const suggestedActions = generateSuggestedActions(reflection, extractedTags);
      setSuggestedActions(suggestedActions);
    }
  }, [reflection, step]);

  // 从反思内容中提取标签
  const extractTags = (text: string): string[] => {
    const lowerText = text.toLowerCase();
    const extractedTags: string[] = [];
    
    // 情绪标签
    if (lowerText.includes('开心') || lowerText.includes('高兴') || lowerText.includes('快乐')) {
      extractedTags.push('开心');
    }
    if (lowerText.includes('难过') || lowerText.includes('伤心') || lowerText.includes('悲伤')) {
      extractedTags.push('难过');
    }
    if (lowerText.includes('焦虑') || lowerText.includes('担心') || lowerText.includes('紧张')) {
      extractedTags.push('焦虑');
    }
    if (lowerText.includes('压力') || lowerText.includes('压抑') || lowerText.includes('重担')) {
      extractedTags.push('压力');
    }
    if (lowerText.includes('疲惫') || lowerText.includes('累') || lowerText.includes('疲劳')) {
      extractedTags.push('疲惫');
    }
    
    // 主题标签
    if (lowerText.includes('工作') || lowerText.includes('职场') || lowerText.includes('事业')) {
      extractedTags.push('工作');
    }
    if (lowerText.includes('学习') || lowerText.includes('考试') || lowerText.includes('课程')) {
      extractedTags.push('学习');
    }
    if (lowerText.includes('家庭') || lowerText.includes('亲人') || lowerText.includes('父母')) {
      extractedTags.push('家庭');
    }
    if (lowerText.includes('朋友') || lowerText.includes('友谊') || lowerText.includes('社交')) {
      extractedTags.push('社交');
    }
    if (lowerText.includes('健康') || lowerText.includes('身体') || lowerText.includes('疾病')) {
      extractedTags.push('健康');
    }
    
    return extractedTags;
  };

  // 根据反思内容和标签生成建议行动
  const generateSuggestedActions = (text: string, tags: string[]): string[] => {
    const actions: string[] = [];
    const lowerText = text.toLowerCase();
    
    // 根据标签添加建议
    if (tags.includes('焦虑') || tags.includes('压力')) {
      actions.push('尝试5分钟的深呼吸冥想');
      actions.push('出去散步15分钟');
      actions.push('与朋友聊天分享感受');
      actions.push('写下三件让你感到感激的事情');
    }
    
    if (tags.includes('疲惫')) {
      actions.push('确保今晚早点休息');
      actions.push('尝试20分钟的午休');
      actions.push('减少今天的任务量');
      actions.push('喝足够的水，吃些健康的食物');
    }
    
    // 根据文本内容添加建议
    if (lowerText.includes('拖延') || lowerText.includes('专注') || lowerText.includes('分心')) {
      actions.push('使用番茄工作法，专注25分钟');
      actions.push('将大任务分解成小步骤');
      actions.push('创建一个无干扰的工作环境');
      actions.push('设置一个小的、可实现的目标');
    }
    
    if (lowerText.includes('孤独') || lowerText.includes('寂寞')) {
      actions.push('给一位久未联系的朋友打电话');
      actions.push('参加一个社区活动或线上聚会');
      actions.push('尝试一项可以认识新朋友的爱好');
    }
    
    // 如果没有匹配到任何建议，添加一些通用建议
    if (actions.length === 0) {
      actions.push('花5分钟进行深呼吸冥想');
      actions.push('写下三件让你感到感激的事情');
      actions.push('设定一个小的、可实现的目标');
      actions.push('与朋友或家人分享你的感受');
    }
    
    return actions;
  };

  // 处理创建反思记录
  const handleCreateReflection = async () => {
    try {
      // 创建反思记录
      const newReflection = await createReflection({
        userId,
        taskId,
        mood,
        reflection,
        action: '',
        tags
      });
      
      // 保存反思ID
      setReflectionId(newReflection.id!);
      
      return newReflection.id!;
    } catch (err) {
      console.error('Failed to create reflection:', err);
      throw err;
    }
  };

  // 处理完成反思
  const handleCompleteReflection = async () => {
    try {
      setIsSubmitting(true);
      
      // 如果还没有创建反思记录，先创建
      let id = reflectionId;
      if (!id) {
        id = await handleCreateReflection();
      }
      
      // 完成反思记录
      await completeReflection(id, action);
      
      // 如果是从触发记录打开的，标记触发记录为已完成
      if (trigger && trigger.id) {
        await markTriggerAsCompleted(trigger.id);
      }
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 如果心情不好，尝试更新为中性
      if (mood === 'sad' || mood === 'anxious' || mood === 'stressed') {
        await updatePandaMood('neutral');
      }
      
      // 通知父组件
      if (onReflectionComplete) {
        onReflectionComplete();
      }
      
      // 重置状态
      setStep(1);
      setReflection('');
      setAction('');
      setReflectionId(null);
      
      // 关闭对话框
      onClose();
    } catch (err) {
      console.error('Failed to complete reflection:', err);
    } finally {
      setIsSubmitting(false);
    }
  };

  // 处理选择建议行动
  const handleSelectAction = (selectedAction: string) => {
    setAction(selectedAction);
  };

  // 处理添加标签
  const handleAddTag = () => {
    if (selectedTag && !tags.includes(selectedTag)) {
      setTags([...tags, selectedTag]);
      setSelectedTag('');
    } else if (customTag && !tags.includes(customTag)) {
      setTags([...tags, customTag]);
      setCustomTag('');
    }
  };

  // 处理移除标签
  const handleRemoveTag = (tag: string) => {
    setTags(tags.filter(t => t !== tag));
  };

  // 渲染步骤1：反思输入
  const renderStep1 = () => (
    <div className="reflection-step">
      <div className="panda-message mb-4 p-3 bg-amber-50 rounded-lg border border-amber-200">
        <div className="flex items-start">
          <div className="panda-avatar mr-2">
            <span className="text-2xl">🐼</span>
          </div>
          <div className="panda-text">
            <p>{pandaMessage}</p>
          </div>
        </div>
      </div>
      
      {/* 情绪追踪器切换按钮 */}
      <div className="mood-tracker-toggle mb-4">
        <Button
          variant="secondary"
          onClick={() => setShowMoodTracker(!showMoodTracker)}
          className="w-full"
        >
          {showMoodTracker ? '隐藏情绪追踪器' : '显示情绪追踪器'}
        </Button>
      </div>
      
      {/* 情绪追踪器 */}
      <AnimatePresence>
        {showMoodTracker && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.3 }}
            className="mood-tracker-container mb-4 overflow-hidden"
          >
            <MoodTracker
              onMoodRecorded={(moodRecord) => {
                setMood(moodRecord.mood);
                setShowMoodTracker(false);
              }}
            />
          </motion.div>
        )}
      </AnimatePresence>
      
      <div className="reflection-input mb-4">
        <label htmlFor="reflection" className="block text-sm font-medium text-gray-700 mb-1">
          分享你的想法（可以是任何感受、困难或成就）
        </label>
        <textarea
          id="reflection"
          className="w-full h-32 p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
          value={reflection}
          onChange={(e) => setReflection(e.target.value)}
          placeholder="今天我感觉..."
        />
      </div>
      
      <div className="reflection-actions flex justify-end">
        <Button 
          variant="jade" 
          onClick={async () => {
            // 创建反思记录
            try {
              await handleCreateReflection();
              setStep(2);
            } catch (err) {
              console.error('Failed to proceed to next step:', err);
            }
          }} 
          disabled={!reflection.trim()}
        >
          继续
        </Button>
      </div>
    </div>
  );

  // 渲染步骤2：行动选择
  const renderStep2 = () => (
    <div className="reflection-step">
      <div className="panda-message mb-4 p-3 bg-amber-50 rounded-lg border border-amber-200">
        <div className="flex items-start">
          <div className="panda-avatar mr-2">
            <span className="text-2xl">🐼</span>
          </div>
          <div className="panda-text">
            <p>谢谢你的分享。以下是一些可能对你有帮助的小行动，你可以选择一个尝试，或者创建自己的行动。</p>
          </div>
        </div>
      </div>
      
      {/* 标签区域 */}
      <div className="tags-section mb-4">
        <h3 className="text-sm font-medium text-gray-700 mb-2">标签</h3>
        <div className="tags-container flex flex-wrap gap-2 mb-2">
          {tags.map((tag) => (
            <div
              key={tag}
              className="tag px-2 py-1 bg-gray-100 rounded-full text-xs flex items-center"
            >
              <span>{tag}</span>
              <button
                onClick={() => handleRemoveTag(tag)}
                className="ml-1 text-gray-500 hover:text-gray-700"
              >
                <span>×</span>
              </button>
            </div>
          ))}
        </div>
        <div className="add-tag-container flex gap-2">
          <select
            value={selectedTag}
            onChange={(e) => setSelectedTag(e.target.value)}
            className="flex-grow p-1 text-sm border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
          >
            <option value="">选择标签...</option>
            <option value="开心">开心</option>
            <option value="难过">难过</option>
            <option value="焦虑">焦虑</option>
            <option value="压力">压力</option>
            <option value="疲惫">疲惫</option>
            <option value="工作">工作</option>
            <option value="学习">学习</option>
            <option value="家庭">家庭</option>
            <option value="社交">社交</option>
            <option value="健康">健康</option>
          </select>
          <input
            type="text"
            value={customTag}
            onChange={(e) => setCustomTag(e.target.value)}
            placeholder="自定义标签"
            className="flex-grow p-1 text-sm border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
          />
          <Button
            variant="secondary"
            size="small"
            onClick={handleAddTag}
            disabled={!selectedTag && !customTag}
          >
            添加
          </Button>
        </div>
      </div>
      
      <div className="suggested-actions mb-4">
        <h3 className="text-sm font-medium text-gray-700 mb-2">建议的行动</h3>
        <div className="grid grid-cols-1 gap-2">
          {suggestedActions.map((suggestedAction, index) => (
            <motion.div
              key={index}
              className={`p-2 border rounded-md cursor-pointer ${action === suggestedAction ? 'border-jade-500 bg-jade-50' : 'border-gray-300'}`}
              onClick={() => handleSelectAction(suggestedAction)}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
            >
              {suggestedAction}
            </motion.div>
          ))}
        </div>
      </div>
      
      <div className="custom-action mb-4">
        <label htmlFor="custom-action" className="block text-sm font-medium text-gray-700 mb-1">
          或者，创建你自己的行动
        </label>
        <input
          id="custom-action"
          type="text"
          className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
          value={action}
          onChange={(e) => setAction(e.target.value)}
          placeholder="我将..."
        />
      </div>
      
      <div className="reflection-actions flex justify-between">
        <Button variant="secondary" onClick={() => setStep(1)}>
          返回
        </Button>
        <Button variant="gold" onClick={handleCompleteReflection} disabled={!action.trim() || isSubmitting}>
          {isSubmitting ? (
            <LoadingSpinner variant="white" size="small" />
          ) : (
            '完成反思'
          )}
        </Button>
      </div>
    </div>
  );

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="静心茶室"
      closeOnOutsideClick={false}
      closeOnEsc={true}
      showCloseButton={true}
    >
      <div className="reflection-module p-4">
        <AnimatePresence mode="wait">
          <motion.div
            key={`step-${step}`}
            initial={{ opacity: 0, x: step === 1 ? -20 : 20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: step === 1 ? 20 : -20 }}
            transition={{ duration: 0.3 }}
          >
            {step === 1 ? renderStep1() : renderStep2()}
          </motion.div>
        </AnimatePresence>
      </div>
    </ScrollDialog>
  );
};

export default EnhancedReflectionModule;
</file>

<file path="src/components/reflection/MoodTracker.tsx">
// src/components/reflection/MoodTracker.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { MoodType, MoodIntensity, recordMood, getUserMoods, MoodRecord } from '@/services/reflectionService';
import Button from '@/components/common/Button';
import { playSound, SoundType } from '@/utils/sound';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface MoodTrackerProps {
  onMoodRecorded?: (mood: MoodRecord) => void;
  compact?: boolean;
  className?: string;
  labels?: {
    currentMoodQuestion?: string;
    intensityLabel?: string;
    noteLabel?: string;
    recordMoodButton?: string;
    historyLabel?: string;
    noMoodsMessage?: string;
    backLabel?: string;
    intensityStrength?: {
      veryMild?: string;
      mild?: string;
      moderate?: string;
      strong?: string;
      veryStrong?: string;
    };
  };
}

/**
 * 情绪追踪组件
 * 用于记录和显示用户的情绪状态
 */
const MoodTracker: React.FC<MoodTrackerProps> = ({
  onMoodRecorded,
  compact = false,
  className = '',
  labels
}) => {
  const [selectedMood, setSelectedMood] = useState<MoodType | null>(null);
  const [intensity, setIntensity] = useState<MoodIntensity>(3);
  const [note, setNote] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [recentMoods, setRecentMoods] = useState<MoodRecord[]>([]);
  const [showHistory, setShowHistory] = useState(false);

  // 当前用户ID（在实际应用中，这应该从用户会话中获取）
  const userId = 'current-user';

  // 加载最近的情绪记录
  const loadRecentMoods = async () => {
    try {
      const moods = await getUserMoods(userId, 5);
      setRecentMoods(moods);
    } catch (err) {
      console.error('Failed to load recent moods:', err);
    }
  };

  // 初始加载
  useEffect(() => {
    loadRecentMoods();
  }, []);

  // 注册数据刷新监听
  useRegisterTableRefresh('moods', loadRecentMoods);

  // 处理提交情绪
  const handleSubmit = async () => {
    if (!selectedMood) return;

    try {
      setIsSubmitting(true);

      // 记录情绪
      const mood = await recordMood({
        userId,
        mood: selectedMood,
        intensity,
        note: note.trim() || undefined
      });

      // 播放音效
      playSound(SoundType.SUCCESS, 0.5);

      // 重置表单
      setSelectedMood(null);
      setIntensity(3);
      setNote('');

      // 重新加载最近的情绪记录
      await loadRecentMoods();

      // 通知父组件
      if (onMoodRecorded) {
        onMoodRecorded(mood);
      }
    } catch (err) {
      console.error('Failed to record mood:', err);
    } finally {
      setIsSubmitting(false);
    }
  };

  // 获取情绪图标和颜色
  const getMoodInfo = (mood: MoodType) => {
    switch (mood) {
      case MoodType.HAPPY:
        return { icon: '😄', color: 'bg-yellow-100 text-yellow-800', label: '开心' };
      case MoodType.CONTENT:
        return { icon: '😊', color: 'bg-green-100 text-green-800', label: '满足' };
      case MoodType.NEUTRAL:
        return { icon: '😐', color: 'bg-gray-100 text-gray-800', label: '平静' };
      case MoodType.SAD:
        return { icon: '😢', color: 'bg-blue-100 text-blue-800', label: '难过' };
      case MoodType.ANXIOUS:
        return { icon: '😰', color: 'bg-purple-100 text-purple-800', label: '焦虑' };
      case MoodType.STRESSED:
        return { icon: '😫', color: 'bg-red-100 text-red-800', label: '压力' };
      case MoodType.TIRED:
        return { icon: '😴', color: 'bg-gray-200 text-gray-800', label: '疲惫' };
      case MoodType.ENERGETIC:
        return { icon: '⚡', color: 'bg-yellow-200 text-yellow-800', label: '精力充沛' };
      case MoodType.MOTIVATED:
        return { icon: '🔥', color: 'bg-orange-100 text-orange-800', label: '有动力' };
      case MoodType.FRUSTRATED:
        return { icon: '😤', color: 'bg-red-200 text-red-800', label: '沮丧' };
      case MoodType.ANGRY:
        return { icon: '😠', color: 'bg-red-100 text-red-800', label: '生气' };
      case MoodType.CALM:
        return { icon: '😌', color: 'bg-blue-100 text-blue-800', label: '平静' };
      default:
        return { icon: '❓', color: 'bg-gray-100 text-gray-800', label: '未知' };
    }
  };

  // 获取强度标签
  const getIntensityLabel = (intensity: MoodIntensity) => {
    switch (intensity) {
      case 1: return labels?.intensityStrength?.veryMild || 'Very Mild';
      case 2: return labels?.intensityStrength?.mild || 'Mild';
      case 3: return labels?.intensityStrength?.moderate || 'Moderate';
      case 4: return labels?.intensityStrength?.strong || 'Strong';
      case 5: return labels?.intensityStrength?.veryStrong || 'Very Strong';
      default: return 'Unknown';
    }
  };

  // 渲染情绪选择器
  const renderMoodSelector = () => {
    const moods = [
      MoodType.HAPPY,
      MoodType.CONTENT,
      MoodType.NEUTRAL,
      MoodType.SAD,
      MoodType.ANXIOUS,
      MoodType.STRESSED,
      MoodType.TIRED,
      MoodType.ENERGETIC,
      MoodType.MOTIVATED,
      MoodType.FRUSTRATED,
      MoodType.ANGRY,
      MoodType.CALM
    ];

    return (
      <div className="mood-selector">
        <h3 className="text-lg font-bold mb-3">
          {labels?.currentMoodQuestion || "How are you feeling right now?"}
        </h3>
        <div className="grid grid-cols-4 gap-3">
          {moods.map((mood) => {
            const { icon, color, label } = getMoodInfo(mood);
            return (
              <motion.div
                key={mood}
                className={`mood-item p-3 rounded-lg cursor-pointer text-center ${
                  selectedMood === mood ? 'ring-2 ring-jade-500 shadow-md' : ''
                } ${color} hover:shadow-md transition-all duration-200`}
                onClick={() => setSelectedMood(mood)}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
              >
                <div className="mood-icon text-2xl mb-1">{icon}</div>
                <div className="mood-label text-xs font-medium">{label}</div>
              </motion.div>
            );
          })}
        </div>
      </div>
    );
  };

  // 渲染强度选择器
  const renderIntensitySelector = () => {
    return (
      <div className="intensity-selector mt-4">
        <h3 className="text-lg font-bold mb-2">{labels?.intensityLabel || "How intense is this feeling?"}</h3>
        <div className="flex items-center">
          <input
            type="range"
            min="1"
            max="5"
            value={intensity}
            onChange={(e) => setIntensity(parseInt(e.target.value) as MoodIntensity)}
            className="flex-grow h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
          />
          <span className="ml-3 text-sm font-medium px-2 py-1 bg-jade-100 text-jade-800 rounded-md">
            {getIntensityLabel(intensity)}
          </span>
        </div>
      </div>
    );
  };

  // 渲染笔记输入框
  const renderNoteInput = () => {
    return (
      <div className="note-input mt-4">
        <h3 className="text-lg font-bold mb-2">{labels?.noteLabel || "Anything you'd like to note? (optional)"}</h3>
        <textarea
          value={note}
          onChange={(e) => setNote(e.target.value)}
          className="w-full p-3 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500 h-24"
          placeholder={labels?.notePlaceholder || "Write down your thoughts..."}
        />
      </div>
    );
  };

  // 渲染最近的情绪记录
  const renderRecentMoods = () => {
    if (recentMoods.length === 0) {
      return (
        <div className="text-center text-gray-500 p-4">
          {labels?.noMoodsMessage || "No mood records yet"}
        </div>
      );
    }

    return (
      <div className="recent-moods-list">
        {recentMoods.map((mood) => {
          const { icon, color } = getMoodInfo(mood.mood as MoodType);
          return (
            <div
              key={mood.id}
              className="mood-record flex items-center p-2 border-b border-gray-200 last:border-b-0"
            >
              <div className={`mood-icon p-2 rounded-full ${color} mr-3`}>
                <span className="text-xl">{icon}</span>
              </div>
              <div className="mood-info flex-grow">
                <div className="flex justify-between">
                  <span className="font-medium">{getMoodInfo(mood.mood as MoodType).label}</span>
                  <span className="text-sm text-gray-500">
                    {new Date(mood.createdAt).toLocaleString()}
                  </span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-sm text-gray-600">
                    强度: {getIntensityLabel(mood.intensity as MoodIntensity)}
                  </span>
                </div>
                {mood.note && (
                  <p className="text-sm text-gray-700 mt-1">{mood.note}</p>
                )}
              </div>
            </div>
          );
        })}
      </div>
    );
  };

  // 紧凑模式
  if (compact) {
    return (
      <div className={`mood-tracker-compact ${className}`}>
        <div className="flex items-center">
          <div className="mood-selector-compact flex-grow">
            <div className="flex flex-wrap gap-2">
              {[MoodType.HAPPY, MoodType.CONTENT, MoodType.NEUTRAL, MoodType.SAD, MoodType.ANXIOUS].map((mood) => {
                const { icon, color } = getMoodInfo(mood);
                return (
                  <motion.div
                    key={mood}
                    className={`mood-item p-2 rounded-full cursor-pointer ${
                      selectedMood === mood ? 'ring-2 ring-jade-500' : ''
                    } ${color}`}
                    onClick={() => setSelectedMood(mood)}
                    whileHover={{ scale: 1.05 }}
                    whileTap={{ scale: 0.95 }}
                  >
                    <div className="mood-icon text-xl">{icon}</div>
                  </motion.div>
                );
              })}
            </div>
          </div>
          <Button
            variant="jade"
            size="small"
            onClick={handleSubmit}
            disabled={!selectedMood || isSubmitting}
            className="ml-2"
          >
            记录
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className={`mood-tracker ${className}`}>
      <div className="mood-tracker-header flex justify-between items-center mb-4">
        <h2 className="text-xl font-bold text-jade-700">
          <span className="mr-2">🍵</span>
          {labels?.title || "Mood Tracking"}
        </h2>
        <Button
          variant="secondary"
          size="small"
          onClick={() => setShowHistory(!showHistory)}
        >
          {showHistory ? (labels?.backLabel || "Back") : (labels?.historyLabel || "History")}
        </Button>
      </div>

      <AnimatePresence mode="wait">
        {showHistory ? (
          <motion.div
            key="history"
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: -20 }}
            transition={{ duration: 0.3 }}
            className="mood-history"
          >
            <h3 className="text-lg font-bold mb-2">最近的情绪记录</h3>
            {renderRecentMoods()}
          </motion.div>
        ) : (
          <motion.div
            key="form"
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: 20 }}
            transition={{ duration: 0.3 }}
            className="mood-form"
          >
            {renderMoodSelector()}

            {selectedMood && (
              <>
                {renderIntensitySelector()}
                {renderNoteInput()}

                <div className="form-actions mt-4 flex justify-end">
                  <Button
                    variant="jade"
                    onClick={handleSubmit}
                    disabled={isSubmitting}
                  >
                    {labels?.recordMoodButton || "Record Mood"}
                  </Button>
                </div>
              </>
            )}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default MoodTracker;
</file>

<file path="src/components/reflection/README.md">
# 反思模块文档

本文档记录了PandaHabit应用中的反思模块，包括它的功能、组件和使用方法。

## 概述

反思模块是PandaHabit应用中的一个重要功能，它提供了一个温和、非判断性的对话系统，帮助用户探索困难并提供支持。反思模块包括情绪追踪、反思记录、支持性反馈和可行建议系统等功能。

## 组件

### EnhancedReflectionModule

`EnhancedReflectionModule` 是反思模块的核心组件，它提供了一个交互式的反思体验，包括情绪记录、反思输入、标签管理和行动建议。

#### 属性

| 属性名 | 类型 | 描述 |
|--------|------|------|
| isOpen | boolean | 控制模块是否显示 |
| onClose | () => void | 关闭模块的回调函数 |
| taskId | number | 相关任务ID（可选） |
| taskName | string | 相关任务名称（可选） |
| trigger | ReflectionTriggerRecord | 触发记录（可选） |
| onReflectionComplete | () => void | 反思完成后的回调函数（可选） |

#### 使用示例

```tsx
<EnhancedReflectionModule
  isOpen={showReflectionModule}
  onClose={() => setShowReflectionModule(false)}
  taskId={123}
  taskName="每日冥想"
  onReflectionComplete={handleReflectionComplete}
/>
```

### MoodTracker

`MoodTracker` 是一个用于记录和显示用户情绪状态的组件，它支持多种情绪类型和强度级别。

#### 属性

| 属性名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| onMoodRecorded | (mood: MoodRecord) => void | undefined | 情绪记录后的回调函数 |
| compact | boolean | false | 是否使用紧凑模式 |
| className | string | '' | 自定义CSS类名 |

#### 使用示例

```tsx
<MoodTracker
  onMoodRecorded={handleMoodRecorded}
  compact={false}
/>
```

### ReflectionTriggerNotification

`ReflectionTriggerNotification` 是一个用于显示反思触发通知的组件，它会在特定条件下（如情绪变化、任务失败等）提示用户进行反思。

#### 属性

| 属性名 | 类型 | 描述 |
|--------|------|------|
| onTriggerAccepted | (trigger: ReflectionTriggerRecord) => void | 用户接受触发后的回调函数 |
| onTriggerDismissed | (trigger: ReflectionTriggerRecord) => void | 用户忽略触发后的回调函数 |

#### 使用示例

```tsx
<ReflectionTriggerNotification
  onTriggerAccepted={handleTriggerAccepted}
  onTriggerDismissed={handleTriggerDismissed}
/>
```

### ReflectionHistory

`ReflectionHistory` 是一个用于显示用户反思历史记录的组件，它支持按标签筛选和查看详情。

#### 属性

| 属性名 | 类型 | 描述 |
|--------|------|------|
| isOpen | boolean | 控制组件是否显示 |
| onClose | () => void | 关闭组件的回调函数 |
| onReflectionSelected | (reflection: ReflectionRecord) => void | 选择反思记录后的回调函数 |

#### 使用示例

```tsx
<ReflectionHistory
  isOpen={showReflectionHistory}
  onClose={() => setShowReflectionHistory(false)}
  onReflectionSelected={handleReflectionSelected}
/>
```

## 服务

### reflectionService

`reflectionService` 是反思模块的核心服务，它提供了管理反思记录、触发记录和情绪记录的功能。

#### 主要函数

| 函数名 | 描述 |
|--------|------|
| createReflection | 创建反思记录 |
| completeReflection | 完成反思记录 |
| getUserReflections | 获取用户的反思记录 |
| createReflectionTrigger | 创建反思触发记录 |
| getUnviewedReflectionTriggers | 获取未查看的反思触发记录 |
| markTriggerAsViewed | 标记触发记录为已查看 |
| markTriggerAsCompleted | 标记触发记录为已完成 |
| recordMood | 记录用户情绪 |
| getUserMoods | 获取用户的情绪记录 |
| checkTaskFailureTrigger | 检查任务失败是否需要触发反思 |
| checkDailyReflectionTrigger | 检查是否需要触发每日反思 |
| checkWeeklyReviewTrigger | 检查是否需要触发每周回顾 |

## 页面

### TeaRoomPage

`TeaRoomPage` 是反思模块的主页面，它集成了所有反思相关的组件，提供了一个完整的反思体验。

## 功能

### 反思机会的触发检测

反思模块会在以下情况下触发反思机会：

1. **情绪变化**：当用户记录负面情绪且强度较高时
2. **任务失败**：当任务过期且未完成时
3. **每日反思**：每天触发一次
4. **每周回顾**：每周触发一次
5. **手动触发**：用户主动开始反思

### 温和、非判断性的对话系统

反思模块使用温和、非判断性的语言与用户交流，帮助用户探索困难并提供支持。例如：

- "我注意到你最近心情不太好。想聊聊吗？"
- "任务未能按时完成。这没关系，我们可以一起反思一下。"
- "谢谢你的分享。以下是一些可能对你有帮助的小行动。"

### 用户输入收集和处理

反思模块收集用户的反思内容，并从中提取关键词和主题，用于生成标签和建议行动。

### 支持性反馈生成

反思模块根据用户的反思内容生成支持性反馈，帮助用户理解自己的感受和想法。

### 可行建议系统

反思模块根据用户的反思内容和标签生成可行的建议行动，帮助用户采取积极的步骤改善状况。

### 情绪跟踪和模式识别

反思模块通过情绪追踪功能记录用户的情绪状态，并识别情绪模式，帮助用户了解自己的情绪变化。

### 自我同情强化机制

反思模块通过温和的语言和支持性反馈，鼓励用户对自己保持同情和理解，减少自我批评。

### 静心茶室环境

反思模块提供了一个名为"静心茶室"的虚拟环境，营造一个安静、放松的氛围，帮助用户进行反思。

## 注意事项

1. 反思模块的所有组件都遵循华丽游戏风格设计，包括动画效果和音效。
2. 反思模块与数据服务集成，自动更新和同步数据。
3. 反思模块支持多语言，可以根据用户的语言设置显示相应的内容。
4. 反思模块的触发机制可以根据用户的使用情况进行调整，避免过于频繁的打扰。
5. 反思模块的建议行动应该是具体、可行的，帮助用户采取实际行动。
</file>

<file path="src/components/reflection/ReflectionHistory.tsx">
// src/components/reflection/ReflectionHistory.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  ReflectionRecord,
  getUserReflections
} from '@/services/reflectionService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import ScrollDialog from '@/components/game/ScrollDialog';

interface ReflectionHistoryProps {
  isOpen: boolean;
  onClose: () => void;
  onReflectionSelected?: (reflection: ReflectionRecord) => void;
}

/**
 * 反思历史组件
 * 用于显示用户的反思历史记录
 */
const ReflectionHistory: React.FC<ReflectionHistoryProps> = ({
  isOpen,
  onClose,
  onReflectionSelected
}) => {
  const [reflections, setReflections] = useState<ReflectionRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedReflection, setSelectedReflection] = useState<ReflectionRecord | null>(null);
  const [filterTag, setFilterTag] = useState<string>('');
  const [allTags, setAllTags] = useState<string[]>([]);
  
  // 当前用户ID（在实际应用中，这应该从用户会话中获取）
  const userId = 'current-user';

  // 加载反思历史
  const loadReflections = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // 获取用户的反思记录
      const userReflections = await getUserReflections(userId);
      setReflections(userReflections);
      
      // 提取所有标签
      const tags = new Set<string>();
      userReflections.forEach(reflection => {
        if (reflection.tags) {
          reflection.tags.forEach(tag => tags.add(tag));
        }
      });
      setAllTags(Array.from(tags));
    } catch (err) {
      console.error('Failed to load reflections:', err);
      setError('加载反思历史失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    if (isOpen) {
      loadReflections();
    }
  }, [isOpen]);

  // 注册数据刷新监听
  useRegisterTableRefresh('reflections', loadReflections);

  // 处理选择反思
  const handleSelectReflection = (reflection: ReflectionRecord) => {
    setSelectedReflection(reflection);
    
    // 通知父组件
    if (onReflectionSelected) {
      onReflectionSelected(reflection);
    }
  };

  // 处理返回列表
  const handleBackToList = () => {
    setSelectedReflection(null);
  };

  // 处理筛选标签
  const handleFilterByTag = (tag: string) => {
    setFilterTag(tag === filterTag ? '' : tag);
  };

  // 获取筛选后的反思记录
  const getFilteredReflections = (): ReflectionRecord[] => {
    if (!filterTag) {
      return reflections;
    }
    
    return reflections.filter(reflection => 
      reflection.tags && reflection.tags.includes(filterTag)
    );
  };

  // 渲染反思列表
  const renderReflectionList = () => {
    const filteredReflections = getFilteredReflections();
    
    if (filteredReflections.length === 0) {
      return (
        <div className="empty-state text-center p-4">
          <p className="text-gray-500">
            {filterTag ? `没有包含"${filterTag}"标签的反思记录` : '暂无反思记录'}
          </p>
        </div>
      );
    }
    
    return (
      <div className="reflections-list">
        {filteredReflections.map((reflection) => (
          <motion.div
            key={reflection.id}
            className="reflection-item p-3 border-b border-gray-200 last:border-b-0 cursor-pointer hover:bg-gray-50"
            onClick={() => handleSelectReflection(reflection)}
            whileHover={{ x: 5 }}
          >
            <div className="reflection-header flex justify-between items-start mb-2">
              <div className="reflection-date text-sm text-gray-500">
                {new Date(reflection.createdAt).toLocaleString()}
              </div>
              <div className="reflection-mood px-2 py-1 rounded-full text-xs bg-gray-100">
                {reflection.mood}
              </div>
            </div>
            <div className="reflection-content mb-2">
              <p className="text-gray-700 line-clamp-2">{reflection.reflection}</p>
            </div>
            {reflection.tags && reflection.tags.length > 0 && (
              <div className="reflection-tags flex flex-wrap gap-1">
                {reflection.tags.map((tag) => (
                  <span
                    key={tag}
                    className="tag px-2 py-0.5 bg-gray-100 rounded-full text-xs"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleFilterByTag(tag);
                    }}
                  >
                    {tag}
                  </span>
                ))}
              </div>
            )}
          </motion.div>
        ))}
      </div>
    );
  };

  // 渲染反思详情
  const renderReflectionDetail = () => {
    if (!selectedReflection) return null;
    
    return (
      <div className="reflection-detail">
        <div className="reflection-header mb-4">
          <div className="flex justify-between items-center">
            <div className="reflection-date text-sm text-gray-500">
              {new Date(selectedReflection.createdAt).toLocaleString()}
            </div>
            <div className="reflection-mood px-2 py-1 rounded-full text-xs bg-gray-100">
              {selectedReflection.mood}
            </div>
          </div>
        </div>
        
        <div className="reflection-content mb-4">
          <h3 className="text-md font-bold mb-2">反思内容</h3>
          <div className="p-3 bg-gray-50 rounded-md">
            <p className="text-gray-700">{selectedReflection.reflection}</p>
          </div>
        </div>
        
        {selectedReflection.action && (
          <div className="reflection-action mb-4">
            <h3 className="text-md font-bold mb-2">行动计划</h3>
            <div className="p-3 bg-jade-50 rounded-md border border-jade-100">
              <p className="text-gray-700">{selectedReflection.action}</p>
            </div>
          </div>
        )}
        
        {selectedReflection.tags && selectedReflection.tags.length > 0 && (
          <div className="reflection-tags mb-4">
            <h3 className="text-md font-bold mb-2">标签</h3>
            <div className="flex flex-wrap gap-1">
              {selectedReflection.tags.map((tag) => (
                <span
                  key={tag}
                  className="tag px-2 py-1 bg-gray-100 rounded-full text-xs"
                >
                  {tag}
                </span>
              ))}
            </div>
          </div>
        )}
        
        <div className="reflection-actions flex justify-start">
          <Button variant="secondary" onClick={handleBackToList}>
            返回列表
          </Button>
        </div>
      </div>
    );
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="反思历史"
      closeOnOutsideClick={true}
      closeOnEsc={true}
      showCloseButton={true}
    >
      <div className="reflection-history p-4">
        {isLoading ? (
          <div className="loading-container flex justify-center items-center h-32">
            <LoadingSpinner variant="jade" size="medium" />
          </div>
        ) : error ? (
          <div className="error-container text-center p-4">
            <div className="error-message text-red-500 mb-4">{error}</div>
            <Button variant="jade" onClick={loadReflections}>
              重试
            </Button>
          </div>
        ) : (
          <AnimatePresence mode="wait">
            {selectedReflection ? (
              <motion.div
                key="detail"
                initial={{ opacity: 0, x: 20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: -20 }}
                transition={{ duration: 0.3 }}
              >
                {renderReflectionDetail()}
              </motion.div>
            ) : (
              <motion.div
                key="list"
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 20 }}
                transition={{ duration: 0.3 }}
              >
                {/* 标签筛选 */}
                {allTags.length > 0 && (
                  <div className="tags-filter mb-4">
                    <h3 className="text-sm font-medium text-gray-700 mb-2">按标签筛选</h3>
                    <div className="flex flex-wrap gap-2">
                      {allTags.map((tag) => (
                        <motion.div
                          key={tag}
                          className={`tag px-2 py-1 rounded-full text-xs cursor-pointer ${
                            filterTag === tag ? 'bg-jade-100 text-jade-800 border border-jade-300' : 'bg-gray-100 text-gray-800'
                          }`}
                          onClick={() => handleFilterByTag(tag)}
                          whileHover={{ scale: 1.05 }}
                          whileTap={{ scale: 0.95 }}
                        >
                          {tag}
                        </motion.div>
                      ))}
                    </div>
                  </div>
                )}
                
                {renderReflectionList()}
              </motion.div>
            )}
          </AnimatePresence>
        )}
      </div>
    </ScrollDialog>
  );
};

export default ReflectionHistory;
</file>

<file path="src/components/reflection/ReflectionTriggerNotification.tsx">
// src/components/reflection/ReflectionTriggerNotification.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  ReflectionTriggerRecord, 
  ReflectionTriggerType,
  getUnviewedReflectionTriggers,
  markTriggerAsViewed,
  markTriggerAsCompleted
} from '@/services/reflectionService';
import Button from '@/components/common/Button';
import { playSound, SoundType } from '@/utils/sound';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface ReflectionTriggerNotificationProps {
  onTriggerAccepted?: (trigger: ReflectionTriggerRecord) => void;
  onTriggerDismissed?: (trigger: ReflectionTriggerRecord) => void;
}

/**
 * 反思触发通知组件
 * 用于显示反思触发通知并处理用户响应
 */
const ReflectionTriggerNotification: React.FC<ReflectionTriggerNotificationProps> = ({
  onTriggerAccepted,
  onTriggerDismissed
}) => {
  const [triggers, setTriggers] = useState<ReflectionTriggerRecord[]>([]);
  const [currentTriggerIndex, setCurrentTriggerIndex] = useState(0);
  const [isVisible, setIsVisible] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  
  // 当前用户ID（在实际应用中，这应该从用户会话中获取）
  const userId = 'current-user';

  // 加载未查看的反思触发记录
  const loadTriggers = async () => {
    try {
      setIsLoading(true);
      const unviewedTriggers = await getUnviewedReflectionTriggers(userId);
      setTriggers(unviewedTriggers);
      
      // 如果有未查看的触发记录，显示通知
      if (unviewedTriggers.length > 0) {
        setIsVisible(true);
        // 播放通知音效
        playSound(SoundType.NOTIFICATION, 0.5);
      }
    } catch (err) {
      console.error('Failed to load reflection triggers:', err);
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadTriggers();
  }, []);

  // 注册数据刷新监听
  useRegisterTableRefresh('reflectionTriggers', loadTriggers);

  // 处理接受反思
  const handleAccept = async () => {
    if (triggers.length === 0) return;
    
    const currentTrigger = triggers[currentTriggerIndex];
    
    try {
      // 标记为已查看
      await markTriggerAsViewed(currentTrigger.id!);
      
      // 播放点击音效
      playSound(SoundType.BUTTON_CLICK, 0.5);
      
      // 隐藏通知
      setIsVisible(false);
      
      // 通知父组件
      if (onTriggerAccepted) {
        setTimeout(() => {
          onTriggerAccepted(currentTrigger);
        }, 300); // 等待关闭动画完成
      }
    } catch (err) {
      console.error('Failed to mark trigger as viewed:', err);
    }
  };

  // 处理稍后提醒
  const handleRemindLater = async () => {
    if (triggers.length === 0) return;
    
    const currentTrigger = triggers[currentTriggerIndex];
    
    try {
      // 标记为已查看
      await markTriggerAsViewed(currentTrigger.id!);
      
      // 播放点击音效
      playSound(SoundType.BUTTON_CLICK, 0.3);
      
      // 移除当前触发记录
      setTriggers(prevTriggers => 
        prevTriggers.filter((_, index) => index !== currentTriggerIndex)
      );
      
      // 重置索引
      setCurrentTriggerIndex(0);
      
      // 如果没有更多触发记录，隐藏通知
      if (triggers.length <= 1) {
        setIsVisible(false);
      }
    } catch (err) {
      console.error('Failed to mark trigger as viewed:', err);
    }
  };

  // 处理忽略
  const handleDismiss = async () => {
    if (triggers.length === 0) return;
    
    const currentTrigger = triggers[currentTriggerIndex];
    
    try {
      // 标记为已完成
      await markTriggerAsCompleted(currentTrigger.id!);
      
      // 播放点击音效
      playSound(SoundType.BUTTON_CLICK, 0.3);
      
      // 移除当前触发记录
      setTriggers(prevTriggers => 
        prevTriggers.filter((_, index) => index !== currentTriggerIndex)
      );
      
      // 重置索引
      setCurrentTriggerIndex(0);
      
      // 如果没有更多触发记录，隐藏通知
      if (triggers.length <= 1) {
        setIsVisible(false);
      }
      
      // 通知父组件
      if (onTriggerDismissed) {
        onTriggerDismissed(currentTrigger);
      }
    } catch (err) {
      console.error('Failed to mark trigger as completed:', err);
    }
  };

  // 获取触发类型标签
  const getTriggerTypeLabel = (type: ReflectionTriggerType): string => {
    switch (type) {
      case ReflectionTriggerType.MOOD_CHANGE:
        return '情绪变化';
      case ReflectionTriggerType.TASK_FAILURE:
        return '任务失败';
      case ReflectionTriggerType.DAILY_REFLECTION:
        return '每日反思';
      case ReflectionTriggerType.WEEKLY_REVIEW:
        return '每周回顾';
      case ReflectionTriggerType.MANUAL:
        return '手动触发';
      default:
        return '未知';
    }
  };

  // 获取触发消息
  const getTriggerMessage = (trigger: ReflectionTriggerRecord): string => {
    switch (trigger.type) {
      case ReflectionTriggerType.MOOD_CHANGE:
        return '熊猫注意到你的情绪有些波动，想和你聊聊吗？';
      case ReflectionTriggerType.TASK_FAILURE:
        return trigger.data?.taskTitle
          ? `任务"${trigger.data.taskTitle}"未能按时完成，想花点时间反思一下吗？`
          : '有一个任务未能按时完成，想花点时间反思一下吗？';
      case ReflectionTriggerType.DAILY_REFLECTION:
        return '今天过得如何？想花点时间进行每日反思吗？';
      case ReflectionTriggerType.WEEKLY_REVIEW:
        return '这周过得如何？想花点时间进行每周回顾吗？';
      case ReflectionTriggerType.MANUAL:
        return '想花点时间进行反思吗？';
      default:
        return '熊猫想和你聊聊，有时间吗？';
    }
  };

  // 如果没有触发记录或不可见，不显示任何内容
  if (triggers.length === 0 || !isVisible) {
    return null;
  }

  const currentTrigger = triggers[currentTriggerIndex];

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          className="reflection-trigger-notification fixed bottom-4 right-4 w-80 bg-white rounded-lg shadow-lg overflow-hidden border border-amber-200 z-50"
          initial={{ opacity: 0, y: 50, scale: 0.9 }}
          animate={{ opacity: 1, y: 0, scale: 1 }}
          exit={{ opacity: 0, y: 50, scale: 0.9 }}
          transition={{ duration: 0.3 }}
        >
          {/* 通知头部 */}
          <div className="notification-header bg-amber-50 p-3 border-b border-amber-200">
            <div className="flex items-center">
              <div className="panda-avatar mr-2">
                <span className="text-2xl">🐼</span>
              </div>
              <div className="flex-grow">
                <h3 className="text-md font-bold text-amber-800">静心茶室</h3>
                <p className="text-xs text-amber-600">
                  {getTriggerTypeLabel(currentTrigger.type)}
                </p>
              </div>
              <div className="trigger-count">
                {triggers.length > 1 && (
                  <span className="text-xs bg-amber-100 text-amber-800 px-2 py-1 rounded-full">
                    {currentTriggerIndex + 1}/{triggers.length}
                  </span>
                )}
              </div>
            </div>
          </div>
          
          {/* 通知内容 */}
          <div className="notification-content p-3">
            <p className="text-gray-700 mb-3">
              {getTriggerMessage(currentTrigger)}
            </p>
            
            <div className="notification-actions flex justify-end gap-2">
              <Button
                variant="secondary"
                size="small"
                onClick={handleDismiss}
              >
                忽略
              </Button>
              <Button
                variant="secondary"
                size="small"
                onClick={handleRemindLater}
              >
                稍后
              </Button>
              <Button
                variant="jade"
                size="small"
                onClick={handleAccept}
              >
                开始
              </Button>
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default ReflectionTriggerNotification;
</file>

<file path="src/components/store/CurrencyDisplay.tsx">
// src/components/store/CurrencyDisplay.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { UserCurrencyRecord } from '@/services/storeService';

interface CurrencyDisplayProps {
  currency: UserCurrencyRecord;
  isVip?: boolean;
  compact?: boolean;
  className?: string;
  labels?: {
    coinsLabel?: string;
    jadeLabel?: string;
    vipLabel?: string;
  };
}

/**
 * 货币显示组件
 * 用于显示用户的金币和玉石
 */
const CurrencyDisplay: React.FC<CurrencyDisplayProps> = ({
  currency,
  isVip = false,
  compact = false,
  className = '',
  labels
}) => {
  // 格式化数字
  const formatNumber = (num: number): string => {
    if (num >= 1000000) {
      return `${(num / 1000000).toFixed(1)}M`;
    }
    if (num >= 1000) {
      return `${(num / 1000).toFixed(1)}K`;
    }
    return num.toString();
  };

  // 紧凑模式
  if (compact) {
    return (
      <div className={`currency-display-compact flex items-center ${className}`}>
        <div className="coins-display flex items-center mr-3">
          <span className="coin-icon mr-1">🪙</span>
          <span className="coin-value font-medium">{formatNumber(currency.coins)}</span>
        </div>
        <div className="jade-display flex items-center">
          <span className="jade-icon mr-1">💎</span>
          <span className="jade-value font-medium">{formatNumber(currency.jade)}</span>
        </div>
        {isVip && (
          <div className="vip-badge ml-3 px-2 py-0.5 rounded-full text-xs bg-amber-100 text-amber-800 border border-amber-300">
            VIP
          </div>
        )}
      </div>
    );
  }

  return (
    <div className={`currency-display p-4 bg-white rounded-lg shadow-md border border-amber-200 ${className}`}>
      <div className="flex justify-between items-center">
        <div className="currency-section flex items-center gap-6">
          <div className="coins-display flex items-center">
            <motion.div
              className="coin-icon text-2xl mr-3 bg-amber-100 p-2 rounded-full"
              initial={{ rotateY: 0 }}
              whileHover={{ rotateY: 180 }}
              transition={{ duration: 0.5 }}
            >
              🪙
            </motion.div>
            <div>
              <div className="coin-value font-bold text-lg">{formatNumber(currency.coins)}</div>
              <div className="coin-label text-xs text-gray-500">{labels?.coinsLabel || "Coins"}</div>
            </div>
          </div>
          <div className="jade-display flex items-center">
            <motion.div
              className="jade-icon text-2xl mr-3 bg-jade-100 p-2 rounded-full"
              initial={{ rotate: 0 }}
              whileHover={{ rotate: 360 }}
              transition={{ duration: 0.5 }}
            >
              💎
            </motion.div>
            <div>
              <div className="jade-value font-bold text-lg">{formatNumber(currency.jade)}</div>
              <div className="jade-label text-xs text-gray-500">{labels?.jadeLabel || "Jade"}</div>
            </div>
          </div>
        </div>

        {isVip && (
          <div className="vip-section">
            <div className="vip-badge px-4 py-2 rounded-full bg-amber-100 text-amber-800 border border-amber-300 font-medium flex items-center">
              <span className="mr-1">✨</span>
              {labels?.vipLabel || "VIP Member"}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default CurrencyDisplay;
</file>

<file path="src/components/store/StoreCategoryList.tsx">
// src/components/store/StoreCategoryList.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { 
  StoreCategoryRecord, 
  getStoreCategories
} from '@/services/storeService';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface StoreCategoryListProps {
  onCategorySelect: (category: StoreCategoryRecord) => void;
  selectedCategoryId?: number;
}

/**
 * 商店类别列表组件
 * 用于显示和选择商店类别
 */
const StoreCategoryList: React.FC<StoreCategoryListProps> = ({
  onCategorySelect,
  selectedCategoryId
}) => {
  const [categories, setCategories] = useState<StoreCategoryRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // 加载商店类别
  const loadCategories = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // 获取商店类别
      const storeCategories = await getStoreCategories();
      setCategories(storeCategories);
    } catch (err) {
      console.error('Failed to load store categories:', err);
      setError('加载商店类别失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadCategories();
  }, []);

  // 注册数据刷新监听
  useRegisterTableRefresh('storeCategories', loadCategories);

  // 处理选择类别
  const handleSelectCategory = (category: StoreCategoryRecord) => {
    // 播放点击音效
    playSound(SoundType.BUTTON_CLICK, 0.3);
    
    // 通知父组件
    onCategorySelect(category);
  };

  // 容器变体
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // 项目变体
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  if (isLoading) {
    return (
      <div className="store-category-list p-4 flex justify-center">
        <LoadingSpinner variant="jade" size="medium" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="store-category-list p-4">
        <div className="error-message text-red-500 mb-2">{error}</div>
        <button
          className="retry-button text-jade-600 underline"
          onClick={loadCategories}
        >
          重试
        </button>
      </div>
    );
  }

  if (categories.length === 0) {
    return (
      <div className="store-category-list p-4">
        <p className="text-gray-500">暂无商店类别</p>
      </div>
    );
  }

  return (
    <motion.div
      className="store-category-list"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <div className="categories-container flex overflow-x-auto py-2 px-4 scrollbar-hide">
        {categories.map((category) => (
          <motion.div
            key={category.id}
            className="category-item flex-shrink-0 mr-4 last:mr-0"
            variants={itemVariants}
          >
            <button
              className={`category-button flex flex-col items-center p-2 rounded-lg ${
                selectedCategoryId === category.id ? 'bg-jade-100 border-2 border-jade-500' : 'bg-white border border-gray-200'
              }`}
              onClick={() => handleSelectCategory(category)}
            >
              <div className="category-icon mb-1">
                <img
                  src={category.iconPath}
                  alt={category.name}
                  className="w-12 h-12 object-contain"
                  onError={(e) => {
                    const target = e.target as HTMLImageElement;
                    target.onerror = null;
                    target.src = '/assets/store/default-category.png';
                  }}
                />
              </div>
              <div className="category-name text-sm">
                {category.name}
              </div>
            </button>
          </motion.div>
        ))}
      </div>
    </motion.div>
  );
};

export default StoreCategoryList;
</file>

<file path="src/components/store/StoreItemCard.tsx">
// src/components/store/StoreItemCard.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { 
  StoreItemRecord, 
  StoreItemRarity, 
  PriceType,
  purchaseStoreItem
} from '@/services/storeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';

interface StoreItemCardProps {
  item: StoreItemRecord;
  onPurchase?: (item: StoreItemRecord) => void;
  onPreview?: (item: StoreItemRecord) => void;
  userCoins?: number;
  userJade?: number;
  isVip?: boolean;
}

/**
 * 商店物品卡片组件
 * 用于显示商店物品和购买按钮
 */
const StoreItemCard: React.FC<StoreItemCardProps> = ({
  item,
  onPurchase,
  onPreview,
  userCoins = 0,
  userJade = 0,
  isVip = false
}) => {
  const [isPurchasing, setIsPurchasing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // 处理购买物品
  const handlePurchase = async (e: React.MouseEvent) => {
    e.stopPropagation(); // 阻止事件冒泡
    
    // 检查是否需要VIP
    if (item.vipRequired && !isVip) {
      setError('需要VIP会员才能购买');
      return;
    }
    
    // 检查是否有足够的货币
    const price = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;
    if (item.priceType === PriceType.COINS && userCoins < price) {
      setError('金币不足');
      return;
    }
    if (item.priceType === PriceType.JADE && userJade < price) {
      setError('玉石不足');
      return;
    }
    
    try {
      setIsPurchasing(true);
      setError(null);
      
      // 购买物品
      await purchaseStoreItem('current-user', item.id!);
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 通知父组件
      if (onPurchase) {
        onPurchase(item);
      }
    } catch (err) {
      console.error('Failed to purchase item:', err);
      setError('购买失败，请重试');
    } finally {
      setIsPurchasing(false);
    }
  };

  // 处理预览物品
  const handlePreview = () => {
    // 播放点击音效
    playSound(SoundType.BUTTON_CLICK, 0.3);
    
    // 通知父组件
    if (onPreview) {
      onPreview(item);
    }
  };

  // 获取稀有度标签和样式
  const getRarityInfo = (rarity: StoreItemRarity) => {
    switch (rarity) {
      case StoreItemRarity.COMMON:
        return { label: '普通', className: 'bg-gray-100 text-gray-800 border-gray-300' };
      case StoreItemRarity.UNCOMMON:
        return { label: '优秀', className: 'bg-green-100 text-green-800 border-green-300' };
      case StoreItemRarity.RARE:
        return { label: '稀有', className: 'bg-blue-100 text-blue-800 border-blue-300' };
      case StoreItemRarity.EPIC:
        return { label: '史诗', className: 'bg-purple-100 text-purple-800 border-purple-300' };
      case StoreItemRarity.LEGENDARY:
        return { label: '传说', className: 'bg-amber-100 text-amber-800 border-amber-300' };
      default:
        return { label: '未知', className: 'bg-gray-100 text-gray-800 border-gray-300' };
    }
  };

  // 获取价格类型图标
  const getPriceTypeIcon = (priceType: PriceType) => {
    switch (priceType) {
      case PriceType.COINS:
        return '🪙';
      case PriceType.JADE:
        return '💎';
      case PriceType.REAL_MONEY:
        return '💵';
      default:
        return '🪙';
    }
  };

  // 检查用户是否有足够的货币
  const canAfford = () => {
    const price = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;
    if (item.priceType === PriceType.COINS) {
      return userCoins >= price;
    }
    if (item.priceType === PriceType.JADE) {
      return userJade >= price;
    }
    return true; // 真实货币需要在应用内购买流程中处理
  };

  const rarityInfo = getRarityInfo(item.rarity);
  const priceTypeIcon = getPriceTypeIcon(item.priceType);
  const displayPrice = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;

  return (
    <motion.div
      className={`store-item-card rounded-lg overflow-hidden shadow-md ${
        item.vipRequired ? 'border-2 border-amber-400' : 'border border-gray-200'
      }`}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
      whileHover={{ scale: 1.03 }}
      whileTap={{ scale: 0.98 }}
      onClick={handlePreview}
    >
      {/* 物品图片 */}
      <div className="item-image-container relative">
        <img
          src={item.imagePath}
          alt={item.name}
          className="w-full h-40 object-cover"
          onError={(e) => {
            const target = e.target as HTMLImageElement;
            target.onerror = null;
            target.src = '/assets/store/default-item.png';
          }}
        />
        
        {/* 稀有度标签 */}
        <div className={`rarity-badge absolute top-2 right-2 px-2 py-1 rounded-full text-xs ${rarityInfo.className}`}>
          {rarityInfo.label}
        </div>
        
        {/* VIP标签 */}
        {item.vipRequired && (
          <div className="vip-badge absolute top-2 left-2 px-2 py-1 rounded-full text-xs bg-amber-100 text-amber-800 border border-amber-300">
            VIP专属
          </div>
        )}
        
        {/* 促销标签 */}
        {item.isOnSale && item.salePrice !== undefined && (
          <div className="sale-badge absolute bottom-2 left-2 px-2 py-1 rounded-full text-xs bg-red-100 text-red-800 border border-red-300">
            促销
          </div>
        )}
      </div>
      
      {/* 物品信息 */}
      <div className="item-info p-3">
        <h3 className="item-name text-md font-bold mb-1">{item.name}</h3>
        <p className="item-description text-xs text-gray-600 mb-2 line-clamp-2">
          {item.description}
        </p>
        
        {/* 价格信息 */}
        <div className="price-info flex justify-between items-center">
          <div className="price-display flex items-center">
            <span className="price-icon mr-1">{priceTypeIcon}</span>
            <span className="price-value font-bold">
              {displayPrice}
            </span>
            {item.isOnSale && item.salePrice !== undefined && (
              <span className="original-price text-xs text-gray-500 line-through ml-2">
                {item.price}
              </span>
            )}
          </div>
          
          <Button
            variant="jade"
            size="small"
            onClick={handlePurchase}
            disabled={isPurchasing || !canAfford() || (item.vipRequired && !isVip)}
          >
            {isPurchasing ? (
              <LoadingSpinner variant="white" size="small" />
            ) : (
              '购买'
            )}
          </Button>
        </div>
        
        {/* 错误信息 */}
        {error && (
          <div className="error-message mt-2 text-xs text-red-500">
            {error}
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default StoreItemCard;
</file>

<file path="src/components/store/StoreItemPreview.tsx">
// src/components/store/StoreItemPreview.tsx
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  StoreItemRecord, 
  StoreItemRarity, 
  StoreItemType,
  PriceType,
  purchaseStoreItem
} from '@/services/storeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from '@/components/game/ScrollDialog';

interface StoreItemPreviewProps {
  isOpen: boolean;
  onClose: () => void;
  item: StoreItemRecord;
  onPurchase?: (item: StoreItemRecord) => void;
  userCoins?: number;
  userJade?: number;
  isVip?: boolean;
}

/**
 * 商店物品预览组件
 * 用于预览商店物品的详细信息和购买
 */
const StoreItemPreview: React.FC<StoreItemPreviewProps> = ({
  isOpen,
  onClose,
  item,
  onPurchase,
  userCoins = 0,
  userJade = 0,
  isVip = false
}) => {
  const [isPurchasing, setIsPurchasing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isPreviewAnimating, setIsPreviewAnimating] = useState(false);
  
  // 处理购买物品
  const handlePurchase = async () => {
    // 检查是否需要VIP
    if (item.vipRequired && !isVip) {
      setError('需要VIP会员才能购买');
      return;
    }
    
    // 检查是否有足够的货币
    const price = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;
    if (item.priceType === PriceType.COINS && userCoins < price) {
      setError('金币不足');
      return;
    }
    if (item.priceType === PriceType.JADE && userJade < price) {
      setError('玉石不足');
      return;
    }
    
    try {
      setIsPurchasing(true);
      setError(null);
      
      // 购买物品
      await purchaseStoreItem('current-user', item.id!);
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 通知父组件
      if (onPurchase) {
        onPurchase(item);
      }
      
      // 关闭预览
      onClose();
    } catch (err) {
      console.error('Failed to purchase item:', err);
      setError('购买失败，请重试');
    } finally {
      setIsPurchasing(false);
    }
  };

  // 获取稀有度标签和样式
  const getRarityInfo = (rarity: StoreItemRarity) => {
    switch (rarity) {
      case StoreItemRarity.COMMON:
        return { label: '普通', className: 'bg-gray-100 text-gray-800 border-gray-300' };
      case StoreItemRarity.UNCOMMON:
        return { label: '优秀', className: 'bg-green-100 text-green-800 border-green-300' };
      case StoreItemRarity.RARE:
        return { label: '稀有', className: 'bg-blue-100 text-blue-800 border-blue-300' };
      case StoreItemRarity.EPIC:
        return { label: '史诗', className: 'bg-purple-100 text-purple-800 border-purple-300' };
      case StoreItemRarity.LEGENDARY:
        return { label: '传说', className: 'bg-amber-100 text-amber-800 border-amber-300' };
      default:
        return { label: '未知', className: 'bg-gray-100 text-gray-800 border-gray-300' };
    }
  };

  // 获取物品类型标签
  const getItemTypeLabel = (type: StoreItemType) => {
    switch (type) {
      case StoreItemType.AVATAR:
        return '熊猫头像';
      case StoreItemType.ACCESSORY:
        return '熊猫配件';
      case StoreItemType.BACKGROUND:
        return '背景';
      case StoreItemType.THEME:
        return '主题';
      case StoreItemType.ABILITY:
        return '能力';
      case StoreItemType.CONSUMABLE:
        return '消耗品';
      case StoreItemType.VIP:
        return 'VIP会员';
      default:
        return '未知';
    }
  };

  // 获取价格类型图标和标签
  const getPriceTypeInfo = (priceType: PriceType) => {
    switch (priceType) {
      case PriceType.COINS:
        return { icon: '🪙', label: '金币' };
      case PriceType.JADE:
        return { icon: '💎', label: '玉石' };
      case PriceType.REAL_MONEY:
        return { icon: '💵', label: '真实货币' };
      default:
        return { icon: '🪙', label: '金币' };
    }
  };

  // 检查用户是否有足够的货币
  const canAfford = () => {
    const price = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;
    if (item.priceType === PriceType.COINS) {
      return userCoins >= price;
    }
    if (item.priceType === PriceType.JADE) {
      return userJade >= price;
    }
    return true; // 真实货币需要在应用内购买流程中处理
  };

  // 处理预览动画
  const handlePreviewAnimation = () => {
    setIsPreviewAnimating(true);
    setTimeout(() => {
      setIsPreviewAnimating(false);
    }, 2000);
  };

  const rarityInfo = getRarityInfo(item.rarity);
  const itemTypeLabel = getItemTypeLabel(item.type);
  const priceTypeInfo = getPriceTypeInfo(item.priceType);
  const displayPrice = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="物品预览"
      closeOnOutsideClick={!isPurchasing}
      closeOnEsc={!isPurchasing}
      showCloseButton={!isPurchasing}
    >
      <div className="store-item-preview p-4">
        {/* 物品图片 */}
        <div className="item-image-container mb-4 relative">
          <div className="preview-image-wrapper relative overflow-hidden rounded-lg border border-gray-200">
            <img
              src={item.imagePath}
              alt={item.name}
              className={`w-full h-64 object-contain ${isPreviewAnimating ? 'animate-pulse' : ''}`}
              onError={(e) => {
                const target = e.target as HTMLImageElement;
                target.onerror = null;
                target.src = '/assets/store/default-item.png';
              }}
            />
            
            {/* 预览动画按钮 */}
            {(item.type === StoreItemType.AVATAR || item.type === StoreItemType.ACCESSORY) && (
              <button
                className="preview-animation-button absolute bottom-2 right-2 bg-white bg-opacity-80 p-2 rounded-full shadow-md"
                onClick={handlePreviewAnimation}
              >
                <span role="img" aria-label="preview">👁️</span>
              </button>
            )}
          </div>
          
          {/* 稀有度标签 */}
          <div className={`rarity-badge absolute top-2 right-2 px-2 py-1 rounded-full text-xs ${rarityInfo.className}`}>
            {rarityInfo.label}
          </div>
          
          {/* VIP标签 */}
          {item.vipRequired && (
            <div className="vip-badge absolute top-2 left-2 px-2 py-1 rounded-full text-xs bg-amber-100 text-amber-800 border border-amber-300">
              VIP专属
            </div>
          )}
          
          {/* 促销标签 */}
          {item.isOnSale && item.salePrice !== undefined && (
            <div className="sale-badge absolute bottom-2 left-2 px-2 py-1 rounded-full text-xs bg-red-100 text-red-800 border border-red-300">
              促销
            </div>
          )}
        </div>
        
        {/* 物品信息 */}
        <div className="item-info mb-4">
          <h3 className="item-name text-xl font-bold mb-2">{item.name}</h3>
          
          <div className="item-meta flex flex-wrap gap-2 mb-2">
            <span className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800">
              {itemTypeLabel}
            </span>
            <span className={`px-2 py-1 rounded-full text-xs ${rarityInfo.className}`}>
              {rarityInfo.label}
            </span>
          </div>
          
          <p className="item-description text-gray-700 mb-4">
            {item.description}
          </p>
          
          {/* 标签 */}
          {item.tags && item.tags.length > 0 && (
            <div className="item-tags flex flex-wrap gap-1 mb-4">
              {item.tags.map((tag, index) => (
                <span
                  key={index}
                  className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-600"
                >
                  {tag}
                </span>
              ))}
            </div>
          )}
          
          {/* 限量信息 */}
          {item.limitedQuantity && item.remainingQuantity !== undefined && (
            <div className="limited-quantity mb-4">
              <p className="text-sm text-gray-600">
                限量: {item.remainingQuantity}/{item.limitedQuantity}
              </p>
              <div className="w-full bg-gray-200 rounded-full h-2 mt-1">
                <div
                  className="bg-jade-500 h-2 rounded-full"
                  style={{ width: `${(item.remainingQuantity / item.limitedQuantity) * 100}%` }}
                ></div>
              </div>
            </div>
          )}
          
          {/* 促销信息 */}
          {item.isOnSale && item.salePrice !== undefined && item.saleEndDate && (
            <div className="sale-info mb-4">
              <p className="text-sm text-red-600">
                促销截止日期: {new Date(item.saleEndDate).toLocaleDateString()}
              </p>
            </div>
          )}
        </div>
        
        {/* 价格和购买 */}
        <div className="price-purchase-section">
          <div className="price-info flex items-center mb-4">
            <span className="price-label text-gray-600 mr-2">价格:</span>
            <span className="price-icon mr-1">{priceTypeInfo.icon}</span>
            <span className="price-value font-bold text-lg">
              {displayPrice}
            </span>
            <span className="price-type text-sm text-gray-500 ml-1">
              ({priceTypeInfo.label})
            </span>
            {item.isOnSale && item.salePrice !== undefined && (
              <span className="original-price text-sm text-gray-500 line-through ml-2">
                {item.price}
              </span>
            )}
          </div>
          
          {/* 错误信息 */}
          {error && (
            <div className="error-message mb-4 p-2 bg-red-50 rounded-md text-red-500">
              {error}
            </div>
          )}
          
          {/* 购买按钮 */}
          <div className="purchase-button">
            <Button
              variant="jade"
              onClick={handlePurchase}
              disabled={isPurchasing || !canAfford() || (item.vipRequired && !isVip)}
              className="w-full"
            >
              {isPurchasing ? (
                <LoadingSpinner variant="white" size="small" />
              ) : (
                '购买'
              )}
            </Button>
            
            {!canAfford() && (
              <p className="text-sm text-red-500 mt-2 text-center">
                {item.priceType === PriceType.COINS ? '金币不足' : '玉石不足'}
              </p>
            )}
            
            {item.vipRequired && !isVip && (
              <p className="text-sm text-amber-500 mt-2 text-center">
                需要VIP会员才能购买
              </p>
            )}
          </div>
        </div>
      </div>
    </ScrollDialog>
  );
};

export default StoreItemPreview;
</file>

<file path="src/components/store/VipSubscriptionCard.tsx">
// src/components/store/VipSubscriptionCard.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { 
  VipSubscriptionRecord, 
  activateVipSubscription
} from '@/services/storeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';

interface VipSubscriptionCardProps {
  tier: number;
  title: string;
  description: string;
  price: number;
  duration: number; // 天数
  benefits: string[];
  imagePath: string;
  currentSubscription?: VipSubscriptionRecord | null;
  onSubscribe?: (tier: number, duration: number) => void;
}

/**
 * VIP订阅卡片组件
 * 用于显示VIP订阅信息和订阅按钮
 */
const VipSubscriptionCard: React.FC<VipSubscriptionCardProps> = ({
  tier,
  title,
  description,
  price,
  duration,
  benefits,
  imagePath,
  currentSubscription,
  onSubscribe
}) => {
  const [isSubscribing, setIsSubscribing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // 检查是否已经订阅了该等级或更高等级的VIP
  const isAlreadySubscribed = () => {
    if (!currentSubscription) return false;
    return currentSubscription.tier >= tier;
  };

  // 处理订阅
  const handleSubscribe = async () => {
    try {
      setIsSubscribing(true);
      setError(null);
      
      // 激活VIP订阅
      await activateVipSubscription(
        'current-user',
        tier,
        duration,
        'in_app_purchase', // 支付方式
        `vip_${tier}_${Date.now()}` // 模拟交易ID
      );
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 通知父组件
      if (onSubscribe) {
        onSubscribe(tier, duration);
      }
    } catch (err) {
      console.error('Failed to subscribe to VIP:', err);
      setError('订阅失败，请重试');
    } finally {
      setIsSubscribing(false);
    }
  };

  // 获取剩余天数
  const getRemainingDays = () => {
    if (!currentSubscription || !currentSubscription.endDate) return 0;
    
    const endDate = new Date(currentSubscription.endDate);
    const now = new Date();
    const diffTime = endDate.getTime() - now.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    return Math.max(0, diffDays);
  };

  // 获取VIP等级标签
  const getTierLabel = (tier: number) => {
    switch (tier) {
      case 1:
        return '基础';
      case 2:
        return '高级';
      case 3:
        return '豪华';
      default:
        return `等级 ${tier}`;
    }
  };

  const tierLabel = getTierLabel(tier);
  const remainingDays = getRemainingDays();
  const isSubscribed = isAlreadySubscribed();

  return (
    <motion.div
      className={`vip-subscription-card rounded-lg overflow-hidden shadow-md ${
        isSubscribed ? 'border-2 border-amber-500' : 'border border-gray-200'
      }`}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
      whileHover={{ scale: 1.03 }}
      whileTap={{ scale: 0.98 }}
    >
      {/* VIP图片 */}
      <div className="vip-image-container relative">
        <img
          src={imagePath}
          alt={title}
          className="w-full h-40 object-cover"
          onError={(e) => {
            const target = e.target as HTMLImageElement;
            target.onerror = null;
            target.src = '/assets/store/default-vip.png';
          }}
        />
        
        {/* VIP等级标签 */}
        <div className="tier-badge absolute top-2 right-2 px-2 py-1 rounded-full text-xs bg-amber-100 text-amber-800 border border-amber-300">
          {tierLabel} VIP
        </div>
        
        {/* 已订阅标签 */}
        {isSubscribed && (
          <div className="subscribed-badge absolute top-2 left-2 px-2 py-1 rounded-full text-xs bg-green-100 text-green-800 border border-green-300">
            已订阅
          </div>
        )}
      </div>
      
      {/* VIP信息 */}
      <div className="vip-info p-3">
        <h3 className="vip-title text-md font-bold mb-1">{title}</h3>
        <p className="vip-description text-xs text-gray-600 mb-2">
          {description}
        </p>
        
        {/* VIP福利 */}
        <div className="vip-benefits mb-3">
          <h4 className="text-xs font-bold text-gray-700 mb-1">会员福利</h4>
          <ul className="benefits-list text-xs text-gray-600">
            {benefits.map((benefit, index) => (
              <li key={index} className="flex items-start mb-1">
                <span className="mr-1">✓</span>
                <span>{benefit}</span>
              </li>
            ))}
          </ul>
        </div>
        
        {/* 价格和订阅 */}
        <div className="price-subscribe-section">
          <div className="price-info flex justify-between items-center mb-2">
            <div className="price-display">
              <span className="price-value font-bold">¥{price}</span>
              <span className="duration text-xs text-gray-500 ml-1">
                / {duration} 天
              </span>
            </div>
            
            {isSubscribed && (
              <div className="remaining-days text-xs text-green-600">
                剩余 {remainingDays} 天
              </div>
            )}
          </div>
          
          <Button
            variant={isSubscribed ? 'secondary' : 'gold'}
            onClick={handleSubscribe}
            disabled={isSubscribing}
            className="w-full"
          >
            {isSubscribing ? (
              <LoadingSpinner variant="white" size="small" />
            ) : isSubscribed ? (
              '续订'
            ) : (
              '订阅'
            )}
          </Button>
        </div>
        
        {/* 错误信息 */}
        {error && (
          <div className="error-message mt-2 text-xs text-red-500">
            {error}
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default VipSubscriptionCard;
</file>

<file path="src/components/task/TaskCard.tsx">
// src/components/task/TaskCard.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { 
  TaskRecord, 
  completeTask, 
  TaskStatus,
  TaskPriority
} from '@/services/taskService';
import { getTaskCategory } from '@/services/taskCategoryService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import TaskDetailDialog from './TaskDetailDialog';

interface TaskCardProps {
  task: TaskRecord;
  onTaskCompleted?: (task: TaskRecord) => void;
  onTaskUpdated?: () => void;
}

/**
 * 任务卡片组件
 * 用于显示任务信息和操作
 */
const TaskCard: React.FC<TaskCardProps> = ({
  task,
  onTaskCompleted,
  onTaskUpdated
}) => {
  const [isCompleting, setIsCompleting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [categoryName, setCategoryName] = useState<string>('');
  const [showDetailDialog, setShowDetailDialog] = useState(false);
  
  // 加载任务分类
  React.useEffect(() => {
    const loadCategory = async () => {
      if (task.categoryId) {
        try {
          const category = await getTaskCategory(task.categoryId);
          if (category) {
            setCategoryName(category.name);
          }
        } catch (err) {
          console.error('Failed to load task category:', err);
        }
      }
    };
    
    loadCategory();
  }, [task.categoryId]);

  // 处理完成任务
  const handleCompleteTask = async (e: React.MouseEvent) => {
    e.stopPropagation(); // 阻止事件冒泡
    
    try {
      setIsCompleting(true);
      setError(null);
      
      // 完成任务
      const completedTask = await completeTask(task.id!);
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 通知父组件
      if (onTaskCompleted) {
        onTaskCompleted(completedTask);
      }
    } catch (err) {
      console.error('Failed to complete task:', err);
      setError('完成任务失败，请重试');
    } finally {
      setIsCompleting(false);
    }
  };

  // 处理查看任务详情
  const handleViewDetails = () => {
    // 播放点击音效
    playSound(SoundType.BUTTON_CLICK, 0.3);
    
    // 显示详情对话框
    setShowDetailDialog(true);
  };

  // 获取优先级标签和样式
  const getPriorityInfo = (priority: TaskPriority) => {
    switch (priority) {
      case TaskPriority.HIGH:
        return { label: '高', className: 'bg-red-100 text-red-800' };
      case TaskPriority.MEDIUM:
        return { label: '中', className: 'bg-yellow-100 text-yellow-800' };
      case TaskPriority.LOW:
        return { label: '低', className: 'bg-green-100 text-green-800' };
      default:
        return { label: '未知', className: 'bg-gray-100 text-gray-800' };
    }
  };

  // 检查任务是否已过期
  const isOverdue = () => {
    return task.dueDate && new Date(task.dueDate) < new Date() && task.status !== TaskStatus.COMPLETED;
  };

  return (
    <>
      <motion.div
        className={`task-card p-3 rounded-lg shadow-md ${
          task.status === TaskStatus.COMPLETED ? 'bg-gray-50' : 'bg-white'
        } ${
          isOverdue() ? 'border-l-4 border-red-500' : ''
        }`}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3 }}
        whileHover={{ scale: 1.02 }}
        whileTap={{ scale: 0.98 }}
        onClick={handleViewDetails}
      >
        <div className="task-header flex justify-between items-start mb-2">
          <div className="task-title-container">
            <h3 className={`text-md font-bold ${
              task.status === TaskStatus.COMPLETED ? 'line-through text-gray-500' : ''
            }`}>
              {task.title}
            </h3>
            <div className="task-meta flex flex-wrap gap-1 mt-1">
              {task.categoryId && (
                <span className="px-2 py-0.5 rounded-full text-xs bg-gray-100 text-gray-800">
                  {categoryName}
                </span>
              )}
              <span className={`px-2 py-0.5 rounded-full text-xs ${getPriorityInfo(task.priority).className}`}>
                {getPriorityInfo(task.priority).label}
              </span>
              {isOverdue() && (
                <span className="px-2 py-0.5 rounded-full text-xs bg-red-100 text-red-800">
                  已过期
                </span>
              )}
            </div>
          </div>
          <div className="task-actions">
            {task.status !== TaskStatus.COMPLETED && (
              <Button
                variant="jade"
                size="small"
                onClick={handleCompleteTask}
                disabled={isCompleting}
              >
                {isCompleting ? (
                  <LoadingSpinner variant="white" size="small" />
                ) : (
                  '完成'
                )}
              </Button>
            )}
          </div>
        </div>
        
        {task.description && (
          <div className="task-description mb-2">
            <p className={`text-sm ${
              task.status === TaskStatus.COMPLETED ? 'text-gray-400' : 'text-gray-600'
            }`}>
              {task.description.length > 100 ? `${task.description.substring(0, 100)}...` : task.description}
            </p>
          </div>
        )}
        
        <div className="task-footer flex justify-between items-center">
          <div className="task-dates text-xs text-gray-500">
            {task.dueDate && (
              <span className={`${isOverdue() ? 'text-red-500 font-medium' : ''}`}>
                截止日期: {new Date(task.dueDate).toLocaleDateString()}
              </span>
            )}
          </div>
          <div className="task-details-link text-xs text-jade-600 cursor-pointer">
            查看详情
          </div>
        </div>
        
        {error && (
          <div className="error-message mt-2 text-xs text-red-500">
            {error}
          </div>
        )}
      </motion.div>
      
      {/* 任务详情对话框 */}
      {showDetailDialog && (
        <TaskDetailDialog
          isOpen={showDetailDialog}
          onClose={() => setShowDetailDialog(false)}
          taskId={task.id!}
          onTaskUpdated={onTaskUpdated}
          onTaskCompleted={onTaskCompleted}
        />
      )}
    </>
  );
};

export default TaskCard;
</file>

<file path="src/components/task/TaskDetailDialog.tsx">
// src/components/task/TaskDetailDialog.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  TaskRecord, 
  getTask, 
  updateTask, 
  completeTask,
  TaskStatus,
  TaskPriority
} from '@/services/taskService';
import { getTaskCategory } from '@/services/taskCategoryService';
import { getTaskReminders } from '@/services/taskReminderService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from '@/components/game/ScrollDialog';
import SubtaskList from '@/components/task/SubtaskList';
import TaskReminderForm from '@/components/task/TaskReminderForm';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface TaskDetailDialogProps {
  isOpen: boolean;
  onClose: () => void;
  taskId: number;
  onTaskUpdated?: () => void;
  onTaskCompleted?: (task: TaskRecord) => void;
}

/**
 * 任务详情对话框组件
 * 用于显示任务详情、子任务和提醒
 */
const TaskDetailDialog: React.FC<TaskDetailDialogProps> = ({
  isOpen,
  onClose,
  taskId,
  onTaskUpdated,
  onTaskCompleted
}) => {
  const [task, setTask] = useState<TaskRecord | null>(null);
  const [categoryName, setCategoryName] = useState<string>('');
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isCompleting, setIsCompleting] = useState(false);
  const [activeTab, setActiveTab] = useState<'details' | 'subtasks' | 'reminders'>('details');
  const [showReminderForm, setShowReminderForm] = useState(false);
  const [reminders, setReminders] = useState<any[]>([]);
  
  // 加载任务数据
  const loadTaskData = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // 获取任务数据
      const taskData = await getTask(taskId);
      if (taskData) {
        setTask(taskData);
        
        // 获取任务分类
        if (taskData.categoryId) {
          const category = await getTaskCategory(taskData.categoryId);
          if (category) {
            setCategoryName(category.name);
          }
        }
        
        // 获取任务提醒
        const taskReminders = await getTaskReminders(taskId);
        setReminders(taskReminders);
      } else {
        setError('无法加载任务数据');
      }
    } catch (err) {
      console.error('Failed to load task data:', err);
      setError('加载任务数据失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    if (isOpen && taskId) {
      loadTaskData();
    }
  }, [isOpen, taskId]);

  // 注册数据刷新监听
  useRegisterTableRefresh('tasks', loadTaskData);
  useRegisterTableRefresh('subtasks', loadTaskData);
  useRegisterTableRefresh('taskReminders', loadTaskData);

  // 处理完成任务
  const handleCompleteTask = async () => {
    if (!task) return;
    
    try {
      setIsCompleting(true);
      
      // 完成任务
      const completedTask = await completeTask(task.id!);
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 通知父组件
      if (onTaskCompleted) {
        onTaskCompleted(completedTask);
      }
      
      // 关闭对话框
      onClose();
    } catch (err) {
      console.error('Failed to complete task:', err);
      setError('完成任务失败，请重试');
    } finally {
      setIsCompleting(false);
    }
  };

  // 处理更新任务优先级
  const handleUpdatePriority = async (priority: TaskPriority) => {
    if (!task) return;
    
    try {
      // 更新任务
      await updateTask(task.id!, { priority });
      
      // 播放点击音效
      playSound(SoundType.BUTTON_CLICK, 0.3);
      
      // 重新加载任务数据
      await loadTaskData();
      
      // 通知父组件
      if (onTaskUpdated) {
        onTaskUpdated();
      }
    } catch (err) {
      console.error('Failed to update task priority:', err);
      setError('更新任务优先级失败，请重试');
    }
  };

  // 处理创建提醒
  const handleCreateReminder = () => {
    setShowReminderForm(true);
  };

  // 处理提醒创建完成
  const handleReminderCreated = () => {
    // 重新加载任务数据
    loadTaskData();
    
    // 通知父组件
    if (onTaskUpdated) {
      onTaskUpdated();
    }
  };

  // 获取优先级标签和样式
  const getPriorityInfo = (priority: TaskPriority) => {
    switch (priority) {
      case TaskPriority.HIGH:
        return { label: '高', className: 'bg-red-100 text-red-800' };
      case TaskPriority.MEDIUM:
        return { label: '中', className: 'bg-yellow-100 text-yellow-800' };
      case TaskPriority.LOW:
        return { label: '低', className: 'bg-green-100 text-green-800' };
      default:
        return { label: '未知', className: 'bg-gray-100 text-gray-800' };
    }
  };

  // 渲染任务详情
  const renderTaskDetails = () => {
    if (!task) return null;
    
    return (
      <div className="task-details">
        <div className="task-header mb-4">
          <div className="task-meta flex flex-wrap gap-2 mb-2">
            {task.categoryId && (
              <span className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800">
                {categoryName}
              </span>
            )}
            <span className={`px-2 py-1 rounded-full text-xs ${getPriorityInfo(task.priority).className}`}>
              {getPriorityInfo(task.priority).label}优先级
            </span>
            {task.dueDate && (
              <span className="px-2 py-1 rounded-full text-xs bg-blue-100 text-blue-800">
                截止日期: {new Date(task.dueDate).toLocaleDateString()}
              </span>
            )}
          </div>
          
          <h3 className="text-xl font-bold">{task.title}</h3>
          
          {task.description && (
            <div className="task-description mt-2">
              <p className="text-gray-700">{task.description}</p>
            </div>
          )}
        </div>
        
        <div className="task-actions mb-4">
          <h3 className="text-md font-bold mb-2">任务操作</h3>
          <div className="grid grid-cols-2 gap-2">
            <Button
              variant="jade"
              onClick={handleCompleteTask}
              disabled={isCompleting || task.status === TaskStatus.COMPLETED}
            >
              {isCompleting ? (
                <LoadingSpinner variant="white" size="small" />
              ) : (
                task.status === TaskStatus.COMPLETED ? '已完成' : '完成任务'
              )}
            </Button>
            <Button
              variant="secondary"
              onClick={handleCreateReminder}
            >
              创建提醒
            </Button>
          </div>
        </div>
        
        <div className="priority-selector mb-4">
          <h3 className="text-md font-bold mb-2">调整优先级</h3>
          <div className="grid grid-cols-3 gap-2">
            <button
              className={`p-2 rounded-md ${
                task.priority === TaskPriority.LOW ? 'bg-green-100 text-green-800 border border-green-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
              }`}
              onClick={() => handleUpdatePriority(TaskPriority.LOW)}
            >
              低
            </button>
            <button
              className={`p-2 rounded-md ${
                task.priority === TaskPriority.MEDIUM ? 'bg-yellow-100 text-yellow-800 border border-yellow-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
              }`}
              onClick={() => handleUpdatePriority(TaskPriority.MEDIUM)}
            >
              中
            </button>
            <button
              className={`p-2 rounded-md ${
                task.priority === TaskPriority.HIGH ? 'bg-red-100 text-red-800 border border-red-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
              }`}
              onClick={() => handleUpdatePriority(TaskPriority.HIGH)}
            >
              高
            </button>
          </div>
        </div>
        
        <div className="task-dates">
          <div className="text-sm text-gray-500">
            <p>创建时间: {new Date(task.createdAt).toLocaleString()}</p>
            {task.updatedAt && (
              <p>更新时间: {new Date(task.updatedAt).toLocaleString()}</p>
            )}
          </div>
        </div>
      </div>
    );
  };

  // 渲染子任务
  const renderSubtasks = () => {
    if (!task) return null;
    
    return (
      <div className="task-subtasks">
        <SubtaskList
          parentTaskId={task.id!}
          onSubtasksUpdated={() => {
            // 重新加载任务数据
            loadTaskData();
            
            // 通知父组件
            if (onTaskUpdated) {
              onTaskUpdated();
            }
          }}
        />
      </div>
    );
  };

  // 渲染提醒
  const renderReminders = () => {
    if (!task) return null;
    
    return (
      <div className="task-reminders">
        <div className="reminders-header flex justify-between items-center mb-4">
          <h3 className="text-md font-bold">任务提醒</h3>
          <Button
            variant="jade"
            size="small"
            onClick={handleCreateReminder}
          >
            添加提醒
          </Button>
        </div>
        
        {reminders.length === 0 ? (
          <div className="no-reminders text-center p-4 bg-gray-50 rounded-md">
            <p className="text-gray-500">暂无提醒</p>
          </div>
        ) : (
          <div className="reminders-list">
            {reminders.map((reminder) => (
              <div
                key={reminder.id}
                className="reminder-item p-3 border-b border-gray-200 last:border-b-0"
              >
                <div className="reminder-time font-medium mb-1">
                  {new Date(reminder.reminderTime).toLocaleString()}
                </div>
                <div className="reminder-message text-gray-700 mb-1">
                  {reminder.message || '任务提醒'}
                </div>
                <div className="reminder-status flex gap-2">
                  {reminder.isViewed && (
                    <span className="text-xs px-2 py-0.5 bg-gray-100 text-gray-800 rounded-full">
                      已查看
                    </span>
                  )}
                  {reminder.isCompleted && (
                    <span className="text-xs px-2 py-0.5 bg-green-100 text-green-800 rounded-full">
                      已完成
                    </span>
                  )}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    );
  };

  return (
    <>
      <ScrollDialog
        isOpen={isOpen}
        onClose={onClose}
        title="任务详情"
        closeOnOutsideClick={!isCompleting}
        closeOnEsc={!isCompleting}
        showCloseButton={!isCompleting}
      >
        <div className="task-detail-dialog p-4">
          {isLoading ? (
            <div className="loading-container flex justify-center items-center h-32">
              <LoadingSpinner variant="jade" size="medium" />
            </div>
          ) : error ? (
            <div className="error-container text-center p-4">
              <div className="error-message text-red-500 mb-4">{error}</div>
              <Button variant="jade" onClick={loadTaskData}>
                重试
              </Button>
            </div>
          ) : task ? (
            <div className="task-content">
              {/* 选项卡 */}
              <div className="tabs-container mb-4">
                <div className="tabs flex border-b border-gray-200">
                  <button
                    className={`tab-button py-2 px-4 ${
                      activeTab === 'details' ? 'border-b-2 border-jade-500 text-jade-600 font-medium' : 'text-gray-500'
                    }`}
                    onClick={() => setActiveTab('details')}
                  >
                    详情
                  </button>
                  <button
                    className={`tab-button py-2 px-4 ${
                      activeTab === 'subtasks' ? 'border-b-2 border-jade-500 text-jade-600 font-medium' : 'text-gray-500'
                    }`}
                    onClick={() => setActiveTab('subtasks')}
                  >
                    子任务
                  </button>
                  <button
                    className={`tab-button py-2 px-4 ${
                      activeTab === 'reminders' ? 'border-b-2 border-jade-500 text-jade-600 font-medium' : 'text-gray-500'
                    }`}
                    onClick={() => setActiveTab('reminders')}
                  >
                    提醒
                  </button>
                </div>
              </div>
              
              {/* 选项卡内容 */}
              <AnimatePresence mode="wait">
                <motion.div
                  key={activeTab}
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -10 }}
                  transition={{ duration: 0.2 }}
                >
                  {activeTab === 'details' && renderTaskDetails()}
                  {activeTab === 'subtasks' && renderSubtasks()}
                  {activeTab === 'reminders' && renderReminders()}
                </motion.div>
              </AnimatePresence>
            </div>
          ) : (
            <div className="not-found-container text-center p-4">
              <p className="text-gray-500">任务不存在或已被删除</p>
            </div>
          )}
        </div>
      </ScrollDialog>
      
      {/* 提醒表单 */}
      {showReminderForm && task && (
        <TaskReminderForm
          isOpen={showReminderForm}
          onClose={() => setShowReminderForm(false)}
          taskId={task.id!}
          onReminderCreated={handleReminderCreated}
        />
      )}
    </>
  );
};

export default TaskDetailDialog;
</file>

<file path="src/components/task/TaskReminderForm.tsx">
// src/components/task/TaskReminderForm.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { 
  scheduleTaskReminder,
  createCustomReminder
} from '@/services/taskReminderService';
import { getTask } from '@/services/taskService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from '@/components/game/ScrollDialog';

interface TaskReminderFormProps {
  isOpen: boolean;
  onClose: () => void;
  taskId: number;
  onReminderCreated?: () => void;
}

/**
 * 任务提醒表单组件
 * 用于创建任务提醒
 */
const TaskReminderForm: React.FC<TaskReminderFormProps> = ({
  isOpen,
  onClose,
  taskId,
  onReminderCreated
}) => {
  const [reminderType, setReminderType] = useState<'scheduled' | 'custom'>('scheduled');
  const [reminderDate, setReminderDate] = useState<string>(new Date().toISOString().split('T')[0]);
  const [reminderTime, setReminderTime] = useState<string>('12:00');
  const [customMessage, setCustomMessage] = useState<string>('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [taskTitle, setTaskTitle] = useState<string>('');
  
  // 加载任务标题
  React.useEffect(() => {
    const loadTaskTitle = async () => {
      try {
        const task = await getTask(taskId);
        if (task) {
          setTaskTitle(task.title);
        }
      } catch (err) {
        console.error('Failed to load task:', err);
      }
    };
    
    if (isOpen && taskId) {
      loadTaskTitle();
    }
  }, [isOpen, taskId]);

  // 处理提交表单
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      setIsSubmitting(true);
      setError(null);
      
      // 创建提醒时间
      const reminderDateTime = new Date(`${reminderDate}T${reminderTime}`);
      
      // 检查提醒时间是否有效
      if (reminderDateTime < new Date()) {
        setError('提醒时间不能早于当前时间');
        return;
      }
      
      // 创建提醒
      if (reminderType === 'scheduled') {
        await scheduleTaskReminder(taskId, reminderDateTime);
      } else {
        if (!customMessage.trim()) {
          setError('请输入自定义消息');
          return;
        }
        
        await createCustomReminder(taskId, reminderDateTime, customMessage);
      }
      
      // 播放成功音效
      playSound(SoundType.SUCCESS, 0.5);
      
      // 通知父组件
      if (onReminderCreated) {
        onReminderCreated();
      }
      
      // 关闭对话框
      onClose();
    } catch (err) {
      console.error('Failed to create reminder:', err);
      setError('创建提醒失败，请重试');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="创建任务提醒"
      closeOnOutsideClick={!isSubmitting}
      closeOnEsc={!isSubmitting}
      showCloseButton={!isSubmitting}
    >
      <div className="task-reminder-form p-4">
        <form onSubmit={handleSubmit}>
          {error && (
            <div className="error-message text-red-500 mb-4 p-2 bg-red-50 rounded-md">
              {error}
            </div>
          )}
          
          {/* 任务信息 */}
          <div className="task-info mb-4 p-3 bg-gray-50 rounded-md">
            <h3 className="text-md font-bold mb-1">任务</h3>
            <p className="text-gray-700">{taskTitle}</p>
          </div>
          
          {/* 提醒类型 */}
          <div className="reminder-type-selector mb-4">
            <h3 className="text-md font-bold mb-2">提醒类型</h3>
            <div className="flex gap-2">
              <button
                type="button"
                className={`flex-1 p-2 rounded-md ${
                  reminderType === 'scheduled' ? 'bg-jade-100 text-jade-800 border border-jade-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
                }`}
                onClick={() => setReminderType('scheduled')}
              >
                计划提醒
              </button>
              <button
                type="button"
                className={`flex-1 p-2 rounded-md ${
                  reminderType === 'custom' ? 'bg-jade-100 text-jade-800 border border-jade-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
                }`}
                onClick={() => setReminderType('custom')}
              >
                自定义提醒
              </button>
            </div>
          </div>
          
          {/* 提醒时间 */}
          <div className="reminder-time-selector mb-4">
            <h3 className="text-md font-bold mb-2">提醒时间</h3>
            <div className="grid grid-cols-2 gap-2">
              <div>
                <label htmlFor="reminderDate" className="block text-sm text-gray-700 mb-1">
                  日期
                </label>
                <input
                  type="date"
                  id="reminderDate"
                  value={reminderDate}
                  onChange={(e) => setReminderDate(e.target.value)}
                  className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
                  required
                />
              </div>
              <div>
                <label htmlFor="reminderTime" className="block text-sm text-gray-700 mb-1">
                  时间
                </label>
                <input
                  type="time"
                  id="reminderTime"
                  value={reminderTime}
                  onChange={(e) => setReminderTime(e.target.value)}
                  className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
                  required
                />
              </div>
            </div>
          </div>
          
          {/* 自定义消息 */}
          {reminderType === 'custom' && (
            <div className="custom-message-input mb-4">
              <h3 className="text-md font-bold mb-2">自定义消息</h3>
              <textarea
                value={customMessage}
                onChange={(e) => setCustomMessage(e.target.value)}
                className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500 h-24"
                placeholder="输入自定义提醒消息..."
                required={reminderType === 'custom'}
              />
            </div>
          )}
          
          {/* 提交按钮 */}
          <div className="form-actions flex justify-end gap-2 mt-4">
            <Button
              variant="secondary"
              type="button"
              onClick={onClose}
              disabled={isSubmitting}
            >
              取消
            </Button>
            <Button
              variant="jade"
              type="submit"
              disabled={isSubmitting}
            >
              {isSubmitting ? (
                <LoadingSpinner variant="white" size="small" />
              ) : (
                '创建提醒'
              )}
            </Button>
          </div>
        </form>
      </div>
    </ScrollDialog>
  );
};

export default TaskReminderForm;
</file>

<file path="src/components/task/TaskReminderNotification.tsx">
// src/components/task/TaskReminderNotification.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  TaskReminderRecord,
  getUnviewedReminders,
  markReminderAsViewed,
  markReminderAsCompleted
} from '@/services/taskReminderService';
import { getTask } from '@/services/taskService';
import Button from '@/components/common/Button';
import { playSound, SoundType } from '@/utils/sound';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import { useComponentLabels } from '@/hooks/useComponentLabels';

interface TaskReminderNotificationProps {
  onTaskClick?: (taskId: number) => void;
  onDismiss?: (reminder: TaskReminderRecord) => void;
}

/**
 * Task reminder notification component
 * Displays task reminders with a panda messenger theme
 */
const TaskReminderNotification: React.FC<TaskReminderNotificationProps> = ({
  onTaskClick,
  onDismiss
}) => {
  const [reminders, setReminders] = useState<TaskReminderRecord[]>([]);
  const [currentReminderIndex, setCurrentReminderIndex] = useState(0);
  const [isVisible, setIsVisible] = useState(false);
  const [taskTitles, setTaskTitles] = useState<Record<number, string>>({});
  const [isLoading, setIsLoading] = useState(false);

  // Get localized labels
  const { labels } = useComponentLabels();

  // 当前用户ID（在实际应用中，这应该从用户会话中获取）
  const userId = 'current-user';

  // 加载未查看的提醒
  const loadReminders = async () => {
    try {
      setIsLoading(true);
      const unviewedReminders = await getUnviewedReminders(userId);
      setReminders(unviewedReminders);

      // 如果有未查看的提醒，显示通知
      if (unviewedReminders.length > 0) {
        setIsVisible(true);

        // 加载任务标题
        const titles: Record<number, string> = {};
        for (const reminder of unviewedReminders) {
          const task = await getTask(reminder.taskId);
          if (task) {
            titles[reminder.taskId] = task.title;
          }
        }
        setTaskTitles(titles);

        // 播放通知音效
        playSound(SoundType.NOTIFICATION, 0.5);
      }
    } catch (err) {
      console.error('Failed to load task reminders:', err);
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadReminders();
  }, []);

  // 注册数据刷新监听
  useRegisterTableRefresh('taskReminders', loadReminders);

  // 处理查看任务
  const handleViewTask = async () => {
    if (reminders.length === 0) return;

    const currentReminder = reminders[currentReminderIndex];

    try {
      // 标记为已查看
      await markReminderAsViewed(currentReminder.id!);

      // 播放点击音效
      playSound(SoundType.BUTTON_CLICK, 0.5);

      // 隐藏通知
      setIsVisible(false);

      // 通知父组件
      if (onTaskClick) {
        setTimeout(() => {
          onTaskClick(currentReminder.taskId);
        }, 300); // 等待关闭动画完成
      }
    } catch (err) {
      console.error('Failed to mark reminder as viewed:', err);
    }
  };

  // 处理稍后提醒
  const handleRemindLater = async () => {
    if (reminders.length === 0) return;

    const currentReminder = reminders[currentReminderIndex];

    try {
      // 标记为已查看
      await markReminderAsViewed(currentReminder.id!);

      // 播放点击音效
      playSound(SoundType.BUTTON_CLICK, 0.3);

      // 移除当前提醒
      setReminders(prevReminders =>
        prevReminders.filter((_, index) => index !== currentReminderIndex)
      );

      // 重置索引
      setCurrentReminderIndex(0);

      // 如果没有更多提醒，隐藏通知
      if (reminders.length <= 1) {
        setIsVisible(false);
      }
    } catch (err) {
      console.error('Failed to mark reminder as viewed:', err);
    }
  };

  // 处理忽略
  const handleDismiss = async () => {
    if (reminders.length === 0) return;

    const currentReminder = reminders[currentReminderIndex];

    try {
      // 标记为已完成
      await markReminderAsCompleted(currentReminder.id!);

      // 播放点击音效
      playSound(SoundType.BUTTON_CLICK, 0.3);

      // 移除当前提醒
      setReminders(prevReminders =>
        prevReminders.filter((_, index) => index !== currentReminderIndex)
      );

      // 重置索引
      setCurrentReminderIndex(0);

      // 如果没有更多提醒，隐藏通知
      if (reminders.length <= 1) {
        setIsVisible(false);
      }

      // 通知父组件
      if (onDismiss) {
        onDismiss(currentReminder);
      }
    } catch (err) {
      console.error('Failed to mark reminder as completed:', err);
    }
  };

  // 如果没有提醒或不可见，不显示任何内容
  if (reminders.length === 0 || !isVisible) {
    return null;
  }

  const currentReminder = reminders[currentReminderIndex];
  const taskTitle = taskTitles[currentReminder.taskId] || labels.taskReminder.unknownTask;

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          className="task-reminder-notification fixed bottom-4 right-4 w-80 bg-white rounded-lg shadow-lg overflow-hidden border border-jade-200 z-50"
          initial={{ opacity: 0, y: 50, scale: 0.9 }}
          animate={{ opacity: 1, y: 0, scale: 1 }}
          exit={{ opacity: 0, y: 50, scale: 0.9 }}
          transition={{ duration: 0.3 }}
        >
          {/* 通知头部 */}
          <div className="notification-header bg-jade-50 p-3 border-b border-jade-200">
            <div className="flex items-center">
              <div className="panda-messenger mr-2">
                <span className="text-2xl">🐼📬</span>
              </div>
              <div className="flex-grow">
                <h3 className="text-md font-bold text-jade-800">{labels.taskReminder.title}</h3>
                <p className="text-xs text-jade-600">
                  {labels.taskReminder.subtitle}
                </p>
              </div>
              <div className="reminder-count">
                {reminders.length > 1 && (
                  <span className="text-xs bg-jade-100 text-jade-800 px-2 py-1 rounded-full">
                    {currentReminderIndex + 1}/{reminders.length}
                  </span>
                )}
              </div>
            </div>
          </div>

          {/* 通知内容 */}
          <div className="notification-content p-3">
            <div className="task-title font-bold mb-2">
              {taskTitle}
            </div>
            <p className="text-gray-700 mb-3">
              {currentReminder.message || labels.taskReminder.defaultMessage}
            </p>

            <div className="reminder-time text-xs text-gray-500 mb-3">
              {labels.taskReminder.reminderTimeLabel} {new Date(currentReminder.reminderTime).toLocaleString()}
            </div>

            <div className="notification-actions flex justify-end gap-2">
              <Button
                variant="secondary"
                size="small"
                onClick={handleDismiss}
              >
                {labels.taskReminder.dismissButton}
              </Button>
              <Button
                variant="secondary"
                size="small"
                onClick={handleRemindLater}
              >
                {labels.taskReminder.laterButton}
              </Button>
              <Button
                variant="jade"
                size="small"
                onClick={handleViewTask}
              >
                {labels.taskReminder.viewTaskButton}
              </Button>
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default TaskReminderNotification;
</file>

<file path="src/components/tasks/SubtaskList.tsx">
// src/components/tasks/SubtaskList.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { SubtaskRecord } from '@/services/subtaskService';
import { TaskStatus } from '@/services/taskService';
import { getSubtasks, updateSubtask, completeSubtask, deleteSubtask, createSubtask } from '@/services/subtaskService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';
import { updateSubtaskOrder } from '@/services/subtaskService';
import { playSound, SoundType } from '@/utils/sound';

interface SubtaskListProps {
  parentTaskId: number;
  onSubtasksChange?: (hasSubtasks: boolean) => void;
}

/**
 * 子任务列表组件
 * 用于显示和管理任务的子任务
 */
const SubtaskList: React.FC<SubtaskListProps> = ({ parentTaskId, onSubtasksChange }) => {
  const [subtasks, setSubtasks] = useState<SubtaskRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [newSubtaskTitle, setNewSubtaskTitle] = useState('');
  const [isAddingSubtask, setIsAddingSubtask] = useState(false);

  // 加载子任务
  const loadSubtasks = async () => {
    try {
      setIsLoading(true);
      setError(null);
      const loadedSubtasks = await getSubtasks(parentTaskId);
      setSubtasks(loadedSubtasks);
      
      // 通知父组件子任务状态变化
      if (onSubtasksChange) {
        onSubtasksChange(loadedSubtasks.length > 0);
      }
    } catch (err) {
      console.error('Failed to load subtasks:', err);
      setError('加载子任务失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadSubtasks();
  }, [parentTaskId]);

  // 注册数据刷新监听
  useRegisterTableRefresh('subtasks', loadSubtasks);

  // 处理添加子任务
  const handleAddSubtask = async () => {
    if (!newSubtaskTitle.trim()) return;

    try {
      setIsAddingSubtask(true);
      await createSubtask({
        parentTaskId,
        title: newSubtaskTitle.trim()
      });
      setNewSubtaskTitle('');
      playSound(SoundType.BUTTON_CLICK, 0.3);
      await loadSubtasks();
    } catch (err) {
      console.error('Failed to add subtask:', err);
      setError('添加子任务失败，请重试');
    } finally {
      setIsAddingSubtask(false);
    }
  };

  // 处理完成子任务
  const handleCompleteSubtask = async (subtaskId: number) => {
    try {
      await completeSubtask(subtaskId);
      playSound(SoundType.SUCCESS, 0.3);
      // 数据会通过刷新机制自动更新
    } catch (err) {
      console.error('Failed to complete subtask:', err);
      setError('完成子任务失败，请重试');
    }
  };

  // 处理删除子任务
  const handleDeleteSubtask = async (subtaskId: number) => {
    try {
      await deleteSubtask(subtaskId);
      playSound(SoundType.BUTTON_CLICK, 0.3);
      // 数据会通过刷新机制自动更新
    } catch (err) {
      console.error('Failed to delete subtask:', err);
      setError('删除子任务失败，请重试');
    }
  };

  // 处理拖放结束
  const handleDragEnd = async (result: any) => {
    if (!result.destination) return;

    const sourceIndex = result.source.index;
    const destinationIndex = result.destination.index;

    if (sourceIndex === destinationIndex) return;

    try {
      // 获取被拖动的子任务
      const draggedSubtask = subtasks[sourceIndex];
      
      // 更新子任务顺序
      await updateSubtaskOrder(draggedSubtask.id!, destinationIndex);
      
      // 重新加载子任务以获取最新顺序
      await loadSubtasks();
    } catch (err) {
      console.error('Failed to reorder subtasks:', err);
      setError('重新排序子任务失败，请重试');
    }
  };

  // 子任务项变体
  const subtaskVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 },
    exit: { opacity: 0, x: -20 }
  };

  if (isLoading && subtasks.length === 0) {
    return (
      <div className="subtask-list-loading flex justify-center items-center p-4">
        <LoadingSpinner variant="jade" size="small" />
      </div>
    );
  }

  return (
    <div className="subtask-list mt-4">
      <h3 className="text-lg font-bold mb-2">子任务</h3>
      
      {error && (
        <div className="error-message text-red-500 mb-2">{error}</div>
      )}
      
      <DragDropContext onDragEnd={handleDragEnd}>
        <Droppable droppableId="subtasks-list">
          {(provided) => (
            <div
              className="subtasks-container"
              {...provided.droppableProps}
              ref={provided.innerRef}
            >
              <AnimatePresence>
                {subtasks.map((subtask, index) => (
                  <Draggable
                    key={subtask.id}
                    draggableId={`subtask-${subtask.id}`}
                    index={index}
                    isDragDisabled={subtask.status === TaskStatus.COMPLETED}
                  >
                    {(provided, snapshot) => (
                      <motion.div
                        ref={provided.innerRef}
                        {...provided.draggableProps}
                        {...provided.dragHandleProps}
                        className={`subtask-item flex items-center p-2 mb-2 rounded-md border ${
                          subtask.status === TaskStatus.COMPLETED
                            ? 'border-gray-300 bg-gray-50'
                            : 'border-jade-300 bg-white'
                        } ${snapshot.isDragging ? 'shadow-md' : ''}`}
                        variants={subtaskVariants}
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        transition={{ duration: 0.2 }}
                      >
                        <div className="subtask-checkbox mr-2">
                          <input
                            type="checkbox"
                            checked={subtask.status === TaskStatus.COMPLETED}
                            onChange={() => {
                              if (subtask.status !== TaskStatus.COMPLETED) {
                                handleCompleteSubtask(subtask.id!);
                              }
                            }}
                            className="form-checkbox h-5 w-5 text-jade-500 rounded"
                          />
                        </div>
                        <div className="subtask-content flex-grow">
                          <p className={`subtask-title ${
                            subtask.status === TaskStatus.COMPLETED ? 'line-through text-gray-500' : 'text-gray-800'
                          }`}>
                            {subtask.title}
                          </p>
                        </div>
                        <div className="subtask-actions">
                          <button
                            onClick={() => handleDeleteSubtask(subtask.id!)}
                            className="text-red-500 hover:text-red-700"
                            aria-label="删除子任务"
                          >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                              <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" />
                            </svg>
                          </button>
                        </div>
                      </motion.div>
                    )}
                  </Draggable>
                ))}
                {provided.placeholder}
              </AnimatePresence>
            </div>
          )}
        </Droppable>
      </DragDropContext>
      
      <div className="add-subtask-form mt-4">
        <div className="flex">
          <input
            type="text"
            value={newSubtaskTitle}
            onChange={(e) => setNewSubtaskTitle(e.target.value)}
            placeholder="添加新子任务..."
            className="flex-grow p-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-2 focus:ring-jade-500"
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                handleAddSubtask();
              }
            }}
          />
          <Button
            variant="jade"
            onClick={handleAddSubtask}
            disabled={!newSubtaskTitle.trim() || isAddingSubtask}
            className="rounded-l-none"
          >
            {isAddingSubtask ? (
              <LoadingSpinner variant="white" size="small" />
            ) : (
              '添加'
            )}
          </Button>
        </div>
      </div>
    </div>
  );
};

export default SubtaskList;
</file>

<file path="src/context/LanguageProvider.tsx">
// src/context/LanguageProvider.tsx
import React, { createContext, useState, useContext, useEffect, ReactNode, useCallback } from "react";
import type { Language, LanguageContextType } from "@/types";

const DEFAULT_LANGUAGE: Language = "en";
const LOCAL_STORAGE_KEY = "app_lang_v3_final";

const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

export const LanguageProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [language, setLanguageState] = useState<Language>(() => {
    try {
      const saved = localStorage.getItem(LOCAL_STORAGE_KEY) as Language | null;
      return (saved === "en" || saved === "zh") ? saved : DEFAULT_LANGUAGE;
    } catch (e) { console.warn("localStorage access error for language", e); return DEFAULT_LANGUAGE; }
  });

  useEffect(() => {
    try {
      localStorage.setItem(LOCAL_STORAGE_KEY, language);
      document.documentElement.lang = language;
    } catch (e) { console.warn("localStorage write error for language", e); }
  }, [language]);

  const setLanguage = useCallback((lang: Language) => setLanguageState(lang), []);
  const value = { language, setLanguage };

  return <LanguageContext.Provider value={value}>{children}</LanguageContext.Provider>;
};

export const useLanguage = (): LanguageContextType => {
  const context = useContext(LanguageContext);
  if (!context) throw new Error("useLanguage must be used within LanguageProvider");
  return context;
};
</file>

<file path="src/context/PandaStateProvider.tsx">
// src/context/PandaStateProvider.tsx
import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';
import {
  getPandaState,
  updatePandaMood,
  updatePandaEnergy,
  addPandaExperience,
  resetPandaState,
  type PandaStateRecord
} from '@/services/pandaStateService';
import {
  initializePandaAbilities,
  checkAndUnlockAbilities,
  getAllPandaAbilities,
  getUnlockedPandaAbilities,
  activateAbility,
  type PandaAbilityRecord
} from '@/services/pandaAbilityService';
import { useDataRefreshContext } from '@/context/DataRefreshProvider';
import type { PandaMood, EnergyLevel } from '@/components/game/PandaAvatar';

// 熊猫状态上下文类型
interface PandaStateContextType {
  pandaState: PandaStateRecord | null;
  abilities: PandaAbilityRecord[];
  unlockedAbilities: PandaAbilityRecord[];
  isLoading: boolean;
  error: Error | null;
  setMood: (mood: PandaMood) => Promise<void>;
  setEnergy: (energy: EnergyLevel) => Promise<void>;
  addExperience: (amount: number) => Promise<void>;
  resetState: () => Promise<void>;
  refreshState: () => Promise<void>;
  activateAbility: (abilityId: number) => Promise<void>;
  checkNewAbilities: () => Promise<PandaAbilityRecord[]>;
}

// 创建上下文
const PandaStateContext = createContext<PandaStateContextType | undefined>(undefined);

// Provider组件属性
interface PandaStateProviderProps {
  children: ReactNode;
}

/**
 * 熊猫状态Provider组件
 * 提供熊猫状态管理功能
 */
export const PandaStateProvider: React.FC<PandaStateProviderProps> = ({ children }) => {
  const [pandaState, setPandaState] = useState<PandaStateRecord | null>(null);
  const [abilities, setAbilities] = useState<PandaAbilityRecord[]>([]);
  const [unlockedAbilities, setUnlockedAbilities] = useState<PandaAbilityRecord[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);
  const { registerRefreshListener } = useDataRefreshContext();

  // 初始加载熊猫状态和能力
  useEffect(() => {
    initializeSystem();
  }, []);

  // 初始化系统
  const initializeSystem = async () => {
    try {
      setIsLoading(true);

      // 加载熊猫状态
      try {
        await loadPandaState();
      } catch (stateErr) {
        console.error('Failed to load panda state:', stateErr);
      }

      // 加载熊猫能力
      try {
        await loadPandaAbilities();
      } catch (abilitiesErr) {
        console.error('Failed to load panda abilities:', abilitiesErr);
      }

      setError(null);
    } catch (err) {
      console.error('Failed to initialize panda system:', err);
      setError(err instanceof Error ? err : new Error('Failed to initialize panda system'));
    } finally {
      setIsLoading(false);
    }
  };

  // 定义状态更新处理函数
  const handleStateUpdate = useCallback((stateData: any) => {
    if (stateData) {
      setPandaState(prevState => {
        if (!prevState) return stateData;
        return {
          ...prevState,
          ...stateData
        };
      });
    }
  }, []);

  // 定义能力更新处理函数
  const handleAbilityUpdate = useCallback(async (abilityData: any) => {
    // 只有当有特定的能力数据时才更新，避免无限循环
    if (abilityData && abilityData.id) {
      try {
        // 更新单个能力而不是重新加载所有能力
        setAbilities(prevAbilities => {
          const index = prevAbilities.findIndex(a => a.id === abilityData.id);
          if (index >= 0) {
            const newAbilities = [...prevAbilities];
            newAbilities[index] = { ...newAbilities[index], ...abilityData };
            return newAbilities;
          }
          return [...prevAbilities, abilityData];
        });

        // 更新已解锁能力列表
        if (abilityData.isUnlocked) {
          setUnlockedAbilities(prevUnlocked => {
            const index = prevUnlocked.findIndex(a => a.id === abilityData.id);
            if (index >= 0) {
              const newUnlocked = [...prevUnlocked];
              newUnlocked[index] = { ...newUnlocked[index], ...abilityData };
              return newUnlocked;
            }
            return [...prevUnlocked, abilityData];
          });
        } else {
          // 如果能力被锁定，从已解锁列表中移除
          setUnlockedAbilities(prevUnlocked =>
            prevUnlocked.filter(a => a.id !== abilityData.id)
          );
        }
      } catch (err) {
        console.error('Failed to update ability:', err);
      }
    }
  }, []);

  // 使用 useEffect 注册监听器
  useEffect(() => {
    // 注册监听器
    const unregisterState = registerRefreshListener('pandaState', handleStateUpdate);
    const unregisterAbility = registerRefreshListener('abilities', handleAbilityUpdate);

    return () => {
      unregisterState();
      unregisterAbility();
    };
  }, [registerRefreshListener, handleStateUpdate, handleAbilityUpdate]);

  // 加载熊猫状态
  const loadPandaState = async () => {
    try {
      const state = await getPandaState();
      setPandaState(state);

      // 检查是否有新解锁的能力
      if (state) {
        await checkAndUnlockAbilities(state.level);
      }

      setError(null);
    } catch (err) {
      console.error('Failed to load panda state:', err);
      setError(err instanceof Error ? err : new Error('Failed to load panda state'));
    }
  };

  // 加载熊猫能力
  const loadPandaAbilities = async () => {
    try {
      // 初始化熊猫能力系统（只在第一次加载时初始化）
      await initializePandaAbilities();

      // 获取所有能力
      let allAbilities: PandaAbilityRecord[] = [];
      try {
        allAbilities = await getAllPandaAbilities();
      } catch (allErr) {
        console.error('Failed to get all abilities:', allErr);
        allAbilities = [];
      }

      // 安全地更新能力列表
      if (Array.isArray(allAbilities)) {
        // 只有当能力列表为空或长度不同时才更新状态
        if (abilities.length === 0 || abilities.length !== allAbilities.length) {
          setAbilities(allAbilities);
        }
      } else {
        console.error('getAllPandaAbilities did not return an array:', allAbilities);
        if (abilities.length === 0) {
          setAbilities([]);
        }
      }

      // 获取已解锁的能力
      let unlocked: PandaAbilityRecord[] = [];
      try {
        unlocked = await getUnlockedPandaAbilities();
      } catch (unlockErr) {
        console.error('Failed to load unlocked abilities:', unlockErr);
        unlocked = [];
      }

      // 安全地更新已解锁能力列表
      if (Array.isArray(unlocked)) {
        // 只有当解锁能力列表为空或长度不同时才更新状态
        if (unlockedAbilities.length === 0 || unlockedAbilities.length !== unlocked.length) {
          setUnlockedAbilities(unlocked);
        }
      } else {
        console.error('getUnlockedPandaAbilities did not return an array:', unlocked);
        if (unlockedAbilities.length === 0) {
          setUnlockedAbilities([]);
        }
      }

      setError(null);
    } catch (err) {
      console.error('Failed to load panda abilities:', err);
      setError(err instanceof Error ? err : new Error('Failed to load panda abilities'));
      // 设置默认空数组，防止UI错误
      if (abilities.length === 0) {
        setAbilities([]);
      }
      if (unlockedAbilities.length === 0) {
        setUnlockedAbilities([]);
      }
    }
  };

  // 设置熊猫情绪
  const setMood = async (mood: PandaMood) => {
    try {
      setIsLoading(true);
      const updatedState = await updatePandaMood(mood);
      setPandaState(updatedState);
    } catch (err) {
      console.error('Failed to update panda mood:', err);
      setError(err instanceof Error ? err : new Error('Failed to update panda mood'));
    } finally {
      setIsLoading(false);
    }
  };

  // 设置熊猫能量
  const setEnergy = async (energy: EnergyLevel) => {
    try {
      setIsLoading(true);
      const updatedState = await updatePandaEnergy(energy);
      setPandaState(updatedState);
    } catch (err) {
      console.error('Failed to update panda energy:', err);
      setError(err instanceof Error ? err : new Error('Failed to update panda energy'));
    } finally {
      setIsLoading(false);
    }
  };

  // 增加熊猫经验
  const addExperience = async (amount: number) => {
    try {
      setIsLoading(true);
      const updatedState = await addPandaExperience(amount);
      setPandaState(updatedState);

      // 检查是否有新解锁的能力
      if (updatedState) {
        await checkAndUnlockAbilities(updatedState.level);
        await loadPandaAbilities(); // 重新加载能力以更新状态
      }
    } catch (err) {
      console.error('Failed to add panda experience:', err);
      setError(err instanceof Error ? err : new Error('Failed to add panda experience'));
    } finally {
      setIsLoading(false);
    }
  };

  // 激活熊猫能力
  const handleActivateAbility = async (abilityId: number) => {
    try {
      setIsLoading(true);
      await activateAbility(abilityId);
      await loadPandaAbilities(); // 重新加载能力以更新状态
      setError(null);
    } catch (err) {
      console.error('Failed to activate ability:', err);
      setError(err instanceof Error ? err : new Error('Failed to activate ability'));
    } finally {
      setIsLoading(false);
    }
  };

  // 检查新解锁的能力
  const checkNewAbilities = async (): Promise<PandaAbilityRecord[]> => {
    try {
      if (!pandaState) {
        return [];
      }

      const newlyUnlocked = await checkAndUnlockAbilities(pandaState.level);
      await loadPandaAbilities(); // 重新加载能力以更新状态

      return newlyUnlocked;
    } catch (err) {
      console.error('Failed to check new abilities:', err);
      setError(err instanceof Error ? err : new Error('Failed to check new abilities'));
      return [];
    }
  };

  // 重置熊猫状态
  const resetState = async () => {
    try {
      setIsLoading(true);
      const resetedState = await resetPandaState();
      setPandaState(resetedState);
    } catch (err) {
      console.error('Failed to reset panda state:', err);
      setError(err instanceof Error ? err : new Error('Failed to reset panda state'));
    } finally {
      setIsLoading(false);
    }
  };

  // 刷新熊猫状态
  const refreshState = async () => {
    await loadPandaState();
  };

  // 提供上下文值
  const contextValue: PandaStateContextType = {
    pandaState,
    abilities,
    unlockedAbilities,
    isLoading,
    error,
    setMood,
    setEnergy,
    addExperience,
    resetState,
    refreshState,
    activateAbility: handleActivateAbility,
    checkNewAbilities
  };

  return (
    <PandaStateContext.Provider value={contextValue}>
      {children}
    </PandaStateContext.Provider>
  );
};

/**
 * 使用熊猫状态的Hook
 * @returns 熊猫状态上下文
 */
export const usePandaState = (): PandaStateContextType => {
  const context = useContext(PandaStateContext);
  if (context === undefined) {
    throw new Error('usePandaState must be used within a PandaStateProvider');
  }
  return context;
};
</file>

<file path="src/db-turso.ts">
// src/db-turso.ts
import { createClient } from '@libsql/client';

// 创建Turso客户端
export const tursoClient = createClient({
  url: process.env.TURSO_DATABASE_URL || 'libsql://your-database-url.turso.io',
  authToken: process.env.TURSO_AUTH_TOKEN || 'your-auth-token',
});

// 初始化数据库模式
export async function initializeSchema() {
  try {
    console.log('Initializing Turso database schema...');
    
    // 创建uiLabels表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS ui_labels (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        scope_key TEXT NOT NULL,
        label_key TEXT NOT NULL,
        language_code TEXT NOT NULL,
        translated_text TEXT NOT NULL,
        UNIQUE(scope_key, label_key, language_code)
      )
    `);
    
    // 创建panda_state表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS panda_state (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        mood TEXT NOT NULL,
        energy TEXT NOT NULL,
        last_updated TEXT NOT NULL,
        level INTEGER NOT NULL,
        experience INTEGER NOT NULL DEFAULT 0
      )
    `);
    
    // 创建task_categories表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS task_categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        color TEXT NOT NULL,
        icon TEXT,
        is_default INTEGER NOT NULL DEFAULT 0
      )
    `);
    
    // 创建tasks表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS tasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        category_id INTEGER,
        priority TEXT NOT NULL,
        status TEXT NOT NULL,
        due_date TEXT,
        created_at TEXT NOT NULL,
        FOREIGN KEY (category_id) REFERENCES task_categories(id)
      )
    `);
    
    // 创建subtasks表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS subtasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        parent_task_id INTEGER NOT NULL,
        title TEXT NOT NULL,
        status TEXT NOT NULL,
        order_index INTEGER NOT NULL,
        created_at TEXT NOT NULL,
        FOREIGN KEY (parent_task_id) REFERENCES tasks(id) ON DELETE CASCADE
      )
    `);
    
    // 创建task_completions表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS task_completions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        task_id INTEGER NOT NULL,
        completed_at TEXT NOT NULL,
        experience_gained INTEGER NOT NULL,
        FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
      )
    `);
    
    // 创建task_reminders表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS task_reminders (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        task_id INTEGER NOT NULL,
        user_id TEXT NOT NULL,
        reminder_time TEXT NOT NULL,
        is_viewed INTEGER NOT NULL DEFAULT 0,
        is_completed INTEGER NOT NULL DEFAULT 0,
        created_at TEXT NOT NULL,
        FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
      )
    `);
    
    // 创建rewards表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS rewards (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        type TEXT NOT NULL,
        rarity TEXT NOT NULL,
        task_id INTEGER,
        obtained_at TEXT NOT NULL,
        is_viewed INTEGER NOT NULL DEFAULT 0,
        FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE SET NULL
      )
    `);
    
    // 创建items表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        type TEXT NOT NULL,
        rarity TEXT NOT NULL,
        quantity INTEGER NOT NULL DEFAULT 1,
        obtained_at TEXT NOT NULL
      )
    `);
    
    // 创建badges表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS badges (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        rarity TEXT NOT NULL,
        obtained_at TEXT NOT NULL,
        is_equipped INTEGER NOT NULL DEFAULT 0
      )
    `);
    
    // 创建abilities表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS abilities (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        type TEXT NOT NULL,
        effect_type TEXT NOT NULL,
        required_level INTEGER NOT NULL,
        is_unlocked INTEGER NOT NULL DEFAULT 0,
        is_active INTEGER NOT NULL DEFAULT 0
      )
    `);
    
    // 创建reward_abilities表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS reward_abilities (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        rarity TEXT NOT NULL,
        obtained_at TEXT NOT NULL,
        is_unlocked INTEGER NOT NULL DEFAULT 0,
        is_active INTEGER NOT NULL DEFAULT 0
      )
    `);
    
    // 创建panda_accessories表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS panda_accessories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        type TEXT NOT NULL,
        description TEXT,
        image_path TEXT NOT NULL,
        overlay_path TEXT,
        is_equipped INTEGER NOT NULL DEFAULT 0,
        is_owned INTEGER NOT NULL DEFAULT 0,
        obtained_at TEXT,
        store_item_id INTEGER,
        rarity TEXT NOT NULL,
        theme_type TEXT NOT NULL
      )
    `);
    
    // 创建panda_environments表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS panda_environments (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        description TEXT,
        background_path TEXT NOT NULL,
        foreground_path TEXT,
        ambient_sound TEXT,
        is_active INTEGER NOT NULL DEFAULT 0,
        is_owned INTEGER NOT NULL DEFAULT 0,
        obtained_at TEXT,
        store_item_id INTEGER,
        rarity TEXT NOT NULL,
        theme_type TEXT NOT NULL,
        interactive_elements TEXT
      )
    `);
    
    // 创建challenges表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS challenges (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        type TEXT NOT NULL,
        difficulty TEXT NOT NULL,
        status TEXT NOT NULL,
        progress REAL NOT NULL DEFAULT 0,
        start_date TEXT,
        end_date TEXT,
        created_at TEXT NOT NULL
      )
    `);
    
    // 创建challenge_categories表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS challenge_categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        description TEXT,
        icon_path TEXT
      )
    `);
    
    // 创建challenge_completions表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS challenge_completions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        challenge_id INTEGER NOT NULL,
        user_id TEXT NOT NULL,
        completed_date TEXT NOT NULL,
        created_at TEXT NOT NULL,
        FOREIGN KEY (challenge_id) REFERENCES challenges(id) ON DELETE CASCADE
      )
    `);
    
    // 创建challenge_discoveries表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS challenge_discoveries (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        challenge_id INTEGER NOT NULL,
        discovered_at TEXT NOT NULL,
        is_viewed INTEGER NOT NULL DEFAULT 0,
        is_accepted INTEGER NOT NULL DEFAULT 0,
        expires_at TEXT,
        FOREIGN KEY (challenge_id) REFERENCES challenges(id) ON DELETE CASCADE
      )
    `);
    
    // 创建reflections表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS reflections (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        task_id INTEGER,
        mood TEXT NOT NULL,
        reflection TEXT,
        action TEXT,
        created_at TEXT NOT NULL,
        is_completed INTEGER NOT NULL DEFAULT 0,
        FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE SET NULL
      )
    `);
    
    // 创建reflection_triggers表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS reflection_triggers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        type TEXT NOT NULL,
        created_at TEXT NOT NULL,
        is_viewed INTEGER NOT NULL DEFAULT 0,
        is_completed INTEGER NOT NULL DEFAULT 0
      )
    `);
    
    // 创建moods表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS moods (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        mood TEXT NOT NULL,
        intensity INTEGER NOT NULL,
        created_at TEXT NOT NULL
      )
    `);
    
    // 创建store_categories表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS store_categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        order_index INTEGER NOT NULL,
        is_visible INTEGER NOT NULL DEFAULT 1,
        created_at TEXT NOT NULL
      )
    `);
    
    // 创建store_items表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS store_items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        type TEXT NOT NULL,
        rarity TEXT NOT NULL,
        price REAL NOT NULL,
        price_type TEXT NOT NULL,
        is_available INTEGER NOT NULL DEFAULT 1,
        is_featured INTEGER NOT NULL DEFAULT 0,
        is_on_sale INTEGER NOT NULL DEFAULT 0,
        sale_price REAL,
        sale_end_date TEXT,
        category_id INTEGER,
        created_at TEXT NOT NULL,
        FOREIGN KEY (category_id) REFERENCES store_categories(id) ON DELETE SET NULL
      )
    `);
    
    // 创建purchases表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS purchases (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        store_item_id INTEGER NOT NULL,
        price REAL NOT NULL,
        price_type TEXT NOT NULL,
        purchase_date TEXT NOT NULL,
        is_refunded INTEGER NOT NULL DEFAULT 0,
        FOREIGN KEY (store_item_id) REFERENCES store_items(id) ON DELETE CASCADE
      )
    `);
    
    // 创建vip_subscriptions表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS vip_subscriptions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        tier INTEGER NOT NULL,
        start_date TEXT NOT NULL,
        end_date TEXT NOT NULL,
        is_active INTEGER NOT NULL DEFAULT 1,
        created_at TEXT NOT NULL
      )
    `);
    
    // 创建user_currencies表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS user_currencies (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        coins INTEGER NOT NULL DEFAULT 0,
        jade INTEGER NOT NULL DEFAULT 0,
        last_updated TEXT NOT NULL
      )
    `);
    
    // 创建timely_rewards表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS timely_rewards (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        type TEXT NOT NULL,
        status TEXT NOT NULL,
        start_time TEXT NOT NULL,
        end_time TEXT NOT NULL,
        created_at TEXT NOT NULL
      )
    `);
    
    // 创建lucky_points表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS lucky_points (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        amount INTEGER NOT NULL,
        is_spent INTEGER NOT NULL DEFAULT 0,
        expiry_date TEXT,
        created_at TEXT NOT NULL
      )
    `);
    
    // 创建lucky_draws表
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS lucky_draws (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        points_spent INTEGER NOT NULL,
        timestamp TEXT NOT NULL,
        created_at TEXT NOT NULL
      )
    `);
    
    console.log('Turso database schema initialized successfully.');
  } catch (error) {
    console.error('Error initializing Turso database schema:', error);
    throw error;
  }
}
</file>

<file path="src/features/home/MoodsSection.tsx">
// src/features/home/MoodsSection.tsx
import React from 'react';
import type { HomeMoodsSectionLabels, MoodItem } from '@/types';
import Button from '@/components/common/Button';

interface MoodsSectionProps {
  labels: HomeMoodsSectionLabels | undefined;
  moods: readonly MoodItem[] | undefined; // Made readonly in type
  onRefresh: () => void;
  isFetching?: boolean;
}

const MoodsSection: React.FC<MoodsSectionProps> = ({ labels, moods, onRefresh, isFetching }) => {
  if (!labels) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Loading moods section...</p>;
  }

  return (
    <section className="page-content" style={{marginTop: '20px'}}> {/* Use class for styling */}
      <h4>{labels.sectionTitle}</h4> {/* Use h4 for sections within a page normally */}
      {moods && moods.length > 0 ? (
        <ul>
          {moods.map(mood => (
            <li key={mood.id}>{mood.name}: <strong>{mood.feeling}</strong></li>
          ))}
        </ul>
      ) : (
        <p>{labels.noMoodsMessage}</p>
      )}
      <Button onClick={onRefresh} isLoading={isFetching} loadingText="Refreshing...">
        {labels.refreshButtonText}
      </Button>
    </section>
  );
};
export default MoodsSection;
</file>

<file path="src/features/home/WelcomeSection.tsx">
// src/features/home/WelcomeSection.tsx
import React from 'react';
import type { HomeWelcomeSectionLabels } from '@/types';

interface WelcomeSectionProps {
  labels: HomeWelcomeSectionLabels | undefined;
  username: string | undefined;
}

const WelcomeSection: React.FC<WelcomeSectionProps> = ({ labels, username }) => {
  if (!labels || username === undefined) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Initializing welcome message...</p>;
  }
  const welcomeText = labels.welcomeMessage.replace('{user}', username);
  return <p>{welcomeText}</p>;
};
export default WelcomeSection;
</file>

<file path="src/features/settings/LanguageSettingsSection.tsx">
// src/features/settings/LanguageSettingsSection.tsx
import React, { useState, useEffect } from 'react';
import { useLanguage } from '@/context/LanguageProvider';
import type { Language, SettingsLanguageSectionLabels } from '@/types';
import Button from '@/components/common/Button';

interface LanguageSettingsSectionProps {
  labels: SettingsLanguageSectionLabels | undefined;
  isUpdatingPage?: boolean; // Indicates if the parent page is fetching new labels
}

const LanguageSettingsSection: React.FC<LanguageSettingsSectionProps> = ({ labels, isUpdatingPage }) => {
  const { language, setLanguage } = useLanguage();
  const [selectedLocalLang, setSelectedLocalLang] = useState<Language>(language);
  const [showSuccess, setShowSuccess] = useState(false);

  useEffect(() => {
    setSelectedLocalLang(language); // Sync with global changes
    if (showSuccess) setShowSuccess(false); // Hide success if global lang changes elsewhere
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [language]); // Only re-sync local if global language changes

  if (!labels) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Loading language settings...</p>;
  }

  const handleSave = () => {
    if (selectedLocalLang !== language) {
      setLanguage(selectedLocalLang); // This will trigger page label refetch
      setShowSuccess(true);
      setTimeout(() => setShowSuccess(false), 2500);
    }
  };

  const currentLangDisplay = labels.currentLanguageIs.replace('{lang}', language.toUpperCase());

  return (
    <section className="task-item"> {/* Apply task-item style for a game-themed look */}
      <h4>{labels.sectionTitle}</h4>
      <p>{currentLangDisplay}</p>
      <div>
        <label htmlFor="lang-select-component" style={{ marginRight: '8px' }}>{labels.selectLanguagePrompt}</label>
        <select
          id="lang-select-component"
          value={selectedLocalLang}
          onChange={e => {
            setSelectedLocalLang(e.target.value as Language);
            if (showSuccess) setShowSuccess(false);
          }}
          disabled={isUpdatingPage}
        >
          <option value="en">{labels.langNameEn}</option>
          <option value="zh">{labels.langNameZh}</option>
        </select>
      </div>
      <Button
        onClick={handleSave}
        disabled={isUpdatingPage || selectedLocalLang === language}
        style={{marginTop: '15px'}}
        variant="jade" // Use jade button style
      >
        {labels.saveButtonText}
      </Button>
      {showSuccess && (
        <p style={{
          color: 'var(--ruyi-green)',
          marginTop: '10px',
          fontStyle:'italic',
          background: 'rgba(46, 139, 87, 0.1)',
          padding: '8px',
          borderRadius: 'var(--radius-sm)'
        }}>
          {labels.successMessage}
        </p>
      )}
    </section>
  );
};
export default LanguageSettingsSection;
</file>

<file path="src/hooks/useInternationalizedQuery.ts">
// src/hooks/useInternationalizedQuery.ts
import {
  useQuery,
  type UseQueryOptions,
  type QueryKey,
  type UseQueryResult,
} from '@tanstack/react-query';
import type { ApiError, LocalizedContent } from '@/types';

interface UseInternationalizedQueryResult<TDataPayload, TLabelsBundle, TErrorResponse> {
  data: TDataPayload | undefined | null; // Data can be TDataPayload OR null
  labels: TLabelsBundle | undefined;
  isPending: boolean;
  isLoading: boolean;
  isFetching: boolean;
  isError: boolean;
  error: TErrorResponse | null;
  refetch: UseQueryResult<LocalizedContent<TDataPayload, TLabelsBundle>, TErrorResponse>['refetch'];
  status: UseQueryResult<LocalizedContent<TDataPayload, TLabelsBundle>, TErrorResponse>['status'];
  isSuccess: boolean;
}

export function useInternationalizedQuery<
  TLocalizedContent extends LocalizedContent<TDataPayload, TLabelsBundle>,
  TErrorResponse extends Error = ApiError,
  TDataPayload = TLocalizedContent['data'],
  TLabelsBundle = TLocalizedContent['labels'],
  TQueryKey extends QueryKey = QueryKey
>(
  options: UseQueryOptions<TLocalizedContent, TErrorResponse, TLocalizedContent, TQueryKey>
): UseInternationalizedQueryResult<TDataPayload, TLabelsBundle, TErrorResponse> {
  const {
    data: queryResult,
    isPending,
    isLoading,
    isFetching,
    isError,
    error,
    refetch,
    status,
    isSuccess,
  } = useQuery<TLocalizedContent, TErrorResponse, TLocalizedContent, TQueryKey>(options);

  return {
    data: queryResult?.data, // queryResult can be undefined during initial fetch
    labels: queryResult?.labels,
    isPending,
    isLoading,
    isFetching,
    isError,
    error,
    refetch,
    status,
    isSuccess,
  };
}
</file>

<file path="src/hooks/useLocalizedView.ts">
// src/hooks/useLocalizedView.ts
import { useLanguage } from '@/context/LanguageProvider';
import { useInternationalizedQuery } from './useInternationalizedQuery';
import type { ApiError, Language, LocalizedContent } from '@/types';
import { QueryKey, UseQueryOptions } from '@tanstack/react-query';

export function useLocalizedView<
  TDataPayload,
  TLabelsBundle
>(
  viewQueryKey: string | QueryKey,
  fetchViewFn: (lang: Language) => Promise<LocalizedContent<TDataPayload, TLabelsBundle>>,
  options?: Omit<UseQueryOptions<LocalizedContent<TDataPayload, TLabelsBundle>, ApiError, LocalizedContent<TDataPayload, TLabelsBundle>, QueryKey>, 'queryKey' | 'queryFn'>
) {
  const { language } = useLanguage();
  const fullQueryKeyWithLang: QueryKey = Array.isArray(viewQueryKey)
    ? [...viewQueryKey, language]
    : [viewQueryKey, language];

  return useInternationalizedQuery<
    LocalizedContent<TDataPayload, TLabelsBundle>,
    ApiError,
    TDataPayload,
    TLabelsBundle
  >({
    queryKey: fullQueryKeyWithLang,
    queryFn: () => fetchViewFn(language),
    enabled: !!language && (options?.enabled === undefined || options.enabled),
    ...options,
  });
}
</file>

<file path="src/main.tsx">
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';
import './index.css'; // Base styles
import './game-theme.css'; // Game-themed styles

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path="src/pages/StorePage.tsx">
// src/pages/StorePage.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  StoreCategoryRecord,
  StoreItemRecord,
  VipSubscriptionRecord,
  UserCurrencyRecord,
  getStoreCategories,
  getCategoryItems,
  getFeaturedItems,
  getSaleItems,
  getUserCurrency,
  getUserVipSubscription,
  isUserVip
} from '@/services/storeService';
import StoreCategoryList from '@/components/store/StoreCategoryList';
import StoreItemCard from '@/components/store/StoreItemCard';
import StoreItemPreview from '@/components/store/StoreItemPreview';
import VipSubscriptionCard from '@/components/store/VipSubscriptionCard';
import CurrencyDisplay from '@/components/store/CurrencyDisplay';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { playSound, SoundType } from '@/utils/sound';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import { pageTransition } from '@/utils/animation';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchStorePageView } from '@/services';
import type { StorePageViewLabelsBundle } from '@/types';

/**
 * 商店页面
 * 用于显示和购买商店物品
 */
const StorePage: React.FC = () => {
  const [categories, setCategories] = useState<StoreCategoryRecord[]>([]);
  const [selectedCategory, setSelectedCategory] = useState<StoreCategoryRecord | null>(null);
  const [items, setItems] = useState<StoreItemRecord[]>([]);
  const [featuredItems, setFeaturedItems] = useState<StoreItemRecord[]>([]);
  const [saleItems, setSaleItems] = useState<StoreItemRecord[]>([]);
  const [selectedItem, setSelectedItem] = useState<StoreItemRecord | null>(null);
  const [showItemPreview, setShowItemPreview] = useState(false);
  const [showVipSection, setShowVipSection] = useState(false);
  const [userCurrency, setUserCurrency] = useState<UserCurrencyRecord | null>(null);
  const [vipSubscription, setVipSubscription] = useState<VipSubscriptionRecord | null>(null);
  const [isVip, setIsVip] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // 获取本地化标签
  const {
    labels: pageLabels,
    isPending: isLabelsPending,
    isError: isLabelsError,
    error: labelsError,
    refetch: refetchLabels
  } = useLocalizedView<null, StorePageViewLabelsBundle>(
    'storePageViewContent',
    fetchStorePageView
  );

  // 当前用户ID（在实际应用中，这应该从用户会话中获取）
  const userId = 'current-user';

  // 加载商店数据
  const loadStoreData = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // 获取商店类别
      const storeCategories = await getStoreCategories();
      setCategories(storeCategories);

      // 如果有类别，选择第一个
      if (storeCategories.length > 0) {
        setSelectedCategory(storeCategories[0]);

        // 获取该类别的物品
        const categoryItems = await getCategoryItems(storeCategories[0].id!);
        setItems(categoryItems);
      }

      // 获取特色物品
      const featured = await getFeaturedItems();
      setFeaturedItems(featured);

      // 获取促销物品
      const sale = await getSaleItems();
      setSaleItems(sale);

      // 获取用户货币
      const currency = await getUserCurrency(userId);
      setUserCurrency(currency);

      // 获取用户VIP订阅
      const subscription = await getUserVipSubscription(userId);
      setVipSubscription(subscription);

      // 检查用户是否是VIP
      const userIsVip = await isUserVip(userId);
      setIsVip(userIsVip);
    } catch (err) {
      console.error('Failed to load store data:', err);
      setError('加载商店数据失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadStoreData();
  }, []);

  // 注册数据刷新监听
  useRegisterTableRefresh('storeCategories', loadStoreData);
  useRegisterTableRefresh('storeItems', loadStoreData);
  useRegisterTableRefresh('userCurrencies', loadStoreData);
  useRegisterTableRefresh('vipSubscriptions', loadStoreData);

  // 处理选择类别
  const handleCategorySelect = async (category: StoreCategoryRecord) => {
    setSelectedCategory(category);

    try {
      // 获取该类别的物品
      const categoryItems = await getCategoryItems(category.id!);
      setItems(categoryItems);
    } catch (err) {
      console.error('Failed to load category items:', err);
      setError('加载类别物品失败，请重试');
    }
  };

  // 处理预览物品
  const handlePreviewItem = (item: StoreItemRecord) => {
    setSelectedItem(item);
    setShowItemPreview(true);
  };

  // 处理购买物品
  const handlePurchaseItem = async () => {
    // 重新加载数据
    await loadStoreData();
  };

  // 处理订阅VIP
  const handleSubscribeVip = async () => {
    // 重新加载数据
    await loadStoreData();
  };

  // 处理切换VIP部分
  const handleToggleVipSection = () => {
    // 播放点击音效
    playSound(SoundType.BUTTON_CLICK, 0.3);

    setShowVipSection(!showVipSection);
  };

  // 容器变体
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // 项目变体
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  // VIP订阅选项
  const vipOptions = [
    {
      tier: 1,
      title: '基础VIP',
      description: '解锁基础VIP特权，享受更多游戏乐趣',
      price: 18,
      duration: 30,
      benefits: [
        '解锁VIP专属物品',
        '每日额外10金币',
        '商店9折优惠'
      ],
      imagePath: '/assets/store/vip-basic.png'
    },
    {
      tier: 2,
      title: '高级VIP',
      description: '解锁高级VIP特权，享受更多游戏乐趣',
      price: 38,
      duration: 30,
      benefits: [
        '包含基础VIP所有特权',
        '每日额外20金币',
        '每周赠送1玉石',
        '商店8折优惠'
      ],
      imagePath: '/assets/store/vip-premium.png'
    },
    {
      tier: 3,
      title: '豪华VIP',
      description: '解锁豪华VIP特权，享受最佳游戏体验',
      price: 68,
      duration: 30,
      benefits: [
        '包含高级VIP所有特权',
        '每日额外30金币',
        '每周赠送3玉石',
        '商店7折优惠',
        '专属熊猫头像和背景'
      ],
      imagePath: '/assets/store/vip-deluxe.png'
    }
  ];

  // 显示加载状态
  if (isLabelsPending && !pageLabels) {
    return (
      <motion.div
        className="page-container"
        variants={pageTransition}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <div className="loading-container flex justify-center items-center h-64">
          <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "加载商店内容..."} />
        </div>
      </motion.div>
    );
  }

  // 显示错误状态
  if (isLabelsError && !pageLabels) {
    return (
      <motion.div
        className="page-container"
        variants={pageTransition}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <div className="error-container text-center p-4">
          <ErrorDisplay
            error={labelsError}
            title={pageLabels?.errorTitle || "商店页面错误"}
            onRetry={refetchLabels}
          />
        </div>
      </motion.div>
    );
  }

  return (
    <motion.div
      className="page-container"
      variants={pageTransition}
      initial="hidden"
      animate="visible"
      exit="exit"
    >
      <div className="bamboo-frame">
        <h2>{pageLabels?.pageTitle || "商店"}</h2>

        {isLoading ? (
          <div className="loading-container flex justify-center items-center h-64">
            <LoadingSpinner variant="jade" size="large" />
          </div>
        ) : error ? (
          <div className="error-container text-center p-4">
            <div className="error-message text-red-500 mb-4">{error}</div>
            <Button variant="jade" onClick={loadStoreData}>
              {pageLabels?.retryButtonText || "重试"}
            </Button>
          </div>
        ) : (
          <div className="store-content">
            {/* 用户货币显示和VIP切换 */}
            <div className="store-header-section mb-6 flex flex-col md:flex-row justify-between items-center gap-4">
              {userCurrency && (
                <div className="currency-section flex-grow">
                  <CurrencyDisplay
                    currency={userCurrency}
                    isVip={isVip}
                    labels={pageLabels?.currencySection}
                  />
                </div>
              )}

              {/* VIP切换按钮 */}
              <div className="vip-toggle-section">
                <Button
                  variant={showVipSection ? 'gold' : 'secondary'}
                  onClick={handleToggleVipSection}
                  className="px-6 py-2"
                >
                  {showVipSection
                    ? (pageLabels?.vipToggleButton?.backToStore || 'Return to Store')
                    : (pageLabels?.vipToggleButton?.showVip || 'View VIP Membership')}
                </Button>
              </div>
            </div>

            <AnimatePresence mode="wait">
              {showVipSection ? (
                <motion.div
                  key="vip-section"
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -20 }}
                  transition={{ duration: 0.3 }}
                  className="vip-section"
                >
                  <div className="vip-header mb-6 text-center">
                    <h3 className="text-xl font-bold text-amber-700">
                      <span className="mr-2">✨</span>
                      {pageLabels?.vipToggleButton?.showVip || 'VIP Membership'}
                      <span className="ml-2">✨</span>
                    </h3>
                    <p className="text-gray-600 mt-2">
                      {pageLabels?.vipSection?.description || 'Unlock exclusive benefits and enhance your experience'}
                    </p>
                  </div>

                  <div className="vip-options-grid grid grid-cols-1 md:grid-cols-3 gap-6">
                    {vipOptions.map((option) => (
                      <VipSubscriptionCard
                        key={option.tier}
                        tier={option.tier}
                        title={option.title}
                        description={option.description}
                        price={option.price}
                        duration={option.duration}
                        benefits={option.benefits}
                        imagePath={option.imagePath}
                        currentSubscription={vipSubscription}
                        onSubscribe={handleSubscribeVip}
                      />
                    ))}
                  </div>
                </motion.div>
              ) : (
                <motion.div
                  key="store-section"
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -20 }}
                  transition={{ duration: 0.3 }}
                  className="store-section"
                >
                  {/* 商店类别 */}
                  {categories.length > 0 && (
                    <div className="categories-section mb-6 bg-white p-3 rounded-lg shadow-sm border border-jade-200">
                      <h3 className="text-lg font-bold mb-3 text-jade-700">
                        <span className="mr-2">🏪</span>
                        {pageLabels?.categoriesTitle || 'Categories'}
                      </h3>
                      <StoreCategoryList
                        onCategorySelect={handleCategorySelect}
                        selectedCategoryId={selectedCategory?.id}
                      />
                    </div>
                  )}

                  {/* 特色物品 */}
                  {featuredItems.length > 0 && (
                    <div className="featured-items-section mb-8">
                      <div className="section-header flex items-center mb-4 border-b-2 border-amber-300 pb-2">
                        <span className="text-2xl mr-2">✨</span>
                        <h3 className="text-xl font-bold text-amber-700">{pageLabels?.featuredItemsTitle || 'Featured Items'}</h3>
                      </div>
                      <motion.div
                        className="featured-items-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
                        variants={containerVariants}
                        initial="hidden"
                        animate="visible"
                      >
                        {featuredItems.map((item) => (
                          <motion.div
                            key={item.id}
                            variants={itemVariants}
                          >
                            <StoreItemCard
                              item={item}
                              onPurchase={handlePurchaseItem}
                              onPreview={handlePreviewItem}
                              userCoins={userCurrency?.coins}
                              userJade={userCurrency?.jade}
                              isVip={isVip}
                            />
                          </motion.div>
                        ))}
                      </motion.div>
                    </div>
                  )}

                  {/* 促销物品 */}
                  {saleItems.length > 0 && (
                    <div className="sale-items-section mb-8">
                      <div className="section-header flex items-center mb-4 border-b-2 border-cinnabar-red pb-2">
                        <span className="text-2xl mr-2">🔥</span>
                        <h3 className="text-xl font-bold text-cinnabar-red">{pageLabels?.saleItemsTitle || 'Sale Items'}</h3>
                      </div>
                      <motion.div
                        className="sale-items-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
                        variants={containerVariants}
                        initial="hidden"
                        animate="visible"
                      >
                        {saleItems.map((item) => (
                          <motion.div
                            key={item.id}
                            variants={itemVariants}
                          >
                            <StoreItemCard
                              item={item}
                              onPurchase={handlePurchaseItem}
                              onPreview={handlePreviewItem}
                              userCoins={userCurrency?.coins}
                              userJade={userCurrency?.jade}
                              isVip={isVip}
                            />
                          </motion.div>
                        ))}
                      </motion.div>
                    </div>
                  )}

                  {/* 类别物品 */}
                  {selectedCategory && (
                    <div className="category-items-section mb-6">
                      <div className="section-header flex items-center mb-4 border-b-2 border-jade-500 pb-2">
                        <span className="text-2xl mr-2">📦</span>
                        <h3 className="text-xl font-bold text-jade-700">{selectedCategory.name || pageLabels?.categoryItemsTitle || 'Category Items'}</h3>
                      </div>
                      {items.length > 0 ? (
                        <motion.div
                          className="category-items-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
                          variants={containerVariants}
                          initial="hidden"
                          animate="visible"
                        >
                          {items.map((item) => (
                            <motion.div
                              key={item.id}
                              variants={itemVariants}
                            >
                              <StoreItemCard
                                item={item}
                                onPurchase={handlePurchaseItem}
                                onPreview={handlePreviewItem}
                                userCoins={userCurrency?.coins}
                                userJade={userCurrency?.jade}
                                isVip={isVip}
                              />
                            </motion.div>
                          ))}
                        </motion.div>
                      ) : (
                        <div className="no-items text-center p-6 bg-gray-50 rounded-lg border border-gray-200">
                          <p className="text-gray-500">{pageLabels?.noItemsMessage || 'No items available in this category'}</p>
                        </div>
                      )}
                    </div>
                  )}
                </motion.div>
              )}
            </AnimatePresence>
          </div>
        )}
      </div>

      {/* 物品预览对话框 */}
      {selectedItem && (
        <StoreItemPreview
          isOpen={showItemPreview}
          onClose={() => setShowItemPreview(false)}
          item={selectedItem}
          onPurchase={handlePurchaseItem}
          userCoins={userCurrency?.coins}
          userJade={userCurrency?.jade}
          isVip={isVip}
        />
      )}
    </motion.div>
  );
};

export default StorePage;
</file>

<file path="src/pages/TeaRoomPage.tsx">
// src/pages/TeaRoomPage.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  ReflectionTriggerRecord,
  ReflectionTriggerType,
  getUnviewedReflectionTriggers,
  markTriggerAsViewed,
  createReflectionTrigger
} from '@/services/reflectionService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import EnhancedReflectionModule from '@/components/reflection/EnhancedReflectionModule';
import ReflectionHistory from '@/components/reflection/ReflectionHistory';
import MoodTracker from '@/components/reflection/MoodTracker';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchTeaRoomPageView } from '@/services';
import type { TeaRoomPageViewLabelsBundle } from '@/types';
import { pageTransition } from '@/utils/animation';
import ReflectionTriggerNotification from '@/components/reflection/ReflectionTriggerNotification';
import { playSound, SoundType } from '@/utils/sound';

/**
 * Tea Room Page
 * Provides reflection, mood tracking, and supportive feedback
 */
const TeaRoomPage: React.FC = () => {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showReflectionModule, setShowReflectionModule] = useState(false);
  const [showReflectionHistory, setShowReflectionHistory] = useState(false);
  const [selectedTrigger, setSelectedTrigger] = useState<ReflectionTriggerRecord | null>(null);

  // Current user ID (in a real application, this should be retrieved from the user session)
  const userId = 'current-user';

  // Get localized labels
  const {
    labels: pageLabels,
    isPending: isLabelsPending,
    isError: isLabelsError,
    error: labelsError,
    refetch: refetchLabels
  } = useLocalizedView<null, TeaRoomPageViewLabelsBundle>(
    'teaRoomPageViewContent',
    fetchTeaRoomPageView
  );

  // Load page data
  const loadPageData = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // Load other data here

    } catch (err) {
      console.error('Failed to load tea room data:', err);
      setError('Failed to load data, please try again');
    } finally {
      setIsLoading(false);
    }
  };

  // Initial loading
  useEffect(() => {
    loadPageData();
  }, []);

  // Register data refresh listeners
  useRegisterTableRefresh('reflections', loadPageData);
  useRegisterTableRefresh('reflectionTriggers', loadPageData);
  useRegisterTableRefresh('moods', loadPageData);

  // Handle start reflection
  const handleStartReflection = () => {
    // Play click sound
    playSound(SoundType.BUTTON_CLICK, 0.5);

    // Create manual trigger record
    createReflectionTrigger({
      userId,
      type: ReflectionTriggerType.MANUAL
    });

    // Show reflection module
    setShowReflectionModule(true);
  };

  // Handle view history
  const handleViewHistory = () => {
    // Play click sound
    playSound(SoundType.BUTTON_CLICK, 0.5);

    // Show reflection history
    setShowReflectionHistory(true);
  };

  // Handle trigger accepted
  const handleTriggerAccepted = (trigger: ReflectionTriggerRecord) => {
    setSelectedTrigger(trigger);
    setShowReflectionModule(true);
  };

  // Handle reflection complete
  const handleReflectionComplete = () => {
    // Reset selected trigger
    setSelectedTrigger(null);

    // Reload page data
    loadPageData();
  };

  // Render page content
  const renderPageContent = () => {
    return (
      <div className="tea-room-content">
        <div className="bamboo-frame">
          <h2>{pageLabels?.pageTitle || "Tea Room"}</h2>
          <p className="text-gray-600 mb-6">
            {pageLabels?.reflectionSection?.description || "Take some time to reflect on your experiences, feelings, and thoughts to better understand yourself and find direction."}
          </p>

          <div className="tea-room-sections grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Mood Tracking Section */}
            <div className="mood-tracking-section bg-white p-4 rounded-lg shadow-md border-l-4 border-jade-500">
              <h2 className="text-xl font-bold text-jade-700 mb-4">
                <span className="mr-2">🍵</span>
                {pageLabels?.moodTrackingSection?.title || "Mood Tracking"}
              </h2>
              <MoodTracker
              labels={pageLabels?.moodTrackingSection}
            />
            </div>

            {/* Reflection Section */}
            <div className="reflection-section bg-white p-4 rounded-lg shadow-md border-l-4 border-amber-500">
              <h2 className="text-xl font-bold text-amber-700 mb-4">
                <span className="mr-2">🪷</span>
                {pageLabels?.reflectionSection?.title || "Reflection"}
              </h2>
              <p className="text-gray-600 mb-4">
                {pageLabels?.reflectionSection?.description || "Taking time to reflect on your experiences, feelings, and thoughts can help you better understand yourself and find direction."}
              </p>
              <div className="reflection-actions flex flex-col gap-2">
                <Button
                  variant="jade"
                  onClick={handleStartReflection}
                  className="w-full"
                >
                  {pageLabels?.reflectionSection?.startReflectionButton || "Start Reflection"}
                </Button>
                <Button
                  variant="secondary"
                  onClick={handleViewHistory}
                  className="w-full"
                >
                  {pageLabels?.reflectionSection?.viewHistoryButton || "View History"}
                </Button>
              </div>
            </div>
          </div>

          {/* Daily Tips Section */}
          <div className="daily-tips-section bg-white p-4 rounded-lg shadow-md mt-6 border border-amber-200">
            <h2 className="text-xl font-bold text-amber-700 mb-4">
              <span className="mr-2">💡</span>
              {pageLabels?.dailyTipSection?.title || "Daily Wisdom"}
            </h2>
            <div className="daily-tip p-3 bg-amber-50 rounded-lg">
              <div className="flex items-start">
                <div className="tip-icon mr-3">
                  <span className="text-2xl">🎋</span>
                </div>
                <div className="tip-content">
                  <p className="text-gray-700">
                    {pageLabels?.dailyTipSection?.content || "Self-compassion is an essential part of mental health. When facing difficulties, try to treat yourself as you would a good friend, with understanding and kindness."}
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Reflection Module */}
        {showReflectionModule && (
          <EnhancedReflectionModule
            isOpen={showReflectionModule}
            onClose={() => setShowReflectionModule(false)}
            trigger={selectedTrigger || undefined}
            onReflectionComplete={handleReflectionComplete}
          />
        )}

        {/* Reflection History */}
        {showReflectionHistory && (
          <ReflectionHistory
            isOpen={showReflectionHistory}
            onClose={() => setShowReflectionHistory(false)}
          />
        )}

        {/* Reflection Trigger Notification */}
        <ReflectionTriggerNotification
          onTriggerAccepted={handleTriggerAccepted}
        />
      </div>
    );
  };

  // Show loading state
  if (isLabelsPending && !pageLabels) {
    return (
      <motion.div
        className="page-container"
        variants={pageTransition}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <div className="loading-container flex justify-center items-center h-64">
          <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "Loading tea room content..."} />
        </div>
      </motion.div>
    );
  }

  // Show error state
  if (isLabelsError && !pageLabels) {
    return (
      <motion.div
        className="page-container"
        variants={pageTransition}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <div className="error-container text-center p-4">
          <ErrorDisplay
            error={labelsError}
            title={pageLabels?.errorTitle || "Tea Room Page Error"}
            onRetry={refetchLabels}
          />
        </div>
      </motion.div>
    );
  }

  return (
    <motion.div
      className="page-container"
      variants={pageTransition}
      initial="hidden"
      animate="visible"
      exit="exit"
    >
      {isLoading ? (
        <div className="loading-container flex justify-center items-center h-64">
          <LoadingSpinner variant="jade" size="large" text={pageLabels?.loadingMessage || "Loading tea room content..."} />
        </div>
      ) : error ? (
        <div className="error-container text-center p-4">
          <div className="error-message text-red-500 mb-4">{error}</div>
          <Button variant="jade" onClick={loadPageData}>
            {pageLabels?.retryButtonText || "Retry"}
          </Button>
        </div>
      ) : (
        <AnimatePresence>
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.5 }}
          >
            {renderPageContent()}
          </motion.div>
        </AnimatePresence>
      )}
    </motion.div>
  );
};

export default TeaRoomPage;
</file>

<file path="src/services/challengeDiscoveryService.ts">
// src/services/challengeDiscoveryService.ts
import { db } from '@/db';
import { 
  ChallengeRecord, 
  ChallengeType, 
  ChallengeDifficulty, 
  ChallengeStatus,
  getAllChallenges
} from './challengeService';
import { 
  TaskRecord, 
  TaskStatus, 
  TaskType, 
  TaskPriority,
  getAllTasks
} from './taskService';
import { getPandaLevel } from './pandaStateService';

/**
 * 挑战推荐记录类型
 */
export interface ChallengeRecommendation {
  challenge: ChallengeRecord;
  score: number;
  reason: string;
}

/**
 * 挑战发现记录类型
 */
export interface ChallengeDiscovery {
  id?: number;
  userId: string;
  challengeId: number;
  discoveredAt: Date;
  isViewed: boolean;
  isAccepted: boolean;
  expiresAt?: Date;
}

/**
 * 获取推荐的挑战
 * 根据用户的任务完成情况、熊猫等级和偏好推荐挑战
 */
export async function getRecommendedChallenges(
  limit: number = 3
): Promise<ChallengeRecommendation[]> {
  try {
    // 获取用户的熊猫等级
    const pandaLevel = await getPandaLevel();
    
    // 获取所有活跃和即将开始的挑战
    const challenges = await getAllChallenges({
      status: ChallengeStatus.ACTIVE
    });
    
    // 获取用户已完成的任务
    const completedTasks = await getAllTasks({
      status: TaskStatus.COMPLETED
    });
    
    // 计算每个挑战的推荐分数
    const recommendations: ChallengeRecommendation[] = [];
    
    for (const challenge of challenges) {
      let score = 0;
      let reason = '';
      
      // 根据挑战难度和熊猫等级计算分数
      if (challenge.difficulty === ChallengeDifficulty.EASY) {
        score += 10;
        reason += '这个挑战难度适中，';
      } else if (challenge.difficulty === ChallengeDifficulty.MEDIUM && pandaLevel >= 3) {
        score += 15;
        reason += '这个挑战难度适合你当前的等级，';
      } else if (challenge.difficulty === ChallengeDifficulty.HARD && pandaLevel >= 5) {
        score += 20;
        reason += '这个挑战有一定难度，但你已经达到了足够的等级，';
      } else if (challenge.difficulty === ChallengeDifficulty.EXPERT && pandaLevel >= 8) {
        score += 25;
        reason += '这个挑战非常有挑战性，适合你的高等级，';
      }
      
      // 根据挑战类型计算分数
      if (challenge.type === ChallengeType.DAILY) {
        score += 5;
        reason += '这是一个日常挑战，';
      } else if (challenge.type === ChallengeType.WEEKLY) {
        score += 10;
        reason += '这是一个每周挑战，';
      } else if (challenge.type === ChallengeType.EVENT) {
        score += 15;
        reason += '这是一个限时活动挑战，';
      }
      
      // 根据已完成任务的相关性计算分数
      const relatedTaskCount = completedTasks.filter(task => {
        // 检查任务标题或描述是否与挑战相关
        const taskTitle = task.title.toLowerCase();
        const taskDesc = task.description?.toLowerCase() || '';
        const challengeTitle = challenge.title.toLowerCase();
        const challengeDesc = challenge.description.toLowerCase();
        
        return (
          taskTitle.includes(challengeTitle) ||
          taskDesc.includes(challengeTitle) ||
          challengeTitle.includes(taskTitle) ||
          taskDesc.includes(challengeDesc) ||
          challengeDesc.includes(taskTitle)
        );
      }).length;
      
      if (relatedTaskCount > 0) {
        score += relatedTaskCount * 5;
        reason += `你已经完成了${relatedTaskCount}个相关任务，`;
      }
      
      // 添加到推荐列表
      recommendations.push({
        challenge,
        score,
        reason: reason + '推荐你尝试这个挑战。'
      });
    }
    
    // 按分数排序并限制数量
    return recommendations
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);
  } catch (err) {
    console.error('Failed to get recommended challenges:', err);
    return [];
  }
}

/**
 * 发现新挑战
 * 根据用户的任务完成情况自动发现新挑战
 */
export async function discoverNewChallenges(): Promise<ChallengeDiscovery[]> {
  try {
    // 获取用户的熊猫等级
    const pandaLevel = await getPandaLevel();
    
    // 获取所有即将开始的挑战
    const upcomingChallenges = await getAllChallenges({
      status: ChallengeStatus.UPCOMING
    });
    
    // 获取用户已完成的任务
    const completedTasks = await getAllTasks({
      status: TaskStatus.COMPLETED
    });
    
    // 获取已发现的挑战
    const discoveredChallenges = await db.table('challengeDiscoveries')
      .where('userId')
      .equals('current-user') // 在实际应用中，这应该是当前用户的ID
      .toArray();
    
    const discoveredChallengeIds = discoveredChallenges.map(dc => dc.challengeId);
    
    // 筛选出符合发现条件的挑战
    const newDiscoveries: ChallengeDiscovery[] = [];
    
    for (const challenge of upcomingChallenges) {
      // 跳过已发现的挑战
      if (discoveredChallengeIds.includes(challenge.id!)) {
        continue;
      }
      
      // 检查是否符合发现条件
      let shouldDiscover = false;
      
      // 条件1：熊猫等级达到要求
      if (
        (challenge.difficulty === ChallengeDifficulty.EASY && pandaLevel >= 1) ||
        (challenge.difficulty === ChallengeDifficulty.MEDIUM && pandaLevel >= 3) ||
        (challenge.difficulty === ChallengeDifficulty.HARD && pandaLevel >= 5) ||
        (challenge.difficulty === ChallengeDifficulty.EXPERT && pandaLevel >= 8)
      ) {
        shouldDiscover = true;
      }
      
      // 条件2：完成了相关任务
      const relatedTaskCount = completedTasks.filter(task => {
        const taskTitle = task.title.toLowerCase();
        const taskDesc = task.description?.toLowerCase() || '';
        const challengeTitle = challenge.title.toLowerCase();
        const challengeDesc = challenge.description.toLowerCase();
        
        return (
          taskTitle.includes(challengeTitle) ||
          taskDesc.includes(challengeTitle) ||
          challengeTitle.includes(taskTitle) ||
          taskDesc.includes(challengeDesc) ||
          challengeDesc.includes(taskTitle)
        );
      }).length;
      
      if (relatedTaskCount >= 3) {
        shouldDiscover = true;
      }
      
      // 如果符合条件，创建新的发现记录
      if (shouldDiscover) {
        const now = new Date();
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7天后过期
        
        const discovery: ChallengeDiscovery = {
          userId: 'current-user', // 在实际应用中，这应该是当前用户的ID
          challengeId: challenge.id!,
          discoveredAt: now,
          isViewed: false,
          isAccepted: false,
          expiresAt
        };
        
        // 添加到数据库
        const id = await db.table('challengeDiscoveries').add(discovery);
        
        newDiscoveries.push({ ...discovery, id: id as number });
      }
    }
    
    return newDiscoveries;
  } catch (err) {
    console.error('Failed to discover new challenges:', err);
    return [];
  }
}

/**
 * 获取未查看的挑战发现
 */
export async function getUnviewedDiscoveries(): Promise<ChallengeDiscovery[]> {
  return db.table('challengeDiscoveries')
    .where('userId')
    .equals('current-user') // 在实际应用中，这应该是当前用户的ID
    .and(discovery => !discovery.isViewed)
    .toArray();
}

/**
 * 标记挑战发现为已查看
 */
export async function markDiscoveryAsViewed(discoveryId: number): Promise<void> {
  await db.table('challengeDiscoveries').update(discoveryId, { isViewed: true });
}

/**
 * 接受挑战发现
 */
export async function acceptChallenge(discoveryId: number): Promise<void> {
  // 获取发现记录
  const discovery = await db.table('challengeDiscoveries').get(discoveryId);
  if (!discovery) {
    throw new Error(`Challenge discovery with id ${discoveryId} not found`);
  }
  
  // 获取挑战
  const challenge = await db.table('challenges').get(discovery.challengeId);
  if (!challenge) {
    throw new Error(`Challenge with id ${discovery.challengeId} not found`);
  }
  
  // 更新挑战状态为活跃
  await db.table('challenges').update(challenge.id!, {
    status: ChallengeStatus.ACTIVE,
    updatedAt: new Date()
  });
  
  // 更新发现记录为已接受
  await db.table('challengeDiscoveries').update(discoveryId, {
    isAccepted: true,
    isViewed: true
  });
}
</file>

<file path="src/services/challengeService.ts">
// src/services/challengeService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { generateRewardsForChallenge, RewardRecord } from './rewardService';
import { TaskRecord, TaskStatus } from './taskService';

// 挑战状态枚举
export enum ChallengeStatus {
  ACTIVE = 'active',         // 活跃中
  COMPLETED = 'completed',   // 已完成
  EXPIRED = 'expired',       // 已过期
  UPCOMING = 'upcoming'      // 即将开始
}

// 挑战类型枚举
export enum ChallengeType {
  DAILY = 'daily',           // 每日挑战
  WEEKLY = 'weekly',         // 每周挑战
  EVENT = 'event',           // 活动挑战
  ONGOING = 'ongoing'        // 持续性挑战
}

// 挑战难度枚举
export enum ChallengeDifficulty {
  EASY = 'easy',             // 简单
  MEDIUM = 'medium',         // 中等
  HARD = 'hard',             // 困难
  EXPERT = 'expert'          // 专家
}

// 挑战记录类型
export interface ChallengeRecord {
  id?: number;               // 挑战ID
  title: string;             // 挑战标题
  description: string;       // 挑战描述
  type: ChallengeType;       // 挑战类型
  difficulty: ChallengeDifficulty; // 挑战难度
  status: ChallengeStatus;   // 挑战状态
  progress: number;          // 进度（0-100）
  startDate: Date;           // 开始日期
  endDate?: Date;            // 结束日期（可选，持续性挑战可能没有）
  completedDate?: Date;      // 完成日期
  taskIds: number[];         // 关联的任务ID列表
  rewardIds?: number[];      // 奖励ID列表
  iconPath: string;          // 图标路径
  createdAt: Date;           // 创建时间
  updatedAt: Date;           // 更新时间
}

// 挑战完成记录类型
export interface ChallengeCompletionRecord {
  id?: number;               // 记录ID
  challengeId: number;       // 挑战ID
  userId: string;            // 用户ID
  completedDate: Date;       // 完成日期
  rewardIds: number[];       // 获得的奖励ID列表
  createdAt: Date;           // 创建时间
}

// 预定义的挑战类别
export const PREDEFINED_CHALLENGE_CATEGORIES = [
  {
    id: 1,
    name: '健康习惯',
    description: '培养健康的生活方式',
    iconPath: '/assets/challenges/health.svg'
  },
  {
    id: 2,
    name: '学习成长',
    description: '提升知识和技能',
    iconPath: '/assets/challenges/learning.svg'
  },
  {
    id: 3,
    name: '工作效率',
    description: '提高工作和学习效率',
    iconPath: '/assets/challenges/productivity.svg'
  },
  {
    id: 4,
    name: '心灵成长',
    description: '培养积极心态和情绪管理',
    iconPath: '/assets/challenges/mindfulness.svg'
  },
  {
    id: 5,
    name: '社交关系',
    description: '改善人际关系和社交技能',
    iconPath: '/assets/challenges/social.svg'
  }
];

/**
 * 初始化挑战类别
 * 如果数据库中没有挑战类别记录，则添加预定义的类别
 */
export async function initializeChallengeCategories(): Promise<void> {
  try {
    const categories = await db.table('challengeCategories').toArray();

    if (categories.length === 0) {
      // 逐个添加类别，避免批量添加时的冲突
      for (const category of PREDEFINED_CHALLENGE_CATEGORIES) {
        try {
          // 检查类别是否已存在
          const existingCategory = await db.table('challengeCategories').get(category.id);
          if (!existingCategory) {
            await db.table('challengeCategories').add(category);
          }
        } catch (err) {
          console.warn(`Failed to add challenge category ${category.id}: ${err}`);
        }
      }
    }
  } catch (err) {
    console.error('Failed to initialize challenge categories:', err);
  }
}

/**
 * 获取所有挑战类别
 */
export async function getAllChallengeCategories(): Promise<any[]> {
  return db.table('challengeCategories').toArray();
}

/**
 * 获取所有挑战
 * @param filter 过滤条件
 */
export async function getAllChallenges(filter?: {
  status?: ChallengeStatus;
  type?: ChallengeType;
  difficulty?: ChallengeDifficulty;
}): Promise<ChallengeRecord[]> {
  let collection = db.table('challenges').toCollection();

  if (filter) {
    if (filter.status) {
      collection = collection.filter(challenge => challenge.status === filter.status);
    }
    if (filter.type) {
      collection = collection.filter(challenge => challenge.type === filter.type);
    }
    if (filter.difficulty) {
      collection = collection.filter(challenge => challenge.difficulty === filter.difficulty);
    }
  }

  return collection.toArray();
}

/**
 * 获取单个挑战
 * @param id 挑战ID
 */
export async function getChallenge(id: number): Promise<ChallengeRecord | undefined> {
  return db.table('challenges').get(id);
}

/**
 * 创建新挑战
 * @param challengeData 挑战数据
 */
export async function createChallenge(
  challengeData: Omit<ChallengeRecord, 'id' | 'createdAt' | 'updatedAt' | 'status' | 'progress'>
): Promise<ChallengeRecord> {
  const now = new Date();

  const challenge: ChallengeRecord = {
    ...challengeData,
    status: ChallengeStatus.UPCOMING,
    progress: 0,
    createdAt: now,
    updatedAt: now
  };

  const id = await db.table('challenges').add(challenge);
  const newChallenge = { ...challenge, id: id as number };

  // 添加到同步队列
  await addSyncItem('challenges', 'create', newChallenge);

  return newChallenge;
}

/**
 * 更新挑战
 * @param id 挑战ID
 * @param challengeData 挑战数据
 */
export async function updateChallenge(
  id: number,
  challengeData: Partial<ChallengeRecord>
): Promise<ChallengeRecord> {
  const challenge = await db.table('challenges').get(id);

  if (!challenge) {
    throw new Error(`Challenge with id ${id} not found`);
  }

  const updatedChallenge = {
    ...challenge,
    ...challengeData,
    updatedAt: new Date()
  };

  await db.table('challenges').update(id, updatedChallenge);

  // 添加到同步队列
  await addSyncItem('challenges', 'update', updatedChallenge);

  return updatedChallenge;
}

/**
 * 删除挑战
 * @param id 挑战ID
 */
export async function deleteChallenge(id: number): Promise<void> {
  const challenge = await db.table('challenges').get(id);

  if (!challenge) {
    throw new Error(`Challenge with id ${id} not found`);
  }

  await db.table('challenges').delete(id);

  // 添加到同步队列
  await addSyncItem('challenges', 'delete', { id });
}

/**
 * 更新挑战进度
 * @param id 挑战ID
 * @param progress 进度值（0-100）
 */
export async function updateChallengeProgress(id: number, progress: number): Promise<ChallengeRecord> {
  const challenge = await db.table('challenges').get(id);

  if (!challenge) {
    throw new Error(`Challenge with id ${id} not found`);
  }

  // 确保进度在0-100范围内
  const validProgress = Math.max(0, Math.min(100, progress));

  // 如果进度达到100%，将状态更新为已完成
  let status = challenge.status;
  let completedDate = challenge.completedDate;

  if (validProgress >= 100 && status !== ChallengeStatus.COMPLETED) {
    status = ChallengeStatus.COMPLETED;
    completedDate = new Date();
  }

  const updatedChallenge = {
    ...challenge,
    progress: validProgress,
    status,
    completedDate,
    updatedAt: new Date()
  };

  await db.table('challenges').update(id, updatedChallenge);

  // 添加到同步队列
  await addSyncItem('challenges', 'update', updatedChallenge);

  return updatedChallenge;
}

/**
 * 完成挑战
 * @param id 挑战ID
 */
export async function completeChallenge(id: number): Promise<RewardRecord[]> {
  const challenge = await db.table('challenges').get(id);

  if (!challenge) {
    throw new Error(`Challenge with id ${id} not found`);
  }

  if (challenge.status === ChallengeStatus.COMPLETED) {
    throw new Error(`Challenge with id ${id} is already completed`);
  }

  // 更新挑战状态
  const updatedChallenge = {
    ...challenge,
    status: ChallengeStatus.COMPLETED,
    progress: 100,
    completedDate: new Date(),
    updatedAt: new Date()
  };

  await db.table('challenges').update(id, updatedChallenge);

  // 生成奖励
  const rewards = await generateRewardsForChallenge(updatedChallenge);

  // 创建挑战完成记录
  const completionRecord: ChallengeCompletionRecord = {
    challengeId: id,
    userId: 'current-user', // 在实际应用中，这应该是当前用户的ID
    completedDate: new Date(),
    rewardIds: rewards.map(reward => reward.id!),
    createdAt: new Date()
  };

  await db.table('challengeCompletions').add(completionRecord);

  // 添加到同步队列
  await addSyncItem('challenges', 'update', updatedChallenge);
  await addSyncItem('challengeCompletions', 'create', completionRecord);

  return rewards;
}

/**
 * 获取挑战关联的任务
 * @param challengeId 挑战ID
 */
export async function getChallengeTasks(challengeId: number): Promise<TaskRecord[]> {
  const challenge = await db.table('challenges').get(challengeId);

  if (!challenge) {
    throw new Error(`Challenge with id ${challengeId} not found`);
  }

  if (!challenge.taskIds || challenge.taskIds.length === 0) {
    return [];
  }

  return db.table('tasks')
    .where('id')
    .anyOf(challenge.taskIds)
    .toArray();
}

/**
 * 更新挑战进度基于任务完成情况
 * @param challengeId 挑战ID
 */
export async function updateChallengeProgressFromTasks(challengeId: number): Promise<ChallengeRecord> {
  const challenge = await db.table('challenges').get(challengeId);

  if (!challenge) {
    throw new Error(`Challenge with id ${challengeId} not found`);
  }

  if (!challenge.taskIds || challenge.taskIds.length === 0) {
    return challenge;
  }

  // 获取挑战关联的所有任务
  const tasks = await getChallengeTasks(challengeId);

  // 计算已完成任务的数量
  const completedTasks = tasks.filter(task => task.status === TaskStatus.COMPLETED);

  // 计算进度百分比
  const progress = Math.round((completedTasks.length / tasks.length) * 100);

  // 更新挑战进度
  return updateChallengeProgress(challengeId, progress);
}

/**
 * Generate test challenge data
 * Creates sample challenges for testing
 */
export async function generateTestChallengeData(): Promise<void> {
  try {
    // Check if challenges already exist
    const existingChallenges = await db.table('challenges').count();
    if (existingChallenges > 0) {
      console.log('Test challenge data already exists, skipping generation');
      return;
    }

    // Initialize challenge categories if needed
    await initializeChallengeCategories();

    // Sample challenge data
    const testChallenges: Omit<ChallengeRecord, 'id' | 'createdAt' | 'updatedAt'>[] = [
      // Active challenges
      {
        title: 'Morning Meditation',
        description: 'Complete a 10-minute meditation session every morning for 7 days to improve focus and mindfulness.',
        type: ChallengeType.DAILY,
        difficulty: ChallengeDifficulty.EASY,
        status: ChallengeStatus.ACTIVE,
        progress: 57,
        startDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000), // 3 days ago
        endDate: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000),   // 4 days from now
        taskIds: [],
        iconPath: '/assets/challenges/meditation.svg'
      },
      {
        title: 'Productivity Sprint',
        description: 'Complete 20 high-priority tasks within 5 days to boost your productivity and task management skills.',
        type: ChallengeType.WEEKLY,
        difficulty: ChallengeDifficulty.MEDIUM,
        status: ChallengeStatus.ACTIVE,
        progress: 35,
        startDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000), // 2 days ago
        endDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),   // 5 days from now
        taskIds: [],
        iconPath: '/assets/challenges/productivity.svg'
      },
      {
        title: 'Healthy Eating Challenge',
        description: 'Prepare and eat healthy meals for 14 days straight. Track your nutrition and avoid processed foods.',
        type: ChallengeType.ONGOING,
        difficulty: ChallengeDifficulty.HARD,
        status: ChallengeStatus.ACTIVE,
        progress: 21,
        startDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000), // 3 days ago
        endDate: new Date(Date.now() + 11 * 24 * 60 * 60 * 1000),  // 11 days from now
        taskIds: [],
        iconPath: '/assets/challenges/health.svg'
      },

      // Completed challenges
      {
        title: 'Reading Marathon',
        description: 'Read for at least 30 minutes every day for a week to develop a reading habit.',
        type: ChallengeType.WEEKLY,
        difficulty: ChallengeDifficulty.EASY,
        status: ChallengeStatus.COMPLETED,
        progress: 100,
        startDate: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000), // 14 days ago
        endDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),     // 7 days ago
        completedDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
        taskIds: [],
        iconPath: '/assets/challenges/learning.svg'
      },
      {
        title: 'Coding Project',
        description: 'Complete a personal coding project within 10 days to improve your programming skills.',
        type: ChallengeType.EVENT,
        difficulty: ChallengeDifficulty.HARD,
        status: ChallengeStatus.COMPLETED,
        progress: 100,
        startDate: new Date(Date.now() - 20 * 24 * 60 * 60 * 1000), // 20 days ago
        endDate: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000),   // 10 days ago
        completedDate: new Date(Date.now() - 11 * 24 * 60 * 60 * 1000),
        taskIds: [],
        iconPath: '/assets/challenges/learning.svg'
      },

      // Upcoming challenges
      {
        title: 'Fitness Challenge',
        description: 'Exercise for at least 30 minutes every day for 21 days to build a fitness habit.',
        type: ChallengeType.ONGOING,
        difficulty: ChallengeDifficulty.MEDIUM,
        status: ChallengeStatus.UPCOMING,
        progress: 0,
        startDate: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000),  // 2 days from now
        endDate: new Date(Date.now() + 23 * 24 * 60 * 60 * 1000),   // 23 days from now
        taskIds: [],
        iconPath: '/assets/challenges/health.svg'
      },
      {
        title: 'Language Learning Sprint',
        description: 'Practice a new language for 15 minutes daily for 30 days to build vocabulary and fluency.',
        type: ChallengeType.EVENT,
        difficulty: ChallengeDifficulty.EXPERT,
        status: ChallengeStatus.UPCOMING,
        progress: 0,
        startDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),  // 5 days from now
        endDate: new Date(Date.now() + 35 * 24 * 60 * 60 * 1000),   // 35 days from now
        taskIds: [],
        iconPath: '/assets/challenges/learning.svg'
      }
    ];

    // Add challenges to database
    const now = new Date();
    for (const challenge of testChallenges) {
      const challengeWithDates = {
        ...challenge,
        createdAt: now,
        updatedAt: now
      };
      await db.table('challenges').add(challengeWithDates);
    }

    console.log('Test challenge data generated successfully');
  } catch (error) {
    console.error('Error generating test challenge data:', error);
  }
}
</file>

<file path="src/services/dataSyncService.ts">
// src/services/dataSyncService.ts
import { db } from '@/db';
import { queryClient } from '@/services/queryClient';

// 同步状态枚举
export enum SyncStatus {
  IDLE = 'idle',
  SYNCING = 'syncing',
  SUCCESS = 'success',
  ERROR = 'error'
}

// 同步项目类型
export interface SyncItem {
  id: string;
  table: string;
  action: 'create' | 'update' | 'delete';
  data: any;
  timestamp: Date;
  retryCount: number;
  status: SyncStatus;
  error?: string;
}

// 同步配置
interface SyncConfig {
  autoSyncInterval: number; // 自动同步间隔（毫秒）
  maxRetryCount: number; // 最大重试次数
  batchSize: number; // 批量同步大小
}

// 默认同步配置
const DEFAULT_SYNC_CONFIG: SyncConfig = {
  autoSyncInterval: 60000, // 1分钟
  maxRetryCount: 3,
  batchSize: 10
};

// 当前同步状态
let currentSyncStatus: SyncStatus = SyncStatus.IDLE;
let syncConfig: SyncConfig = DEFAULT_SYNC_CONFIG;
let autoSyncInterval: NodeJS.Timeout | null = null;

/**
 * 初始化数据同步服务
 * @param config 同步配置
 */
export function initializeDataSync(config: Partial<SyncConfig> = {}): void {
  // 合并配置
  syncConfig = { ...DEFAULT_SYNC_CONFIG, ...config };

  // 启动自动同步
  startAutoSync();

  console.log('Data sync service initialized');
}

/**
 * 启动自动同步
 */
function startAutoSync(): void {
  if (autoSyncInterval) {
    clearInterval(autoSyncInterval);
  }

  autoSyncInterval = setInterval(() => {
    syncPendingItems().catch(err => {
      console.error('Auto sync failed:', err);
    });
  }, syncConfig.autoSyncInterval);
}

/**
 * 停止自动同步
 */
export function stopAutoSync(): void {
  if (autoSyncInterval) {
    clearInterval(autoSyncInterval);
    autoSyncInterval = null;
  }
}

/**
 * 添加同步项目
 * @param table 表名
 * @param action 操作类型
 * @param data 数据
 */
export async function addSyncItem(
  table: string,
  action: 'create' | 'update' | 'delete',
  data: any
): Promise<void> {
  try {
    // 检查表是否存在
    if (!db.tables.some(t => t.name === 'syncQueue')) {
      console.warn('syncQueue table does not exist yet, creating it');
      // 在实际应用中，这里应该创建表或重新初始化数据库
      // 但在这个示例中，我们只是记录警告并返回
      return;
    }

    // 检查数据是否有效
    if (!data || !data.id) {
      console.warn('Invalid data for sync item, skipping', data);
      return;
    }

    const syncItem: SyncItem = {
      id: `${table}_${data.id}_${Date.now()}`,
      table,
      action,
      data,
      timestamp: new Date(),
      retryCount: 0,
      status: SyncStatus.IDLE
    };

    // 添加到同步队列
    await db.table('syncQueue').add(syncItem);

    // 触发自定义事件，通知同步状态指示器更新
    try {
      const syncEvent = new CustomEvent('syncItemAdded', { detail: syncItem });
      window.dispatchEvent(syncEvent);
    } catch (eventErr) {
      console.error('Failed to dispatch sync event:', eventErr);
    }

    console.log(`Sync item added: ${table} ${action}`, data.id);

    // 如果是在线状态，立即尝试同步
    if (navigator.onLine) {
      syncPendingItems().catch(err => {
        console.error('Sync failed:', err);
      });
    }
  } catch (err) {
    console.error('Failed to add sync item:', err);
  }
}

/**
 * 同步待处理项目
 */
export async function syncPendingItems(): Promise<void> {
  // 如果已经在同步中，则跳过
  if (currentSyncStatus === SyncStatus.SYNCING) {
    return;
  }

  // 如果离线，则跳过
  if (!navigator.onLine) {
    return;
  }

  // 检查表是否存在
  try {
    if (!db.tables.some(table => table.name === 'syncQueue')) {
      console.warn('syncQueue table does not exist yet');
      return;
    }
  } catch (err) {
    console.error('Error checking syncQueue table:', err);
    return;
  }

  try {
    // 更新同步状态并触发事件
    currentSyncStatus = SyncStatus.SYNCING;
    const syncEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
    window.dispatchEvent(syncEvent);

    console.log('Sync started');

    // 获取待处理项目
    const pendingItems = await db.table('syncQueue')
      .where('status')
      .equals(SyncStatus.IDLE)
      .or('status')
      .equals(SyncStatus.ERROR)
      .filter(item => item.retryCount < syncConfig.maxRetryCount)
      .limit(syncConfig.batchSize)
      .toArray();

    if (pendingItems.length === 0) {
      currentSyncStatus = SyncStatus.IDLE;
      const syncCompleteEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
      window.dispatchEvent(syncCompleteEvent);
      console.log('No pending items to sync');
      return;
    }

    console.log(`Found ${pendingItems.length} items to sync`);

    // 批量处理项目
    for (const item of pendingItems) {
      try {
        // 在实际应用中，这里应该调用API进行同步
        // 这里只是模拟同步成功
        await simulateSyncItem(item);

        // 更新项目状态
        await db.table('syncQueue').update(item.id, {
          status: SyncStatus.SUCCESS
        });

        // 更新缓存，传递数据
        invalidateRelatedQueries(item.table, item.data);
      } catch (err) {
        console.error(`Sync item ${item.id} failed:`, err);

        // 更新重试次数和状态
        await db.table('syncQueue').update(item.id, {
          retryCount: item.retryCount + 1,
          status: SyncStatus.ERROR,
          error: err instanceof Error ? err.message : String(err)
        });
      }
    }

    // 清理已成功的项目
    await db.table('syncQueue')
      .where('status')
      .equals(SyncStatus.SUCCESS)
      .delete();

    // 更新同步状态并触发事件
    currentSyncStatus = SyncStatus.SUCCESS;
    const syncSuccessEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
    window.dispatchEvent(syncSuccessEvent);

    console.log('Sync completed successfully');

    // 2秒后重置状态为空闲
    setTimeout(() => {
      currentSyncStatus = SyncStatus.IDLE;
      const resetEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
      window.dispatchEvent(resetEvent);
    }, 2000);
  } catch (err) {
    console.error('Sync failed:', err);
    currentSyncStatus = SyncStatus.ERROR;

    // 触发错误事件
    const syncErrorEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
    window.dispatchEvent(syncErrorEvent);
  }
}

/**
 * 模拟同步项目（实际应用中应替换为真实API调用）
 */
async function simulateSyncItem(item: SyncItem): Promise<void> {
  // 模拟网络延迟
  await new Promise(resolve => setTimeout(resolve, 500));

  // 模拟同步成功
  console.log(`Simulated sync for item ${item.id}:`, item);
}

/**
 * 使相关查询缓存失效
 * @param table 表名
 * @param data 数据
 */
function invalidateRelatedQueries(table: string, data?: any): void {
  // 触发自定义事件，通知组件刷新
  // 这将通过 DataRefreshProvider 传播到所有使用 useDataRefresh 和 useTableRefresh 的组件
  const refreshEvent = new CustomEvent('dataRefresh', {
    detail: { table, data }
  });
  window.dispatchEvent(refreshEvent);

  // 根据表名使相关查询缓存失效
  switch (table) {
    case 'tasks':
      // 如果有特定任务ID，只使该任务的缓存失效
      if (data && data.id) {
        queryClient.invalidateQueries({
          queryKey: ['tasks', data.id],
          exact: true
        });
        // 同时使任务列表缓存失效，但不重新获取数据
        queryClient.invalidateQueries({
          queryKey: ['tasks'],
          exact: true,
          refetchType: 'none'
        });
      } else {
        // 否则使所有任务缓存失效
        queryClient.invalidateQueries({ queryKey: ['tasks'] });
      }
      break;
    case 'pandaState':
      queryClient.invalidateQueries({ queryKey: ['pandaState'] });
      break;
    case 'abilities':
      queryClient.invalidateQueries({ queryKey: ['abilities'] });
      break;
    case 'rewards':
      queryClient.invalidateQueries({ queryKey: ['rewards'] });
      break;
    default:
      // 默认使所有查询缓存失效，但不重新获取数据
      queryClient.invalidateQueries({
        refetchType: 'none'
      });
  }
}

/**
 * 获取当前同步状态
 */
export function getCurrentSyncStatus(): SyncStatus {
  return currentSyncStatus;
}

/**
 * 获取待同步项目数量
 */
export async function getPendingSyncCount(): Promise<number> {
  try {
    // 检查表是否存在
    if (!db.tables.some(table => table.name === 'syncQueue')) {
      console.warn('syncQueue table does not exist yet');
      return 0;
    }

    return db.table('syncQueue')
      .where('status')
      .equals(SyncStatus.IDLE)
      .or('status')
      .equals(SyncStatus.ERROR)
      .count();
  } catch (err) {
    console.error('Error getting pending sync count:', err);
    return 0;
  }
}

/**
 * 手动触发同步
 */
export async function manualSync(): Promise<void> {
  return syncPendingItems();
}
</file>

<file path="src/services/index.ts">
// src/services/index.ts
export * from './localizedContentService';
</file>

<file path="src/services/pandaAbilityService.ts">
// src/services/pandaAbilityService.ts
import { db } from '@/db';
import { RewardRarity } from './rewardService';

// Panda ability type enum
export enum AbilityType {
  PASSIVE = 'passive',   // Passive ability (permanent effect)
  ACTIVE = 'active',     // Active ability (needs activation)
  ULTIMATE = 'ultimate'  // Ultimate ability (powerful but with cooldown)
}

// Panda ability effect type enum
export enum AbilityEffectType {
  EXPERIENCE_BOOST = 'experience_boost',       // Experience boost
  ENERGY_BOOST = 'energy_boost',               // Energy boost
  TASK_EFFICIENCY = 'task_efficiency',         // Task efficiency boost
  REWARD_BOOST = 'reward_boost',               // Reward boost
  MOOD_STABILIZER = 'mood_stabilizer',         // Mood stabilizer
  TIME_EXTENSION = 'time_extension',           // Time extension
  FOCUS_ENHANCEMENT = 'focus_enhancement',     // Focus enhancement
  INSPIRATION = 'inspiration',                 // Inspiration
  RESILIENCE = 'resilience',                   // Resilience
  WISDOM = 'wisdom'                            // Wisdom
}

// Panda ability record type
export interface PandaAbilityRecord {
  id?: number;
  name: string;
  description: string;
  type: AbilityType;
  effectType: AbilityEffectType;
  effectValue: number;
  iconPath: string;
  rarity: RewardRarity;
  requiredLevel: number;
  isUnlocked: boolean;
  isActive: boolean;
  cooldownMinutes?: number;
  lastUsedAt?: Date;
  unlockDate?: Date;
}

// Predefined panda abilities list
const PREDEFINED_ABILITIES: PandaAbilityRecord[] = [
  // Passive abilities - Basic
  {
    name: 'Bamboo Heart',
    description: 'Passive: Increases experience gained from completing tasks by 10%',
    type: AbilityType.PASSIVE,
    effectType: AbilityEffectType.EXPERIENCE_BOOST,
    effectValue: 0.1,
    iconPath: '/assets/abilities/bamboo-heart.svg',
    rarity: RewardRarity.COMMON,
    requiredLevel: 2,
    isUnlocked: false,
    isActive: false
  },
  {
    name: 'Panda Vitality',
    description: 'Passive: Increases panda energy recovery rate by 15%',
    type: AbilityType.PASSIVE,
    effectType: AbilityEffectType.ENERGY_BOOST,
    effectValue: 0.15,
    iconPath: '/assets/abilities/panda-vitality.svg',
    rarity: RewardRarity.COMMON,
    requiredLevel: 3,
    isUnlocked: false,
    isActive: false
  },

  // Active abilities - Intermediate
  {
    name: 'Bamboo Focus',
    description: 'Active: When activated, increases experience gained from completing tasks by 25% for 1 hour',
    type: AbilityType.ACTIVE,
    effectType: AbilityEffectType.FOCUS_ENHANCEMENT,
    effectValue: 0.25,
    iconPath: '/assets/abilities/bamboo-focus.svg',
    rarity: RewardRarity.UNCOMMON,
    requiredLevel: 5,
    isUnlocked: false,
    isActive: false,
    cooldownMinutes: 120
  },
  {
    name: 'Panda Wisdom',
    description: 'Active: When activated, increases rewards from completed tasks by 20% for 2 hours',
    type: AbilityType.ACTIVE,
    effectType: AbilityEffectType.REWARD_BOOST,
    effectValue: 0.2,
    iconPath: '/assets/abilities/panda-wisdom.svg',
    rarity: RewardRarity.UNCOMMON,
    requiredLevel: 7,
    isUnlocked: false,
    isActive: false,
    cooldownMinutes: 240
  },

  // Ultimate abilities - Advanced
  {
    name: 'Bamboo Master',
    description: 'Ultimate: When activated, increases all ability effects by 50% for 4 hours',
    type: AbilityType.ULTIMATE,
    effectType: AbilityEffectType.WISDOM,
    effectValue: 0.5,
    iconPath: '/assets/abilities/bamboo-master.svg',
    rarity: RewardRarity.RARE,
    requiredLevel: 10,
    isUnlocked: false,
    isActive: false,
    cooldownMinutes: 1440 // 24 hours
  }
];

/**
 * Initialize panda abilities system
 * If there are no ability records in the database, add predefined abilities
 */
export async function initializePandaAbilities(): Promise<void> {
  const abilities = await db.table('abilities').toArray();

  if (abilities.length === 0) {
    await db.table('abilities').bulkAdd(PREDEFINED_ABILITIES);
  }
}

/**
 * Get all panda abilities
 */
export async function getAllPandaAbilities(): Promise<PandaAbilityRecord[]> {
  return db.table('abilities').toArray();
}

/**
 * Get unlocked panda abilities
 */
export async function getUnlockedPandaAbilities(): Promise<PandaAbilityRecord[]> {
  try {
    // Check if table exists
    if (!db.tables.some(table => table.name === 'abilities')) {
      console.warn('abilities table does not exist yet');
      // Initialize abilities system
      await initializePandaAbilities();
    }

    // Try to get all abilities, then filter in memory
    try {
      const allAbilities = await db.table('abilities').toArray();
      // Ensure the result is an array and each element has the correct properties
      return allAbilities
        .filter(ability => ability && typeof ability === 'object')
        .filter(ability => ability.isUnlocked === true);
    } catch (err) {
      console.error('Error querying unlocked abilities:', err);
      // If query fails, return empty array
      return [];
    }
  } catch (err) {
    console.error('Error in getUnlockedPandaAbilities:', err);
    return [];
  }
}

/**
 * Get available panda abilities (unlocked and not on cooldown)
 */
export async function getAvailablePandaAbilities(): Promise<PandaAbilityRecord[]> {
  const now = new Date();
  const unlockedAbilities = await getUnlockedPandaAbilities();

  return unlockedAbilities.filter(ability => {
    // Passive abilities are always available
    if (ability.type === AbilityType.PASSIVE) {
      return true;
    }

    // Active or ultimate abilities need to check cooldown time
    if (ability.lastUsedAt && ability.cooldownMinutes) {
      const cooldownEndTime = new Date(ability.lastUsedAt);
      cooldownEndTime.setMinutes(cooldownEndTime.getMinutes() + ability.cooldownMinutes);

      return now >= cooldownEndTime;
    }

    return true;
  });
}

/**
 * Check and unlock panda abilities
 * Unlock abilities based on the current panda level
 * @param currentLevel Current panda level
 */
export async function checkAndUnlockAbilities(currentLevel: number): Promise<PandaAbilityRecord[]> {
  const abilities = await getAllPandaAbilities();
  const newlyUnlocked: PandaAbilityRecord[] = [];

  for (const ability of abilities) {
    if (!ability.isUnlocked && ability.requiredLevel <= currentLevel) {
      // Unlock ability
      const now = new Date();
      await db.table('abilities').update(ability.id!, {
        isUnlocked: true,
        unlockDate: now
      });

      // Add to newly unlocked list
      newlyUnlocked.push({
        ...ability,
        isUnlocked: true,
        unlockDate: now
      });
    }
  }

  return newlyUnlocked;
}

/**
 * Activate panda ability
 * @param abilityId ID of the ability to activate
 */
export async function activateAbility(abilityId: number): Promise<PandaAbilityRecord> {
  const ability = await db.table('abilities').get(abilityId);

  if (!ability) {
    throw new Error(`Ability with id ${abilityId} not found`);
  }

  if (!ability.isUnlocked) {
    throw new Error(`Ability with id ${abilityId} is not unlocked yet`);
  }

  // Passive abilities don't need activation
  if (ability.type === AbilityType.PASSIVE) {
    return ability;
  }

  // Check cooldown time
  if (ability.lastUsedAt && ability.cooldownMinutes) {
    const now = new Date();
    const cooldownEndTime = new Date(ability.lastUsedAt);
    cooldownEndTime.setMinutes(cooldownEndTime.getMinutes() + ability.cooldownMinutes);

    if (now < cooldownEndTime) {
      throw new Error(`Ability with id ${abilityId} is still in cooldown`);
    }
  }

  // Activate ability
  const now = new Date();
  const updatedAbility = {
    ...ability,
    isActive: true,
    lastUsedAt: now
  };

  await db.table('abilities').update(abilityId, updatedAbility);
  return updatedAbility;
}

/**
 * Get ability effect description
 * @param effectType Ability effect type
 */
export function getAbilityEffectDescription(effectType: AbilityEffectType): string {
  switch (effectType) {
    case AbilityEffectType.EXPERIENCE_BOOST:
      return 'Experience Boost';
    case AbilityEffectType.ENERGY_BOOST:
      return 'Energy Boost';
    case AbilityEffectType.TASK_EFFICIENCY:
      return 'Task Efficiency Boost';
    case AbilityEffectType.REWARD_BOOST:
      return 'Reward Boost';
    case AbilityEffectType.MOOD_STABILIZER:
      return 'Mood Stabilizer';
    case AbilityEffectType.TIME_EXTENSION:
      return 'Time Extension';
    case AbilityEffectType.FOCUS_ENHANCEMENT:
      return 'Focus Enhancement';
    case AbilityEffectType.INSPIRATION:
      return 'Inspiration';
    case AbilityEffectType.RESILIENCE:
      return 'Resilience';
    case AbilityEffectType.WISDOM:
      return 'Wisdom';
    default:
      return 'Unknown Effect';
  }
}

/**
 * Get localized ability name
 * @param abilityKey The key of the ability (e.g., 'bambooHeart')
 * @param defaultName Default name to use if localized name is not found
 */
export async function getLocalizedAbilityName(abilityKey: string, defaultName: string): Promise<string> {
  const languageCode = localStorage.getItem('language') || 'en';
  try {
    // Query the database directly
    const label = await db.table('uiLabels')
      .where('[scopeKey+labelKey+languageCode]')
      .equals(['abilities', `${abilityKey}.name`, languageCode])
      .first();

    return label ? label.translatedText : defaultName;
  } catch (error) {
    console.error(`Error getting localized name for ability ${abilityKey}:`, error);
    return defaultName;
  }
}

/**
 * Get localized ability description
 * @param abilityKey The key of the ability (e.g., 'bambooHeart')
 * @param defaultDescription Default description to use if localized description is not found
 */
export async function getLocalizedAbilityDescription(abilityKey: string, defaultDescription: string): Promise<string> {
  const languageCode = localStorage.getItem('language') || 'en';
  try {
    // Query the database directly
    const label = await db.table('uiLabels')
      .where('[scopeKey+labelKey+languageCode]')
      .equals(['abilities', `${abilityKey}.description`, languageCode])
      .first();

    return label ? label.translatedText : defaultDescription;
  } catch (error) {
    console.error(`Error getting localized description for ability ${abilityKey}:`, error);
    return defaultDescription;
  }
}

/**
 * Get ability key from name
 * @param name The name of the ability
 */
export function getAbilityKeyFromName(name: string): string {
  const nameMap: Record<string, string> = {
    'Bamboo Heart': 'bambooHeart',
    'Panda Vitality': 'pandaVitality',
    'Bamboo Focus': 'bambooFocus',
    'Panda Wisdom': 'pandaWisdom',
    'Bamboo Master': 'bambooMaster',
    '竹林之心': 'bambooHeart',
    '熊猫活力': 'pandaVitality',
    '竹影专注': 'bambooFocus',
    '熊猫智慧': 'pandaWisdom',
    '竹林大师': 'bambooMaster'
  };

  return nameMap[name] || '';
}
</file>

<file path="src/services/pandaCustomizationService.ts">
// src/services/pandaCustomizationService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { StoreItemType } from './storeService';

// 熊猫装饰类型
export enum PandaAccessoryType {
  HAT = 'hat',               // 帽子
  GLASSES = 'glasses',       // 眼镜
  SCARF = 'scarf',           // 围巾
  PENDANT = 'pendant',       // 挂饰
  BACKGROUND = 'background', // 背景
  FRAME = 'frame',           // 边框
  EFFECT = 'effect'          // 特效
}

// 熊猫装饰记录类型
export interface PandaAccessoryRecord {
  id?: number;
  name: string;
  type: PandaAccessoryType;
  description: string;
  imagePath: string;
  overlayPath?: string; // 叠加图层路径
  isEquipped: boolean;
  isOwned: boolean;
  obtainedAt?: Date;
  storeItemId?: number;
  rarity: string;
  themeType: string; // 中国风主题类型：传统、现代、节日等
}

// 熊猫环境记录类型
export interface PandaEnvironmentRecord {
  id?: number;
  name: string;
  description: string;
  backgroundPath: string;
  foregroundPath?: string;
  ambientSound?: string;
  isActive: boolean;
  isOwned: boolean;
  obtainedAt?: Date;
  storeItemId?: number;
  rarity: string;
  themeType: string; // 中国风主题类型：园林、山水、竹林等
  interactiveElements?: PandaEnvironmentElement[];
}

// 环境互动元素类型
export interface PandaEnvironmentElement {
  id: string;
  name: string;
  type: string;
  position: { x: number; y: number };
  size: { width: number; height: number };
  imagePath: string;
  animationPath?: string;
  interactionType: 'click' | 'hover' | 'drag';
  interactionEffect: string;
  soundEffect?: string;
}

// 默认熊猫装饰
const DEFAULT_ACCESSORIES: PandaAccessoryRecord[] = [
  {
    name: '竹叶帽',
    type: PandaAccessoryType.HAT,
    description: '用竹叶编织的简单帽子，清新自然',
    imagePath: '/assets/accessories/bamboo-hat.svg',
    isEquipped: false,
    isOwned: true,
    obtainedAt: new Date(),
    rarity: 'common',
    themeType: '传统'
  },
  {
    name: '红丝带',
    type: PandaAccessoryType.SCARF,
    description: '象征好运的红丝带，为熊猫带来喜气',
    imagePath: '/assets/accessories/red-ribbon.svg',
    isEquipped: false,
    isOwned: true,
    obtainedAt: new Date(),
    rarity: 'common',
    themeType: '传统'
  },
  {
    name: '金框',
    type: PandaAccessoryType.FRAME,
    description: '华丽的金色边框，彰显尊贵',
    imagePath: '/assets/accessories/gold-frame.svg',
    isEquipped: false,
    isOwned: true,
    obtainedAt: new Date(),
    rarity: 'rare',
    themeType: '传统'
  }
];

// 默认熊猫环境
const DEFAULT_ENVIRONMENTS: PandaEnvironmentRecord[] = [
  {
    name: '竹林小径',
    description: '宁静的竹林小径，熊猫的最爱',
    backgroundPath: '/assets/environments/bamboo-path.svg',
    ambientSound: '/assets/sounds/bamboo-forest.mp3',
    isActive: true,
    isOwned: true,
    obtainedAt: new Date(),
    rarity: 'common',
    themeType: '竹林',
    interactiveElements: [
      {
        id: 'bamboo1',
        name: '竹子',
        type: 'plant',
        position: { x: 20, y: 50 },
        size: { width: 30, height: 100 },
        imagePath: '/assets/environments/elements/bamboo.svg',
        animationPath: '/assets/environments/animations/bamboo-sway.json',
        interactionType: 'click',
        interactionEffect: 'sway',
        soundEffect: '/assets/sounds/bamboo-rustle.mp3'
      },
      {
        id: 'butterfly1',
        name: '蝴蝶',
        type: 'animal',
        position: { x: 70, y: 30 },
        size: { width: 20, height: 20 },
        imagePath: '/assets/environments/elements/butterfly.svg',
        animationPath: '/assets/environments/animations/butterfly-flutter.json',
        interactionType: 'hover',
        interactionEffect: 'flutter',
        soundEffect: '/assets/sounds/butterfly-wings.mp3'
      }
    ]
  },
  {
    name: '中式园林',
    description: '精致的中式园林，亭台楼阁，山水相依',
    backgroundPath: '/assets/environments/chinese-garden.svg',
    ambientSound: '/assets/sounds/garden-birds.mp3',
    isActive: false,
    isOwned: true,
    obtainedAt: new Date(),
    rarity: 'uncommon',
    themeType: '园林',
    interactiveElements: [
      {
        id: 'pavilion1',
        name: '亭子',
        type: 'structure',
        position: { x: 60, y: 40 },
        size: { width: 50, height: 60 },
        imagePath: '/assets/environments/elements/pavilion.svg',
        interactionType: 'click',
        interactionEffect: 'glow',
        soundEffect: '/assets/sounds/wind-chimes.mp3'
      },
      {
        id: 'koi1',
        name: '锦鲤',
        type: 'animal',
        position: { x: 30, y: 70 },
        size: { width: 25, height: 15 },
        imagePath: '/assets/environments/elements/koi.svg',
        animationPath: '/assets/environments/animations/koi-swim.json',
        interactionType: 'hover',
        interactionEffect: 'swim',
        soundEffect: '/assets/sounds/water-splash.mp3'
      }
    ]
  }
];

/**
 * 初始化熊猫定制系统
 */
export async function initializePandaCustomization(): Promise<void> {
  // 检查装饰是否已初始化
  const accessories = await db.table('pandaAccessories').toArray();
  if (accessories.length === 0) {
    await db.table('pandaAccessories').bulkAdd(DEFAULT_ACCESSORIES);
  }

  // 检查环境是否已初始化
  const environments = await db.table('pandaEnvironments').toArray();
  if (environments.length === 0) {
    await db.table('pandaEnvironments').bulkAdd(DEFAULT_ENVIRONMENTS);
  }
}

/**
 * 获取所有熊猫装饰
 */
export async function getAllAccessories(): Promise<PandaAccessoryRecord[]> {
  return db.table('pandaAccessories').toArray();
}

/**
 * 获取已拥有的熊猫装饰
 */
export async function getOwnedAccessories(): Promise<PandaAccessoryRecord[]> {
  return db.table('pandaAccessories')
    .filter(accessory => accessory.isOwned === true)
    .toArray();
}

/**
 * 获取已装备的熊猫装饰
 */
export async function getEquippedAccessories(): Promise<PandaAccessoryRecord[]> {
  return db.table('pandaAccessories')
    .filter(accessory => accessory.isEquipped === true)
    .toArray();
}

/**
 * 装备熊猫装饰
 * @param accessoryId 装饰ID
 */
export async function equipAccessory(accessoryId: number): Promise<PandaAccessoryRecord> {
  const accessory = await db.table('pandaAccessories').get(accessoryId);

  if (!accessory) {
    throw new Error(`Accessory with id ${accessoryId} not found`);
  }

  if (!accessory.isOwned) {
    throw new Error(`Accessory with id ${accessoryId} is not owned`);
  }

  // 先取消同类型的其他装饰
  const sameTypeAccessories = await db.table('pandaAccessories')
    .where('type')
    .equals(accessory.type)
    .filter(item => item.isEquipped === true)
    .toArray();

  for (const item of sameTypeAccessories) {
    await db.table('pandaAccessories').update(item.id!, { isEquipped: false });
    await addSyncItem('pandaAccessories', 'update', { ...item, isEquipped: false });
  }

  // 装备新装饰
  const updatedAccessory = { ...accessory, isEquipped: true };
  await db.table('pandaAccessories').update(accessoryId, updatedAccessory);
  await addSyncItem('pandaAccessories', 'update', updatedAccessory);

  return updatedAccessory;
}

/**
 * 取消装备熊猫装饰
 * @param accessoryId 装饰ID
 */
export async function unequipAccessory(accessoryId: number): Promise<PandaAccessoryRecord> {
  const accessory = await db.table('pandaAccessories').get(accessoryId);

  if (!accessory) {
    throw new Error(`Accessory with id ${accessoryId} not found`);
  }

  const updatedAccessory = { ...accessory, isEquipped: false };
  await db.table('pandaAccessories').update(accessoryId, updatedAccessory);
  await addSyncItem('pandaAccessories', 'update', updatedAccessory);

  return updatedAccessory;
}

/**
 * 添加新的熊猫装饰
 * @param accessory 装饰数据
 */
export async function addAccessory(accessory: Omit<PandaAccessoryRecord, 'id'>): Promise<PandaAccessoryRecord> {
  const id = await db.table('pandaAccessories').add(accessory);
  const newAccessory = { ...accessory, id: id as number };
  await addSyncItem('pandaAccessories', 'create', newAccessory);
  return newAccessory;
}

/**
 * 获取所有熊猫环境
 */
export async function getAllEnvironments(): Promise<PandaEnvironmentRecord[]> {
  return db.table('pandaEnvironments').toArray();
}

/**
 * 获取已拥有的熊猫环境
 */
export async function getOwnedEnvironments(): Promise<PandaEnvironmentRecord[]> {
  return db.table('pandaEnvironments')
    .filter(environment => environment.isOwned === true)
    .toArray();
}

/**
 * 获取当前激活的熊猫环境
 */
export async function getActiveEnvironment(): Promise<PandaEnvironmentRecord | undefined> {
  return db.table('pandaEnvironments')
    .filter(environment => environment.isActive === true)
    .first();
}

/**
 * 激活熊猫环境
 * @param environmentId 环境ID
 */
export async function activateEnvironment(environmentId: number): Promise<PandaEnvironmentRecord> {
  const environment = await db.table('pandaEnvironments').get(environmentId);

  if (!environment) {
    throw new Error(`Environment with id ${environmentId} not found`);
  }

  if (!environment.isOwned) {
    throw new Error(`Environment with id ${environmentId} is not owned`);
  }

  // 先取消其他环境的激活状态
  const activeEnvironments = await db.table('pandaEnvironments')
    .filter(environment => environment.isActive === true)
    .toArray();

  for (const item of activeEnvironments) {
    await db.table('pandaEnvironments').update(item.id!, { isActive: false });
    await addSyncItem('pandaEnvironments', 'update', { ...item, isActive: false });
  }

  // 激活新环境
  const updatedEnvironment = { ...environment, isActive: true };
  await db.table('pandaEnvironments').update(environmentId, updatedEnvironment);
  await addSyncItem('pandaEnvironments', 'update', updatedEnvironment);

  return updatedEnvironment;
}

/**
 * 添加新的熊猫环境
 * @param environment 环境数据
 */
export async function addEnvironment(environment: Omit<PandaEnvironmentRecord, 'id'>): Promise<PandaEnvironmentRecord> {
  const id = await db.table('pandaEnvironments').add(environment);
  const newEnvironment = { ...environment, id: id as number };
  await addSyncItem('pandaEnvironments', 'create', newEnvironment);
  return newEnvironment;
}

/**
 * 从商店购买装饰或环境后添加到用户拥有的物品中
 * @param storeItemId 商店物品ID
 * @param itemType 物品类型
 * @param itemData 物品数据
 */
export async function addCustomizationFromStore(
  storeItemId: number,
  itemType: StoreItemType,
  itemData: any
): Promise<void> {
  const now = new Date();

  if (itemType === StoreItemType.ACCESSORY) {
    // 添加装饰
    await addAccessory({
      name: itemData.name,
      type: itemData.accessoryType,
      description: itemData.description,
      imagePath: itemData.imagePath,
      overlayPath: itemData.overlayPath,
      isEquipped: false,
      isOwned: true,
      obtainedAt: now,
      storeItemId,
      rarity: itemData.rarity,
      themeType: itemData.themeType
    });
  } else if (itemType === StoreItemType.BACKGROUND) {
    // 添加环境
    await addEnvironment({
      name: itemData.name,
      description: itemData.description,
      backgroundPath: itemData.backgroundPath,
      foregroundPath: itemData.foregroundPath,
      ambientSound: itemData.ambientSound,
      isActive: false,
      isOwned: true,
      obtainedAt: now,
      storeItemId,
      rarity: itemData.rarity,
      themeType: itemData.themeType,
      interactiveElements: itemData.interactiveElements
    });
  }
}
</file>

<file path="src/services/queryClient.ts">
// src/services/queryClient.ts
import { QueryClient } from '@tanstack/react-query';

// 创建 QueryClient 实例并导出，以便其他模块使用
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 2, // 2 minutes
      refetchOnWindowFocus: false, // Personal preference for demos
      retry: 1, // Retry failed queries once
    },
  },
});
</file>

<file path="src/services/reflectionService.ts">
// src/services/reflectionService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { TaskRecord, TaskStatus } from './taskService';
import { getPandaMood, updatePandaMood } from './pandaStateService';
import type { PandaMood, EnergyLevel } from '@/components/game/PandaAvatar';

// 反思记录类型
export interface ReflectionRecord {
  id?: number;
  userId: string;
  taskId?: number;
  mood: string;
  reflection: string;
  action: string;
  createdAt: Date;
  completedAt?: Date;
  isCompleted: boolean;
  tags?: string[];
}

// 反思触发类型
export enum ReflectionTriggerType {
  MOOD_CHANGE = 'mood_change',
  TASK_FAILURE = 'task_failure',
  DAILY_REFLECTION = 'daily_reflection',
  WEEKLY_REVIEW = 'weekly_review',
  MANUAL = 'manual'
}

// 反思触发记录类型
export interface ReflectionTriggerRecord {
  id?: number;
  userId: string;
  type: ReflectionTriggerType;
  createdAt: Date;
  isViewed: boolean;
  isCompleted: boolean;
  data?: any;
}

// 情绪记录类型
export interface MoodRecord {
  id?: number;
  userId: string;
  mood: PandaMood;
  intensity: number;
  note?: string;
  createdAt: Date;
  tags?: string[];
}

// 情绪类型
export enum MoodType {
  HAPPY = 'happy',
  CONTENT = 'content',
  NEUTRAL = 'neutral',
  SAD = 'sad',
  ANXIOUS = 'anxious',
  STRESSED = 'stressed',
  TIRED = 'tired',
  ENERGETIC = 'energetic',
  MOTIVATED = 'motivated',
  FRUSTRATED = 'frustrated',
  ANGRY = 'angry',
  CALM = 'calm'
}

// 情绪强度（1-5）
export type MoodIntensity = 1 | 2 | 3 | 4 | 5;

/**
 * 创建反思记录
 * @param reflection 反思数据
 */
export async function createReflection(
  reflection: Omit<ReflectionRecord, 'id' | 'createdAt' | 'isCompleted'>
): Promise<ReflectionRecord> {
  const now = new Date();

  const newReflection: ReflectionRecord = {
    ...reflection,
    createdAt: now,
    isCompleted: false
  };

  // 添加到数据库
  const id = await db.table('reflections').add(newReflection);
  const createdReflection = { ...newReflection, id: id as number };

  // 添加到同步队列
  await addSyncItem('reflections', 'create', createdReflection);

  return createdReflection;
}

/**
 * 完成反思记录
 * @param id 反思记录ID
 * @param action 采取的行动
 */
export async function completeReflection(
  id: number,
  action: string
): Promise<ReflectionRecord> {
  const reflection = await db.table('reflections').get(id);
  if (!reflection) {
    throw new Error(`Reflection with id ${id} not found`);
  }

  const now = new Date();
  const updatedReflection = {
    ...reflection,
    action,
    completedAt: now,
    isCompleted: true
  };

  // 更新数据库
  await db.table('reflections').update(id, updatedReflection);

  // 添加到同步队列
  await addSyncItem('reflections', 'update', updatedReflection);

  return updatedReflection;
}

/**
 * 获取用户的反思记录
 * @param userId 用户ID
 * @param limit 限制数量
 */
export async function getUserReflections(
  userId: string,
  limit?: number
): Promise<ReflectionRecord[]> {
  let query = db.table('reflections')
    .where('userId')
    .equals(userId)
    .reverse();

  if (limit) {
    query = query.limit(limit);
  }

  return query.sortBy('createdAt');
}

/**
 * 创建反思触发记录
 * @param trigger 触发数据
 */
export async function createReflectionTrigger(
  trigger: Omit<ReflectionTriggerRecord, 'id' | 'createdAt' | 'isViewed' | 'isCompleted'>
): Promise<ReflectionTriggerRecord> {
  const now = new Date();

  const newTrigger: ReflectionTriggerRecord = {
    ...trigger,
    createdAt: now,
    isViewed: false,
    isCompleted: false
  };

  // 添加到数据库
  const id = await db.table('reflectionTriggers').add(newTrigger);
  const createdTrigger = { ...newTrigger, id: id as number };

  // 添加到同步队列
  await addSyncItem('reflectionTriggers', 'create', createdTrigger);

  return createdTrigger;
}

/**
 * 获取用户的未查看反思触发记录
 * @param userId 用户ID
 */
export async function getUnviewedReflectionTriggers(
  userId: string
): Promise<ReflectionTriggerRecord[]> {
  return db.table('reflectionTriggers')
    .where('userId')
    .equals(userId)
    .and(trigger => !trigger.isViewed)
    .sortBy('createdAt');
}

/**
 * 标记反思触发记录为已查看
 * @param id 触发记录ID
 */
export async function markTriggerAsViewed(
  id: number
): Promise<ReflectionTriggerRecord> {
  const trigger = await db.table('reflectionTriggers').get(id);
  if (!trigger) {
    throw new Error(`Reflection trigger with id ${id} not found`);
  }

  const updatedTrigger = {
    ...trigger,
    isViewed: true
  };

  // 更新数据库
  await db.table('reflectionTriggers').update(id, updatedTrigger);

  // 添加到同步队列
  await addSyncItem('reflectionTriggers', 'update', updatedTrigger);

  return updatedTrigger;
}

/**
 * 标记反思触发记录为已完成
 * @param id 触发记录ID
 */
export async function markTriggerAsCompleted(
  id: number
): Promise<ReflectionTriggerRecord> {
  const trigger = await db.table('reflectionTriggers').get(id);
  if (!trigger) {
    throw new Error(`Reflection trigger with id ${id} not found`);
  }

  const updatedTrigger = {
    ...trigger,
    isViewed: true,
    isCompleted: true
  };

  // 更新数据库
  await db.table('reflectionTriggers').update(id, updatedTrigger);

  // 添加到同步队列
  await addSyncItem('reflectionTriggers', 'update', updatedTrigger);

  return updatedTrigger;
}

/**
 * 记录用户情绪
 * @param mood 情绪数据
 */
export async function recordMood(
  mood: Omit<MoodRecord, 'id' | 'createdAt'>
): Promise<MoodRecord> {
  const now = new Date();

  const newMood: MoodRecord = {
    ...mood,
    createdAt: now
  };

  // 添加到数据库
  const id = await db.table('moods').add(newMood);
  const createdMood = { ...newMood, id: id as number };

  // 添加到同步队列
  await addSyncItem('moods', 'create', createdMood);

  // 更新熊猫心情
  await updatePandaMood(mood.mood);

  // 检查是否需要触发反思
  await checkMoodTrigger(mood.userId, mood.mood, mood.intensity);

  return createdMood;
}

/**
 * 获取用户的情绪记录
 * @param userId 用户ID
 * @param limit 限制数量
 */
export async function getUserMoods(
  userId: string,
  limit?: number
): Promise<MoodRecord[]> {
  let query = db.table('moods')
    .where('userId')
    .equals(userId)
    .reverse();

  if (limit) {
    query = query.limit(limit);
  }

  return query.sortBy('createdAt');
}

/**
 * 检查情绪是否需要触发反思
 * @param userId 用户ID
 * @param mood 情绪
 * @param intensity 强度
 */
async function checkMoodTrigger(
  userId: string,
  mood: string,
  intensity: number
): Promise<void> {
  // 如果是负面情绪且强度较高，触发反思
  if (
    (mood === MoodType.SAD ||
     mood === MoodType.ANXIOUS ||
     mood === MoodType.STRESSED ||
     mood === MoodType.FRUSTRATED ||
     mood === MoodType.ANGRY) &&
    intensity >= 4
  ) {
    await createReflectionTrigger({
      userId,
      type: ReflectionTriggerType.MOOD_CHANGE,
      data: { mood, intensity }
    });
  }
}

/**
 * 检查任务失败是否需要触发反思
 * @param userId 用户ID
 * @param task 任务
 */
export async function checkTaskFailureTrigger(
  userId: string,
  task: TaskRecord
): Promise<void> {
  // 如果任务已过期且未完成，触发反思
  if (
    task.status !== TaskStatus.COMPLETED &&
    task.dueDate &&
    new Date(task.dueDate) < new Date()
  ) {
    await createReflectionTrigger({
      userId,
      type: ReflectionTriggerType.TASK_FAILURE,
      data: { taskId: task.id, taskTitle: task.title }
    });
  }
}

/**
 * 检查是否需要触发每日反思
 * @param userId 用户ID
 */
export async function checkDailyReflectionTrigger(
  userId: string
): Promise<void> {
  // 获取最近的每日反思触发记录
  const recentTriggers = await db.table('reflectionTriggers')
    .where('userId')
    .equals(userId)
    .and(trigger => trigger.type === ReflectionTriggerType.DAILY_REFLECTION)
    .reverse()
    .sortBy('createdAt');

  // 如果没有记录或最近的记录是昨天之前的，触发每日反思
  if (
    recentTriggers.length === 0 ||
    isYesterdayOrBefore(recentTriggers[0].createdAt)
  ) {
    await createReflectionTrigger({
      userId,
      type: ReflectionTriggerType.DAILY_REFLECTION,
      data: {}
    });
  }
}

/**
 * 检查是否需要触发每周回顾
 * @param userId 用户ID
 */
export async function checkWeeklyReviewTrigger(
  userId: string
): Promise<void> {
  // 获取最近的每周回顾触发记录
  const recentTriggers = await db.table('reflectionTriggers')
    .where('userId')
    .equals(userId)
    .and(trigger => trigger.type === ReflectionTriggerType.WEEKLY_REVIEW)
    .reverse()
    .sortBy('createdAt');

  // 如果没有记录或最近的记录是一周之前的，触发每周回顾
  if (
    recentTriggers.length === 0 ||
    isWeekOrBefore(recentTriggers[0].createdAt)
  ) {
    await createReflectionTrigger({
      userId,
      type: ReflectionTriggerType.WEEKLY_REVIEW,
      data: {}
    });
  }
}

/**
 * 判断日期是否是昨天或之前
 * @param date 日期
 */
function isYesterdayOrBefore(date: Date): boolean {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  yesterday.setHours(0, 0, 0, 0);

  return new Date(date) < yesterday;
}

/**
 * 判断日期是否是一周或之前
 * @param date 日期
 */
function isWeekOrBefore(date: Date): boolean {
  const weekAgo = new Date();
  weekAgo.setDate(weekAgo.getDate() - 7);
  weekAgo.setHours(0, 0, 0, 0);

  return new Date(date) < weekAgo;
}
</file>

<file path="src/services/socialChallengeService.ts">
// src/services/socialChallengeService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { ChallengeDifficulty, ChallengeStatus } from './challengeService';

// 社交挑战类型
export enum SocialChallengeType {
  COOPERATIVE = 'cooperative', // 合作型
  COMPETITIVE = 'competitive', // 竞争型
  TEAM = 'team' // 团队型
}

// 社交挑战记录类型
export interface SocialChallengeRecord {
  id?: number;
  title: string;
  description: string;
  type: SocialChallengeType;
  difficulty: ChallengeDifficulty;
  status: ChallengeStatus;
  creatorId: string;
  participantIds: string[];
  maxParticipants: number;
  progress: number;
  startDate: Date;
  endDate?: Date;
  createdAt: Date;
  updatedAt: Date;
  iconPath?: string;
  rewards?: any[];
  isPublic: boolean;
  inviteCode?: string;
  milestones?: SocialChallengeMilestone[];
}

// 社交挑战里程碑类型
export interface SocialChallengeMilestone {
  id?: number;
  challengeId: number;
  title: string;
  description?: string;
  targetValue: number;
  currentValue: number;
  isCompleted: boolean;
  completedAt?: Date;
  order: number;
}

// 社交挑战参与记录类型
export interface SocialChallengeParticipation {
  id?: number;
  challengeId: number;
  userId: string;
  joinedAt: Date;
  status: 'active' | 'completed' | 'abandoned';
  contribution: number;
  lastContributedAt?: Date;
}

/**
 * 创建社交挑战
 * @param challenge 社交挑战数据
 */
export async function createSocialChallenge(
  challenge: Omit<SocialChallengeRecord, 'id' | 'createdAt' | 'updatedAt' | 'progress' | 'participantIds' | 'inviteCode'>
): Promise<SocialChallengeRecord> {
  const now = new Date();
  
  // 生成邀请码
  const inviteCode = generateInviteCode();
  
  const newChallenge: SocialChallengeRecord = {
    ...challenge,
    participantIds: [challenge.creatorId], // 创建者自动成为参与者
    progress: 0,
    createdAt: now,
    updatedAt: now,
    inviteCode
  };
  
  // 添加到数据库
  const id = await db.table('socialChallenges').add(newChallenge);
  const createdChallenge = { ...newChallenge, id: id as number };
  
  // 添加到同步队列
  await addSyncItem('socialChallenges', 'create', createdChallenge);
  
  // 创建参与记录
  await createParticipation(id as number, challenge.creatorId);
  
  return createdChallenge;
}

/**
 * 获取社交挑战
 * @param id 社交挑战ID
 */
export async function getSocialChallenge(id: number): Promise<SocialChallengeRecord | null> {
  return db.table('socialChallenges').get(id);
}

/**
 * 获取所有社交挑战
 * @param filter 过滤条件
 */
export async function getAllSocialChallenges(
  filter?: Partial<SocialChallengeRecord>
): Promise<SocialChallengeRecord[]> {
  let collection = db.table('socialChallenges').toCollection();
  
  if (filter) {
    collection = collection.filter(challenge => {
      for (const key in filter) {
        if (filter[key as keyof typeof filter] !== undefined) {
          if (challenge[key as keyof typeof challenge] !== filter[key as keyof typeof filter]) {
            return false;
          }
        }
      }
      return true;
    });
  }
  
  return collection.sortBy('createdAt');
}

/**
 * 获取用户参与的社交挑战
 * @param userId 用户ID
 */
export async function getUserSocialChallenges(userId: string): Promise<SocialChallengeRecord[]> {
  return db.table('socialChallenges')
    .filter(challenge => challenge.participantIds.includes(userId))
    .sortBy('createdAt');
}

/**
 * 获取公开的社交挑战
 */
export async function getPublicSocialChallenges(): Promise<SocialChallengeRecord[]> {
  return db.table('socialChallenges')
    .filter(challenge => 
      challenge.isPublic && 
      challenge.status === ChallengeStatus.ACTIVE &&
      challenge.participantIds.length < challenge.maxParticipants
    )
    .sortBy('createdAt');
}

/**
 * 更新社交挑战
 * @param id 社交挑战ID
 * @param updates 更新数据
 */
export async function updateSocialChallenge(
  id: number,
  updates: Partial<Omit<SocialChallengeRecord, 'id' | 'createdAt'>>
): Promise<SocialChallengeRecord> {
  const challenge = await db.table('socialChallenges').get(id);
  if (!challenge) {
    throw new Error(`Social challenge with id ${id} not found`);
  }
  
  const updatedChallenge = {
    ...challenge,
    ...updates,
    updatedAt: new Date()
  };
  
  // 更新数据库
  await db.table('socialChallenges').update(id, updatedChallenge);
  
  // 添加到同步队列
  await addSyncItem('socialChallenges', 'update', updatedChallenge);
  
  return updatedChallenge;
}

/**
 * 加入社交挑战
 * @param challengeId 社交挑战ID
 * @param userId 用户ID
 * @param inviteCode 邀请码（如果是非公开挑战）
 */
export async function joinSocialChallenge(
  challengeId: number,
  userId: string,
  inviteCode?: string
): Promise<SocialChallengeRecord> {
  const challenge = await db.table('socialChallenges').get(challengeId);
  if (!challenge) {
    throw new Error(`Social challenge with id ${challengeId} not found`);
  }
  
  // 检查是否已经是参与者
  if (challenge.participantIds.includes(userId)) {
    return challenge;
  }
  
  // 检查是否已达到最大参与人数
  if (challenge.participantIds.length >= challenge.maxParticipants) {
    throw new Error('Challenge has reached maximum number of participants');
  }
  
  // 检查邀请码（如果是非公开挑战）
  if (!challenge.isPublic && challenge.inviteCode !== inviteCode) {
    throw new Error('Invalid invite code');
  }
  
  // 更新参与者列表
  const updatedParticipantIds = [...challenge.participantIds, userId];
  const updatedChallenge = await updateSocialChallenge(challengeId, {
    participantIds: updatedParticipantIds
  });
  
  // 创建参与记录
  await createParticipation(challengeId, userId);
  
  return updatedChallenge;
}

/**
 * 离开社交挑战
 * @param challengeId 社交挑战ID
 * @param userId 用户ID
 */
export async function leaveSocialChallenge(
  challengeId: number,
  userId: string
): Promise<SocialChallengeRecord> {
  const challenge = await db.table('socialChallenges').get(challengeId);
  if (!challenge) {
    throw new Error(`Social challenge with id ${challengeId} not found`);
  }
  
  // 检查是否是参与者
  if (!challenge.participantIds.includes(userId)) {
    return challenge;
  }
  
  // 如果是创建者，不允许离开
  if (challenge.creatorId === userId) {
    throw new Error('Creator cannot leave the challenge');
  }
  
  // 更新参与者列表
  const updatedParticipantIds = challenge.participantIds.filter(id => id !== userId);
  const updatedChallenge = await updateSocialChallenge(challengeId, {
    participantIds: updatedParticipantIds
  });
  
  // 更新参与记录
  await updateParticipation(challengeId, userId, {
    status: 'abandoned'
  });
  
  return updatedChallenge;
}

/**
 * 创建参与记录
 * @param challengeId 社交挑战ID
 * @param userId 用户ID
 */
export async function createParticipation(
  challengeId: number,
  userId: string
): Promise<SocialChallengeParticipation> {
  const now = new Date();
  
  const participation: SocialChallengeParticipation = {
    challengeId,
    userId,
    joinedAt: now,
    status: 'active',
    contribution: 0
  };
  
  // 添加到数据库
  const id = await db.table('socialChallengeParticipations').add(participation);
  const createdParticipation = { ...participation, id: id as number };
  
  // 添加到同步队列
  await addSyncItem('socialChallengeParticipations', 'create', createdParticipation);
  
  return createdParticipation;
}

/**
 * 更新参与记录
 * @param challengeId 社交挑战ID
 * @param userId 用户ID
 * @param updates 更新数据
 */
export async function updateParticipation(
  challengeId: number,
  userId: string,
  updates: Partial<Omit<SocialChallengeParticipation, 'id' | 'challengeId' | 'userId' | 'joinedAt'>>
): Promise<SocialChallengeParticipation> {
  const participation = await db.table('socialChallengeParticipations')
    .filter(p => p.challengeId === challengeId && p.userId === userId)
    .first();
  
  if (!participation) {
    throw new Error(`Participation record not found for challenge ${challengeId} and user ${userId}`);
  }
  
  const updatedParticipation = {
    ...participation,
    ...updates
  };
  
  // 如果更新了贡献值，设置最后贡献时间
  if (updates.contribution !== undefined) {
    updatedParticipation.lastContributedAt = new Date();
  }
  
  // 更新数据库
  await db.table('socialChallengeParticipations').update(participation.id!, updatedParticipation);
  
  // 添加到同步队列
  await addSyncItem('socialChallengeParticipations', 'update', updatedParticipation);
  
  return updatedParticipation;
}

/**
 * 获取社交挑战的参与记录
 * @param challengeId 社交挑战ID
 */
export async function getChallengeParticipations(
  challengeId: number
): Promise<SocialChallengeParticipation[]> {
  return db.table('socialChallengeParticipations')
    .filter(p => p.challengeId === challengeId)
    .sortBy('joinedAt');
}

/**
 * 贡献社交挑战进度
 * @param challengeId 社交挑战ID
 * @param userId 用户ID
 * @param amount 贡献量
 */
export async function contributeToChallenge(
  challengeId: number,
  userId: string,
  amount: number
): Promise<SocialChallengeRecord> {
  const challenge = await db.table('socialChallenges').get(challengeId);
  if (!challenge) {
    throw new Error(`Social challenge with id ${challengeId} not found`);
  }
  
  // 检查是否是参与者
  if (!challenge.participantIds.includes(userId)) {
    throw new Error('User is not a participant of this challenge');
  }
  
  // 获取参与记录
  const participation = await db.table('socialChallengeParticipations')
    .filter(p => p.challengeId === challengeId && p.userId === userId)
    .first();
  
  if (!participation) {
    throw new Error(`Participation record not found for challenge ${challengeId} and user ${userId}`);
  }
  
  // 更新参与记录
  await updateParticipation(challengeId, userId, {
    contribution: participation.contribution + amount
  });
  
  // 更新挑战进度
  const newProgress = Math.min(100, challenge.progress + amount);
  const updatedChallenge = await updateSocialChallenge(challengeId, {
    progress: newProgress
  });
  
  // 如果进度达到100%，标记为已完成
  if (newProgress >= 100 && challenge.status !== ChallengeStatus.COMPLETED) {
    await updateSocialChallenge(challengeId, {
      status: ChallengeStatus.COMPLETED
    });
    
    // 更新所有活跃参与者的状态为已完成
    const participations = await getChallengeParticipations(challengeId);
    for (const p of participations) {
      if (p.status === 'active') {
        await updateParticipation(challengeId, p.userId, {
          status: 'completed'
        });
      }
    }
  }
  
  return updatedChallenge;
}

/**
 * 生成邀请码
 */
function generateInviteCode(): string {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for (let i = 0; i < 6; i++) {
    code += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return code;
}
</file>

<file path="src/services/storeService.ts">
// src/services/storeService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { ItemRecord, addItem } from './rewardService';

// 商店物品类型
export enum StoreItemType {
  AVATAR = 'avatar',           // 熊猫头像
  ACCESSORY = 'accessory',     // 熊猫配件
  BACKGROUND = 'background',   // 背景
  THEME = 'theme',             // 主题
  ABILITY = 'ability',         // 能力
  CONSUMABLE = 'consumable',   // 消耗品
  VIP = 'vip'                  // VIP会员
}

// 商店物品稀有度
export enum StoreItemRarity {
  COMMON = 'common',
  UNCOMMON = 'uncommon',
  RARE = 'rare',
  EPIC = 'epic',
  LEGENDARY = 'legendary'
}

// 商店物品价格类型
export enum PriceType {
  COINS = 'coins',             // 游戏内货币
  JADE = 'jade',               // 高级货币
  REAL_MONEY = 'real_money'    // 真实货币
}

// 商店物品记录类型
export interface StoreItemRecord {
  id?: number;
  name: string;
  description: string;
  type: StoreItemType;
  rarity: StoreItemRarity;
  price: number;
  priceType: PriceType;
  imagePath: string;
  isAvailable: boolean;
  isFeatured: boolean;
  isOnSale: boolean;
  salePrice?: number;
  saleEndDate?: Date;
  categoryId: number;
  createdAt: Date;
  updatedAt?: Date;
  vipRequired?: boolean;
  limitedQuantity?: number;
  remainingQuantity?: number;
  tags?: string[];
}

// 商店类别记录类型
export interface StoreCategoryRecord {
  id?: number;
  name: string;
  description: string;
  iconPath: string;
  order: number;
  isVisible: boolean;
  createdAt: Date;
  updatedAt?: Date;
}

// 购买记录类型
export interface PurchaseRecord {
  id?: number;
  userId: string;
  storeItemId: number;
  price: number;
  priceType: PriceType;
  purchaseDate: Date;
  transactionId?: string;
  isRefunded: boolean;
  refundDate?: Date;
}

// VIP订阅记录类型
export interface VipSubscriptionRecord {
  id?: number;
  userId: string;
  tier: number;
  startDate: Date;
  endDate?: Date;
  isActive: boolean;
  autoRenew: boolean;
  paymentMethod: string;
  transactionId?: string;
  createdAt: Date;
  updatedAt?: Date;
}

// 用户货币记录类型
export interface UserCurrencyRecord {
  id?: number;
  userId: string;
  coins: number;
  jade: number;
  lastUpdated: Date;
}

/**
 * 获取所有商店类别
 */
export async function getStoreCategories(): Promise<StoreCategoryRecord[]> {
  return db.table('storeCategories')
    .filter(category => category.isVisible === true)
    .sortBy('order');
}

/**
 * 获取商店类别
 * @param id 类别ID
 */
export async function getStoreCategory(id: number): Promise<StoreCategoryRecord | undefined> {
  return db.table('storeCategories').get(id);
}

/**
 * 获取商店物品
 * @param id 物品ID
 */
export async function getStoreItem(id: number): Promise<StoreItemRecord | undefined> {
  return db.table('storeItems').get(id);
}

/**
 * 获取类别的商店物品
 * @param categoryId 类别ID
 */
export async function getCategoryItems(categoryId: number): Promise<StoreItemRecord[]> {
  return db.table('storeItems')
    .where('categoryId')
    .equals(categoryId)
    .and(item => item.isAvailable)
    .toArray();
}

/**
 * 获取特色商店物品
 */
export async function getFeaturedItems(): Promise<StoreItemRecord[]> {
  return db.table('storeItems')
    .filter(item => item.isFeatured === true && item.isAvailable === true)
    .toArray();
}

/**
 * 获取促销商店物品
 */
export async function getSaleItems(): Promise<StoreItemRecord[]> {
  const now = new Date();
  return db.table('storeItems')
    .filter(item =>
      item.isOnSale === true &&
      item.isAvailable === true &&
      (!item.saleEndDate || new Date(item.saleEndDate) > now)
    )
    .toArray();
}

/**
 * 获取VIP专属商店物品
 */
export async function getVipItems(): Promise<StoreItemRecord[]> {
  return db.table('storeItems')
    .filter(item => item.vipRequired === true && item.isAvailable === true)
    .toArray();
}

/**
 * 获取用户货币
 * @param userId 用户ID
 */
export async function getUserCurrency(userId: string): Promise<UserCurrencyRecord | null> {
  const currency = await db.table('userCurrencies')
    .where('userId')
    .equals(userId)
    .first();

  if (!currency) {
    // 如果用户没有货币记录，创建一个新的
    const newCurrency: UserCurrencyRecord = {
      userId,
      coins: 0,
      jade: 0,
      lastUpdated: new Date()
    };

    const id = await db.table('userCurrencies').add(newCurrency);
    return { ...newCurrency, id: id as number };
  }

  return currency;
}

/**
 * 更新用户货币
 * @param userId 用户ID
 * @param coins 金币数量变化（可以是正数或负数）
 * @param jade 玉石数量变化（可以是正数或负数）
 */
export async function updateUserCurrency(
  userId: string,
  coins: number = 0,
  jade: number = 0
): Promise<UserCurrencyRecord> {
  const currency = await getUserCurrency(userId);
  if (!currency) {
    throw new Error(`User currency not found for user ${userId}`);
  }

  const updatedCurrency: UserCurrencyRecord = {
    ...currency,
    coins: Math.max(0, currency.coins + coins),
    jade: Math.max(0, currency.jade + jade),
    lastUpdated: new Date()
  };

  // 更新数据库
  await db.table('userCurrencies').update(currency.id!, updatedCurrency);

  // 添加到同步队列
  await addSyncItem('userCurrencies', 'update', updatedCurrency);

  return updatedCurrency;
}

/**
 * 购买商店物品
 * @param userId 用户ID
 * @param storeItemId 商店物品ID
 */
export async function purchaseStoreItem(
  userId: string,
  storeItemId: number
): Promise<PurchaseRecord> {
  // 获取商店物品
  const storeItem = await getStoreItem(storeItemId);
  if (!storeItem) {
    throw new Error(`Store item with id ${storeItemId} not found`);
  }

  // 检查物品是否可用
  if (!storeItem.isAvailable) {
    throw new Error(`Store item with id ${storeItemId} is not available`);
  }

  // 检查是否有足够的库存
  if (storeItem.limitedQuantity && storeItem.remainingQuantity !== undefined && storeItem.remainingQuantity <= 0) {
    throw new Error(`Store item with id ${storeItemId} is out of stock`);
  }

  // 获取用户货币
  const currency = await getUserCurrency(userId);
  if (!currency) {
    throw new Error(`User currency not found for user ${userId}`);
  }

  // 计算价格
  const price = storeItem.isOnSale && storeItem.salePrice !== undefined ? storeItem.salePrice : storeItem.price;

  // 检查用户是否有足够的货币
  if (storeItem.priceType === PriceType.COINS && currency.coins < price) {
    throw new Error('Not enough coins');
  }

  if (storeItem.priceType === PriceType.JADE && currency.jade < price) {
    throw new Error('Not enough jade');
  }

  // 扣除货币
  if (storeItem.priceType === PriceType.COINS) {
    await updateUserCurrency(userId, -price, 0);
  } else if (storeItem.priceType === PriceType.JADE) {
    await updateUserCurrency(userId, 0, -price);
  }

  // 更新库存
  if (storeItem.limitedQuantity && storeItem.remainingQuantity !== undefined) {
    await db.table('storeItems').update(storeItemId, {
      ...storeItem,
      remainingQuantity: storeItem.remainingQuantity - 1,
      updatedAt: new Date()
    });
  }

  // 创建购买记录
  const purchase: PurchaseRecord = {
    userId,
    storeItemId,
    price,
    priceType: storeItem.priceType,
    purchaseDate: new Date(),
    isRefunded: false
  };

  // 添加到数据库
  const id = await db.table('purchases').add(purchase);
  const createdPurchase = { ...purchase, id: id as number };

  // 添加到同步队列
  await addSyncItem('purchases', 'create', createdPurchase);

  // 添加物品到用户库存
  await addItem({
    type: storeItem.type,
    rarity: storeItem.rarity,
    quantity: 1,
    obtainedAt: new Date()
  });

  return createdPurchase;
}

/**
 * 获取用户的VIP订阅
 * @param userId 用户ID
 */
export async function getUserVipSubscription(userId: string): Promise<VipSubscriptionRecord | null> {
  return db.table('vipSubscriptions')
    .where('userId')
    .equals(userId)
    .and(sub => sub.isActive)
    .first();
}

/**
 * 检查用户是否是VIP
 * @param userId 用户ID
 */
export async function isUserVip(userId: string): Promise<boolean> {
  const subscription = await getUserVipSubscription(userId);
  if (!subscription) {
    return false;
  }

  // 检查订阅是否过期
  if (subscription.endDate && new Date(subscription.endDate) < new Date()) {
    // 更新订阅状态
    await db.table('vipSubscriptions').update(subscription.id!, {
      ...subscription,
      isActive: false,
      updatedAt: new Date()
    });
    return false;
  }

  return true;
}

/**
 * 激活VIP订阅
 * @param userId 用户ID
 * @param tier VIP等级
 * @param durationDays 订阅时长（天）
 * @param paymentMethod 支付方式
 * @param transactionId 交易ID
 */
export async function activateVipSubscription(
  userId: string,
  tier: number,
  durationDays: number,
  paymentMethod: string,
  transactionId?: string
): Promise<VipSubscriptionRecord> {
  // 检查用户是否已经有VIP订阅
  const existingSubscription = await getUserVipSubscription(userId);

  const now = new Date();
  const endDate = new Date(now);
  endDate.setDate(endDate.getDate() + durationDays);

  if (existingSubscription) {
    // 如果已经有订阅，延长订阅时间
    const updatedSubscription: VipSubscriptionRecord = {
      ...existingSubscription,
      tier: Math.max(existingSubscription.tier, tier), // 使用更高的等级
      endDate: existingSubscription.endDate && new Date(existingSubscription.endDate) > now
        ? new Date(new Date(existingSubscription.endDate).getTime() + durationDays * 24 * 60 * 60 * 1000)
        : endDate,
      isActive: true,
      updatedAt: now
    };

    // 更新数据库
    await db.table('vipSubscriptions').update(existingSubscription.id!, updatedSubscription);

    // 添加到同步队列
    await addSyncItem('vipSubscriptions', 'update', updatedSubscription);

    return updatedSubscription;
  } else {
    // 创建新的订阅
    const newSubscription: VipSubscriptionRecord = {
      userId,
      tier,
      startDate: now,
      endDate,
      isActive: true,
      autoRenew: false,
      paymentMethod,
      transactionId,
      createdAt: now,
      updatedAt: now
    };

    // 添加到数据库
    const id = await db.table('vipSubscriptions').add(newSubscription);
    const createdSubscription = { ...newSubscription, id: id as number };

    // 添加到同步队列
    await addSyncItem('vipSubscriptions', 'create', createdSubscription);

    return createdSubscription;
  }
}
</file>

<file path="src/services/subtaskService.ts">
// src/services/subtaskService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { TaskRecord, TaskStatus, updateTask } from './taskService';

// 子任务记录类型
export interface SubtaskRecord {
  id?: number;
  parentTaskId: number;
  title: string;
  description?: string;
  status: TaskStatus;
  order: number;
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
}

/**
 * 创建子任务
 * @param subtask 子任务数据
 */
export async function createSubtask(
  subtask: Omit<SubtaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status' | 'order'>
): Promise<SubtaskRecord> {
  // 获取父任务
  const parentTask = await db.table('tasks').get(subtask.parentTaskId);
  if (!parentTask) {
    throw new Error(`Parent task with id ${subtask.parentTaskId} not found`);
  }

  // 获取当前子任务数量，用于设置顺序
  const existingSubtasks = await getSubtasks(subtask.parentTaskId);
  const order = existingSubtasks.length;

  const now = new Date();
  const newSubtask: SubtaskRecord = {
    ...subtask,
    status: TaskStatus.TODO,
    order,
    createdAt: now,
    updatedAt: now
  };

  // 添加子任务到数据库
  const id = await db.table('subtasks').add(newSubtask);
  const createdSubtask = { ...newSubtask, id: id as number };

  // 添加到同步队列
  await addSyncItem('subtasks', 'create', createdSubtask);

  return createdSubtask;
}

/**
 * 获取任务的所有子任务
 * @param parentTaskId 父任务ID
 */
export async function getSubtasks(parentTaskId: number): Promise<SubtaskRecord[]> {
  return db.table('subtasks')
    .where('parentTaskId')
    .equals(parentTaskId)
    .sortBy('order');
}

/**
 * 更新子任务
 * @param id 子任务ID
 * @param updates 更新数据
 */
export async function updateSubtask(
  id: number,
  updates: Partial<Omit<SubtaskRecord, 'id' | 'parentTaskId' | 'createdAt'>>
): Promise<SubtaskRecord> {
  const subtask = await db.table('subtasks').get(id);
  if (!subtask) {
    throw new Error(`Subtask with id ${id} not found`);
  }

  const updatedSubtask = {
    ...subtask,
    ...updates,
    updatedAt: new Date()
  };

  // 更新数据库
  await db.table('subtasks').update(id, updatedSubtask);

  // 添加到同步队列
  await addSyncItem('subtasks', 'update', updatedSubtask);

  // 如果状态变为已完成，更新完成时间
  if (updates.status === TaskStatus.COMPLETED && !updatedSubtask.completedAt) {
    updatedSubtask.completedAt = new Date();
    await db.table('subtasks').update(id, { completedAt: updatedSubtask.completedAt });
  }

  // 更新父任务进度
  await updateParentTaskProgress(subtask.parentTaskId);

  return updatedSubtask;
}

/**
 * 完成子任务
 * @param id 子任务ID
 */
export async function completeSubtask(id: number): Promise<SubtaskRecord> {
  return updateSubtask(id, {
    status: TaskStatus.COMPLETED,
    completedAt: new Date()
  });
}

/**
 * 删除子任务
 * @param id 子任务ID
 */
export async function deleteSubtask(id: number): Promise<void> {
  const subtask = await db.table('subtasks').get(id);
  if (!subtask) {
    throw new Error(`Subtask with id ${id} not found`);
  }

  // 删除子任务
  await db.table('subtasks').delete(id);

  // 添加到同步队列
  await addSyncItem('subtasks', 'delete', { id });

  // 更新父任务进度
  await updateParentTaskProgress(subtask.parentTaskId);

  // 重新排序剩余子任务
  const remainingSubtasks = await getSubtasks(subtask.parentTaskId);
  for (let i = 0; i < remainingSubtasks.length; i++) {
    if (remainingSubtasks[i].order !== i) {
      await updateSubtask(remainingSubtasks[i].id!, { order: i });
    }
  }
}

/**
 * 更新子任务顺序
 * @param id 子任务ID
 * @param newOrder 新顺序
 */
export async function updateSubtaskOrder(id: number, newOrder: number): Promise<void> {
  const subtask = await db.table('subtasks').get(id);
  if (!subtask) {
    throw new Error(`Subtask with id ${id} not found`);
  }

  const oldOrder = subtask.order;
  if (oldOrder === newOrder) {
    return; // 顺序没有变化
  }

  // 获取所有同级子任务
  const siblingSubtasks = await getSubtasks(subtask.parentTaskId);

  // 更新受影响的子任务顺序
  for (const sibling of siblingSubtasks) {
    if (sibling.id === id) {
      // 更新当前子任务的顺序
      await updateSubtask(id, { order: newOrder });
    } else if (
      (oldOrder < newOrder && sibling.order > oldOrder && sibling.order <= newOrder) ||
      (oldOrder > newOrder && sibling.order >= newOrder && sibling.order < oldOrder)
    ) {
      // 更新受影响的其他子任务顺序
      const newSiblingOrder = oldOrder < newOrder
        ? sibling.order - 1 // 向上移动时，中间的子任务顺序减1
        : sibling.order + 1; // 向下移动时，中间的子任务顺序加1
      await updateSubtask(sibling.id!, { order: newSiblingOrder });
    }
  }
}

/**
 * 更新父任务进度
 * @param parentTaskId 父任务ID
 */
export async function updateParentTaskProgress(parentTaskId: number): Promise<void> {
  const subtasks = await getSubtasks(parentTaskId);
  if (subtasks.length === 0) {
    return;
  }

  // 计算完成的子任务数量
  const completedCount = subtasks.filter(
    subtask => subtask.status === TaskStatus.COMPLETED
  ).length;

  // 计算进度百分比
  const progressPercentage = Math.round((completedCount / subtasks.length) * 100);

  // 如果所有子任务都完成，将父任务标记为已完成
  if (completedCount === subtasks.length) {
    await updateTask(parentTaskId, {
      status: TaskStatus.COMPLETED,
      completedAt: new Date()
    });
  } else if (completedCount > 0) {
    // 如果有部分子任务完成，将父任务标记为进行中
    await updateTask(parentTaskId, {
      status: TaskStatus.IN_PROGRESS
    });
  }
}

/**
 * 将任务转换为带有子任务的任务
 * @param taskId 任务ID
 * @param subtaskTitles 子任务标题列表
 */
export async function convertTaskToParentTask(
  taskId: number,
  subtaskTitles: string[]
): Promise<SubtaskRecord[]> {
  const task = await db.table('tasks').get(taskId);
  if (!task) {
    throw new Error(`Task with id ${taskId} not found`);
  }

  const createdSubtasks: SubtaskRecord[] = [];

  // 创建子任务
  for (let i = 0; i < subtaskTitles.length; i++) {
    const subtask = await createSubtask({
      parentTaskId: taskId,
      title: subtaskTitles[i]
    });
    createdSubtasks.push(subtask);
  }

  // 将父任务状态更新为进行中
  await updateTask(taskId, {
    status: TaskStatus.IN_PROGRESS
  });

  return createdSubtasks;
}

/**
 * 检查任务是否有子任务
 * @param taskId 任务ID
 */
export async function hasSubtasks(taskId: number): Promise<boolean> {
  const count = await db.table('subtasks')
    .where('parentTaskId')
    .equals(taskId)
    .count();
  return count > 0;
}
</file>

<file path="src/services/taskReminderService.ts">
// src/services/taskReminderService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { TaskRecord, getTask, getAllTasks, TaskStatus } from './taskService';

// 任务提醒记录类型
export interface TaskReminderRecord {
  id?: number;
  taskId: number;
  userId: string;
  reminderTime: Date;
  isViewed: boolean;
  isCompleted: boolean;
  createdAt: Date;
  message?: string;
}

// 提醒类型
export enum ReminderType {
  DUE_SOON = 'due_soon',      // 即将到期
  OVERDUE = 'overdue',        // 已过期
  SCHEDULED = 'scheduled',    // 计划提醒
  CUSTOM = 'custom'           // 自定义提醒
}

/**
 * 创建任务提醒
 * @param taskId 任务ID
 * @param reminderTime 提醒时间
 * @param message 自定义消息（可选）
 */
export async function createTaskReminder(
  taskId: number,
  reminderTime: Date,
  message?: string
): Promise<TaskReminderRecord> {
  const now = new Date();

  // 获取当前用户ID（在实际应用中，这应该从用户会话中获取）
  const userId = 'current-user';

  const reminder: TaskReminderRecord = {
    taskId,
    userId,
    reminderTime,
    isViewed: false,
    isCompleted: false,
    createdAt: now,
    message
  };

  // 添加到数据库
  const id = await db.table('taskReminders').add(reminder);
  const createdReminder = { ...reminder, id: id as number };

  // 添加到同步队列
  await addSyncItem('taskReminders', 'create', createdReminder);

  return createdReminder;
}

/**
 * 获取任务的提醒
 * @param taskId 任务ID
 */
export async function getTaskReminders(taskId: number): Promise<TaskReminderRecord[]> {
  return db.table('taskReminders')
    .where('taskId')
    .equals(taskId)
    .toArray();
}

/**
 * 获取用户的未查看提醒
 * @param userId 用户ID
 */
export async function getUnviewedReminders(userId: string): Promise<TaskReminderRecord[]> {
  return db.table('taskReminders')
    .where('userId')
    .equals(userId)
    .and(reminder => !reminder.isViewed)
    .toArray();
}

/**
 * 获取用户的活跃提醒（未查看且未完成）
 * @param userId 用户ID
 */
export async function getActiveReminders(userId: string): Promise<TaskReminderRecord[]> {
  return db.table('taskReminders')
    .where('userId')
    .equals(userId)
    .and(reminder => !reminder.isViewed && !reminder.isCompleted)
    .toArray();
}

/**
 * 标记提醒为已查看
 * @param id 提醒ID
 */
export async function markReminderAsViewed(id: number): Promise<TaskReminderRecord> {
  const reminder = await db.table('taskReminders').get(id);
  if (!reminder) {
    throw new Error(`Reminder with id ${id} not found`);
  }

  const updatedReminder = {
    ...reminder,
    isViewed: true
  };

  // 更新数据库
  await db.table('taskReminders').update(id, updatedReminder);

  // 添加到同步队列
  await addSyncItem('taskReminders', 'update', updatedReminder);

  return updatedReminder;
}

/**
 * 标记提醒为已完成
 * @param id 提醒ID
 */
export async function markReminderAsCompleted(id: number): Promise<TaskReminderRecord> {
  const reminder = await db.table('taskReminders').get(id);
  if (!reminder) {
    throw new Error(`Reminder with id ${id} not found`);
  }

  const updatedReminder = {
    ...reminder,
    isViewed: true,
    isCompleted: true
  };

  // 更新数据库
  await db.table('taskReminders').update(id, updatedReminder);

  // 添加到同步队列
  await addSyncItem('taskReminders', 'update', updatedReminder);

  return updatedReminder;
}

/**
 * 删除提醒
 * @param id 提醒ID
 */
export async function deleteReminder(id: number): Promise<void> {
  // 检查提醒是否存在
  const reminder = await db.table('taskReminders').get(id);
  if (!reminder) {
    throw new Error(`Reminder with id ${id} not found`);
  }

  // 从数据库中删除
  await db.table('taskReminders').delete(id);

  // 添加到同步队列
  await addSyncItem('taskReminders', 'delete', { id });
}

/**
 * 为即将到期的任务创建提醒
 * 检查未完成的任务，如果任务即将到期（24小时内），创建提醒
 */
export async function checkDueSoonTasks(): Promise<void> {
  // 获取当前用户ID（在实际应用中，这应该从用户会话中获取）
  const userId = 'current-user';

  // 获取所有未完成的任务
  const tasks = await getAllTasks({ status: TaskStatus.TODO });

  // 当前时间
  const now = new Date();

  // 24小时后
  const tomorrow = new Date(now);
  tomorrow.setHours(tomorrow.getHours() + 24);

  // 检查每个任务
  for (const task of tasks) {
    // 如果任务有截止日期且在24小时内
    if (task.dueDate && new Date(task.dueDate) <= tomorrow && new Date(task.dueDate) > now) {
      // 检查是否已经有提醒
      const reminders = await getTaskReminders(task.id!);
      const hasDueSoonReminder = reminders.some(r =>
        r.message?.includes('即将到期') ||
        (r.reminderTime >= now && r.reminderTime <= tomorrow)
      );

      // 如果没有提醒，创建一个
      if (!hasDueSoonReminder) {
        await createTaskReminder(
          task.id!,
          new Date(task.dueDate),
          `任务"${task.title}"即将到期，请尽快完成。`
        );
      }
    }
  }
}

/**
 * 为已过期的任务创建提醒
 * 检查未完成的任务，如果任务已过期，创建提醒
 */
export async function checkOverdueTasks(): Promise<void> {
  // 获取当前用户ID（在实际应用中，这应该从用户会话中获取）
  const userId = 'current-user';

  // 获取所有未完成的任务
  const tasks = await getAllTasks({ status: TaskStatus.TODO });

  // 当前时间
  const now = new Date();

  // 检查每个任务
  for (const task of tasks) {
    // 如果任务有截止日期且已过期
    if (task.dueDate && new Date(task.dueDate) < now) {
      // 检查是否已经有提醒
      const reminders = await getTaskReminders(task.id!);
      const hasOverdueReminder = reminders.some(r =>
        r.message?.includes('已过期') &&
        new Date(r.createdAt) > new Date(task.dueDate!)
      );

      // 如果没有提醒，创建一个
      if (!hasOverdueReminder) {
        await createTaskReminder(
          task.id!,
          now,
          `任务"${task.title}"已过期，请及时处理。`
        );
      }
    }
  }
}

/**
 * 为计划任务创建提醒
 * @param taskId 任务ID
 * @param reminderTime 提醒时间
 */
export async function scheduleTaskReminder(
  taskId: number,
  reminderTime: Date
): Promise<TaskReminderRecord> {
  // 获取任务
  const task = await getTask(taskId);
  if (!task) {
    throw new Error(`Task with id ${taskId} not found`);
  }

  // 创建提醒
  return createTaskReminder(
    taskId,
    reminderTime,
    `计划提醒：任务"${task.title}"需要处理。`
  );
}

/**
 * 创建自定义提醒
 * @param taskId 任务ID
 * @param reminderTime 提醒时间
 * @param message 自定义消息
 */
export async function createCustomReminder(
  taskId: number,
  reminderTime: Date,
  message: string
): Promise<TaskReminderRecord> {
  return createTaskReminder(taskId, reminderTime, message);
}
</file>

<file path="src/services/timelyRewardService.ts">
// src/services/timelyRewardService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { generateRewards, RewardRecord, RewardRarity } from './rewardService';
import { TaskRecord, TaskStatus } from './taskService';

// 及时奖励状态枚举
export enum TimelyRewardStatus {
  ACTIVE = 'active',         // 活跃中
  COMPLETED = 'completed',   // 已完成
  EXPIRED = 'expired',       // 已过期
  UPCOMING = 'upcoming'      // 即将开始
}

// 及时奖励类型枚举
export enum TimelyRewardType {
  DAILY = 'daily',           // 每日奖励
  MORNING = 'morning',       // 早起鸟奖励
  STREAK = 'streak',         // 连续完成奖励
  SPECIAL = 'special'        // 特殊奖励
}

// 及时奖励记录类型
export interface TimelyRewardRecord {
  id?: number;               // 奖励ID
  title: string;             // 奖励标题
  description: string;       // 奖励描述
  type: TimelyRewardType;    // 奖励类型
  status: TimelyRewardStatus; // 奖励状态
  progress: number;          // 进度（0-100）
  startTime: Date;           // 开始时间
  endTime: Date;             // 结束时间
  completedTime?: Date;      // 完成时间
  luckyPoints: number;       // 幸运点数
  taskIds?: number[];        // 关联的任务ID列表
  rewardIds?: number[];      // 奖励ID列表
  iconPath: string;          // 图标路径
  createdAt: Date;           // 创建时间
  updatedAt: Date;           // 更新时间
}

// 幸运点记录类型
export interface LuckyPointRecord {
  id?: number;               // 记录ID
  userId: string;            // 用户ID
  amount: number;            // 点数数量
  source: string;            // 来源
  timestamp: Date;           // 时间戳
  expiryDate?: Date;         // 过期日期
  isSpent: boolean;          // 是否已使用
  createdAt: Date;           // 创建时间
}

// 幸运抽奖记录类型
export interface LuckyDrawRecord {
  id?: number;               // 记录ID
  userId: string;            // 用户ID
  pointsSpent: number;       // 使用的点数
  rewards: RewardRecord[];   // 获得的奖励
  timestamp: Date;           // 时间戳
  createdAt: Date;           // 创建时间
}

// 奖品层级
export enum PrizeLevel {
  COMMON = 'common',         // 普通
  UNCOMMON = 'uncommon',     // 不常见
  RARE = 'rare',             // 稀有
  EPIC = 'epic',             // 史诗
  LEGENDARY = 'legendary'    // 传说
}

// 奖品层级概率配置
const PRIZE_LEVEL_PROBABILITIES = {
  [PrizeLevel.COMMON]: 0.6,      // 60%
  [PrizeLevel.UNCOMMON]: 0.25,   // 25%
  [PrizeLevel.RARE]: 0.1,        // 10%
  [PrizeLevel.EPIC]: 0.04,       // 4%
  [PrizeLevel.LEGENDARY]: 0.01   // 1%
};

// 奖品层级对应的奖励稀有度
const PRIZE_LEVEL_TO_RARITY: Record<PrizeLevel, string> = {
  [PrizeLevel.COMMON]: 'common',
  [PrizeLevel.UNCOMMON]: 'uncommon',
  [PrizeLevel.RARE]: 'rare',
  [PrizeLevel.EPIC]: 'epic',
  [PrizeLevel.LEGENDARY]: 'legendary'
};

/**
 * 初始化及时奖励系统
 */
export async function initializeTimelyRewards(): Promise<void> {
  // 检查是否已有及时奖励
  const count = await db.table('timelyRewards').count();

  if (count === 0) {
    // 创建默认的及时奖励
    await createDailyTimelyReward();
    await createMorningTimelyReward();
  }
}

/**
 * 创建每日及时奖励
 */
async function createDailyTimelyReward(): Promise<TimelyRewardRecord> {
  const now = new Date();
  const startTime = new Date(now);
  startTime.setHours(9, 0, 0, 0); // 每天9点开始

  const endTime = new Date(now);
  endTime.setHours(21, 0, 0, 0); // 每天21点结束

  // 如果当前时间已经超过今天的结束时间，则设置为明天
  if (now > endTime) {
    startTime.setDate(startTime.getDate() + 1);
    endTime.setDate(endTime.getDate() + 1);
  }

  const dailyReward: TimelyRewardRecord = {
    title: '每日及时完成',
    description: '在规定时间内完成任务，获得额外奖励',
    type: TimelyRewardType.DAILY,
    status: TimelyRewardStatus.ACTIVE,
    progress: 0,
    startTime,
    endTime,
    luckyPoints: 10,
    iconPath: '/assets/rewards/daily-reward.svg',
    createdAt: now,
    updatedAt: now
  };

  const id = await db.table('timelyRewards').add(dailyReward);
  const newReward = { ...dailyReward, id: id as number };

  // 添加到同步队列
  await addSyncItem('timelyRewards', 'create', newReward);

  return newReward;
}

/**
 * 创建早起鸟及时奖励
 */
async function createMorningTimelyReward(): Promise<TimelyRewardRecord> {
  const now = new Date();
  const startTime = new Date(now);
  startTime.setHours(5, 0, 0, 0); // 每天5点开始

  const endTime = new Date(now);
  endTime.setHours(9, 0, 0, 0); // 每天9点结束

  // 如果当前时间已经超过今天的结束时间，则设置为明天
  if (now > endTime) {
    startTime.setDate(startTime.getDate() + 1);
    endTime.setDate(endTime.getDate() + 1);
  }

  const morningReward: TimelyRewardRecord = {
    title: '早起鸟奖励',
    description: '早起完成任务，获得额外奖励',
    type: TimelyRewardType.MORNING,
    status: TimelyRewardStatus.ACTIVE,
    progress: 0,
    startTime,
    endTime,
    luckyPoints: 15,
    iconPath: '/assets/rewards/morning-reward.svg',
    createdAt: now,
    updatedAt: now
  };

  const id = await db.table('timelyRewards').add(morningReward);
  const newReward = { ...morningReward, id: id as number };

  // 添加到同步队列
  await addSyncItem('timelyRewards', 'create', newReward);

  return newReward;
}

/**
 * 获取所有及时奖励
 * @param filter 过滤条件
 */
export async function getAllTimelyRewards(filter?: {
  status?: TimelyRewardStatus;
  type?: TimelyRewardType;
}): Promise<TimelyRewardRecord[]> {
  let collection = db.table('timelyRewards').toCollection();

  if (filter) {
    if (filter.status) {
      collection = collection.filter(reward => reward.status === filter.status);
    }
    if (filter.type) {
      collection = collection.filter(reward => reward.type === filter.type);
    }
  }

  return collection.toArray();
}

/**
 * 获取单个及时奖励
 * @param id 奖励ID
 */
export async function getTimelyReward(id: number): Promise<TimelyRewardRecord | undefined> {
  return db.table('timelyRewards').get(id);
}

/**
 * 更新及时奖励进度
 * @param id 奖励ID
 * @param progress 进度值（0-100）
 */
export async function updateTimelyRewardProgress(id: number, progress: number): Promise<TimelyRewardRecord> {
  const reward = await db.table('timelyRewards').get(id);

  if (!reward) {
    throw new Error(`Timely reward with id ${id} not found`);
  }

  // 确保进度在0-100范围内
  const validProgress = Math.max(0, Math.min(100, progress));

  // 如果进度达到100%，将状态更新为已完成
  let status = reward.status;
  let completedTime = reward.completedTime;

  if (validProgress >= 100 && status !== TimelyRewardStatus.COMPLETED) {
    status = TimelyRewardStatus.COMPLETED;
    completedTime = new Date();
  }

  const updatedReward = {
    ...reward,
    progress: validProgress,
    status,
    completedTime,
    updatedAt: new Date()
  };

  await db.table('timelyRewards').update(id, updatedReward);

  // 添加到同步队列
  await addSyncItem('timelyRewards', 'update', updatedReward);

  return updatedReward;
}

/**
 * 完成及时奖励
 * @param id 奖励ID
 */
export async function completeTimelyReward(id: number): Promise<RewardRecord[]> {
  const reward = await db.table('timelyRewards').get(id);

  if (!reward) {
    throw new Error(`Timely reward with id ${id} not found`);
  }

  if (reward.status === TimelyRewardStatus.COMPLETED) {
    throw new Error(`Timely reward with id ${id} is already completed`);
  }

  // 检查是否在有效时间范围内
  const now = new Date();
  if (now < reward.startTime || now > reward.endTime) {
    throw new Error(`Timely reward with id ${id} is not active`);
  }

  // 更新奖励状态
  const updatedReward = {
    ...reward,
    status: TimelyRewardStatus.COMPLETED,
    progress: 100,
    completedTime: now,
    updatedAt: now
  };

  await db.table('timelyRewards').update(id, updatedReward);

  // 生成奖励
  const rewards = await generateRewards(2, 'uncommon' as RewardRarity);

  // 添加幸运点
  await addLuckyPoints(reward.luckyPoints, `完成及时奖励: ${reward.title}`);

  // 添加到同步队列
  await addSyncItem('timelyRewards', 'update', updatedReward);

  return rewards;
}

/**
 * 添加幸运点
 * @param amount 点数数量
 * @param source 来源
 */
export async function addLuckyPoints(amount: number, source: string): Promise<LuckyPointRecord> {
  const now = new Date();

  // 设置过期日期为30天后
  const expiryDate = new Date(now);
  expiryDate.setDate(expiryDate.getDate() + 30);

  const luckyPoint: LuckyPointRecord = {
    userId: 'current-user', // 在实际应用中，这应该是当前用户的ID
    amount,
    source,
    timestamp: now,
    expiryDate,
    isSpent: false,
    createdAt: now
  };

  const id = await db.table('luckyPoints').add(luckyPoint);
  const newLuckyPoint = { ...luckyPoint, id: id as number };

  // 添加到同步队列
  await addSyncItem('luckyPoints', 'create', newLuckyPoint);

  return newLuckyPoint;
}

/**
 * 获取用户的幸运点总数
 */
export async function getLuckyPointsTotal(): Promise<number> {
  const points = await db.table('luckyPoints')
    .where('userId')
    .equals('current-user')
    .and(point => !point.isSpent)
    .and(point => !point.expiryDate || point.expiryDate > new Date())
    .toArray();

  return points.reduce((total, point) => total + point.amount, 0);
}

/**
 * 进行幸运抽奖
 * @param pointsToSpend 要使用的点数
 */
export async function performLuckyDraw(pointsToSpend: number): Promise<LuckyDrawRecord> {
  // 检查用户是否有足够的点数
  const totalPoints = await getLuckyPointsTotal();
  if (totalPoints < pointsToSpend) {
    throw new Error(`Not enough lucky points. Required: ${pointsToSpend}, Available: ${totalPoints}`);
  }

  // 确定奖品层级
  const prizeLevel = determinePrizeLevel();

  // 生成奖励
  const rarityString = PRIZE_LEVEL_TO_RARITY[prizeLevel];
  const rarity = rarityString as RewardRarity;
  const rewards = await generateRewards(1, rarity);

  // 使用幸运点
  await spendLuckyPoints(pointsToSpend);

  const now = new Date();
  const luckyDraw: LuckyDrawRecord = {
    userId: 'current-user',
    pointsSpent: pointsToSpend,
    rewards,
    timestamp: now,
    createdAt: now
  };

  const id = await db.table('luckyDraws').add(luckyDraw);
  const newLuckyDraw = { ...luckyDraw, id: id as number };

  // 添加到同步队列
  await addSyncItem('luckyDraws', 'create', newLuckyDraw);

  return newLuckyDraw;
}

/**
 * 使用幸运点
 * @param amount 要使用的点数数量
 */
async function spendLuckyPoints(amount: number): Promise<void> {
  // 获取未使用的幸运点
  const points = await db.table('luckyPoints')
    .where('userId')
    .equals('current-user')
    .and(point => !point.isSpent)
    .and(point => !point.expiryDate || point.expiryDate > new Date())
    .sortBy('expiryDate'); // 先使用快过期的点数

  let remainingAmount = amount;

  for (const point of points) {
    if (remainingAmount <= 0) break;

    if (point.amount <= remainingAmount) {
      // 如果当前点数记录小于等于剩余需要使用的点数，则全部使用
      await db.table('luckyPoints').update(point.id!, { isSpent: true });
      await addSyncItem('luckyPoints', 'update', { ...point, isSpent: true });
      remainingAmount -= point.amount;
    } else {
      // 如果当前点数记录大于剩余需要使用的点数，则拆分记录
      await db.table('luckyPoints').update(point.id!, { amount: point.amount - remainingAmount });
      await addSyncItem('luckyPoints', 'update', { ...point, amount: point.amount - remainingAmount });

      // 创建一个新的已使用记录
      const spentPoint: LuckyPointRecord = {
        userId: point.userId,
        amount: remainingAmount,
        source: point.source,
        timestamp: point.timestamp,
        expiryDate: point.expiryDate,
        isSpent: true,
        createdAt: new Date()
      };

      await db.table('luckyPoints').add(spentPoint);
      await addSyncItem('luckyPoints', 'create', spentPoint);

      remainingAmount = 0;
    }
  }

  if (remainingAmount > 0) {
    throw new Error(`Not enough lucky points. Required: ${amount}, Used: ${amount - remainingAmount}`);
  }
}

/**
 * 确定奖品层级
 */
function determinePrizeLevel(): PrizeLevel {
  const random = Math.random();
  let cumulativeProbability = 0;

  for (const [level, probability] of Object.entries(PRIZE_LEVEL_PROBABILITIES)) {
    cumulativeProbability += probability;
    if (random <= cumulativeProbability) {
      return level as PrizeLevel;
    }
  }

  return PrizeLevel.COMMON; // 默认返回普通层级
}

/**
 * 检查任务是否在及时奖励时间窗口内
 * @param task 任务
 */
export async function checkTaskForTimelyReward(task: TaskRecord): Promise<TimelyRewardRecord | null> {
  if (task.status !== TaskStatus.COMPLETED) {
    return null;
  }

  const now = new Date();

  // 获取活跃的及时奖励
  const activeRewards = await db.table('timelyRewards')
    .where('status')
    .equals(TimelyRewardStatus.ACTIVE)
    .toArray();

  // 检查任务是否在任何及时奖励的时间窗口内
  for (const reward of activeRewards) {
    if (now >= reward.startTime && now <= reward.endTime) {
      // 更新及时奖励进度
      const updatedReward = await updateTimelyRewardProgress(
        reward.id!,
        reward.progress + 20 // 每完成一个任务增加20%的进度
      );

      return updatedReward;
    }
  }

  return null;
}

/**
 * 更新及时奖励状态
 * 检查所有及时奖励，更新它们的状态（过期、即将开始等）
 */
export async function updateTimelyRewardsStatus(): Promise<void> {
  const now = new Date();

  // 获取所有及时奖励
  const rewards = await db.table('timelyRewards').toArray();

  for (const reward of rewards) {
    let newStatus = reward.status;

    // 如果已经完成，则跳过
    if (reward.status === TimelyRewardStatus.COMPLETED) {
      continue;
    }

    // 检查是否过期
    if (now > reward.endTime) {
      newStatus = TimelyRewardStatus.EXPIRED;
    }
    // 检查是否活跃
    else if (now >= reward.startTime && now <= reward.endTime) {
      newStatus = TimelyRewardStatus.ACTIVE;
    }
    // 检查是否即将开始
    else if (now < reward.startTime) {
      newStatus = TimelyRewardStatus.UPCOMING;
    }

    // 如果状态有变化，则更新
    if (newStatus !== reward.status) {
      const updatedReward = {
        ...reward,
        status: newStatus,
        updatedAt: now
      };

      await db.table('timelyRewards').update(reward.id!, updatedReward);
      await addSyncItem('timelyRewards', 'update', updatedReward);
    }
  }
}
</file>

<file path="src/types/dataRefresh.ts">
// src/types/dataRefresh.ts

/**
 * 数据刷新事件类型
 */
export interface DataRefreshEvent {
  table: string;
  data?: any;
}
</file>

<file path="src/utils/animation.ts">
// src/utils/animation.ts
import { Variants } from 'framer-motion';

/**
 * 淡入动画变体
 */
export const fadeIn: Variants = {
  hidden: { opacity: 0 },
  visible: { 
    opacity: 1,
    transition: { duration: 0.5 }
  },
  exit: { 
    opacity: 0,
    transition: { duration: 0.3 }
  }
};

/**
 * 从下方滑入动画变体
 */
export const slideUp: Variants = {
  hidden: { 
    opacity: 0, 
    y: 20 
  },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: { 
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  },
  exit: { 
    opacity: 0, 
    y: 20,
    transition: { duration: 0.2 }
  }
};

/**
 * 从左侧滑入动画变体
 */
export const slideInLeft: Variants = {
  hidden: { 
    opacity: 0, 
    x: -50 
  },
  visible: { 
    opacity: 1, 
    x: 0,
    transition: { 
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  },
  exit: { 
    opacity: 0, 
    x: -50,
    transition: { duration: 0.2 }
  }
};

/**
 * 从右侧滑入动画变体
 */
export const slideInRight: Variants = {
  hidden: { 
    opacity: 0, 
    x: 50 
  },
  visible: { 
    opacity: 1, 
    x: 0,
    transition: { 
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  },
  exit: { 
    opacity: 0, 
    x: 50,
    transition: { duration: 0.2 }
  }
};

/**
 * 缩放动画变体
 */
export const scale: Variants = {
  hidden: { 
    opacity: 0, 
    scale: 0.8 
  },
  visible: { 
    opacity: 1, 
    scale: 1,
    transition: { 
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  },
  exit: { 
    opacity: 0, 
    scale: 0.8,
    transition: { duration: 0.2 }
  }
};

/**
 * 弹跳动画变体
 */
export const bounce: Variants = {
  hidden: { 
    opacity: 0, 
    y: 50,
    scale: 0.9
  },
  visible: { 
    opacity: 1, 
    y: 0,
    scale: 1,
    transition: { 
      type: 'spring', 
      stiffness: 400, 
      damping: 10 
    }
  },
  exit: { 
    opacity: 0, 
    y: 20,
    transition: { duration: 0.2 }
  }
};

/**
 * 水墨效果动画变体
 */
export const inkSplash: Variants = {
  hidden: { 
    opacity: 0, 
    scale: 0.1,
    filter: 'blur(10px)'
  },
  visible: { 
    opacity: 1, 
    scale: 1,
    filter: 'blur(0px)',
    transition: { 
      duration: 0.5,
      ease: [0.25, 0.1, 0.25, 1]
    }
  },
  exit: { 
    opacity: 0, 
    scale: 1.2,
    filter: 'blur(10px)',
    transition: { duration: 0.3 }
  }
};

/**
 * 竹叶摇摆动画变体
 */
export const bambooSway: Variants = {
  hidden: { 
    opacity: 0, 
    rotate: -5,
    y: 20
  },
  visible: { 
    opacity: 1, 
    rotate: 0,
    y: 0,
    transition: { 
      type: 'spring', 
      stiffness: 100, 
      damping: 10 
    }
  },
  exit: { 
    opacity: 0, 
    rotate: 5,
    y: -20,
    transition: { duration: 0.3 }
  }
};

/**
 * 金光闪烁动画变体
 */
export const goldenGlow: Variants = {
  hidden: { 
    opacity: 0, 
    filter: 'brightness(0.8) saturate(0.8)'
  },
  visible: { 
    opacity: 1, 
    filter: 'brightness(1.2) saturate(1.2)',
    transition: { 
      duration: 0.5,
      ease: [0.25, 0.1, 0.25, 1]
    }
  },
  exit: { 
    opacity: 0, 
    filter: 'brightness(1.5) saturate(1.5)',
    transition: { duration: 0.3 }
  }
};

/**
 * 列表项动画变体（用于列表中的项目，带有交错效果）
 */
export const listItem: Variants = {
  hidden: { 
    opacity: 0, 
    y: 20 
  },
  visible: (i: number) => ({ 
    opacity: 1, 
    y: 0,
    transition: { 
      delay: i * 0.1,
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  }),
  exit: { 
    opacity: 0, 
    y: 20,
    transition: { duration: 0.2 }
  }
};

/**
 * 页面过渡动画变体
 */
export const pageTransition: Variants = {
  hidden: { 
    opacity: 0, 
    y: 20 
  },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: { 
      duration: 0.5,
      ease: [0.25, 0.1, 0.25, 1]
    }
  },
  exit: { 
    opacity: 0, 
    y: -20,
    transition: { duration: 0.3 }
  }
};

/**
 * 创建带有延迟的容器动画变体
 * @param staggerChildren 子元素之间的延迟时间
 * @param delayChildren 所有子元素的初始延迟
 */
export const createContainerVariants = (
  staggerChildren = 0.1, 
  delayChildren = 0
): Variants => ({
  hidden: { opacity: 0 },
  visible: { 
    opacity: 1,
    transition: { 
      staggerChildren,
      delayChildren
    }
  },
  exit: { 
    opacity: 0,
    transition: { 
      staggerChildren: 0.05,
      staggerDirection: -1
    }
  }
});
</file>

<file path="src/utils/dateUtils.ts">
// src/utils/dateUtils.ts

/**
 * 格式化日期为易读的字符串（不包含时间）
 * @param dateString 日期字符串或Date对象
 * @returns 格式化后的日期字符串
 */
export function formatDate(dateString: string | Date): string {
  return formatTime(dateString, false);
}

/**
 * 格式化日期时间为易读的字符串
 * @param dateString 日期字符串或Date对象
 * @param includeTime 是否包含时间部分
 * @returns 格式化后的日期时间字符串
 */
export function formatTime(dateString: string | Date, includeTime: boolean = true): string {
  if (!dateString) return '';

  const date = typeof dateString === 'string' ? new Date(dateString) : dateString;

  // 检查日期是否有效
  if (isNaN(date.getTime())) {
    return 'Invalid Date';
  }

  // 格式化日期部分
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');

  const dateFormatted = `${year}-${month}-${day}`;

  // 如果不需要时间部分，直接返回日期
  if (!includeTime) {
    return dateFormatted;
  }

  // 格式化时间部分
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');

  return `${dateFormatted} ${hours}:${minutes}`;
}

/**
 * 计算两个日期之间的天数差
 * @param date1 第一个日期
 * @param date2 第二个日期，默认为当前日期
 * @returns 天数差
 */
export function daysBetween(date1: Date | string, date2: Date | string = new Date()): number {
  const d1 = typeof date1 === 'string' ? new Date(date1) : date1;
  const d2 = typeof date2 === 'string' ? new Date(date2) : date2;

  // 将时间部分设置为0，只比较日期部分
  d1.setHours(0, 0, 0, 0);
  d2.setHours(0, 0, 0, 0);

  // 计算毫秒差并转换为天数
  const diffTime = Math.abs(d2.getTime() - d1.getTime());
  const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

  return diffDays;
}

/**
 * 检查日期是否是今天
 * @param date 要检查的日期
 * @returns 是否是今天
 */
export function isToday(date: Date | string): boolean {
  const today = new Date();
  const checkDate = typeof date === 'string' ? new Date(date) : date;

  return (
    checkDate.getDate() === today.getDate() &&
    checkDate.getMonth() === today.getMonth() &&
    checkDate.getFullYear() === today.getFullYear()
  );
}

/**
 * 获取相对时间描述（例如：刚刚、5分钟前、1小时前等）
 * @param date 日期
 * @returns 相对时间描述
 */
export function getRelativeTimeDescription(date: Date | string): string {
  const now = new Date();
  const targetDate = typeof date === 'string' ? new Date(date) : date;

  const diffMs = now.getTime() - targetDate.getTime();
  const diffSecs = Math.floor(diffMs / 1000);
  const diffMins = Math.floor(diffSecs / 60);
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);

  if (diffSecs < 60) {
    return '刚刚';
  } else if (diffMins < 60) {
    return `${diffMins}分钟前`;
  } else if (diffHours < 24) {
    return `${diffHours}小时前`;
  } else if (diffDays < 30) {
    return `${diffDays}天前`;
  } else {
    return formatTime(targetDate, false);
  }
}
</file>

<file path="src/utils/sound.ts">
// src/utils/sound.ts
/**
 * 声音工具类
 * 用于播放游戏中的各种音效
 */

// 音效类型枚举
export enum SoundType {
  // 奖励音效
  REWARD_COMMON = 'reward_common',
  REWARD_UNCOMMON = 'reward_uncommon',
  REWARD_RARE = 'reward_rare',
  REWARD_EPIC = 'reward_epic',
  REWARD_LEGENDARY = 'reward_legendary',

  // 任务相关音效
  TASK_COMPLETE = 'task_complete',
  TASK_COMPLETE_HIGH = 'task_complete_high',
  TASK_COMPLETE_MAIN = 'task_complete_main',
  TASK_FAILED = 'task_failed',
  TASK_CREATED = 'task_created',

  // 挑战相关音效
  CHALLENGE_COMPLETE = 'challenge_complete',
  CHALLENGE_COMPLETE_EPIC = 'challenge_complete_epic',
  CHALLENGE_COMPLETE_LEGENDARY = 'challenge_complete_legendary',
  CHALLENGE_FAILED = 'challenge_failed',
  CHALLENGE_UNLOCKED = 'challenge_unlocked',

  // 系统音效
  LEVEL_UP = 'level_up',
  ABILITY_UNLOCKED = 'ability_unlocked',
  ABILITY_ACTIVATED = 'ability_activated',
  BUTTON_CLICK = 'button_click',
  ERROR = 'error',
  SUCCESS = 'success',
  NOTIFICATION = 'notification'
}

// 音效文件路径映射
const soundPaths: Record<SoundType, string> = {
  // 奖励音效
  [SoundType.REWARD_COMMON]: '/assets/sounds/reward_common.mp3',
  [SoundType.REWARD_UNCOMMON]: '/assets/sounds/reward_uncommon.mp3',
  [SoundType.REWARD_RARE]: '/assets/sounds/reward_rare.mp3',
  [SoundType.REWARD_EPIC]: '/assets/sounds/reward_epic.mp3',
  [SoundType.REWARD_LEGENDARY]: '/assets/sounds/reward_legendary.mp3',

  // 任务相关音效
  [SoundType.TASK_COMPLETE]: '/assets/sounds/task_complete.mp3',
  [SoundType.TASK_COMPLETE_HIGH]: '/assets/sounds/task_complete_high.mp3',
  [SoundType.TASK_COMPLETE_MAIN]: '/assets/sounds/task_complete_main.mp3',
  [SoundType.TASK_FAILED]: '/assets/sounds/task_failed.mp3',
  [SoundType.TASK_CREATED]: '/assets/sounds/task_created.mp3',

  // 挑战相关音效
  [SoundType.CHALLENGE_COMPLETE]: '/assets/sounds/challenge_complete.mp3',
  [SoundType.CHALLENGE_COMPLETE_EPIC]: '/assets/sounds/challenge_complete_epic.mp3',
  [SoundType.CHALLENGE_COMPLETE_LEGENDARY]: '/assets/sounds/challenge_complete_legendary.mp3',
  [SoundType.CHALLENGE_FAILED]: '/assets/sounds/challenge_failed.mp3',
  [SoundType.CHALLENGE_UNLOCKED]: '/assets/sounds/challenge_unlocked.mp3',

  // 系统音效
  [SoundType.LEVEL_UP]: '/assets/sounds/level_up.mp3',
  [SoundType.ABILITY_UNLOCKED]: '/assets/sounds/ability_unlocked.mp3',
  [SoundType.ABILITY_ACTIVATED]: '/assets/sounds/ability_activated.mp3',
  [SoundType.BUTTON_CLICK]: '/assets/sounds/button_click.mp3',
  [SoundType.ERROR]: '/assets/sounds/error.mp3',
  [SoundType.SUCCESS]: '/assets/sounds/success.mp3',
  [SoundType.NOTIFICATION]: '/assets/sounds/notification.mp3'
};

// 音频对象缓存
const audioCache: Record<string, HTMLAudioElement> = {};

/**
 * 播放音效
 * @param type 音效类型
 * @param volume 音量（0-1）
 * @returns 是否成功播放
 */
export function playSound(type: SoundType, volume: number = 0.5): boolean {
  try {
    const soundPath = soundPaths[type];

    // 检查音频是否已缓存
    if (!audioCache[soundPath]) {
      audioCache[soundPath] = new Audio(soundPath);
    }

    const audio = audioCache[soundPath];

    // 设置音量
    audio.volume = Math.max(0, Math.min(1, volume));

    // 重置播放位置
    audio.currentTime = 0;

    // 播放音效
    audio.play().catch(error => {
      console.warn(`Failed to play sound: ${error.message}`);
      return false;
    });

    return true;
  } catch (error) {
    console.error('Error playing sound:', error);
    return false;
  }
}

/**
 * 根据奖励稀有度播放对应音效
 * @param rarity 奖励稀有度
 * @param volume 音量（0-1）
 * @returns 是否成功播放
 */
export function playRewardSound(rarity: string, volume: number = 0.5): boolean {
  switch (rarity) {
    case 'common':
      return playSound(SoundType.REWARD_COMMON, volume);
    case 'uncommon':
      return playSound(SoundType.REWARD_UNCOMMON, volume);
    case 'rare':
      return playSound(SoundType.REWARD_RARE, volume);
    case 'epic':
      return playSound(SoundType.REWARD_EPIC, volume);
    case 'legendary':
      return playSound(SoundType.REWARD_LEGENDARY, volume);
    default:
      return playSound(SoundType.REWARD_COMMON, volume);
  }
}

/**
 * 根据任务类型和优先级播放对应音效
 * @param taskType 任务类型
 * @param taskPriority 任务优先级
 * @param volume 音量（0-1）
 * @returns 是否成功播放
 */
export function playTaskCompletionSound(taskType: string, taskPriority: string, volume: number = 0.5): boolean {
  // 主线任务
  if (taskType === 'main') {
    return playSound(SoundType.TASK_COMPLETE_MAIN, volume);
  }

  // 高优先级任务
  if (taskPriority === 'high') {
    return playSound(SoundType.TASK_COMPLETE_HIGH, volume);
  }

  // 默认任务完成音效
  return playSound(SoundType.TASK_COMPLETE, volume);
}

/**
 * 根据挑战难度播放对应音效
 * @param difficulty 挑战难度
 * @param volume 音量（0-1）
 * @returns 是否成功播放
 */
export function playChallengeCompletionSound(difficulty: string, volume: number = 0.5): boolean {
  switch (difficulty) {
    case 'expert':
    case 'legendary':
      return playSound(SoundType.CHALLENGE_COMPLETE_LEGENDARY, volume);
    case 'hard':
    case 'epic':
      return playSound(SoundType.CHALLENGE_COMPLETE_EPIC, volume);
    default:
      return playSound(SoundType.CHALLENGE_COMPLETE, volume);
  }
}

/**
 * 预加载所有音效
 * 在游戏启动时调用，提前加载所有音效文件
 */
export function preloadAllSounds(): void {
  Object.values(SoundType).forEach(type => {
    const soundPath = soundPaths[type as SoundType];
    if (!audioCache[soundPath]) {
      audioCache[soundPath] = new Audio(soundPath);
      // 只加载元数据，不播放
      audioCache[soundPath].preload = 'metadata';
      audioCache[soundPath].load();
    }
  });
}

/**
 * 设置全局音量
 * @param volume 音量（0-1）
 */
export function setGlobalVolume(volume: number): void {
  const normalizedVolume = Math.max(0, Math.min(1, volume));
  Object.values(audioCache).forEach(audio => {
    audio.volume = normalizedVolume;
  });
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src", "vite.config.ts"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})
</file>

<file path="src/App.tsx">
// src/App.tsx
import React, { useEffect } from 'react';
import { BrowserRouter } from 'react-router-dom';
import { QueryClientProvider } from '@tanstack/react-query';
// import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { LanguageProvider } from '@/context/LanguageProvider';
import { PandaStateProvider } from '@/context/PandaStateProvider';
import { DataRefreshProvider } from '@/context/DataRefreshProvider';
import { populateDB, db } from '@/db';
import AppShell from '@/components/layout/AppShell';
import AppRouter from '@/router';
import { initializeDataSync } from '@/services/dataSyncService';
import { initializeTimelyRewards, updateTimelyRewardsStatus } from '@/services/timelyRewardService';
import { queryClient } from '@/services/queryClient';

const App: React.FC = () => {
  useEffect(() => {
    // 初始化和填充数据库
    const initDB = async () => {
      try {
        // Populate Dexie DB on app start for development
        if (import.meta.env.DEV) { // Vite specific dev check
          await populateDB();
        }

        // 初始化数据同步服务
        setTimeout(() => {
          try {
            initializeDataSync({
              autoSyncInterval: 30000, // 30秒
              maxRetryCount: 5,
              batchSize: 20
            });

            // 确保数据库表已创建
            try {
              // 检查及时奖励表是否存在
              db.table('timelyRewards').count().then(count => {
                console.log(`TimelyRewards table exists with ${count} records`);

                // 初始化及时奖励系统
                initializeTimelyRewards().then(() => {
                  console.log("Timely rewards initialized successfully");

                  // 更新及时奖励状态
                  updateTimelyRewardsStatus().then(() => {
                    console.log("Timely rewards status updated successfully");
                  }).catch(err => {
                    console.error("Failed to update timely rewards status:", err);
                  });
                }).catch(err => {
                  console.error("Failed to initialize timely rewards:", err);
                });
              }).catch(err => {
                console.error("Failed to access timelyRewards table:", err);
              });
            } catch (err) {
              console.error("Error during timely rewards initialization:", err);
            }
          } catch (syncErr) {
            console.error("Failed to initialize data sync service:", syncErr);
          }
        }, 2000); // 延迟2秒初始化同步服务，确保数据库已经准备好
      } catch (err) {
        console.error("Failed to initialize database:", err);
      }
    };

    initDB();

    // 监听在线状态变化
    const handleOnline = () => {
      console.log('App is online, triggering sync');
      import('@/services/dataSyncService').then(({ syncPendingItems }) => {
        syncPendingItems().catch(err => {
          console.error('Sync failed:', err);
        });
      }).catch(err => {
        console.error('Failed to import dataSyncService:', err);
      });
    };

    window.addEventListener('online', handleOnline);

    return () => {
      window.removeEventListener('online', handleOnline);

      // 停止自动同步
      import('@/services/dataSyncService').then(({ stopAutoSync }) => {
        stopAutoSync();
      }).catch(err => {
        console.error('Failed to import dataSyncService for cleanup:', err);
      });
    };
  }, []);

  return (
    <QueryClientProvider client={queryClient}>
      <LanguageProvider>
        <DataRefreshProvider>
          <PandaStateProvider>
            <BrowserRouter>
              <AppShell> {/* AppShell fetches global layout labels and provides overall structure */}
                <AppRouter /> {/* AppRouter handles page-specific content and routing */}
              </AppShell>
            </BrowserRouter>
          </PandaStateProvider>
        </DataRefreshProvider>
      </LanguageProvider>
      {/* <ReactQueryDevtools initialIsOpen={false} /> */}
    </QueryClientProvider>
  );
};
export default App;
</file>

<file path="src/components/animation/AnimatedTaskCard.tsx">
// src/components/animation/AnimatedTaskCard.tsx
import React, { forwardRef } from 'react';
import { motion } from 'framer-motion';
import TaskCard from '@/components/game/TaskCard';
import { TaskRecord } from '@/services/taskService';
import { listItem } from '@/utils/animation';

interface AnimatedTaskCardProps {
  task: TaskRecord;
  onComplete?: (taskId: number) => void;
  onEdit?: (taskId: number) => void;
  onDelete?: (taskId: number) => void;
  index?: number;
  className?: string;
}

/**
 * 动画任务卡片组件，为TaskCard组件添加动画效果
 * 
 * @param task - 任务数据
 * @param onComplete - 完成任务回调
 * @param onEdit - 编辑任务回调
 * @param onDelete - 删除任务回调
 * @param index - 索引，用于计算动画延迟
 * @param className - CSS类名
 */
const AnimatedTaskCard = forwardRef<HTMLDivElement, AnimatedTaskCardProps>(({
  task,
  onComplete,
  onEdit,
  onDelete,
  index = 0,
  className = ''
}, ref) => {
  return (
    <motion.div
      ref={ref}
      variants={listItem}
      initial="hidden"
      animate="visible"
      exit="exit"
      custom={index}
      layout
      layoutId={`task-${task.id}`}
      whileHover={{ 
        y: -5, 
        boxShadow: '0 10px 20px rgba(0, 0, 0, 0.1)',
        transition: { duration: 0.2 }
      }}
    >
      <TaskCard
        task={task}
        onComplete={onComplete}
        onEdit={onEdit}
        onDelete={onDelete}
        className={className}
      />
    </motion.div>
  );
});

AnimatedTaskCard.displayName = 'AnimatedTaskCard';

export default AnimatedTaskCard;
</file>

<file path="src/components/animation/AnimatedTaskList.tsx">
// src/components/animation/AnimatedTaskList.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { AnimatePresence } from 'framer-motion';
import {
  TaskRecord,
  TaskStatus,
  TaskPriority,
  TaskType,
  getAllTasks,
  completeTask,
  deleteTask
} from '@/services/taskService';

// 扩展Window接口，添加全局回调函数
declare global {
  interface Window {
    handleCompletionAnimationEnd?: () => void;
  }
}
import { RewardRecord } from '@/services/rewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import { TimelyRewardRecord } from '@/services/timelyRewardService';
import AnimatedContainer from './AnimatedContainer';
import AnimatedTaskCard from './AnimatedTaskCard';
import AnimatedButton from './AnimatedButton';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import RewardModal from '@/components/game/RewardModal';
import TimelyRewardCard from '@/components/game/TimelyRewardCard';
import { useComponentLabels } from '@/hooks/useComponentLabels';
import TaskCompletionAnimation from './TaskCompletionAnimation';
import { createContainerVariants } from '@/utils/animation';

interface AnimatedTaskListProps {
  onEditTask: (taskId: number) => void;
  filter?: {
    status?: TaskStatus;
    categoryId?: number;
    type?: TaskType;
    priority?: TaskPriority;
  };
  refreshTrigger?: number;
}

/**
 * 动画任务列表组件，为任务列表添加动画效果
 *
 * @param onEditTask - 编辑任务回调
 * @param filter - 过滤条件
 * @param refreshTrigger - 刷新触发器
 */
const AnimatedTaskList: React.FC<AnimatedTaskListProps> = ({
  onEditTask,
  filter,
  refreshTrigger = 0
}) => {
  const [tasks, setTasks] = useState<TaskRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [showRewardModal, setShowRewardModal] = useState(false);
  const [timelyReward, setTimelyReward] = useState<TimelyRewardRecord | null>(null);
  const [showTimelyReward, setShowTimelyReward] = useState(false);
  const [completedTask, setCompletedTask] = useState<TaskRecord | null>(null);
  const [showCompletionAnimation, setShowCompletionAnimation] = useState(false);

  // Get localized labels
  const { labels } = useComponentLabels();

  // 加载任务
  const loadTasks = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const taskList = await getAllTasks(filter);
      setTasks(taskList);
    } catch (err) {
      console.error('Failed to load tasks:', err);
      setError(labels?.error?.loadingError || 'Failed to load tasks, please try again');
    } finally {
      setIsLoading(false);
    }
  }, [filter]);

  // 初始加载和刷新触发器变化时加载任务
  useEffect(() => {
    loadTasks();
  }, [loadTasks, refreshTrigger]);

  // 定义任务数据更新处理函数 - 使用 useRef 来避免依赖变化
  const filterRef = React.useRef(filter);
  const loadTasksRef = React.useRef(loadTasks);

  // 更新 refs 当依赖变化时
  React.useEffect(() => {
    filterRef.current = filter;
    loadTasksRef.current = loadTasks;
  }, [filter, loadTasks]);

  // 使用稳定的回调函数，不依赖于 filter 或 loadTasks
  const handleTaskDataUpdate = useCallback((taskData: any) => {
    // 使用 ref 值而不是直接依赖
    const currentFilter = filterRef.current;
    const currentLoadTasks = loadTasksRef.current;

    // 如果有特定任务数据，则更新该任务
    if (taskData && taskData.id) {
      setTasks(prevTasks => {
        // 检查任务是否已存在
        const taskExists = prevTasks.some(task => task.id === taskData.id);

        if (taskExists) {
          // 更新现有任务
          return prevTasks.map(task =>
            task.id === taskData.id ? { ...task, ...taskData } : task
          );
        } else {
          // 添加新任务（如果符合过滤条件）
          if (!currentFilter ||
              ((!currentFilter.status || taskData.status === currentFilter.status) &&
               (!currentFilter.categoryId || taskData.categoryId === currentFilter.categoryId) &&
               (!currentFilter.type || taskData.type === currentFilter.type) &&
               (!currentFilter.priority || taskData.priority === currentFilter.priority))) {
            return [...prevTasks, taskData];
          }
          return prevTasks;
        }
      });
    } else {
      // 如果没有特定任务数据，则重新加载所有任务
      currentLoadTasks();
    }
  }, [/* 没有依赖项，使用 ref 来获取最新值 */]);

  // Use useRegisterTableRefresh hook to listen for task table changes
  // Call the hook at the top level. It will manage its own lifecycle.
  useRegisterTableRefresh('tasks', handleTaskDataUpdate);
  // console.log('AnimatedTaskList: Registered table refresh for tasks'); // Optional: for debugging

  // 处理完成任务
  const handleCompleteTask = async (taskId: number) => {
    try {
      setIsLoading(true);

      // 获取要完成的任务
      const taskToComplete = tasks.find(task => task.id === taskId);
      if (!taskToComplete) {
        throw new Error(labels?.error?.taskNotFound || 'Task not found');
      }

      // 先显示任务完成动画
      setCompletedTask(taskToComplete);
      setShowCompletionAnimation(true);

      // 完成任务并获取奖励
      const result = await completeTask(taskId);

      // 不需要手动更新任务列表，数据同步服务会自动触发更新
      // 但为了UI立即响应，我们仍然更新本地状态
      setTasks(prevTasks =>
        prevTasks.map(task =>
          task.id === taskId
            ? { ...task, status: TaskStatus.COMPLETED, completedAt: new Date() }
            : task
        )
      );

      // 动画完成后显示奖励
      const handleCompletionAnimationEnd = () => {
        setShowCompletionAnimation(false);

        // 显示奖励
        if (result.rewards && result.rewards.length > 0) {
          setTimeout(() => {
            setRewards(result.rewards);
            setShowRewardModal(true);
          }, 300);
        }

        // 如果有及时奖励，显示及时奖励
        if (result.timelyReward) {
          setTimelyReward(result.timelyReward);

          // 延迟显示及时奖励，先显示任务奖励
          if (result.rewards && result.rewards.length > 0) {
            setTimeout(() => {
              setShowTimelyReward(true);
            }, 1000);
          } else {
            setTimeout(() => {
              setShowTimelyReward(true);
            }, 500);
          }
        }
      };

      // 如果动画已经完成，直接显示奖励
      if (!showCompletionAnimation) {
        handleCompletionAnimationEnd();
      } else {
        // 否则等待动画完成
        window.handleCompletionAnimationEnd = handleCompletionAnimationEnd;
      }
    } catch (err) {
      console.error('Failed to complete task:', err);
      setError(labels?.error?.completeTaskError || 'Failed to complete task, please try again');
      setShowCompletionAnimation(false);
    } finally {
      setIsLoading(false);
    }
  };

  // 处理删除任务
  const handleDeleteTask = async (taskId: number) => {
    if (!window.confirm(labels?.deleteConfirmation || 'Are you sure you want to delete this task?')) {
      return;
    }

    try {
      setIsLoading(true);
      await deleteTask(taskId);

      // 不需要手动更新任务列表，数据同步服务会自动触发更新
      // 但为了UI立即响应，我们仍然更新本地状态
      setTasks(prevTasks => prevTasks.filter(task => task.id !== taskId));
    } catch (err) {
      console.error('Failed to delete task:', err);
      setError(labels?.error?.deleteTaskError || 'Failed to delete task, please try again');
    } finally {
      setIsLoading(false);
    }
  };

  // 按优先级排序任务
  const sortedTasks = [...tasks].sort((a, b) => {
    // 首先按状态排序（未完成的在前）
    if (a.status !== b.status) {
      if (a.status === TaskStatus.COMPLETED) return 1;
      if (b.status === TaskStatus.COMPLETED) return -1;
    }

    // 然后按优先级排序
    const priorityOrder = {
      [TaskPriority.HIGH]: 0,
      [TaskPriority.MEDIUM]: 1,
      [TaskPriority.LOW]: 2
    };

    return priorityOrder[a.priority] - priorityOrder[b.priority];
  });

  if (isLoading && tasks.length === 0) {
    return <LoadingSpinner variant="jade" text={labels?.loading?.data || "Loading tasks..."} />;
  }

  if (error) {
    return (
      <div className="task-list-error">
        <p>{error}</p>
        <AnimatedButton variant="jade" onClick={() => window.location.reload()}>
          {labels?.button?.retry || "Retry"}
        </AnimatedButton>
      </div>
    );
  }

  if (tasks.length === 0) {
    return (
      <AnimatedContainer
        variants={createContainerVariants(0.1, 0.2)}
        className="task-list-empty"
      >
        <p>{labels?.emptyState?.noItems || "No tasks available"}</p>
      </AnimatedContainer>
    );
  }

  // 关闭奖励模态框
  const handleCloseRewardModal = () => {
    setShowRewardModal(false);
    setRewards([]);

    // 如果有及时奖励，显示及时奖励
    if (timelyReward && !showTimelyReward) {
      setTimeout(() => {
        setShowTimelyReward(true);
      }, 500);
    }
  };

  // 关闭及时奖励
  const handleCloseTimelyReward = () => {
    setShowTimelyReward(false);
    setTimelyReward(null);
  };

  return (
    <div className="task-list">
      {isLoading && (
        <div className="task-list-loading-overlay">
          <LoadingSpinner variant="jade" />
        </div>
      )}

      <AnimatedContainer
        variants={createContainerVariants(0.05, 0)}
      >
        <AnimatePresence mode="popLayout">
          {sortedTasks.map((task, index) => (
            <AnimatedTaskCard
              key={task.id}
              task={task}
              index={index}
              onComplete={handleCompleteTask}
              onEdit={onEditTask}
              onDelete={handleDeleteTask}
            />
          ))}
        </AnimatePresence>
      </AnimatedContainer>

      {/* 奖励模态框 */}
      {showRewardModal && (
        <RewardModal
          isOpen={showRewardModal}
          onClose={handleCloseRewardModal}
          rewards={rewards}
        />
      )}

      {/* Timely reward modal */}
      {showTimelyReward && timelyReward && (
        <div className="timely-reward-modal">
          <div className="timely-reward-modal-backdrop" onClick={handleCloseTimelyReward}></div>
          <div className="timely-reward-modal-content">
            <h3 className="timely-reward-modal-title">{labels?.taskReminder?.title || "Timely Reward"}</h3>
            <p className="timely-reward-modal-description">
              {labels?.timelyRewardCongrats || "Congratulations! You completed the task in time and earned a timely reward!"}
            </p>
            <TimelyRewardCard
              reward={timelyReward}
              onComplete={() => {}}
              labels={labels?.taskReminder}
            />
            <div className="timely-reward-modal-actions">
              <AnimatedButton onClick={handleCloseTimelyReward}>
                {labels?.modal?.close || "Close"}
              </AnimatedButton>
            </div>
          </div>
        </div>
      )}

      {/* 任务完成动画 */}
      {showCompletionAnimation && completedTask && (
        <TaskCompletionAnimation
          task={completedTask}
          style={completedTask.priority === TaskPriority.HIGH ? 'fireworks' :
                 completedTask.type === TaskType.MAIN ? 'stars' : 'confetti'}
          onAnimationComplete={() => {
            setShowCompletionAnimation(false);
            // 调用全局回调函数（如果存在）
            if (window.handleCompletionAnimationEnd) {
              window.handleCompletionAnimationEnd();
              delete window.handleCompletionAnimationEnd;
            }
          }}
        />
      )}
    </div>
  );
};

export default AnimatedTaskList;
</file>

<file path="src/components/animation/RewardAnimation.tsx">
// src/components/animation/RewardAnimation.tsx
import React, { useEffect, useState } from 'react';
import { motion, Variants, AnimatePresence } from 'framer-motion';
import { RewardType, RewardRarity } from '@/services/rewardService';
import { playRewardSound } from '@/utils/sound';

interface RewardAnimationProps {
  type: RewardType;
  rarity: RewardRarity;
  iconPath: string;
  amount?: number;
  size?: number;
  onAnimationComplete?: () => void;
  animationStyle?: 'default' | 'burst' | 'float' | 'spin' | 'pulse';
  playSound?: boolean;
  soundVolume?: number;
}

/**
 * 奖励动画组件
 * 显示奖励获取的动画效果
 *
 * @param type - 奖励类型
 * @param rarity - 奖励稀有度
 * @param iconPath - 图标路径
 * @param amount - 奖励数量
 * @param size - 图标大小
 * @param onAnimationComplete - 动画完成回调
 */
const RewardAnimation: React.FC<RewardAnimationProps> = ({
  type,
  rarity,
  iconPath,
  amount = 1,
  size = 100,
  onAnimationComplete,
  animationStyle = 'default',
  playSound = true,
  soundVolume = 0.5
}) => {
  // 动画完成状态
  const [isAnimationComplete, setIsAnimationComplete] = useState(false);

  // 播放音效
  useEffect(() => {
    if (playSound) {
      playRewardSound(rarity, soundVolume);
    }
  }, [playSound, rarity, soundVolume]);
  // 根据稀有度获取光晕颜色
  const getGlowColor = (rarity: RewardRarity): string => {
    switch (rarity) {
      case RewardRarity.COMMON:
        return 'rgba(255, 255, 255, 0.7)';
      case RewardRarity.UNCOMMON:
        return 'rgba(75, 175, 80, 0.7)';
      case RewardRarity.RARE:
        return 'rgba(33, 150, 243, 0.7)';
      case RewardRarity.EPIC:
        return 'rgba(156, 39, 176, 0.7)';
      case RewardRarity.LEGENDARY:
        return 'rgba(255, 193, 7, 0.7)';
      default:
        return 'rgba(255, 255, 255, 0.7)';
    }
  };

  // 根据稀有度获取粒子数量
  const getParticleCount = (rarity: RewardRarity): number => {
    switch (rarity) {
      case RewardRarity.COMMON:
        return 5;
      case RewardRarity.UNCOMMON:
        return 10;
      case RewardRarity.RARE:
        return 15;
      case RewardRarity.EPIC:
        return 20;
      case RewardRarity.LEGENDARY:
        return 25;
      default:
        return 5;
    }
  };

  // 获取图标动画变体
  const getIconVariants = (): Variants => {
    // 默认动画
    const defaultVariants: Variants = {
      hidden: {
        scale: 0,
        opacity: 0,
        rotate: -180
      },
      visible: {
        scale: 1,
        opacity: 1,
        rotate: 0,
        transition: {
          type: 'spring',
          damping: 10,
          stiffness: 100,
          duration: 0.8
        }
      },
      exit: {
        scale: 0,
        opacity: 0,
        transition: {
          duration: 0.3
        }
      }
    };

    // 爆发动画
    const burstVariants: Variants = {
      hidden: {
        scale: 0,
        opacity: 0,
      },
      visible: {
        scale: [0, 1.5, 1],
        opacity: [0, 1, 1],
        transition: {
          times: [0, 0.6, 1],
          duration: 1,
          ease: "easeOut"
        }
      },
      exit: {
        scale: [1, 1.2, 0],
        opacity: [1, 1, 0],
        transition: {
          duration: 0.5
        }
      }
    };

    // 浮动动画
    const floatVariants: Variants = {
      hidden: {
        y: 50,
        opacity: 0,
      },
      visible: {
        y: [50, -10, 0],
        opacity: [0, 1, 1],
        transition: {
          times: [0, 0.6, 1],
          duration: 1.2,
          ease: "easeOut"
        }
      },
      exit: {
        y: -50,
        opacity: 0,
        transition: {
          duration: 0.5
        }
      }
    };

    // 旋转动画
    const spinVariants: Variants = {
      hidden: {
        scale: 0,
        opacity: 0,
        rotate: 0
      },
      visible: {
        scale: 1,
        opacity: 1,
        rotate: 360 * 2,
        transition: {
          duration: 1.2,
          ease: "easeOut"
        }
      },
      exit: {
        scale: 0,
        opacity: 0,
        rotate: 180,
        transition: {
          duration: 0.5
        }
      }
    };

    // 脉冲动画
    const pulseVariants: Variants = {
      hidden: {
        scale: 0.8,
        opacity: 0,
      },
      visible: {
        scale: [0.8, 1.1, 1, 1.05, 1],
        opacity: 1,
        transition: {
          times: [0, 0.3, 0.5, 0.8, 1],
          duration: 1,
          ease: "easeInOut",
          repeat: 0
        }
      },
      exit: {
        scale: 0.8,
        opacity: 0,
        transition: {
          duration: 0.3
        }
      }
    };

    // 根据动画样式返回对应的变体
    switch (animationStyle) {
      case 'burst':
        return burstVariants;
      case 'float':
        return floatVariants;
      case 'spin':
        return spinVariants;
      case 'pulse':
        return pulseVariants;
      default:
        return defaultVariants;
    }
  };

  // 获取当前动画变体
  const iconVariants = getIconVariants();

  // 数量动画变体
  const amountVariants: Variants = {
    hidden: {
      opacity: 0,
      y: 20
    },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        delay: 0.3,
        duration: 0.5
      }
    },
    exit: {
      opacity: 0,
      y: -20,
      transition: {
        duration: 0.2
      }
    }
  };

  // 光晕动画变体
  const getGlowVariants = (): Variants => {
    // 默认光晕动画
    const defaultGlowVariants: Variants = {
      hidden: {
        scale: 0.5,
        opacity: 0
      },
      visible: {
        scale: [0.5, 1.2, 1],
        opacity: [0, 0.8, 0.5],
        transition: {
          times: [0, 0.5, 1],
          duration: 1
        }
      }
    };

    // 稀有和史诗光晕动画（更强烈的脉冲）
    const rareGlowVariants: Variants = {
      hidden: {
        scale: 0.5,
        opacity: 0
      },
      visible: {
        scale: [0.5, 1.3, 0.9, 1.1, 1],
        opacity: [0, 0.9, 0.7, 0.8, 0.6],
        transition: {
          times: [0, 0.3, 0.5, 0.7, 1],
          duration: 1.5,
          repeat: Infinity,
          repeatType: "reverse"
        }
      }
    };

    // 传说光晕动画（彩虹色变化）
    const legendaryGlowVariants: Variants = {
      hidden: {
        scale: 0.5,
        opacity: 0
      },
      visible: {
        scale: [0.8, 1.2, 1, 1.1, 0.9, 1],
        opacity: [0.3, 0.8, 0.6, 0.7, 0.5, 0.6],
        transition: {
          times: [0, 0.2, 0.4, 0.6, 0.8, 1],
          duration: 3,
          repeat: Infinity,
          repeatType: "loop"
        }
      }
    };

    // 根据稀有度返回对应的光晕动画
    if (rarity === RewardRarity.LEGENDARY) {
      return legendaryGlowVariants;
    } else if (rarity === RewardRarity.EPIC || rarity === RewardRarity.RARE) {
      return rareGlowVariants;
    } else {
      return defaultGlowVariants;
    }
  };

  const glowVariants = getGlowVariants();

  // 生成随机粒子
  const renderParticles = () => {
    const particleCount = getParticleCount(rarity);
    const particles = [];

    // 根据稀有度和动画样式调整粒子效果
    const getParticleStyle = () => {
      // 默认粒子样式
      if (animationStyle === 'default' || animationStyle === 'pulse') {
        // 标准放射状粒子
        for (let i = 0; i < particleCount; i++) {
          const angle = (i / particleCount) * 360;
          const distance = Math.random() * 50 + 50;
          const delay = Math.random() * 0.3;
          const duration = Math.random() * 0.5 + 0.5;
          const size = Math.random() * 6 + 4;

          particles.push(
            <motion.div
              key={`standard-${i}`}
              style={{
                position: 'absolute',
                width: size,
                height: size,
                borderRadius: '50%',
                backgroundColor: getGlowColor(rarity),
                top: '50%',
                left: '50%',
                margin: `-${size / 2}px 0 0 -${size / 2}px`
              }}
              initial={{
                x: 0,
                y: 0,
                opacity: 0
              }}
              animate={{
                x: Math.cos(angle * Math.PI / 180) * distance,
                y: Math.sin(angle * Math.PI / 180) * distance,
                opacity: [0, 1, 0],
                scale: [1, 1.5, 0.5]
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'easeOut'
              }}
            />
          );
        }
      }

      // 爆发式粒子 - 更多、更快的粒子
      if (animationStyle === 'burst') {
        for (let i = 0; i < particleCount * 1.5; i++) {
          const angle = Math.random() * 360;
          const distance = Math.random() * 80 + 40;
          const delay = Math.random() * 0.2;
          const duration = Math.random() * 0.4 + 0.3;
          const size = Math.random() * 5 + 3;

          particles.push(
            <motion.div
              key={`burst-${i}`}
              style={{
                position: 'absolute',
                width: size,
                height: size,
                borderRadius: '50%',
                backgroundColor: getGlowColor(rarity),
                top: '50%',
                left: '50%',
                margin: `-${size / 2}px 0 0 -${size / 2}px`
              }}
              initial={{
                x: 0,
                y: 0,
                opacity: 0
              }}
              animate={{
                x: Math.cos(angle * Math.PI / 180) * distance,
                y: Math.sin(angle * Math.PI / 180) * distance,
                opacity: [0, 1, 0],
                scale: [1, 2, 0]
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'easeOut'
              }}
            />
          );
        }
      }

      // 浮动粒子 - 上升的粒子
      if (animationStyle === 'float') {
        for (let i = 0; i < particleCount; i++) {
          const xOffset = (Math.random() - 0.5) * 80;
          const yDistance = -1 * (Math.random() * 60 + 40);
          const delay = Math.random() * 0.5;
          const duration = Math.random() * 1 + 1;
          const size = Math.random() * 6 + 3;

          particles.push(
            <motion.div
              key={`float-${i}`}
              style={{
                position: 'absolute',
                width: size,
                height: size,
                borderRadius: '50%',
                backgroundColor: getGlowColor(rarity),
                top: '50%',
                left: '50%',
                margin: `-${size / 2}px 0 0 -${size / 2}px`
              }}
              initial={{
                x: xOffset / 3,
                y: 10,
                opacity: 0
              }}
              animate={{
                x: xOffset,
                y: yDistance,
                opacity: [0, 0.8, 0],
                scale: [0.8, 1.2, 0.5]
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'easeOut'
              }}
            />
          );
        }
      }

      // 旋转粒子 - 围绕中心旋转
      if (animationStyle === 'spin') {
        for (let i = 0; i < particleCount; i++) {
          const radius = Math.random() * 30 + 30;
          const startAngle = Math.random() * 360;
          const duration = Math.random() * 2 + 2;
          const delay = Math.random() * 0.3;
          const size = Math.random() * 5 + 3;

          particles.push(
            <motion.div
              key={`spin-${i}`}
              style={{
                position: 'absolute',
                width: size,
                height: size,
                borderRadius: '50%',
                backgroundColor: getGlowColor(rarity),
                top: '50%',
                left: '50%',
                margin: `-${size / 2}px 0 0 -${size / 2}px`
              }}
              initial={{
                opacity: 0,
                x: Math.cos(startAngle * Math.PI / 180) * radius,
                y: Math.sin(startAngle * Math.PI / 180) * radius,
              }}
              animate={{
                opacity: [0, 0.8, 0.8, 0],
                x: [
                  Math.cos(startAngle * Math.PI / 180) * radius,
                  Math.cos((startAngle + 120) * Math.PI / 180) * radius,
                  Math.cos((startAngle + 240) * Math.PI / 180) * radius,
                  Math.cos((startAngle + 360) * Math.PI / 180) * radius
                ],
                y: [
                  Math.sin(startAngle * Math.PI / 180) * radius,
                  Math.sin((startAngle + 120) * Math.PI / 180) * radius,
                  Math.sin((startAngle + 240) * Math.PI / 180) * radius,
                  Math.sin((startAngle + 360) * Math.PI / 180) * radius
                ]
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'linear',
                times: [0, 0.33, 0.66, 1]
              }}
            />
          );
        }
      }

      // 传说级特效 - 额外的星星粒子
      if (rarity === RewardRarity.LEGENDARY) {
        // 添加星形粒子
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * 360;
          const distance = Math.random() * 30 + 60;
          const delay = Math.random() * 0.5 + 0.5;
          const duration = Math.random() * 1.5 + 1.5;

          particles.push(
            <motion.div
              key={`star-${i}`}
              style={{
                position: 'absolute',
                width: 10,
                height: 10,
                top: '50%',
                left: '50%',
                margin: '-5px 0 0 -5px',
                clipPath: 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
                backgroundColor: '#FFD700',
                boxShadow: '0 0 10px #FFD700'
              }}
              initial={{
                x: 0,
                y: 0,
                scale: 0,
                opacity: 0,
                rotate: 0
              }}
              animate={{
                x: Math.cos(angle * Math.PI / 180) * distance,
                y: Math.sin(angle * Math.PI / 180) * distance,
                scale: [0, 1.5, 1, 1.2, 0],
                opacity: [0, 1, 1, 0.8, 0],
                rotate: 360
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'easeInOut',
                times: [0, 0.2, 0.4, 0.8, 1]
              }}
            />
          );
        }
      }
    };

    // 生成粒子
    getParticleStyle();

    return particles;
  };

  // 处理动画完成
  const handleAnimationComplete = () => {
    setIsAnimationComplete(true);
    if (onAnimationComplete) {
      onAnimationComplete();
    }
  };

  // 获取传说级奖励的彩虹边框
  const getLegendaryBorder = () => {
    if (rarity === RewardRarity.LEGENDARY) {
      return (
        <motion.div
          style={{
            position: 'absolute',
            width: '110%',
            height: '110%',
            borderRadius: '50%',
            border: '3px solid transparent',
            backgroundImage: 'linear-gradient(white, white), linear-gradient(to right, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff)',
            backgroundOrigin: 'border-box',
            backgroundClip: 'content-box, border-box',
            top: '-5%',
            left: '-5%'
          }}
          animate={{
            rotate: [0, 360],
          }}
          transition={{
            duration: 8,
            repeat: Infinity,
            ease: 'linear'
          }}
        />
      );
    }
    return null;
  };

  // 获取稀有级奖励的特殊边框
  const getRareBorder = () => {
    if (rarity === RewardRarity.RARE || rarity === RewardRarity.EPIC) {
      return (
        <motion.div
          style={{
            position: 'absolute',
            width: '110%',
            height: '110%',
            borderRadius: '50%',
            border: '2px solid',
            borderColor: rarity === RewardRarity.RARE ? '#0088ff' : '#a335ee',
            top: '-5%',
            left: '-5%'
          }}
          animate={{
            boxShadow: [
              `0 0 5px ${rarity === RewardRarity.RARE ? '#0088ff' : '#a335ee'}`,
              `0 0 15px ${rarity === RewardRarity.RARE ? '#0088ff' : '#a335ee'}`,
              `0 0 5px ${rarity === RewardRarity.RARE ? '#0088ff' : '#a335ee'}`
            ]
          }}
          transition={{
            duration: 2,
            repeat: Infinity,
            ease: 'easeInOut'
          }}
        />
      );
    }
    return null;
  };

  return (
    <div
      style={{
        position: 'relative',
        width: size,
        height: size,
        margin: '0 auto'
      }}
    >
      {/* 特殊边框效果 */}
      {getLegendaryBorder()}
      {getRareBorder()}

      {/* 光晕效果 */}
      <motion.div
        style={{
          position: 'absolute',
          width: '100%',
          height: '100%',
          borderRadius: '50%',
          backgroundColor: getGlowColor(rarity),
          top: 0,
          left: 0
        }}
        variants={glowVariants}
        initial="hidden"
        animate="visible"
      />

      {/* 粒子效果 */}
      <AnimatePresence>
        {!isAnimationComplete && renderParticles()}
      </AnimatePresence>

      {/* 奖励图标 */}
      <motion.div
        style={{
          position: 'relative',
          width: '100%',
          height: '100%',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          zIndex: 2
        }}
        variants={iconVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
        onAnimationComplete={handleAnimationComplete}
      >
        <img
          src={iconPath}
          alt={`${type} reward`}
          style={{
            width: '80%',
            height: '80%',
            objectFit: 'contain',
            filter: rarity === RewardRarity.LEGENDARY
              ? 'drop-shadow(0 0 5px gold)'
              : rarity === RewardRarity.EPIC
                ? 'drop-shadow(0 0 3px purple)'
                : rarity === RewardRarity.RARE
                  ? 'drop-shadow(0 0 3px blue)'
                  : 'none'
          }}
          onError={(e) => {
            // 图标加载失败时使用默认图标
            const target = e.target as HTMLImageElement;
            target.onerror = null; // 防止无限循环
            target.src = type === RewardType.EXPERIENCE
              ? '/assets/rewards/experience.svg'
              : type === RewardType.COIN
                ? '/assets/rewards/coin.svg'
                : '/assets/rewards/item_common.svg';
          }}
        />
      </motion.div>

      {/* 数量显示 */}
      {amount > 1 && (
        <motion.div
          style={{
            position: 'absolute',
            bottom: -10,
            right: -10,
            backgroundColor: 'var(--imperial-gold)',
            color: 'white',
            borderRadius: '50%',
            width: 30,
            height: 30,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            fontWeight: 'bold',
            fontSize: '0.9rem',
            boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)',
            zIndex: 3
          }}
          variants={amountVariants}
          initial="hidden"
          animate="visible"
          exit="exit"
        >
          {amount}
        </motion.div>
      )}

      {/* 稀有度指示器 - 只对稀有及以上显示 */}
      {(rarity === RewardRarity.RARE || rarity === RewardRarity.EPIC || rarity === RewardRarity.LEGENDARY) && (
        <motion.div
          style={{
            position: 'absolute',
            top: -15,
            left: '50%',
            transform: 'translateX(-50%)',
            backgroundColor: rarity === RewardRarity.LEGENDARY
              ? '#FFD700'
              : rarity === RewardRarity.EPIC
                ? '#a335ee'
                : '#0088ff',
            color: 'white',
            borderRadius: '4px',
            padding: '2px 6px',
            fontSize: '0.7rem',
            fontWeight: 'bold',
            boxShadow: `0 0 5px ${
              rarity === RewardRarity.LEGENDARY
                ? '#FFD700'
                : rarity === RewardRarity.EPIC
                  ? '#a335ee'
                  : '#0088ff'
            }`,
            zIndex: 3
          }}
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.5, duration: 0.3 }}
        >
          {rarity === RewardRarity.LEGENDARY
            ? '传说'
            : rarity === RewardRarity.EPIC
              ? '史诗'
              : '稀有'}
        </motion.div>
      )}
    </div>
  );
};

export default RewardAnimation;
</file>

<file path="src/components/game/AbilityList.tsx">
// src/components/game/AbilityList.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import AbilityCard from './AbilityCard';
import { PandaAbilityRecord, AbilityType } from '@/services/pandaAbilityService';
import ScrollDialog from './ScrollDialog';
import { AbilityCardLabels, AbilityDetailLabels, AbilityFilterLabels } from '@/types';

interface AbilityListProps {
  abilities: PandaAbilityRecord[];
  unlockedAbilities: PandaAbilityRecord[];
  onActivateAbility: (abilityId: number) => Promise<void>;
  pandaLevel: number;
  labels?: {
    filters?: AbilityFilterLabels;
    card?: AbilityCardLabels;
    detail?: AbilityDetailLabels;
    noAbilitiesMessage?: string;
  };
}

/**
 * Panda ability list component
 * Displays all panda abilities and allows activation of unlocked abilities
 *
 * @param abilities - List of all abilities
 * @param unlockedAbilities - List of unlocked abilities
 * @param onActivateAbility - Callback function to activate an ability
 * @param pandaLevel - Current panda level
 * @param labels - Localized labels for the component
 */
const AbilityList: React.FC<AbilityListProps> = ({
  abilities,
  unlockedAbilities,
  onActivateAbility,
  pandaLevel,
  labels
}) => {
  const [activeFilter, setActiveFilter] = useState<string>('all');
  const [selectedAbility, setSelectedAbility] = useState<PandaAbilityRecord | null>(null);
  const [isDetailModalOpen, setIsDetailModalOpen] = useState(false);

  // Filter abilities based on selected filter
  const filteredAbilities = abilities.filter(ability => {
    if (activeFilter === 'all') {
      return true;
    }
    if (activeFilter === 'unlocked') {
      return unlockedAbilities.some(unlocked => unlocked.id === ability.id);
    }
    if (activeFilter === 'locked') {
      return !unlockedAbilities.some(unlocked => unlocked.id === ability.id);
    }
    if (activeFilter === 'passive') {
      return ability.type === AbilityType.PASSIVE;
    }
    if (activeFilter === 'active') {
      return ability.type === AbilityType.ACTIVE;
    }
    if (activeFilter === 'ultimate') {
      return ability.type === AbilityType.ULTIMATE;
    }
    return true;
  });

  // Check if ability is unlocked
  const isAbilityUnlocked = (ability: PandaAbilityRecord): boolean => {
    return unlockedAbilities.some(unlocked => unlocked.id === ability.id);
  };

  // Handle ability activation
  const handleActivateAbility = async (abilityId: number) => {
    await onActivateAbility(abilityId);
  };

  // Open ability detail modal
  const openAbilityDetail = (ability: PandaAbilityRecord) => {
    setSelectedAbility(ability);
    setIsDetailModalOpen(true);
  };

  // Close ability detail modal
  const closeAbilityDetail = () => {
    setIsDetailModalOpen(false);
    setSelectedAbility(null);
  };

  return (
    <div className="ability-list-container">
      <div className="filter-section">
        <h3 className="filter-title">{labels?.filters?.statusLabel || 'Status'}</h3>
        <div className="ability-filters">
          <button
            className={`filter-button ${activeFilter === 'all' ? 'active' : ''}`}
            onClick={() => setActiveFilter('all')}
          >
            {labels?.filters?.allLabel || 'All'}
          </button>
          <button
            className={`filter-button ${activeFilter === 'unlocked' ? 'active' : ''}`}
            onClick={() => setActiveFilter('unlocked')}
          >
            {labels?.filters?.unlockedLabel || 'Unlocked'}
          </button>
          <button
            className={`filter-button ${activeFilter === 'locked' ? 'active' : ''}`}
            onClick={() => setActiveFilter('locked')}
          >
            {labels?.filters?.lockedLabel || 'Locked'}
          </button>
          <button
            className={`filter-button ${activeFilter === 'passive' ? 'active' : ''}`}
            onClick={() => setActiveFilter('passive')}
          >
            {labels?.filters?.passiveLabel || 'Passive'}
          </button>
          <button
            className={`filter-button ${activeFilter === 'active' ? 'active' : ''}`}
            onClick={() => setActiveFilter('active')}
          >
            {labels?.filters?.activeLabel || 'Active'}
          </button>
          <button
            className={`filter-button ${activeFilter === 'ultimate' ? 'active' : ''}`}
            onClick={() => setActiveFilter('ultimate')}
          >
            {labels?.filters?.ultimateLabel || 'Ultimate'}
          </button>
        </div>
      </div>

      <div className="abilities-grid">
        <AnimatePresence>
          {filteredAbilities.map(ability => (
            <motion.div
              key={ability.id}
              layout
              initial={{ opacity: 0, scale: 0.8 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.8 }}
              transition={{ duration: 0.3 }}
              onClick={() => openAbilityDetail(ability)}
            >
              <AbilityCard
                ability={ability}
                isUnlocked={isAbilityUnlocked(ability)}
                onActivate={() => ability.id && handleActivateAbility(ability.id)}
                labels={labels?.card}
              />
            </motion.div>
          ))}
        </AnimatePresence>
      </div>

      {filteredAbilities.length === 0 && (
        <div className="no-abilities">
          <p>{labels?.noAbilitiesMessage || 'No abilities match the current filter'}</p>
        </div>
      )}

      {/* Ability detail modal */}
      <ScrollDialog
        isOpen={isDetailModalOpen}
        onClose={closeAbilityDetail}
        title={selectedAbility?.name || labels?.detail?.title || 'Ability Details'}
      >
        {selectedAbility && (
          <div className="ability-detail">
            <div className="ability-detail-icon">
              <img
                src={selectedAbility.iconPath}
                alt={selectedAbility.name}
                onError={(e) => {
                  const target = e.target as HTMLImageElement;
                  target.onerror = null;
                  target.src = '/assets/abilities/default-ability.svg';
                }}
              />
            </div>

            <div className="ability-detail-info">
              <p className="ability-detail-description">
                {selectedAbility.description}
              </p>

              <div className="ability-detail-meta">
                <div className="meta-item">
                  <span className="meta-label">{labels?.detail?.typeLabel || 'Type'}:</span>
                  <span className="meta-value">
                    {selectedAbility.type === AbilityType.PASSIVE
                      ? (labels?.card?.typePassive || 'Passive')
                      : selectedAbility.type === AbilityType.ACTIVE
                        ? (labels?.card?.typeActive || 'Active')
                        : (labels?.card?.typeUltimate || 'Ultimate')}
                  </span>
                </div>

                <div className="meta-item">
                  <span className="meta-label">{labels?.detail?.effectLabel || 'Effect Value'}:</span>
                  <span className="meta-value">{selectedAbility.effectValue * 100}%</span>
                </div>

                {selectedAbility.cooldownMinutes && (
                  <div className="meta-item">
                    <span className="meta-label">{labels?.detail?.cooldownLabel || 'Cooldown'}:</span>
                    <span className="meta-value">{selectedAbility.cooldownMinutes} {labels?.card?.minutesUnit || 'minutes'}</span>
                  </div>
                )}

                <div className="meta-item">
                  <span className="meta-label">{labels?.detail?.requiredLevelLabel || 'Required Level'}:</span>
                  <span className="meta-value">
                    {selectedAbility.requiredLevel}
                    {pandaLevel < selectedAbility.requiredLevel &&
                      ` (${labels?.detail?.levelsNeededText || 'Need'} ${selectedAbility.requiredLevel - pandaLevel} ${labels?.detail?.levelsNeededText ? '' : 'more'})`}
                  </span>
                </div>
              </div>

              {isAbilityUnlocked(selectedAbility) && selectedAbility.type !== AbilityType.PASSIVE && (
                <div className="ability-detail-actions">
                  <button
                    className="activate-detail-button"
                    onClick={() => {
                      selectedAbility.id && handleActivateAbility(selectedAbility.id);
                      closeAbilityDetail();
                    }}
                    disabled={selectedAbility.isActive}
                  >
                    {selectedAbility.isActive
                      ? (labels?.detail?.alreadyActivatedText || 'Already Activated')
                      : (labels?.detail?.activateButtonText || 'Activate Ability')}
                  </button>
                </div>
              )}
            </div>
          </div>
        )}
      </ScrollDialog>
    </div>
  );
};

export default AbilityList;
</file>

<file path="src/components/game/LuckyDraw.tsx">
// src/components/game/LuckyDraw.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  getLuckyPointsTotal,
  performLuckyDraw,
  PrizeLevel
} from '@/services/timelyRewardService';
import { RewardRecord } from '@/services/rewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import LuckyPointsDisplay from './LuckyPointsDisplay';
import RewardAnimation from '@/components/animation/RewardAnimation';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { getLocalizedLabel, getLocalizedLabels } from '@/utils/localization';

interface LuckyDrawProps {
  onClose?: () => void;
  onRewardEarned?: (rewards: RewardRecord[]) => void;
}

/**
 * 幸运抽奖组件
 * 允许用户使用幸运点进行抽奖
 */
const LuckyDraw: React.FC<LuckyDrawProps> = ({ onClose, onRewardEarned }) => {
  const [points, setPoints] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [isDrawing, setIsDrawing] = useState(false);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [showRewards, setShowRewards] = useState(false);
  const [selectedPoints, setSelectedPoints] = useState(10); // 默认使用10点
  const [error, setError] = useState<string | null>(null);
  const [labels, setLabels] = useState({
    title: 'Lucky Draw',
    basicDrawLabel: 'Basic Draw',
    basicDrawDescription: 'Chance to get common rewards',
    premiumDrawLabel: 'Premium Draw',
    premiumDrawDescription: 'Higher chance to get rare rewards',
    deluxeDrawLabel: 'Deluxe Draw',
    deluxeDrawDescription: 'Highest chance to get epic and legendary rewards',
    notEnoughPointsError: 'Not enough lucky points',
    loadPointsError: 'Failed to load lucky points, please try again',
    drawError: 'Failed to perform lucky draw, please try again',
    continueDrawingButton: 'Continue Drawing',
    closeButton: 'Close',
    drawingButton: 'Drawing...',
    drawButton: 'Draw'
  });

  // 抽奖选项
  const drawOptions = [
    { points: 10, label: labels.basicDrawLabel, description: labels.basicDrawDescription },
    { points: 30, label: labels.premiumDrawLabel, description: labels.premiumDrawDescription },
    { points: 50, label: labels.deluxeDrawLabel, description: labels.deluxeDrawDescription }
  ];

  // 加载本地化标签
  useEffect(() => {
    const loadLocalizedLabels = async () => {
      const languageCode = localStorage.getItem('language') || 'en';
      const localizedLabels = await getLocalizedLabels('luckyDraw', languageCode);

      if (Object.keys(localizedLabels).length > 0) {
        setLabels(prev => ({
          ...prev,
          ...localizedLabels
        }));
      }
    };

    loadLocalizedLabels();
  }, []);

  // 加载幸运点数量
  const loadPoints = async () => {
    try {
      setIsLoading(true);
      const total = await getLuckyPointsTotal();
      setPoints(total);
    } catch (err) {
      console.error('Failed to load lucky points:', err);
      setError(labels.loadPointsError);
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadPoints();
  }, []);

  // 定义幸运点数据更新处理函数
  const handleLuckyPointsUpdate = useCallback(() => {
    loadPoints();
  }, [loadPoints]);

  // 使用 useRegisterTableRefresh hook 监听幸运点表的变化
  useRegisterTableRefresh('luckyPoints', handleLuckyPointsUpdate);

  // 处理抽奖
  const handleDraw = async () => {
    if (points < selectedPoints) {
      setError(labels.notEnoughPointsError);
      return;
    }

    try {
      setIsDrawing(true);
      setError(null);

      // 执行抽奖
      const result = await performLuckyDraw(selectedPoints);

      // 更新幸运点
      setPoints(prev => prev - selectedPoints);

      // 设置奖励
      setRewards(result.rewards);

      // 显示奖励动画
      setTimeout(() => {
        setShowRewards(true);
      }, 1000);

      // 通知父组件
      if (onRewardEarned) {
        onRewardEarned(result.rewards);
      }
    } catch (err) {
      console.error('Failed to perform lucky draw:', err);
      setError(labels.drawError);
    } finally {
      setIsDrawing(false);
    }
  };

  // 处理关闭
  const handleClose = () => {
    if (onClose) {
      onClose();
    }
  };

  // 处理选择抽奖选项
  const handleSelectOption = (points: number) => {
    setSelectedPoints(points);
  };

  // 处理继续抽奖
  const handleContinue = () => {
    setShowRewards(false);
    setRewards([]);
  };

  return (
    <div className="lucky-draw-container">
      <div className="lucky-draw-header">
        <h2 className="lucky-draw-title">{labels.title}</h2>
        <LuckyPointsDisplay variant="large" />
      </div>

      {isLoading ? (
        <LoadingSpinner />
      ) : showRewards ? (
        <div className="lucky-draw-results">
          <RewardAnimation rewards={rewards} />
          <div className="lucky-draw-actions">
            <Button onClick={handleContinue}>{labels.continueDrawingButton}</Button>
            <Button onClick={handleClose}>{labels.closeButton}</Button>
          </div>
        </div>
      ) : (
        <>
          <div className="lucky-draw-options">
            <AnimatePresence>
              {drawOptions.map(option => (
                <motion.div
                  key={option.points}
                  className={`draw-option ${selectedPoints === option.points ? 'selected' : ''} ${points < option.points ? 'disabled' : ''}`}
                  onClick={() => handleSelectOption(option.points)}
                  whileHover={{ scale: points >= option.points ? 1.05 : 1 }}
                  whileTap={{ scale: points >= option.points ? 0.95 : 1 }}
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -20 }}
                  transition={{ duration: 0.3 }}
                >
                  <div className="draw-option-header">
                    <div className="draw-option-points">
                      <span className="lucky-points-icon">🍀</span>
                      <span>{option.points}</span>
                    </div>
                    <h3 className="draw-option-label">{option.label}</h3>
                  </div>
                  <p className="draw-option-description">{option.description}</p>
                  {points < option.points && (
                    <div className="draw-option-insufficient">{labels.notEnoughPointsError}</div>
                  )}
                </motion.div>
              ))}
            </AnimatePresence>
          </div>

          {error && (
            <div className="error-message">{error}</div>
          )}

          <div className="lucky-draw-actions">
            <Button
              onClick={handleDraw}
              disabled={isDrawing || points < selectedPoints}
              className="draw-button"
            >
              {isDrawing ? labels.drawingButton : labels.drawButton}
            </Button>
            <Button onClick={handleClose}>{labels.closeButton}</Button>
          </div>
        </>
      )}
    </div>
  );
};

export default LuckyDraw;
</file>

<file path="src/components/game/LuckyPointsDisplay.tsx">
// src/components/game/LuckyPointsDisplay.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { getLuckyPointsTotal } from '@/services/timelyRewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import { getLocalizedLabel } from '@/utils/localization';

interface LuckyPointsDisplayProps {
  onClick?: () => void;
  variant?: 'default' | 'compact' | 'large';
}

/**
 * 幸运点显示组件
 * 显示用户当前的幸运点数量
 */
const LuckyPointsDisplay: React.FC<LuckyPointsDisplayProps> = ({
  onClick,
  variant = 'default'
}) => {
  const [points, setPoints] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [isAnimating, setIsAnimating] = useState(false);
  const [labels, setLabels] = useState<{
    label: string;
    loadingText: string;
  }>({
    label: 'Lucky Points',
    loadingText: 'Loading...'
  });

  // 加载幸运点数量
  const loadPoints = async () => {
    try {
      setIsLoading(true);
      const total = await getLuckyPointsTotal();
      setPoints(total);
    } catch (err) {
      console.error('Failed to load lucky points:', err);
    } finally {
      setIsLoading(false);
    }
  };

  // 加载本地化标签
  useEffect(() => {
    const loadLabels = async () => {
      const languageCode = localStorage.getItem('language') || 'en';
      const labelText = await getLocalizedLabel('luckyPointsDisplay', 'label', languageCode);
      const loadingText = await getLocalizedLabel('luckyPointsDisplay', 'loadingText', languageCode);

      setLabels({
        label: labelText || 'Lucky Points',
        loadingText: loadingText || 'Loading...'
      });
    };

    loadLabels();
  }, []);

  // 初始加载
  useEffect(() => {
    loadPoints();
  }, []);

  // 定义幸运点数据更新处理函数
  const handleLuckyPointsUpdate = useCallback(() => {
    loadPoints();
    setIsAnimating(true);

    // 动画结束后重置状态
    setTimeout(() => {
      setIsAnimating(false);
    }, 1000);
  }, [loadPoints]);

  // 使用 useRegisterTableRefresh hook 监听幸运点表的变化
  useRegisterTableRefresh('luckyPoints', handleLuckyPointsUpdate);

  // 处理点击事件
  const handleClick = () => {
    if (onClick) {
      onClick();
    }
  };

  // 获取变体类名
  const getVariantClass = () => {
    switch (variant) {
      case 'compact':
        return 'lucky-points-compact';
      case 'large':
        return 'lucky-points-large';
      default:
        return 'lucky-points-default';
    }
  };

  return (
    <motion.div
      className={`lucky-points-display ${getVariantClass()} ${isAnimating ? 'animating' : ''}`}
      onClick={handleClick}
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
    >
      <div className="lucky-points-icon">🍀</div>
      <AnimatePresence mode="wait">
        <motion.div
          key={points}
          className="lucky-points-value"
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: 10 }}
          transition={{ duration: 0.3 }}
        >
          {isLoading ? (
            <span className="loading-dots">{labels.loadingText}</span>
          ) : (
            <span>{points}</span>
          )}
        </motion.div>
      </AnimatePresence>
      <div className="lucky-points-label">{labels.label}</div>
    </motion.div>
  );
};

export default LuckyPointsDisplay;
</file>

<file path="src/components/game/PandaAvatar.tsx">
// src/components/game/PandaAvatar.tsx
import React, { useState, useEffect } from 'react';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import {
  getEquippedAccessories,
  PandaAccessoryRecord,
  PandaAccessoryType,
  getActiveEnvironment,
  PandaEnvironmentRecord
} from '@/services/pandaCustomizationService';

// 熊猫状态类型
export type PandaMood = 'normal' | 'happy' | 'focused' | 'tired';

// 熊猫能量级别
export type EnergyLevel = 'high' | 'medium' | 'low';

interface PandaAvatarProps {
  mood?: PandaMood;
  energy?: EnergyLevel;
  size?: number;
  onClick?: () => void;
  className?: string;
  animate?: boolean;
  showAccessories?: boolean;
  showEnvironment?: boolean;
}

/**
 * 熊猫头像组件，显示不同情绪和能量状态的熊猫
 *
 * @param mood - 熊猫的情绪状态：normal(正常), happy(开心), focused(专注), tired(疲惫)
 * @param energy - 熊猫的能量级别：high(高), medium(中), low(低)
 * @param size - 头像大小，默认为120px
 * @param onClick - 点击头像时的回调函数
 * @param className - 额外的CSS类名
 * @param animate - 是否启用动画效果
 * @param showAccessories - 是否显示装饰，默认为true
 * @param showEnvironment - 是否显示环境，默认为false
 */
const PandaAvatar: React.FC<PandaAvatarProps> = ({
  mood = 'normal',
  energy = 'medium',
  size = 120,
  onClick,
  className = '',
  animate = true,
  showAccessories = true,
  showEnvironment = false
}) => {
  const [isAnimating, setIsAnimating] = useState(false);
  const [accessories, setAccessories] = useState<PandaAccessoryRecord[]>([]);
  const [environment, setEnvironment] = useState<PandaEnvironmentRecord | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // 加载装饰和环境
  const loadCustomizations = async () => {
    try {
      setIsLoading(true);

      // 加载装饰
      if (showAccessories) {
        const equippedAccessories = await getEquippedAccessories();
        setAccessories(equippedAccessories);
      }

      // 加载环境
      if (showEnvironment) {
        const activeEnvironment = await getActiveEnvironment();
        if (activeEnvironment) {
          setEnvironment(activeEnvironment);
        }
      }
    } catch (err) {
      console.error('Failed to load customizations:', err);
    } finally {
      setIsLoading(false);
    }
  };

  // 初始加载
  useEffect(() => {
    loadCustomizations();
  }, [showAccessories, showEnvironment]);

  // 注册数据刷新监听
  useRegisterTableRefresh('pandaAccessories', loadCustomizations);
  useRegisterTableRefresh('pandaEnvironments', loadCustomizations);

  // 根据情绪状态获取对应的SVG图像路径
  const getPandaImage = (pandaMood: PandaMood) => {
    switch (pandaMood) {
      case 'happy':
        return '/assets/panda-happy.svg';
      case 'focused':
        return '/assets/panda-focused.svg';
      case 'tired':
        return '/assets/panda-tired.svg';
      case 'normal':
      default:
        return '/assets/panda-normal.svg';
    }
  };

  // 根据能量级别获取对应的样式
  const getEnergyStyle = (level: EnergyLevel) => {
    switch (level) {
      case 'high':
        return { filter: 'brightness(1.2) saturate(1.2)', transform: 'scale(1.05)' };
      case 'low':
        return { filter: 'brightness(0.9) saturate(0.8)', transform: 'scale(0.95)' };
      case 'medium':
      default:
        return { filter: 'brightness(1) saturate(1)', transform: 'scale(1)' };
    }
  };

  // 处理点击事件
  const handleClick = () => {
    if (onClick) {
      onClick();
    }

    if (animate) {
      setIsAnimating(true);
      setTimeout(() => setIsAnimating(false), 500);
    }
  };

  // 动画效果
  useEffect(() => {
    if (animate && isAnimating) {
      // 动画逻辑可以在这里添加
    }
  }, [animate, isAnimating]);

  // 获取装饰的z-index
  const getAccessoryZIndex = (type: PandaAccessoryType): number => {
    switch (type) {
      case PandaAccessoryType.BACKGROUND:
        return -1;
      case PandaAccessoryType.FRAME:
        return 1;
      case PandaAccessoryType.HAT:
        return 2;
      case PandaAccessoryType.GLASSES:
        return 3;
      case PandaAccessoryType.SCARF:
        return 4;
      case PandaAccessoryType.PENDANT:
        return 5;
      case PandaAccessoryType.EFFECT:
        return 10;
      default:
        return 0;
    }
  };

  // 组合样式
  const energyStyle = getEnergyStyle(energy);
  const animationStyle = isAnimating ? { animation: 'panda-bounce 0.5s ease' } : {};
  const combinedStyle = {
    width: `${size}px`,
    height: `${size}px`,
    cursor: onClick ? 'pointer' : 'default',
    transition: 'all 0.3s ease',
    ...energyStyle,
    ...animationStyle
  };

  // 环境样式
  const environmentStyle = showEnvironment && environment ? {
    backgroundImage: `url(${environment.backgroundPath})`,
    backgroundSize: 'cover',
    backgroundPosition: 'center',
    borderRadius: '8px',
    padding: '10px'
  } : {};

  return (
    <div
      className={`panda-environment ${className}`}
      style={environmentStyle}
    >
      <div
        className={`panda-avatar ${className}`}
        style={combinedStyle}
        onClick={handleClick}
      >
        {/* 背景装饰 */}
        {showAccessories && accessories.filter(a => a.type === PandaAccessoryType.BACKGROUND).map(accessory => (
          <img
            key={accessory.id}
            src={accessory.imagePath}
            alt={accessory.name}
            style={{
              position: 'absolute',
              width: '100%',
              height: '100%',
              zIndex: getAccessoryZIndex(accessory.type)
            }}
          />
        ))}

        {/* 熊猫基础图像 */}
        <img
          src={getPandaImage(mood)}
          alt={`Panda in ${mood} mood`}
          style={{ width: '100%', height: '100%', position: 'relative', zIndex: 0 }}
        />

        {/* 其他装饰 */}
        {showAccessories && accessories.filter(a => a.type !== PandaAccessoryType.BACKGROUND).map(accessory => (
          <img
            key={accessory.id}
            src={accessory.imagePath}
            alt={accessory.name}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',
              zIndex: getAccessoryZIndex(accessory.type),
              pointerEvents: 'none'
            }}
          />
        ))}
      </div>

      {/* 环境前景 */}
      {showEnvironment && environment && environment.foregroundPath && (
        <img
          src={environment.foregroundPath}
          alt={`${environment.name} foreground`}
          style={{
            position: 'absolute',
            bottom: 0,
            left: 0,
            width: '100%',
            zIndex: 20,
            pointerEvents: 'none'
          }}
        />
      )}
    </div>
  );
};

export default PandaAvatar;
</file>

<file path="src/components/game/RewardModal.tsx">
// src/components/game/RewardModal.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ScrollDialog from './ScrollDialog';
import Button from '@/components/common/Button';
import RewardAnimation from '@/components/animation/RewardAnimation';
import { RewardRecord, markRewardsAsViewed } from '@/services/rewardService';
import { useTableRefresh } from '@/hooks/useDataRefresh';

interface RewardModalProps {
  isOpen: boolean;
  onClose: () => void;
  rewards: RewardRecord[];
}

/**
 * 奖励展示模态框
 * 以卷轴风格展示任务完成后获得的奖励
 *
 * @param isOpen - 控制模态框是否显示
 * @param onClose - 关闭模态框的回调函数
 * @param rewards - 要展示的奖励列表
 */
const RewardModal: React.FC<RewardModalProps> = ({
  isOpen,
  onClose,
  rewards
}) => {
  const [currentRewardIndex, setCurrentRewardIndex] = useState(0);
  const [showAll, setShowAll] = useState(false);
  const [animationComplete, setAnimationComplete] = useState(false);

  // 当前展示的奖励
  const currentReward = rewards[currentRewardIndex];

  // 重置状态
  useEffect(() => {
    if (isOpen) {
      setCurrentRewardIndex(0);
      setShowAll(false);
      setAnimationComplete(false);
    }
  }, [isOpen]);

  // 标记奖励为已查看
  useEffect(() => {
    if (!isOpen) return;

    const rewardIds = rewards
      .filter(reward => reward.id !== undefined)
      .map(reward => reward.id as number);

    if (rewardIds.length > 0) {
      markRewardsAsViewed(rewardIds);
    }
  }, [isOpen, rewards]);

  // 处理动画完成
  const handleAnimationComplete = () => {
    setAnimationComplete(true);
  };

  // 显示下一个奖励
  const handleNextReward = () => {
    if (currentRewardIndex < rewards.length - 1) {
      setCurrentRewardIndex(prev => prev + 1);
      setAnimationComplete(false);
    } else {
      setShowAll(true);
    }
  };

  // 获取奖励稀有度的名称
  const getRarityName = (rarity: string): string => {
    switch (rarity) {
      case 'common': return 'Common';
      case 'uncommon': return 'Uncommon';
      case 'rare': return 'Rare';
      case 'epic': return 'Epic';
      case 'legendary': return 'Legendary';
      default: return 'Common';
    }
  };

  // 获取奖励类型的名称
  const getTypeName = (type: string): string => {
    switch (type) {
      case 'experience': return 'Experience';
      case 'coin': return 'Bamboo Coin';
      case 'item': return 'Item';
      case 'badge': return 'Badge';
      case 'ability': return 'Ability';
      default: return 'Reward';
    }
  };

  // 根据稀有度获取动画样式
  const getAnimationStyleForRarity = (rarity: string): 'default' | 'burst' | 'float' | 'spin' | 'pulse' => {
    switch (rarity) {
      case 'legendary': return 'burst';
      case 'epic': return 'spin';
      case 'rare': return 'pulse';
      case 'uncommon': return 'float';
      default: return 'default';
    }
  };

  // 渲染单个奖励展示
  const renderSingleReward = () => {
    // 确保有奖励可以显示
    if (!rewards.length || !currentReward) {
      return (
        <div className="reward-showcase">
          <h3 className="reward-title">No Rewards</h3>
          <div className="reward-navigation">
            <Button variant="gold" onClick={onClose}>
              Close
            </Button>
          </div>
        </div>
      );
    }

    return (
      <div className="reward-showcase">
        <h3 className="reward-title">
          You got a {getTypeName(currentReward.type)} reward!
        </h3>

        <div className="reward-animation-container">
          <RewardAnimation
            type={currentReward.type}
            rarity={currentReward.rarity}
            iconPath={currentReward.iconPath}
            amount={currentReward.amount}
            size={120}
            onAnimationComplete={handleAnimationComplete}
            animationStyle={getAnimationStyleForRarity(currentReward.rarity)}
            playSound={true}
            soundVolume={0.6}
          />
        </div>

        <div className="reward-details">
          <h4>{currentReward.name}</h4>
          <p className="reward-rarity">
            {getRarityName(currentReward.rarity)}
          </p>
          <p className="reward-description">
            {currentReward.description}
          </p>
          {currentReward.amount > 1 && (
            <p className="reward-amount">
              Quantity: {currentReward.amount}
            </p>
          )}
        </div>

        <div className="reward-navigation">
          <AnimatePresence>
            {animationComplete && (
              <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                transition={{ duration: 0.3 }}
              >
                {currentRewardIndex < rewards.length - 1 ? (
                  <Button variant="jade" onClick={handleNextReward}>
                    Next Reward
                  </Button>
                ) : (
                  <Button variant="jade" onClick={() => setShowAll(true)}>
                    View All Rewards
                  </Button>
                )}
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      </div>
    );
  };

  // 渲染所有奖励列表
  const renderAllRewards = () => {
    // 确保有奖励可以显示
    if (!rewards.length) {
      return (
        <div className="rewards-summary">
          <h3 className="rewards-summary-title">No Rewards</h3>
          <div className="rewards-summary-footer">
            <Button variant="gold" onClick={onClose}>
              Close
            </Button>
          </div>
        </div>
      );
    }

    return (
      <div className="rewards-summary">
        <h3 className="rewards-summary-title">
          Rewards Summary
        </h3>

        <div className="rewards-list">
          {rewards.map((reward, index) => (
            <div key={index} className="reward-item">
              <div className="reward-item-icon">
                <img
                  src={reward.iconPath}
                  alt={reward.name}
                  style={{ width: 40, height: 40 }}
                />
              </div>
              <div className="reward-item-details">
                <h4>{reward.name}</h4>
                <p className="reward-item-description">
                  {reward.description}
                </p>
              </div>
              <div className="reward-item-amount">
                {reward.amount > 0 && `x${reward.amount}`}
              </div>
            </div>
          ))}
        </div>

        <div className="rewards-summary-footer">
          <Button variant="gold" onClick={onClose}>
            Close
          </Button>
        </div>
      </div>
    );
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="Task Rewards"
      closeOnOutsideClick={false}
      closeOnEsc={false}
      showCloseButton={showAll}
      footer={null}
    >
      <div className="reward-modal-content">
        {!showAll ? renderSingleReward() : renderAllRewards()}
      </div>
    </ScrollDialog>
  );
};

export default RewardModal;
</file>

<file path="src/components/game/TaskCard.tsx">
// src/components/game/TaskCard.tsx
import React, { useState } from 'react';
import { TaskRecord, TaskPriority, TaskStatus, TaskType } from '@/services/taskService';
import { hasSubtasks } from '@/services/subtaskService';
import TaskDetailDialog from './TaskDetailDialog';

interface TaskCardProps {
  task: TaskRecord;
  onComplete?: (taskId: number) => void;
  onEdit?: (taskId: number) => void;
  onDelete?: (taskId: number) => void;
  onTaskUpdated?: () => void;
  className?: string;
}

/**
 * 任务卡片组件，显示任务信息和操作按钮
 */
const TaskCard: React.FC<TaskCardProps> = ({
  task,
  onComplete,
  onEdit,
  onDelete,
  onTaskUpdated,
  className = ''
}) => {
  const [showDetailDialog, setShowDetailDialog] = useState(false);
  const [hasSubtasksList, setHasSubtasksList] = useState(false);

  // 检查任务是否有子任务
  React.useEffect(() => {
    const checkSubtasks = async () => {
      if (task && task.id) {
        try {
          const hasSubtasksList = await hasSubtasks(task.id);
          setHasSubtasksList(hasSubtasksList);
        } catch (err) {
          console.error('Failed to check subtasks:', err);
        }
      }
    };

    checkSubtasks();
  }, [task]);
  // 获取任务优先级对应的样式
  const getPriorityStyle = (priority: TaskPriority) => {
    switch (priority) {
      case TaskPriority.HIGH:
        return 'task-priority-high';
      case TaskPriority.MEDIUM:
        return 'task-priority-medium';
      case TaskPriority.LOW:
        return 'task-priority-low';
      default:
        return '';
    }
  };

  // 获取任务类型对应的样式
  const getTypeStyle = (type: TaskType) => {
    switch (type) {
      case TaskType.MAIN:
        return 'task-type-main';
      case TaskType.DAILY:
        return 'task-type-daily';
      case TaskType.SIDE:
        return 'task-type-side';
      default:
        return '';
    }
  };

  // 获取任务状态对应的样式
  const getStatusStyle = (status: TaskStatus) => {
    switch (status) {
      case TaskStatus.COMPLETED:
        return 'task-status-completed';
      case TaskStatus.IN_PROGRESS:
        return 'task-status-in-progress';
      case TaskStatus.TODO:
        return 'task-status-todo';
      case TaskStatus.ARCHIVED:
        return 'task-status-archived';
      default:
        return '';
    }
  };

  // 格式化日期显示
  const formatDate = (date: Date | undefined) => {
    if (!date) return '';
    return new Date(date).toLocaleDateString();
  };

  // 处理完成任务
  const handleComplete = () => {
    if (onComplete && task.id) {
      onComplete(task.id);
    }
  };

  // 处理编辑任务
  const handleEdit = () => {
    if (onEdit && task.id) {
      onEdit(task.id);
    }
  };

  // 处理删除任务
  const handleDelete = () => {
    if (onDelete && task.id) {
      onDelete(task.id);
    }
  };

  // 处理查看详情
  const handleViewDetails = () => {
    setShowDetailDialog(true);
  };

  // 处理任务更新
  const handleTaskUpdated = () => {
    if (onTaskUpdated) {
      onTaskUpdated();
    }
  };

  return (
    <>
      <div
        className={`task-card ${getPriorityStyle(task.priority)} ${getStatusStyle(task.status)} ${className}`}
        onClick={handleViewDetails}
      >
        <div className="task-card-header">
          <div className={`task-type-badge ${getTypeStyle(task.type)}`}>
            {task.type.toUpperCase()}
          </div>
          <h3 className="task-title">{task.title}</h3>
          {hasSubtasksList && (
            <div className="subtasks-indicator ml-2" title="包含子任务">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
              </svg>
            </div>
          )}
        </div>

      {task.description && (
        <div className="task-description">
          {task.description}
        </div>
      )}

      <div className="task-meta">
        {task.dueDate && (
          <div className="task-due-date">
            <span>Due: {formatDate(task.dueDate)}</span>
          </div>
        )}

        {task.estimatedMinutes && (
          <div className="task-estimated-time">
            <span>Est: {task.estimatedMinutes} min</span>
          </div>
        )}
      </div>

      <div className="task-actions">
        {task.status !== TaskStatus.COMPLETED && (
          <button
            className="task-action-complete jade-button-small"
            onClick={handleComplete}
            aria-label="Complete task"
          >
            完成
          </button>
        )}

        <button
          className="task-action-edit"
          onClick={handleEdit}
          aria-label="Edit task"
        >
          编辑
        </button>

        <button
          className="task-action-delete"
          onClick={handleDelete}
          aria-label="Delete task"
        >
          删除
        </button>
      </div>
      </div>

      {/* 任务详情对话框 */}
      {showDetailDialog && (
        <TaskDetailDialog
          isOpen={showDetailDialog}
          onClose={() => setShowDetailDialog(false)}
          task={task}
          onTaskUpdated={handleTaskUpdated}
        />
      )}
    </>
  );
};

export default TaskCard;
</file>

<file path="src/components/game/TaskList.tsx">
// src/components/game/TaskList.tsx
import React, { useState, useEffect } from 'react';
import {
  TaskRecord,
  TaskStatus,
  TaskPriority,
  TaskType,
  TaskCategoryRecord,
  getAllTasks,
  getAllTaskCategories,
  completeTask,
  deleteTask
} from '@/services/taskService';
import TaskCard from './TaskCard';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';

interface TaskListProps {
  onEditTask: (taskId: number) => void;
  filter?: {
    status?: TaskStatus;
    categoryId?: number;
    type?: TaskType;
    priority?: TaskPriority;
  };
  refreshTrigger?: number; // 用于触发刷新的值
}

/**
 * 任务列表组件，显示任务卡片列表
 */
const TaskList: React.FC<TaskListProps> = ({
  onEditTask,
  filter,
  refreshTrigger = 0
}) => {
  const [tasks, setTasks] = useState<TaskRecord[]>([]);
  const [categories, setCategories] = useState<Record<number, TaskCategoryRecord>>({});
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 加载任务和类别
  useEffect(() => {
    const loadData = async () => {
      try {
        setIsLoading(true);
        setError(null);

        // 加载任务
        const taskList = await getAllTasks(filter);
        setTasks(taskList);

        // 加载类别
        const categoryList = await getAllTaskCategories();
        const categoryMap: Record<number, TaskCategoryRecord> = {};
        categoryList.forEach(category => {
          if (category.id) {
            categoryMap[category.id] = category;
          }
        });
        setCategories(categoryMap);
      } catch (err) {
        console.error('Failed to load tasks:', err);
        setError('加载任务失败，请重试');
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, [filter, refreshTrigger]);

  // 处理完成任务
  const handleCompleteTask = async (taskId: number) => {
    try {
      setIsLoading(true);
      await completeTask(taskId);

      // 更新任务列表
      setTasks(prevTasks =>
        prevTasks.map(task =>
          task.id === taskId
            ? { ...task, status: TaskStatus.COMPLETED, completedAt: new Date() }
            : task
        )
      );
    } catch (err) {
      console.error('Failed to complete task:', err);
      setError('完成任务失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 处理删除任务
  const handleDeleteTask = async (taskId: number) => {
    if (!window.confirm('确定要删除这个任务吗？')) {
      return;
    }

    try {
      setIsLoading(true);
      await deleteTask(taskId);

      // 更新任务列表
      setTasks(prevTasks => prevTasks.filter(task => task.id !== taskId));
    } catch (err) {
      console.error('Failed to delete task:', err);
      setError('删除任务失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  // 获取任务类别名称
  const getCategoryName = (categoryId: number) => {
    return categories[categoryId]?.name || '未分类';
  };

  // 按优先级排序任务
  const sortedTasks = [...tasks].sort((a, b) => {
    // 首先按状态排序（未完成的在前）
    if (a.status !== b.status) {
      if (a.status === TaskStatus.COMPLETED) return 1;
      if (b.status === TaskStatus.COMPLETED) return -1;
    }

    // 然后按优先级排序
    const priorityOrder = {
      [TaskPriority.HIGH]: 0,
      [TaskPriority.MEDIUM]: 1,
      [TaskPriority.LOW]: 2
    };

    return priorityOrder[a.priority] - priorityOrder[b.priority];
  });

  if (isLoading && tasks.length === 0) {
    return <LoadingSpinner variant="jade" text="加载任务中..." />;
  }

  if (error) {
    return (
      <div className="task-list-error">
        <p>{error}</p>
        <Button variant="jade" onClick={() => window.location.reload()}>
          重试
        </Button>
      </div>
    );
  }

  if (tasks.length === 0) {
    return (
      <div className="task-list-empty">
        <p>暂无任务</p>
      </div>
    );
  }

  // 处理任务更新
  const handleTaskUpdated = async () => {
    try {
      setIsLoading(true);
      const taskList = await getAllTasks(filter);
      setTasks(taskList);
    } catch (err) {
      console.error('Failed to reload tasks:', err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="task-list">
      {isLoading && (
        <div className="task-list-loading-overlay">
          <LoadingSpinner variant="jade" />
        </div>
      )}

      {sortedTasks.map(task => (
        <TaskCard
          key={task.id}
          task={task}
          onComplete={handleCompleteTask}
          onEdit={onEditTask}
          onDelete={handleDeleteTask}
          onTaskUpdated={handleTaskUpdated}
        />
      ))}
    </div>
  );
};

export default TaskList;
</file>

<file path="src/components/game/TimelyRewardList.tsx">
// src/components/game/TimelyRewardList.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  TimelyRewardRecord,
  TimelyRewardStatus,
  TimelyRewardType,
  getAllTimelyRewards,
  completeTimelyReward,
  updateTimelyRewardsStatus
} from '@/services/timelyRewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import TimelyRewardCard from './TimelyRewardCard';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import RewardModal from '@/components/game/RewardModal';
import { RewardRecord } from '@/services/rewardService';
import ScrollDialog from './ScrollDialog';
import LuckyPointsDisplay from './LuckyPointsDisplay';
import { TimelyRewardCardLabels } from '@/types';

interface TimelyRewardListProps {
  filter?: {
    status?: TimelyRewardStatus;
    type?: TimelyRewardType;
  };
  onSelectReward?: (reward: TimelyRewardRecord) => void;
  labels?: TimelyRewardCardLabels;
}

/**
 * Timely reward list component
 * Displays a list of timely rewards with filtering and selection support
 */
const TimelyRewardList: React.FC<TimelyRewardListProps> = ({ filter, onSelectReward, labels }) => {
  // Add console log to check labels
  console.log('TimelyRewardList labels:', labels);
  const [rewards, setRewards] = useState<TimelyRewardRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [earnedRewards, setEarnedRewards] = useState<RewardRecord[]>([]);
  const [showRewardModal, setShowRewardModal] = useState(false);
  const [selectedReward, setSelectedReward] = useState<TimelyRewardRecord | null>(null);
  const [showRewardDetails, setShowRewardDetails] = useState(false);

  // 加载及时奖励
  const loadTimelyRewards = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      // 更新及时奖励状态
      await updateTimelyRewardsStatus();

      // 获取及时奖励列表
      const rewardList = await getAllTimelyRewards(filter);
      setRewards(rewardList);
    } catch (err) {
      console.error('Failed to load timely rewards:', err);
      setError('Failed to load timely rewards, please try again');
    } finally {
      setIsLoading(false);
    }
  }, [filter]);

  // 初始加载
  useEffect(() => {
    loadTimelyRewards();
  }, [loadTimelyRewards]);

  // 定义奖励数据更新处理函数
  const handleRewardDataUpdate = useCallback((rewardData: any) => {
    // 如果有特定奖励数据，则更新该奖励
    if (rewardData && rewardData.id) {
      setRewards(prevRewards => {
        // 检查奖励是否已存在
        const rewardExists = prevRewards.some(reward => reward.id === rewardData.id);

        if (rewardExists) {
          // 更新现有奖励
          return prevRewards.map(reward =>
            reward.id === rewardData.id ? { ...reward, ...rewardData } : reward
          );
        } else {
          // 添加新奖励（如果符合过滤条件）
          if (!filter ||
              ((!filter.status || rewardData.status === filter.status) &&
               (!filter.type || rewardData.type === filter.type))) {
            return [...prevRewards, rewardData];
          }
          return prevRewards;
        }
      });
    } else {
      // 如果没有特定奖励数据，则重新加载所有奖励
      loadTimelyRewards();
    }
  }, [loadTimelyRewards, filter]);

  // 使用 useRegisterTableRefresh hook 监听及时奖励表的变化
  useRegisterTableRefresh('timelyRewards', handleRewardDataUpdate);

  // 处理选择奖励
  const handleSelectReward = (reward: TimelyRewardRecord) => {
    setSelectedReward(reward);
    setShowRewardDetails(true);

    if (onSelectReward) {
      onSelectReward(reward);
    }
  };

  // Get type text for a reward with localization
  const getTypeTextForReward = (reward: TimelyRewardRecord) => {
    switch (reward.type) {
      case TimelyRewardType.DAILY:
        return labels?.typeDaily || 'Daily Reward';
      case TimelyRewardType.MORNING:
        return labels?.typeMorning || 'Early Bird Reward';
      case TimelyRewardType.STREAK:
        return labels?.typeStreak || 'Streak Reward';
      case TimelyRewardType.SPECIAL:
        return labels?.typeSpecial || 'Special Reward';
      default:
        return '';
    }
  };

  // Get status text for a reward with localization
  const getStatusTextForReward = (reward: TimelyRewardRecord) => {
    switch (reward.status) {
      case TimelyRewardStatus.ACTIVE:
        return labels?.statusActive || 'Active';
      case TimelyRewardStatus.COMPLETED:
        return labels?.statusCompleted || 'Completed';
      case TimelyRewardStatus.EXPIRED:
        return labels?.statusExpired || 'Expired';
      case TimelyRewardStatus.UPCOMING:
        return labels?.statusUpcoming || 'Upcoming';
      default:
        return '';
    }
  };

  // 处理完成奖励
  const handleCompleteReward = async (rewardId: number) => {
    try {
      setIsLoading(true);

      // 完成奖励并获取奖励
      const rewards = await completeTimelyReward(rewardId);

      // 更新奖励列表
      setRewards(prevRewards =>
        prevRewards.map(reward =>
          reward.id === rewardId
            ? {
                ...reward,
                status: TimelyRewardStatus.COMPLETED,
                progress: 100,
                completedTime: new Date()
              }
            : reward
        )
      );

      // 显示奖励
      if (rewards && rewards.length > 0) {
        setEarnedRewards(rewards);
        setShowRewardModal(true);
      }
    } catch (err) {
      console.error('Failed to complete timely reward:', err);
      setError('Failed to complete timely reward, please try again');
    } finally {
      setIsLoading(false);
    }
  };

  // 关闭奖励模态框
  const handleCloseRewardModal = () => {
    setShowRewardModal(false);
  };

  // 关闭奖励详情
  const handleCloseRewardDetails = () => {
    setShowRewardDetails(false);
    setSelectedReward(null);
  };

  // 如果正在加载，显示加载动画
  if (isLoading && rewards.length === 0) {
    return <LoadingSpinner />;
  }

  // 如果有错误，显示错误信息
  if (error && rewards.length === 0) {
    return <div className="error-message">{error}</div>;
  }

  // 如果没有奖励，显示提示信息
  if (rewards.length === 0) {
    return <div className="no-rewards-message">{labels?.noRewardsMessage || "No timely rewards available"}</div>;
  }

  return (
    <div className="timely-reward-list">
      <div className="lucky-points-container">
        <LuckyPointsDisplay />
      </div>

      <AnimatePresence>
        {rewards.map(reward => (
          <TimelyRewardCard
            key={reward.id}
            reward={reward}
            onClick={handleSelectReward}
            onComplete={handleCompleteReward}
            labels={labels}
          />
        ))}
      </AnimatePresence>

      {/* 奖励模态框 */}
      {showRewardModal && (
        <RewardModal
          rewards={earnedRewards}
          onClose={handleCloseRewardModal}
        />
      )}

      {/* 奖励详情 */}
      {showRewardDetails && selectedReward && (
        <ScrollDialog
          title={selectedReward.title}
          onClose={handleCloseRewardDetails}
        >
          <div className="reward-details">
            <div className="reward-header">
              <img
                src={selectedReward.iconPath}
                alt={selectedReward.title}
                className="reward-icon-large"
              />
              <div className="reward-meta-details">
                <div className="reward-type">
                  {labels?.typeLabel || "Type"}: {getTypeTextForReward(selectedReward)}
                </div>
                <div className="reward-status">
                  {labels?.statusLabel || "Status"}: {getStatusTextForReward(selectedReward)}
                </div>
                <div className="reward-lucky-points">
                  {labels?.luckyPointsLabel || "Lucky Points"}: {selectedReward.luckyPoints}
                </div>
              </div>
            </div>

            <div className="reward-description-full">
              {selectedReward.description}
            </div>

            <div className="reward-progress-details">
              <h4>{labels?.progressLabel || "Progress"}: {selectedReward.progress}%</h4>
              <div className="progress-bar-container">
                <div
                  className="progress-bar-fill"
                  style={{ width: `${selectedReward.progress}%` }}
                ></div>
              </div>
            </div>

            <div className="reward-time-details">
              <div>{labels?.startTimeLabel || "Start Time"}: {new Date(selectedReward.startTime).toLocaleString()}</div>
              <div>{labels?.endTimeLabel || "End Time"}: {new Date(selectedReward.endTime).toLocaleString()}</div>
              {selectedReward.completedTime && (
                <div>{labels?.completedTimeLabel || "Completed Time"}: {new Date(selectedReward.completedTime).toLocaleString()}</div>
              )}
            </div>

            {selectedReward.status === TimelyRewardStatus.ACTIVE && (
              <button
                className="complete-reward-button-large"
                onClick={() => handleCompleteReward(selectedReward.id!)}
                disabled={selectedReward.progress < 100}
              >
                {selectedReward.progress >= 100
                  ? (labels?.claimRewardButton || 'Claim Reward')
                  : (labels?.continueEffortButton || 'Keep Going')}
              </button>
            )}
          </div>
        </ScrollDialog>
      )}
    </div>
  );
};

export default TimelyRewardList;
</file>

<file path="src/components/layout/AppShell.tsx">
// src/components/layout/AppShell.tsx
import React, { ReactNode } from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchGlobalLayoutView } from '@/services';
import Header from './Header';
import Navigation from './Navigation';
import LoadingSpinner from '../common/LoadingSpinner';
import ErrorDisplay from '../common/ErrorDisplay';
import ChineseDecoration from '../decoration/ChineseDecoration';
import SyncStatusIndicator from '../common/SyncStatusIndicator';
import type { GlobalLayoutLabelsBundle, ApiError } from '@/types';

interface AppShellProps { children: ReactNode; }

const AppShell: React.FC<AppShellProps> = ({ children }) => {
  const {
    labels: globalLabels, isPending, isError, error, isFetching, refetch
  } = useLocalizedView<null, GlobalLayoutLabelsBundle>(
    'globalLayoutViewContent', // Unique query key for this "view"
    fetchGlobalLayoutView
  );

  if (isPending && !globalLabels) {
    // Use a very generic loading text if global labels themselves are not available
    return <LoadingSpinner variant="jade" text={globalLabels?.loadingGeneric || "Initializing Application..."} />;
  }

  if (isError || !globalLabels) { // Critical error if global labels fail
    return (
      <div style={{ padding: '20px' }}>
        <ErrorDisplay
          error={error} // Error from the hook
          title={globalLabels?.appErrorHeading || "Application Shell Error"}
          messageTemplate={globalLabels?.appErrorGeneralMessage || "Core UI failed. Details: {message}"}
          onRetry={refetch}
          retryButtonText="Retry Loading Shell"
        />
      </div>
    );
  }

  return (
    <div className="app-shell">
      {/* Add Chinese pattern decorative elements */}
      <div className="chinese-pattern top"></div>

      {/* 添加中国风装饰元素 */}
      <ChineseDecoration />

      <Header labels={globalLabels} isFetching={isFetching && !!globalLabels}/> {/* Pass fetching only if labels are loaded */}

      <main>{children}</main>

      {/* 移动应用底部导航 */}
      <Navigation labels={globalLabels} variant="bamboo" />

      {/* 同步状态指示器 */}
      <SyncStatusIndicator variant="standard" showCount={true} showLabel={true} />

      <div className="chinese-pattern bottom"></div>
    </div>
  );
};
export default AppShell;
</file>

<file path="src/context/DataRefreshProvider.tsx">
// src/context/DataRefreshProvider.tsx
import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode, useMemo } from 'react';
import { DataRefreshEvent } from '@/types/dataRefresh';

// 数据刷新上下文类型
interface DataRefreshContextType {
  lastRefresh: Record<string, DataRefreshEvent | null>;
  refreshTable: (table: string, data?: any) => void;
  registerRefreshListener: (table: string, callback: (data?: any) => void) => () => void;
}

// 创建上下文
const DataRefreshContext = createContext<DataRefreshContextType | undefined>(undefined);

// Provider组件属性
interface DataRefreshProviderProps {
  children: ReactNode;
}

/**
 * 数据刷新Provider组件
 * 提供全局数据刷新管理功能
 */
export const DataRefreshProvider: React.FC<DataRefreshProviderProps> = ({ children }) => {
  const [lastRefresh, setLastRefresh] = useState<Record<string, DataRefreshEvent | null>>({});
  const [listeners, setListeners] = useState<Record<string, Set<(data?: any) => void>>>({});

  // 监听数据刷新事件
  useEffect(() => {
    const handleDataRefresh = (event: Event) => {
      const customEvent = event as CustomEvent<DataRefreshEvent>;
      const { table, data } = customEvent.detail;

      // 更新最近一次刷新的数据
      setLastRefresh(prev => ({
        ...prev,
        [table]: { table, data }
      }));

      // 通知该表的所有监听器
      if (listeners[table]) {
        listeners[table].forEach(callback => {
          try {
            callback(data);
          } catch (err) {
            console.error(`Error in refresh listener for table ${table}:`, err);
          }
        });
      }
    };

    // 添加事件监听器
    window.addEventListener('dataRefresh', handleDataRefresh);

    // 清理函数
    return () => {
      window.removeEventListener('dataRefresh', handleDataRefresh);
    };
  }, [listeners]);

  // 刷新表数据
  const refreshTable = useCallback((table: string, data?: any) => {
    const refreshEvent = new CustomEvent('dataRefresh', {
      detail: { table, data }
    });
    window.dispatchEvent(refreshEvent);
  }, []);

  // 注册刷新监听器
  const registerRefreshListener = useCallback((table: string, callback: (data?: any) => void) => {
    setListeners(prev => {
      const tableListeners = prev[table] || new Set();
      tableListeners.add(callback);

      return {
        ...prev,
        [table]: tableListeners
      };
    });

    // 返回取消注册的函数
    return () => {
      setListeners(prev => {
        const tableListeners = prev[table];
        if (tableListeners) {
          tableListeners.delete(callback);

          return {
            ...prev,
            [table]: tableListeners
          };
        }
        return prev;
      });
    };
  }, []);

  // 提供上下文值
  const contextValue: DataRefreshContextType = useMemo(() => ({
    lastRefresh,
    refreshTable,
    registerRefreshListener
  }), [lastRefresh, refreshTable, registerRefreshListener]);

  return (
    <DataRefreshContext.Provider value={contextValue}>
      {children}
    </DataRefreshContext.Provider>
  );
};

/**
 * 使用数据刷新的Hook
 * @returns 数据刷新上下文
 */
export const useDataRefreshContext = (): DataRefreshContextType => {
  const context = useContext(DataRefreshContext);
  if (context === undefined) {
    throw new Error('useDataRefreshContext must be used within a DataRefreshProvider');
  }
  return context;
};
</file>

<file path="src/features/home/PandaSection.tsx">
// src/features/home/PandaSection.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import PandaAvatar from '@/components/game/PandaAvatar';
import { usePandaState } from '@/context/PandaStateProvider';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import AnimatedButton from '@/components/animation/AnimatedButton';
import GoldenGlow from '@/components/animation/GoldenGlow';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import PandaCustomizationPanel from '@/components/panda/PandaCustomizationPanel';
import PandaEnvironmentPanel from '@/components/panda/PandaEnvironmentPanel';
import { initializePandaCustomization } from '@/services/pandaCustomizationService';
import { playSound, SoundType } from '@/utils/sound';

interface PandaSectionLabels {
  sectionTitle?: string;
  levelLabel?: string;
  experienceLabel?: string;
  interactButtonText?: string;
  feedButtonText?: string;
  playButtonText?: string;
  trainButtonText?: string;
  customizeButtonText?: string;
  environmentButtonText?: string;
}

interface PandaSectionProps {
  labels?: PandaSectionLabels;
}

/**
 * 熊猫互动区域组件
 * 显示熊猫头像和互动按钮
 */
const PandaSection: React.FC<PandaSectionProps> = ({ labels }) => {
  const {
    pandaState,
    isLoading,
    setMood,
    addExperience
  } = usePandaState();

  const [interactionMode, setInteractionMode] = useState<'none' | 'feed' | 'play' | 'train'>('none');
  const [showCustomizationPanel, setShowCustomizationPanel] = useState(false);
  const [showEnvironmentPanel, setShowEnvironmentPanel] = useState(false);
  const [showAccessories, setShowAccessories] = useState(true);
  const [showEnvironment, setShowEnvironment] = useState(false);

  // 初始化熊猫定制系统
  useEffect(() => {
    const initialize = async () => {
      try {
        await initializePandaCustomization();
      } catch (err) {
        console.error('Failed to initialize panda customization:', err);
      }
    };

    initialize();
  }, []);

  // 默认标签文本
  const defaultLabels: PandaSectionLabels = {
    sectionTitle: '熊猫伙伴',
    levelLabel: '等级',
    experienceLabel: '经验',
    interactButtonText: '互动',
    feedButtonText: '喂食',
    playButtonText: '玩耍',
    trainButtonText: '训练',
    customizeButtonText: '装扮',
    environmentButtonText: '环境'
  };

  // 合并默认标签和传入的标签
  const mergedLabels = { ...defaultLabels, ...labels };

  // 定义熊猫状态更新处理函数
  const handlePandaStateUpdate = useCallback(() => {
    // 熊猫状态已经通过 usePandaState 获取，不需要额外处理
    console.log('Panda state updated in PandaSection');
  }, []);

  // 使用 useRegisterTableRefresh hook 监听熊猫状态变化
  useRegisterTableRefresh('pandaState', handlePandaStateUpdate);

  // 处理互动按钮点击
  const handleInteractClick = () => {
    if (interactionMode === 'none') {
      setInteractionMode('feed');
    } else {
      setInteractionMode('none');
    }
  };

  // 处理喂食按钮点击
  const handleFeedClick = async () => {
    await setMood('happy');
    await addExperience(10);
    setInteractionMode('none');
  };

  // 处理玩耍按钮点击
  const handlePlayClick = async () => {
    await setMood('happy');
    await addExperience(15);
    setInteractionMode('none');
  };

  // 处理训练按钮点击
  const handleTrainClick = async () => {
    await setMood('focused');
    await addExperience(20);
    setInteractionMode('none');
  };

  // 处理打开装扮面板
  const handleOpenCustomizationPanel = () => {
    setShowCustomizationPanel(true);
    playSound(SoundType.BUTTON_CLICK, 0.3);
  };

  // 处理关闭装扮面板
  const handleCloseCustomizationPanel = () => {
    setShowCustomizationPanel(false);
  };

  // 处理装扮变化
  const handleCustomizationChanged = () => {
    playSound(SoundType.SUCCESS, 0.5);
  };

  // 处理打开环境面板
  const handleOpenEnvironmentPanel = () => {
    setShowEnvironmentPanel(true);
    playSound(SoundType.BUTTON_CLICK, 0.3);
  };

  // 处理关闭环境面板
  const handleCloseEnvironmentPanel = () => {
    setShowEnvironmentPanel(false);
  };

  // 处理环境变化
  const handleEnvironmentChanged = () => {
    setShowEnvironment(true);
    playSound(SoundType.SUCCESS, 0.5);
  };

  if (isLoading && !pandaState) {
    return <LoadingSpinner variant="jade" text="加载熊猫中..." />;
  }

  if (!pandaState) {
    return <div>无法加载熊猫状态</div>;
  }

  return (
    <motion.section
      className="panda-section"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
    >
      <motion.h3
        initial={{ opacity: 0, x: -20 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ delay: 0.2, duration: 0.5 }}
      >
        {mergedLabels.sectionTitle}
      </motion.h3>

      <div className="panda-container" style={{ textAlign: 'center', marginBottom: '20px' }}>
        <motion.div
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
        >
          {pandaState.level > 5 ? (
            <GoldenGlow intensity="medium">
              <PandaAvatar
                mood={pandaState.mood}
                energy={pandaState.energy}
                size={150}
                onClick={handleInteractClick}
                className={pandaState.mood}
                showAccessories={showAccessories}
                showEnvironment={showEnvironment}
              />
            </GoldenGlow>
          ) : (
            <PandaAvatar
              mood={pandaState.mood}
              energy={pandaState.energy}
              size={150}
              onClick={handleInteractClick}
              className={pandaState.mood}
              showAccessories={showAccessories}
              showEnvironment={showEnvironment}
            />
          )}
        </motion.div>

        <motion.div
          className="panda-stats"
          style={{ marginTop: '10px' }}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.3, duration: 0.5 }}
        >
          <p>
            <strong>{mergedLabels.levelLabel}:</strong> {pandaState.level} |
            <strong> {mergedLabels.experienceLabel}:</strong> {pandaState.experience}
          </p>
        </motion.div>
      </div>

      <AnimatePresence mode="wait">
        {interactionMode === 'none' ? (
          <motion.div
            key="interact"
            className="panda-actions"
            style={{ textAlign: 'center' }}
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            transition={{ duration: 0.3 }}
          >
            <div className="flex justify-center gap-2">
              <AnimatedButton
                variant="jade"
                onClick={handleInteractClick}
                disabled={isLoading}
              >
                {isLoading ? '请稍候...' : mergedLabels.interactButtonText}
              </AnimatedButton>

              <AnimatedButton
                variant="secondary"
                onClick={handleOpenCustomizationPanel}
                disabled={isLoading}
              >
                {mergedLabels.customizeButtonText}
              </AnimatedButton>

              <AnimatedButton
                variant="secondary"
                onClick={handleOpenEnvironmentPanel}
                disabled={isLoading}
              >
                {mergedLabels.environmentButtonText}
              </AnimatedButton>
            </div>
          </motion.div>
        ) : (
          <motion.div
            key="buttons"
            className="panda-interaction-buttons"
            style={{
              display: 'flex',
              justifyContent: 'space-around',
              marginTop: '10px'
            }}
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            transition={{ duration: 0.3 }}
          >
            <AnimatedButton
              variant="jade"
              onClick={handleFeedClick}
              disabled={isLoading}
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
            >
              {mergedLabels.feedButtonText}
            </AnimatedButton>

            <AnimatedButton
              variant="jade"
              onClick={handlePlayClick}
              disabled={isLoading}
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
            >
              {mergedLabels.playButtonText}
            </AnimatedButton>

            <AnimatedButton
              variant="jade"
              onClick={handleTrainClick}
              disabled={isLoading}
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
            >
              {mergedLabels.trainButtonText}
            </AnimatedButton>
          </motion.div>
        )}
      </AnimatePresence>

      {/* 装扮面板 */}
      <PandaCustomizationPanel
        isOpen={showCustomizationPanel}
        onClose={handleCloseCustomizationPanel}
        onCustomizationChanged={handleCustomizationChanged}
      />

      {/* 环境面板 */}
      <PandaEnvironmentPanel
        isOpen={showEnvironmentPanel}
        onClose={handleCloseEnvironmentPanel}
        onEnvironmentChanged={handleEnvironmentChanged}
      />
    </motion.section>
  );
};

export default PandaSection;
</file>

<file path="src/features/tasks/TaskManager.tsx">
// src/features/tasks/TaskManager.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { AnimatePresence } from 'framer-motion';
import {
  TaskRecord,
  TaskStatus,
  TaskPriority,
  TaskType,
  createTask,
  updateTask,
  getAllTasks,
  initializeTaskCategories
} from '@/services/taskService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import TaskForm from '@/components/game/TaskForm';
import AnimatedTaskList from '@/components/animation/AnimatedTaskList';
import AnimatedButton from '@/components/animation/AnimatedButton';
import PageTransition from '@/components/animation/PageTransition';

interface TaskManagerLabels {
  sectionTitle?: string;
  createTaskButton?: string;
  filterAllLabel?: string;
  filterTodoLabel?: string;
  filterInProgressLabel?: string;
  filterCompletedLabel?: string;
  noTasksMessage?: string;
}

interface TaskManagerProps {
  labels?: TaskManagerLabels;
}

/**
 * 任务管理器组件，包含任务列表和任务表单
 */
const TaskManager: React.FC<TaskManagerProps> = ({ labels }) => {
  const [showForm, setShowForm] = useState(false);
  const [editingTask, setEditingTask] = useState<TaskRecord | null>(null);
  const [statusFilter, setStatusFilter] = useState<TaskStatus | undefined>(undefined);
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  // 默认标签
  const defaultLabels: TaskManagerLabels = {
    sectionTitle: '任务管理',
    createTaskButton: '创建新任务',
    filterAllLabel: '全部',
    filterTodoLabel: '待办',
    filterInProgressLabel: '进行中',
    filterCompletedLabel: '已完成',
    noTasksMessage: '暂无任务'
  };

  // 合并标签
  const mergedLabels = { ...defaultLabels, ...labels };

  // 使用 useRef 来避免依赖变化
  const setRefreshTriggerRef = React.useRef(setRefreshTrigger);

  // 更新 ref 当依赖变化时
  React.useEffect(() => {
    setRefreshTriggerRef.current = setRefreshTrigger;
  }, [setRefreshTrigger]);

  // 使用稳定的回调函数，不依赖于 setRefreshTrigger
  const handleDataRefresh = useCallback(() => {
    // 只需要触发刷新，不需要重新获取所有数据
    setRefreshTriggerRef.current(prev => prev + 1);
  }, []); // 没有依赖项，使用 ref 来获取最新值

  // 使用 useRegisterTableRefresh 监听 'tasks' 表的数据刷新
  useRegisterTableRefresh('tasks', handleDataRefresh);

  // 初始化任务类别
  useEffect(() => {
    initializeTaskCategories();
  }, []);

  // 处理创建任务
  const handleCreateTask = async (taskData: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'>) => {
    try {
      await createTask(taskData);
      setShowForm(false);
      // 不需要手动触发刷新，数据同步服务会自动触发
    } catch (error) {
      console.error('Failed to create task:', error);
      alert('创建任务失败，请重试');
    }
  };

  // 处理更新任务
  const handleUpdateTask = async (taskData: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'>) => {
    if (!editingTask?.id) return;

    try {
      await updateTask(editingTask.id, taskData);
      setEditingTask(null);
      setShowForm(false);
      // 不需要手动触发刷新，数据同步服务会自动触发
    } catch (error) {
      console.error('Failed to update task:', error);
      alert('更新任务失败，请重试');
    }
  };

  // 处理编辑任务
  const handleEditTask = async (taskId: number) => {
    try {
      const tasks = await getAllTasks();
      const task = tasks.find(t => t.id === taskId);

      if (task) {
        setEditingTask(task);
        setShowForm(true);
      }
    } catch (error) {
      console.error('Failed to get task for editing:', error);
      alert('获取任务详情失败，请重试');
    }
  };

  // 处理取消表单
  const handleCancelForm = () => {
    setShowForm(false);
    setEditingTask(null);
  };

  return (
    <PageTransition className="task-manager">
      <div className="task-manager-header">
        <h2>{mergedLabels.sectionTitle}</h2>

        {!showForm && (
          <AnimatedButton
            variant="jade"
            onClick={() => setShowForm(true)}
          >
            {mergedLabels.createTaskButton}
          </AnimatedButton>
        )}
      </div>

      <AnimatePresence mode="wait">
        {showForm ? (
          <PageTransition key="task-form">
            <TaskForm
              initialTask={editingTask || {}}
              onSubmit={editingTask ? handleUpdateTask : handleCreateTask}
              onCancel={handleCancelForm}
            />
          </PageTransition>
        ) : (
          <PageTransition key="task-list">
            <div className="task-filter-tabs">
              <button
                className={statusFilter === undefined ? 'active' : ''}
                onClick={() => setStatusFilter(undefined)}
              >
                {mergedLabels.filterAllLabel}
              </button>
              <button
                className={statusFilter === TaskStatus.TODO ? 'active' : ''}
                onClick={() => setStatusFilter(TaskStatus.TODO)}
              >
                {mergedLabels.filterTodoLabel}
              </button>
              <button
                className={statusFilter === TaskStatus.IN_PROGRESS ? 'active' : ''}
                onClick={() => setStatusFilter(TaskStatus.IN_PROGRESS)}
              >
                {mergedLabels.filterInProgressLabel}
              </button>
              <button
                className={statusFilter === TaskStatus.COMPLETED ? 'active' : ''}
                onClick={() => setStatusFilter(TaskStatus.COMPLETED)}
              >
                {mergedLabels.filterCompletedLabel}
              </button>
            </div>

            <AnimatedTaskList
              onEditTask={handleEditTask}
              filter={{ status: statusFilter }}
              refreshTrigger={refreshTrigger}
            />
          </PageTransition>
        )}
      </AnimatePresence>
    </PageTransition>
  );
};

export default TaskManager;
</file>

<file path="src/game-theme.css">
/* src/game-theme.css */
/* 华丽熊猫竹林主题 - PandaHabit 华丽游戏风格 */

/* 导入Google字体 */
@import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&family=Playfair+Display:wght@400;500;600;700&family=Fredoka+One&display=swap');
/* 导入中文字体 - 思源宋体 */
@import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700&display=swap');
/* 导入中文字体 - 思源黑体 */
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap');
/* 导入中文字体 - 站酷高端黑 */
@import url('https://fonts.font.im/css?family=ZCOOL+QingKe+HuangYou');
/* 导入中文字体 - 站酷快乐体 */
@import url('https://fonts.font.im/css?family=ZCOOL+KuaiLe');
/* 导入中文字体 - 站酷文艺体 */
@import url('https://fonts.font.im/css?family=ZCOOL+XiaoWei');
/* 导入中文字体 - 思源黑体 */
@import url('https://fonts.font.im/css?family=Ma+Shan+Zheng');

/* CSS变量主题颜色 */
:root {
  /* 华丽色彩方案 */
  --royal-jade: #1A5F4A; /* 皇家翡翠绿：代表成长、宁静与自然 */
  --bamboo-green: #88B04B; /* 富贵竹绿：象征熊猫的食物和活力 */
  --snow-white: #F7F9F9; /* 瑞雪白：提供视觉呼吸空间和清晰度 */
  --cinnabar-red: #D73E35; /* 朱砂红：传统中国红，象征喜庆、活力与好运 */
  --imperial-gold: #D4AF37; /* 华贵金：突出成就和高级元素 */
  --porcelain-blue: #1A6DB0; /* 青花蓝：代表水分和流动 */
  --peony-pink: #F8C8DC; /* 牡丹粉：增添温暖和情感连接 */
  --rosewood-purple: #5D3954; /* 紫檀紫：增添神秘感和高贵感 */
  --ruyi-green: #2E8B57; /* 如意绿：表示完成和积极成果 */
  --amber-yellow: #FFA500; /* 琥珀黄：引起注意但不刺眼 */
  --ink-gray: #8A8D91; /* 墨灰：用于次要文本和非活动元素 */

  /* 功能色彩 */
  --text-primary: var(--royal-jade);
  --text-secondary: var(--ink-gray);
  --text-light: var(--snow-white);
  --background-main: var(--snow-white);
  --background-panel: #FFFFFF;
  --border-color: var(--bamboo-green);
  --shadow-color: rgba(26, 95, 74, 0.2);
  --highlight-color: var(--imperial-gold);
  --accent-color: var(--cinnabar-red);

  /* 组件特定颜色 */
  --primary-green: var(--bamboo-green);
  --deep-green: var(--royal-jade);
  --light-green: rgba(136, 176, 75, 0.2);
  --deep-night: #333333;
  --accent-jade: #00BFA5;
  --accent-gold: var(--imperial-gold);

  /* 字体设置 */
  --font-main: 'Noto Sans SC', 'Quicksand', sans-serif;
  --font-accent: 'Noto Serif SC', 'Playfair Display', serif;
  --font-game: 'Fredoka One', cursive;
  --font-title: 'Ma Shan Zheng', cursive;
  --font-decorative: 'ZCOOL XiaoWei', serif;
  --font-fun: 'ZCOOL KuaiLe', cursive;
  --font-modern: 'ZCOOL QingKe HuangYou', sans-serif;

  /* 间距 */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;

  /* 圆角 */
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 16px;
  --radius-round: 50%;

  /* 动画时间 */
  --timing-quick: 0.2s;
  --timing-medium: 0.4s;
  --timing-slow: 0.8s;

  /* 特效 */
  --gold-gradient: linear-gradient(145deg, var(--imperial-gold), #FFA000);
  --jade-gradient: linear-gradient(145deg, var(--royal-jade), var(--bamboo-green));
  --red-gradient: linear-gradient(145deg, var(--cinnabar-red), #FF6B6B);
  --ink-animation: 0.8s ease-out;
}

/* 基础样式 - 移动应用 */
body {
  font-family: var(--font-main);
  background-color: var(--background-main);
  background-image: url('/assets/bamboo-bg-pattern.svg');
  background-size: 200px;
  background-attachment: fixed;
  color: var(--text-primary);
  line-height: 1.6;
  margin: 0;
  padding: 0;
  position: relative;
  max-width: 100vw;
  overflow-x: hidden;
  -webkit-tap-highlight-color: transparent; /* 移除移动端点击高亮 */
  touch-action: manipulation; /* 优化触摸操作 */
}

/* 添加水墨风格背景装饰 */
body::before {
  content: '';
  position: fixed;
  top: 0;
  right: 0;
  width: 300px;
  height: 300px;
  background-image: url('/assets/ink-splash.svg');
  background-size: contain;
  background-repeat: no-repeat;
  opacity: 0.1;
  z-index: -1;
  pointer-events: none;
}

body::after {
  content: '';
  position: fixed;
  bottom: 0;
  left: 0;
  width: 250px;
  height: 250px;
  background-image: url('/assets/bamboo-leaves.svg');
  background-size: contain;
  background-repeat: no-repeat;
  opacity: 0.1;
  z-index: -1;
  pointer-events: none;
}

#root {
  width: 100%;
  margin: 0 auto;
  padding: 0;
  position: relative;
  min-height: 100vh;
}

/* 中国风装饰元素 */
.chinese-pattern {
  position: fixed;
  width: 100%;
  height: 8px;
  background-image: url('/assets/chinese-pattern.svg');
  background-repeat: repeat-x;
  background-size: auto 100%;
  opacity: 0.8;
  z-index: 50;
}

.chinese-pattern.top {
  top: 0;
  left: 0;
}

.chinese-pattern.bottom {
  bottom: 70px; /* 为底部导航留出空间 */
  left: 0;
  transform: rotate(180deg);
}

/* 页面容器样式 */
.page-container {
  padding: 10px 0;
  margin-top: 10px;
  width: 100%;
  box-sizing: border-box;
}

/* 中国风装饰元素 - 云朵 */
.chinese-cloud {
  position: fixed;
  width: 200px;
  height: 100px;
  background-image: url('/assets/chinese-cloud.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.2;
  z-index: -1;
  pointer-events: none;
}

.chinese-cloud.top-right {
  top: 50px;
  right: 20px;
  transform: scale(0.8);
}

.chinese-cloud.top-left {
  top: 100px;
  left: 10px;
  transform: scale(0.6) rotate(10deg);
}

/* 中国风装饰元素 - 中国结 */
.chinese-knot {
  position: fixed;
  width: 100px;
  height: 150px;
  background-image: url('/assets/chinese-knot.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.7;
  z-index: 10;
  pointer-events: none;
}

.chinese-knot.top-right {
  top: 10px;
  right: 10px;
  transform: scale(0.5);
}

/* 中国风装饰元素 - 荷花 */
.lotus-flower {
  position: fixed;
  width: 150px;
  height: 150px;
  background-image: url('/assets/lotus-flower.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.5;
  z-index: -1;
  pointer-events: none;
}

.lotus-flower.bottom-left {
  bottom: 80px;
  left: 10px;
  transform: scale(0.6);
}

/* 中国风装饰元素 - 灯笼 */
.chinese-lantern {
  position: fixed;
  width: 100px;
  height: 150px;
  background-image: url('/assets/chinese-lantern.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.8;
  z-index: 10;
  pointer-events: none;
}

.chinese-lantern.top-left {
  top: 10px;
  left: 10px;
  transform: scale(0.5);
}

/* 中国风装饰元素 - 山水画 */
.mountain-landscape {
  position: fixed;
  width: 300px;
  height: 150px;
  background-image: url('/assets/mountain-landscape.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.2;
  z-index: -2;
  pointer-events: none;
}

.mountain-landscape.bottom {
  bottom: 70px;
  left: 50%;
  transform: translateX(-50%) scale(1.5);
}

/* 熊猫头像样式 */
.panda-avatar {
  position: relative;
  border-radius: 50%;
  overflow: hidden;
  box-shadow: 0 4px 8px var(--shadow-color);
  margin: 0 auto;
}

.panda-avatar::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  border-radius: 50%;
  box-shadow: inset 0 -3px 6px rgba(0,0,0,0.2);
  pointer-events: none;
}

.panda-avatar:hover {
  transform: translateY(-5px) scale(1.05) !important;
  box-shadow: 0 8px 16px var(--shadow-color);
}

.panda-avatar:active {
  transform: translateY(2px) scale(0.98) !important;
  box-shadow: 0 2px 4px var(--shadow-color);
}

/* 熊猫动画 */
@keyframes panda-bounce {
  0% { transform: translateY(0) scale(1); }
  50% { transform: translateY(-15px) scale(1.1); }
  100% { transform: translateY(0) scale(1); }
}

@keyframes panda-wiggle {
  0% { transform: rotate(0deg); }
  25% { transform: rotate(-5deg); }
  50% { transform: rotate(0deg); }
  75% { transform: rotate(5deg); }
  100% { transform: rotate(0deg); }
}

.panda-avatar.happy {
  animation: panda-wiggle 1s infinite;
}

.panda-avatar.tired {
  animation: panda-bounce 3s ease-in-out infinite;
}

/* 任务卡片样式 */
.task-card {
  background-color: var(--background-panel);
  border: 2px solid var(--primary-green);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  position: relative;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px var(--shadow-color);
}

.task-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 4px 8px var(--shadow-color);
}

.task-card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.task-title {
  margin: 0;
  font-size: 1.1rem;
  color: var(--text-primary);
}

.task-type-badge {
  font-size: 0.7rem;
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  font-weight: bold;
  color: white;
}

.task-type-main {
  background-color: var(--imperial-gold);
}

.task-type-daily {
  background-color: var(--bamboo-green);
}

.task-type-side {
  background-color: var(--ink-gray);
}

.task-description {
  margin-bottom: var(--spacing-sm);
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.task-meta {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  color: var(--text-secondary);
  margin-bottom: var(--spacing-sm);
}

.task-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-sm);
}

.task-action-complete,
.task-action-edit,
.task-action-delete {
  padding: 4px 8px;
  font-size: 0.8rem;
  border-radius: var(--radius-sm);
  cursor: pointer;
  border: none;
  transition: all 0.2s ease;
}

.task-action-complete {
  background-color: var(--bamboo-green);
  color: white;
}

.task-action-edit {
  background-color: var(--imperial-gold);
  color: white;
}

.task-action-delete {
  background-color: var(--cinnabar-red);
  color: white;
}

.task-priority-high {
  border-left: 4px solid var(--cinnabar-red);
}

.task-priority-medium {
  border-left: 4px solid var(--imperial-gold);
}

.task-priority-low {
  border-left: 4px solid var(--bamboo-green);
}

.task-status-completed {
  opacity: 0.7;
  background-color: rgba(136, 176, 75, 0.1);
}

.task-status-completed .task-title {
  text-decoration: line-through;
}

.task-status-in-progress {
  background-color: rgba(212, 175, 55, 0.1);
}

/* 任务列表样式 */
.task-list {
  position: relative;
  min-height: 100px;
}

.task-list-loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(255, 255, 255, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10;
}

.task-list-empty,
.task-list-error {
  text-align: center;
  padding: var(--spacing-lg);
  color: var(--text-secondary);
}

/* 任务表单样式 */
.task-form {
  margin-bottom: var(--spacing-lg);
}

.form-group {
  margin-bottom: var(--spacing-md);
}

.form-group label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-weight: 500;
  color: var(--text-primary);
}

.form-group input,
.form-group select,
.form-group textarea {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  background-color: white;
  font-size: 1rem;
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
  outline: none;
  border-color: var(--primary-green);
  box-shadow: 0 0 0 2px rgba(136, 176, 75, 0.2);
}

.form-group input.error,
.form-group select.error {
  border-color: var(--cinnabar-red);
}

.error-message {
  color: var(--cinnabar-red);
  font-size: 0.8rem;
  margin-top: 4px;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-md);
  margin-top: var(--spacing-lg);
}

/* 任务过滤器样式 */
.task-filter-tabs {
  display: flex;
  margin-bottom: var(--spacing-md);
  border-bottom: 1px solid var(--border-color);
  overflow-x: auto;
}

.task-filter-tabs button {
  padding: 8px 16px;
  background: none;
  border: none;
  cursor: pointer;
  font-size: 0.9rem;
  color: var(--text-secondary);
  position: relative;
  white-space: nowrap;
}

.task-filter-tabs button.active {
  color: var(--text-primary);
  font-weight: 500;
}

.task-filter-tabs button.active::after {
  content: '';
  position: absolute;
  bottom: -1px;
  left: 0;
  right: 0;
  height: 2px;
  background-color: var(--primary-green);
}

/* 任务管理器样式 */
.task-manager-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-md);
}

/* 小按钮样式 */
.jade-button-small {
  background: linear-gradient(to bottom, var(--bamboo-green), var(--deep-green));
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: 4px 8px;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.jade-button-small:hover {
  background: linear-gradient(to bottom, var(--bamboo-green), var(--deep-green));
  filter: brightness(1.1);
  transform: translateY(-1px);
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
}

/* 字体排版 */
h1, h2, h3 {
  font-family: var(--font-accent);
  color: var(--royal-jade);
  margin-top: 0;
  position: relative;
}

h1 {
  font-family: var(--font-title);
  font-size: 2.2rem;
  text-shadow: 1px 1px 2px var(--shadow-color);
  background: linear-gradient(to right, var(--royal-jade), var(--bamboo-green));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  letter-spacing: 0.5px;
  padding-bottom: var(--spacing-md);
  position: relative;
}

h2 {
  font-family: var(--font-decorative);
  font-size: 1.8rem;
  letter-spacing: 1px;
}

h3 {
  font-family: var(--font-modern);
  font-size: 1.4rem;
}

/* 添加中国风装饰线 */
h1::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100px;
  height: 3px;
  background: var(--gold-gradient);
  border-radius: var(--radius-sm);
}

/* 模态框样式 */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: var(--spacing-md);
}

.modal-content {
  position: relative;
  max-width: 90%;
  max-height: 90vh;
  overflow-y: auto;
  z-index: 1001;
}

.modal-container {
  position: relative;
  background-color: var(--background-panel);
  border-radius: var(--radius-md);
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
  overflow: hidden;
}

/* 卷轴风格模态框 */
.scroll-modal {
  background-color: #f8f0d8; /* 古纸色 */
  border: none;
  box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
  position: relative;
  padding: var(--spacing-lg) var(--spacing-xl);
  color: var(--deep-night);
}

.scroll-modal::before,
.scroll-modal::after {
  content: '';
  position: absolute;
  left: 0;
  right: 0;
  height: 30px;
  background-image: url('/assets/scroll-edge.svg');
  background-repeat: repeat-x;
  background-size: auto 100%;
}

.scroll-modal::before {
  top: 0;
  transform: rotateX(180deg);
}

.scroll-modal::after {
  bottom: 0;
}

.scroll-modal-content {
  max-height: 70vh;
  overflow-y: auto;
  padding: var(--spacing-md) 0;
  background-image: url('/assets/paper-texture.svg');
  background-repeat: repeat;
  background-size: 200px;
  position: relative;
}

.scroll-modal-header {
  text-align: center;
  margin-bottom: var(--spacing-lg);
  position: relative;
}

.scroll-modal-title {
  font-family: var(--font-accent);
  font-size: 1.8rem;
  color: var(--cinnabar-red);
  margin: 0;
  padding-bottom: var(--spacing-md);
  position: relative;
  display: inline-block;
}

.scroll-modal-title::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 10%;
  right: 10%;
  height: 2px;
  background: var(--gold-gradient);
}

.scroll-modal-close {
  position: absolute;
  top: var(--spacing-md);
  right: var(--spacing-md);
  background: none;
  border: none;
  font-size: 1.5rem;
  color: var(--cinnabar-red);
  cursor: pointer;
  width: 30px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-round);
  transition: all 0.2s ease;
}

.scroll-modal-close:hover {
  background-color: rgba(215, 62, 53, 0.1);
  transform: rotate(90deg);
}

.scroll-modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-md);
  margin-top: var(--spacing-lg);
  padding-top: var(--spacing-md);
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

/* 窗棂风格模态框 */
.lattice-modal {
  background-color: var(--background-panel);
  border: 4px solid var(--imperial-gold);
  border-radius: var(--radius-md);
  position: relative;
  overflow: hidden;
}

.lattice-modal-header {
  background: var(--gold-gradient);
  color: var(--deep-night);
  padding: var(--spacing-md) var(--spacing-lg);
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
}

.lattice-modal-title {
  font-family: var(--font-accent);
  font-size: 1.5rem;
  margin: 0;
  text-align: center;
  position: relative;
}

.lattice-modal-close {
  position: absolute;
  top: 50%;
  right: var(--spacing-md);
  transform: translateY(-50%);
  background: none;
  border: none;
  color: var(--deep-night);
  cursor: pointer;
  width: 30px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-round);
  transition: all 0.2s ease;
}

.lattice-modal-close:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

.lattice-modal-content {
  padding: var(--spacing-lg);
  position: relative;
  max-height: 70vh;
  overflow-y: auto;
}

.lattice-modal-content::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: url('/assets/lattice-pattern.svg');
  background-repeat: repeat;
  background-size: 100px;
  opacity: 0.05;
  pointer-events: none;
  z-index: -1;
}

.lattice-modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-md);
  padding: var(--spacing-md) var(--spacing-lg);
  background-color: rgba(212, 175, 55, 0.1);
  border-top: 1px solid var(--imperial-gold);
}

/* 奖励模态框样式 */
.reward-modal-content {
  padding: var(--spacing-md);
  text-align: center;
}

.reward-showcase {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--spacing-md);
}

.reward-title {
  font-family: var(--font-accent);
  font-size: 1.5rem;
  color: var(--cinnabar-red);
  margin-bottom: var(--spacing-lg);
  position: relative;
}

.reward-title::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 25%;
  right: 25%;
  height: 2px;
  background: var(--gold-gradient);
}

.reward-animation-container {
  margin: var(--spacing-lg) 0;
  height: 150px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.reward-details {
  margin: var(--spacing-md) 0;
  padding: var(--spacing-md);
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: var(--radius-md);
  max-width: 300px;
}

.reward-details h4 {
  font-family: var(--font-accent);
  font-size: 1.2rem;
  color: var(--deep-night);
  margin: 0 0 var(--spacing-sm) 0;
}

.reward-rarity {
  font-size: 0.9rem;
  color: var(--text-secondary);
  margin: 0 0 var(--spacing-sm) 0;
}

.reward-description {
  font-size: 1rem;
  margin: 0 0 var(--spacing-sm) 0;
}

.reward-amount {
  font-weight: bold;
  margin: var(--spacing-sm) 0 0 0;
}

.reward-navigation {
  margin-top: var(--spacing-lg);
  height: 50px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.rewards-summary {
  display: flex;
  flex-direction: column;
  width: 100%;
}

.rewards-summary-title {
  font-family: var(--font-accent);
  font-size: 1.5rem;
  color: var(--cinnabar-red);
  margin-bottom: var(--spacing-lg);
  position: relative;
  text-align: center;
}

.rewards-summary-title::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 25%;
  right: 25%;
  height: 2px;
  background: var(--gold-gradient);
}

.rewards-list {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
  margin: var(--spacing-md) 0;
  max-height: 300px;
  overflow-y: auto;
  padding: var(--spacing-sm);
}

.reward-item {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm);
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: var(--radius-md);
  transition: all 0.2s ease;
}

.reward-item:hover {
  background-color: rgba(255, 255, 255, 0.3);
  transform: translateY(-2px);
}

.reward-item-icon {
  margin-right: var(--spacing-md);
  display: flex;
  justify-content: center;
  align-items: center;
}

.reward-item-details {
  flex: 1;
  text-align: left;
}

.reward-item-details h4 {
  font-family: var(--font-accent);
  font-size: 1.1rem;
  color: var(--deep-night);
  margin: 0 0 var(--spacing-xs) 0;
}

.reward-item-description {
  font-size: 0.9rem;
  color: var(--text-secondary);
  margin: 0;
}

.reward-item-amount {
  font-weight: bold;
  font-size: 1.1rem;
  color: var(--imperial-gold);
  margin-left: var(--spacing-md);
}

.rewards-summary-footer {
  margin-top: var(--spacing-lg);
  display: flex;
  justify-content: center;
}

/* 熊猫能力样式 */
.abilities-header {
  margin-bottom: var(--spacing-lg);
  padding-bottom: var(--spacing-md);
  border-bottom: 1px solid var(--border-color);
}

.panda-level-info {
  margin-bottom: var(--spacing-md);
}

.panda-level-info h3 {
  font-family: var(--font-accent);
  color: var(--imperial-gold);
  margin-bottom: var(--spacing-xs);
}

.abilities-description {
  color: var(--text-secondary);
  font-size: 0.95rem;
  line-height: 1.5;
}

.ability-filters {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-sm);
  margin-bottom: var(--spacing-md);
}

.filter-button {
  background-color: var(--background-panel);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  padding: var(--spacing-xs) var(--spacing-sm);
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.filter-button:hover {
  background-color: var(--background-hover);
}

.filter-button.active {
  background-color: var(--jade-green);
  color: white;
  border-color: var(--jade-green);
}

.abilities-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: var(--spacing-md);
  margin-top: var(--spacing-md);
}

.ability-card {
  background-color: var(--background-panel);
  border-radius: var(--radius-md);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
}

.ability-card:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  transform: translateY(-2px);
}

.ability-card.locked {
  opacity: 0.7;
  filter: grayscale(0.5);
}

.ability-card.passive-ability {
  border-left: 4px solid var(--jade-green);
}

.ability-card.active-ability {
  border-left: 4px solid var(--imperial-blue);
}

.ability-card.ultimate-ability {
  border-left: 4px solid var(--imperial-gold);
}

.ability-card-header {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm);
  background-color: rgba(0, 0, 0, 0.03);
  border-bottom: 1px solid var(--border-color);
}

.ability-icon {
  width: 50px;
  height: 50px;
  margin-right: var(--spacing-sm);
  display: flex;
  justify-content: center;
  align-items: center;
}

.ability-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.ability-info {
  flex: 1;
}

.ability-name {
  font-family: var(--font-accent);
  font-size: 1.1rem;
  margin: 0 0 var(--spacing-xs) 0;
}

.ability-meta {
  display: flex;
  gap: var(--spacing-sm);
  font-size: 0.8rem;
  color: var(--text-secondary);
}

.ability-type, .ability-rarity {
  background-color: rgba(0, 0, 0, 0.05);
  padding: 2px 6px;
  border-radius: var(--radius-sm);
}

.ability-card-body {
  padding: var(--spacing-sm);
}

.ability-description {
  font-size: 0.9rem;
  line-height: 1.5;
  margin-bottom: var(--spacing-sm);
}

.ability-unlock-info {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-size: 0.85rem;
  color: var(--text-secondary);
  margin-top: var(--spacing-sm);
}

.ability-lock-icon {
  font-size: 1rem;
}

.ability-cooldown {
  font-size: 0.85rem;
  color: var(--text-secondary);
  margin-top: var(--spacing-sm);
}

.cooldown-remaining {
  color: var(--cinnabar-red);
}

.ability-card-footer {
  padding: var(--spacing-sm);
  border-top: 1px solid var(--border-color);
  display: flex;
  justify-content: flex-end;
}

.activate-button {
  background-color: var(--imperial-blue);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: var(--spacing-xs) var(--spacing-md);
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.activate-button:hover {
  background-color: var(--imperial-blue-dark);
}

.activate-button.unavailable {
  background-color: var(--text-disabled);
  cursor: not-allowed;
}

.no-abilities {
  text-align: center;
  padding: var(--spacing-lg);
  color: var(--text-secondary);
}

/* 能力详情样式 */
.ability-detail {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--spacing-md);
}

.ability-detail-icon {
  width: 80px;
  height: 80px;
  margin-bottom: var(--spacing-md);
}

.ability-detail-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.ability-detail-info {
  width: 100%;
  text-align: center;
}

.ability-detail-description {
  font-size: 1rem;
  line-height: 1.6;
  margin-bottom: var(--spacing-md);
}

.ability-detail-meta {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--spacing-sm);
  margin-bottom: var(--spacing-md);
}

.meta-item {
  background-color: rgba(0, 0, 0, 0.03);
  padding: var(--spacing-sm);
  border-radius: var(--radius-sm);
  display: flex;
  flex-direction: column;
  align-items: center;
}

.meta-label {
  font-size: 0.8rem;
  color: var(--text-secondary);
  margin-bottom: var(--spacing-xs);
}

.meta-value {
  font-weight: bold;
  font-size: 0.95rem;
}

.ability-detail-actions {
  margin-top: var(--spacing-md);
}

.activate-detail-button {
  background-color: var(--imperial-blue);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: var(--spacing-sm) var(--spacing-lg);
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.activate-detail-button:hover {
  background-color: var(--imperial-blue-dark);
}

.activate-detail-button:disabled {
  background-color: var(--text-disabled);
  cursor: not-allowed;
}

/* 能力解锁通知样式 */
.ability-unlock-content {
  padding: var(--spacing-md);
}

.ability-unlock-view {
  width: 100%;
  min-height: 300px;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.ability-unlock-single {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.ability-unlock-icon {
  width: 100px;
  height: 100px;
  margin-bottom: var(--spacing-md);
}

.ability-unlock-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.ability-unlock-title {
  font-family: var(--font-accent);
  font-size: 1.5rem;
  color: var(--imperial-gold);
  margin-bottom: var(--spacing-sm);
}

.ability-unlock-name {
  font-size: 1.2rem;
  margin-bottom: var(--spacing-md);
}

.ability-unlock-description {
  font-size: 1rem;
  line-height: 1.6;
  margin-bottom: var(--spacing-lg);
  max-width: 500px;
}

.ability-unlock-actions {
  margin-top: var(--spacing-md);
}

.ability-unlock-list {
  width: 100%;
  max-height: 300px;
  overflow-y: auto;
  margin: var(--spacing-md) 0;
}

.ability-unlock-item {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm);
  background-color: rgba(0, 0, 0, 0.03);
  border-radius: var(--radius-md);
  margin-bottom: var(--spacing-sm);
  transition: all 0.2s ease;
}

.ability-unlock-item:hover {
  background-color: rgba(0, 0, 0, 0.05);
}

.ability-unlock-item-icon {
  width: 40px;
  height: 40px;
  margin-right: var(--spacing-sm);
}

.ability-unlock-item-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.ability-unlock-item-info {
  flex: 1;
  text-align: left;
}

.ability-unlock-item-name {
  font-size: 1rem;
  margin: 0 0 var(--spacing-xs) 0;
}

.ability-unlock-item-description {
  font-size: 0.9rem;
  color: var(--text-secondary);
  margin: 0;
}

h2 {
  font-size: 1.8rem;
  margin-bottom: 0.8em;
  border-bottom: 2px solid var(--imperial-gold);
  padding-bottom: var(--spacing-sm);
  display: inline-block;
  position: relative;
}

/* 添加中国风装饰元素 */
h2::before {
  content: '❖';
  color: var(--cinnabar-red);
  position: absolute;
  left: -1.5rem;
  top: 0.2rem;
  font-size: 1rem;
}

h3 {
  font-size: 1.5rem;
  margin-bottom: 0.6em;
  color: var(--royal-jade);
  position: relative;
  padding-left: var(--spacing-md);
}

h3::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0.5rem;
  height: 1rem;
  width: 4px;
  background: var(--bamboo-green);
  border-radius: var(--radius-sm);
}

h4 {
  font-size: 1.2rem;
  margin-bottom: 0.5em;
  color: var(--ruyi-green);
  font-family: var(--font-main);
  font-weight: 600;
}

/* Bamboo Frame Container */
.bamboo-frame {
  background-color: var(--background-panel);
  border: 4px solid var(--primary-green);
  border-radius: var(--radius-md);
  box-shadow: 0 4px 12px var(--shadow-color);
  padding: var(--spacing-lg);
  position: relative;
  overflow: hidden;
  margin-bottom: var(--spacing-lg);
}

.bamboo-frame::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 12px;
  background: repeating-linear-gradient(
    to right,
    var(--primary-green),
    var(--primary-green) 20px,
    var(--deep-green) 20px,
    var(--deep-green) 30px
  );
  border-top-left-radius: var(--radius-md);
  border-top-right-radius: var(--radius-md);
}

.bamboo-frame::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 12px;
  background: repeating-linear-gradient(
    to right,
    var(--primary-green),
    var(--primary-green) 20px,
    var(--deep-green) 20px,
    var(--deep-green) 30px
  );
  border-bottom-left-radius: var(--radius-md);
  border-bottom-right-radius: var(--radius-md);
}

/* Jade Button */
.jade-button {
  background: linear-gradient(145deg, var(--accent-jade), var(--primary-green));
  color: white;
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-md) var(--spacing-lg);
  font-family: var(--font-main);
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(0, 191, 165, 0.3);
  transition: all var(--timing-quick) ease;
  position: relative;
  overflow: hidden;
}

.jade-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    rgba(255, 255, 255, 0) 0%,
    rgba(255, 255, 255, 0.2) 50%,
    rgba(255, 255, 255, 0) 100%
  );
  transition: left 0.8s ease;
}

.jade-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(0, 191, 165, 0.4);
}

.jade-button:hover::before {
  left: 100%;
}

.jade-button:active {
  transform: translateY(1px);
  box-shadow: 0 2px 4px rgba(0, 191, 165, 0.3);
}

.jade-button:disabled {
  background: #B0BEC5;
  cursor: not-allowed;
  box-shadow: none;
  transform: none;
}

/* Gold Button - for premium/special actions */
.gold-button {
  background: linear-gradient(145deg, var(--accent-gold), #FFA000);
  color: var(--deep-night);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-md) var(--spacing-lg);
  font-family: var(--font-main);
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(255, 215, 0, 0.3);
  transition: all var(--timing-quick) ease;
}

.gold-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(255, 215, 0, 0.4);
}

.gold-button:active {
  transform: translateY(1px);
  box-shadow: 0 2px 4px rgba(255, 215, 0, 0.3);
}

/* Navigation Bar - Mobile Style */
.bamboo-nav {
  display: flex;
  justify-content: space-around;
  background: linear-gradient(to right, var(--deep-green), var(--primary-green));
  padding: var(--spacing-md) var(--spacing-sm);
  box-shadow: 0 -2px 10px var(--shadow-color);
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 100;
}

.bamboo-nav a {
  color: white;
  text-decoration: none;
  padding: var(--spacing-md) var(--spacing-lg);
  border-radius: var(--radius-md);
  transition: all var(--timing-quick) ease;
  font-weight: 500;
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: 0.9rem;
}

.bamboo-nav a::before {
  content: '•';
  font-size: 1.5rem;
  margin-bottom: 4px;
}

.bamboo-nav a:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.bamboo-nav a.active {
  background-color: rgba(255, 255, 255, 0.2);
  box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
  font-weight: 700;
}

/* Add padding to main content to account for fixed navigation */
main {
  padding-bottom: 80px;
}

/* Loading Spinner - Jade Coin */
.jade-spinner {
  width: 50px;
  height: 50px;
  border-radius: var(--radius-round);
  border: 5px solid var(--accent-jade);
  border-top-color: var(--accent-gold);
  animation: spin 1s infinite linear;
  margin: var(--spacing-lg) auto;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Bamboo Progress Bar */
.bamboo-progress {
  height: 24px;
  background-color: var(--light-green);
  border-radius: var(--radius-lg);
  overflow: hidden;
  position: relative;
  margin: var(--spacing-md) 0;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
}

.bamboo-progress-fill {
  height: 100%;
  background: repeating-linear-gradient(
    45deg,
    var(--primary-green),
    var(--primary-green) 10px,
    var(--deep-green) 10px,
    var(--deep-green) 20px
  );
  border-radius: var(--radius-lg);
  transition: width var(--timing-medium) ease-out;
  position: relative;
}

.bamboo-progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  width: 10px;
  height: 100%;
  background-color: var(--accent-gold);
  border-top-right-radius: var(--radius-lg);
  border-bottom-right-radius: var(--radius-lg);
}

/* Task Item */
.task-item {
  background-color: white;
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  box-shadow: 0 2px 4px var(--shadow-color);
  display: flex;
  align-items: center;
  transition: transform var(--timing-quick) ease;
  border-left: 4px solid var(--primary-green);
}

.task-item:hover {
  transform: translateX(4px);
}

.task-item.completed {
  border-left-color: var(--accent-gold);
  background-color: rgba(255, 215, 0, 0.05);
}

.task-checkbox {
  width: 24px;
  height: 24px;
  border: 2px solid var(--primary-green);
  border-radius: var(--radius-sm);
  margin-right: var(--spacing-md);
  position: relative;
  cursor: pointer;
}

.task-checkbox.checked::after {
  content: '✓';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: var(--accent-gold);
  font-weight: bold;
}

/* Footer */
footer {
  text-align: center;
  margin-top: var(--spacing-xl);
  padding: var(--spacing-lg);
  color: var(--text-secondary);
  font-size: 0.9rem;
  background: linear-gradient(to right, var(--deep-green), var(--primary-green));
  color: white;
  border-radius: var(--radius-lg) var(--radius-lg) 0 0;
}

/* 数据加载器样式 */
.data-loader-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 200px;
  width: 100%;
}

.empty-state {
  text-align: center;
  padding: var(--spacing-lg);
  color: var(--text-secondary);
  font-style: italic;
}

/* 同步状态指示器样式 */
.sync-status-indicator {
  display: flex;
  align-items: center;
  padding: var(--spacing-xs) var(--spacing-sm);
  background-color: var(--background-panel);
  border-radius: var(--radius-full);
  box-shadow: var(--shadow-md);
  cursor: pointer;
  transition: all 0.2s ease;
  user-select: none;
  position: fixed;
  bottom: 80px;
  right: 20px;
  z-index: 100;
  border: 1px solid var(--border-color);
}

.sync-status-indicator:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.sync-status-indicator.minimal {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  justify-content: center;
  padding: 0;
}

.sync-status-indicator.detailed {
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--radius-md);
}

.sync-status-indicator.syncing {
  background-color: rgba(74, 144, 226, 0.1);
  border-color: var(--imperial-blue);
  animation: pulse 1.5s infinite;
}

.sync-status-indicator.success {
  background-color: rgba(136, 176, 75, 0.1);
  border-color: var(--jade-green);
}

.sync-status-indicator.error {
  background-color: rgba(215, 62, 53, 0.1);
  border-color: var(--cinnabar-red);
}

@keyframes pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(74, 144, 226, 0.4);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(74, 144, 226, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(74, 144, 226, 0);
  }
}

.sync-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  font-size: 1.2rem;
  margin-right: var(--spacing-xs);
}

.sync-status-indicator.minimal .sync-icon {
  margin-right: 0;
}

.sync-icon.syncing {
  color: var(--imperial-blue);
}

.sync-icon.success {
  color: var(--jade-green);
}

.sync-icon.error {
  color: var(--cinnabar-red);
}

.sync-icon.idle {
  color: var(--text-secondary);
}

.sync-label {
  font-size: 0.9rem;
  color: var(--text-primary);
  margin-right: var(--spacing-xs);
}

.sync-count {
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 20px;
  height: 20px;
  border-radius: var(--radius-full);
  background-color: var(--imperial-blue);
  color: white;
  font-size: 0.8rem;
  padding: 0 var(--spacing-xs);
}

/* 及时奖励卡片 */
.timely-reward-card {
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border: 1px solid var(--border-color);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  box-shadow: var(--shadow-md);
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
}

.timely-reward-card:hover {
  transform: translateY(-3px);
  box-shadow: var(--shadow-lg);
}

.reward-card-header {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.reward-icon {
  width: 48px;
  height: 48px;
  border-radius: var(--radius-round);
  overflow: hidden;
  margin-right: var(--spacing-md);
  background-color: var(--background-panel-dark);
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid var(--border-color);
}

.reward-icon img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.reward-title-section {
  flex: 1;
}

.reward-title {
  margin: 0 0 var(--spacing-xs) 0;
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--text-primary);
}

.reward-meta {
  display: flex;
  gap: var(--spacing-sm);
}

.reward-type,
.reward-status {
  font-size: 0.8rem;
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  background-color: var(--background-panel-dark);
}

.reward-card-body {
  margin-bottom: var(--spacing-md);
}

.reward-description {
  margin: 0 0 var(--spacing-md) 0;
  font-size: 0.9rem;
  color: var(--text-secondary);
  line-height: 1.4;
}

.reward-progress-section {
  margin-top: var(--spacing-md);
}

.reward-time-info {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  color: var(--text-tertiary);
  margin-top: var(--spacing-xs);
}

.reward-card-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.reward-points {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-size: 0.9rem;
  color: var(--imperial-gold);
  font-weight: 600;
}

.lucky-points-icon {
  font-size: 1.2rem;
}

.complete-reward-button {
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-xs) var(--spacing-md);
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.complete-reward-button:disabled {
  background: linear-gradient(145deg, var(--background-panel-dark), var(--background-panel));
  color: var(--text-tertiary);
  cursor: not-allowed;
}

.reward-completed-info {
  font-size: 0.8rem;
  color: var(--jade-green);
  font-weight: 600;
}

/* 奖励状态样式 */
.reward-active {
  border-left: 4px solid var(--imperial-blue);
}

.reward-completed {
  border-left: 4px solid var(--jade-green);
}

.reward-expired {
  border-left: 4px solid var(--cinnabar-red);
  opacity: 0.7;
}

.reward-upcoming {
  border-left: 4px solid var(--imperial-gold);
}

/* 及时奖励列表 */
.timely-reward-list {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

/* 幸运点显示 */
.lucky-points-display {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-sm) var(--spacing-md);
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border-radius: var(--radius-full);
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
  cursor: pointer;
  transition: all 0.2s ease;
}

.lucky-points-display:hover {
  box-shadow: var(--shadow-md);
}

.lucky-points-display.animating {
  animation: pulse 1s;
}

.lucky-points-icon {
  font-size: 1.2rem;
  color: var(--imperial-gold);
}

.lucky-points-value {
  font-weight: 600;
  color: var(--imperial-gold);
}

.lucky-points-label {
  font-size: 0.8rem;
  color: var(--text-secondary);
}

.lucky-points-compact {
  padding: var(--spacing-xs);
}

.lucky-points-large {
  padding: var(--spacing-md);
  font-size: 1.2rem;
}

.lucky-points-container {
  display: flex;
  justify-content: flex-end;
  margin-bottom: var(--spacing-md);
}

/* 幸运抽奖 */
.lucky-draw-container {
  padding: var(--spacing-md);
}

.lucky-draw-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-lg);
}

.lucky-draw-title {
  margin: 0;
  font-size: 1.5rem;
  color: var(--text-primary);
}

.lucky-draw-options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-lg);
}

.draw-option {
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border: 1px solid var(--border-color);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  box-shadow: var(--shadow-sm);
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.draw-option.selected {
  border: 2px solid var(--imperial-gold);
  box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
}

.draw-option.disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

.draw-option-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.draw-option-points {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-weight: 600;
  color: var(--imperial-gold);
}

.draw-option-label {
  margin: 0;
  font-size: 1.1rem;
  color: var(--text-primary);
}

.draw-option-description {
  margin: 0;
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.draw-option-insufficient {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: var(--spacing-xs);
  background-color: rgba(215, 62, 53, 0.8);
  color: white;
  font-size: 0.8rem;
  text-align: center;
}

.lucky-draw-actions {
  display: flex;
  justify-content: center;
  gap: var(--spacing-md);
  margin-top: var(--spacing-lg);
}

.draw-button {
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-sm) var(--spacing-lg);
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.draw-button:disabled {
  background: linear-gradient(145deg, var(--background-panel-dark), var(--background-panel));
  color: var(--text-tertiary);
  cursor: not-allowed;
}

.lucky-draw-results {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--spacing-lg);
}

/* 及时奖励页面 */
.timely-rewards-page {
  padding: var(--spacing-md);
}

.lucky-draw-button {
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-sm) var(--spacing-md);
  font-size: 0.9rem;
  font-weight: 600;
}

.lucky-draw-dialog {
  max-width: 800px;
}

/* 及时奖励模态框 */
.timely-reward-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.timely-reward-modal-backdrop {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(5px);
}

.timely-reward-modal-content {
  position: relative;
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border: 2px solid var(--imperial-gold);
  border-radius: var(--radius-md);
  padding: var(--spacing-lg);
  max-width: 90%;
  width: 500px;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: var(--shadow-lg), 0 0 20px rgba(212, 175, 55, 0.3);
  animation: scale-in 0.3s ease-out;
}

.timely-reward-modal-title {
  margin: 0 0 var(--spacing-md) 0;
  font-size: 1.5rem;
  color: var(--imperial-gold);
  text-align: center;
  text-shadow: 0 0 5px rgba(212, 175, 55, 0.5);
}

.timely-reward-modal-description {
  margin: 0 0 var(--spacing-md) 0;
  font-size: 1rem;
  color: var(--text-secondary);
  text-align: center;
}

.timely-reward-modal-actions {
  display: flex;
  justify-content: center;
  margin-top: var(--spacing-md);
}

@keyframes scale-in {
  0% {
    transform: scale(0.8);
    opacity: 0;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

/* 挑战卡片 */
.challenge-card {
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border: 1px solid var(--border-color);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  box-shadow: var(--shadow-md);
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
}

.challenge-card:hover {
  transform: translateY(-3px);
  box-shadow: var(--shadow-lg);
}

.challenge-card-header {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.challenge-icon {
  width: 48px;
  height: 48px;
  border-radius: var(--radius-round);
  overflow: hidden;
  margin-right: var(--spacing-md);
  background-color: var(--background-panel-dark);
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid var(--border-color);
}

.challenge-icon img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.challenge-title-section {
  flex: 1;
}

.challenge-title {
  margin: 0 0 var(--spacing-xs) 0;
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--text-primary);
}

.challenge-meta {
  display: flex;
  gap: var(--spacing-sm);
}

.challenge-difficulty,
.challenge-status {
  font-size: 0.8rem;
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  background-color: var(--background-panel-dark);
}

.challenge-card-body {
  margin-bottom: var(--spacing-md);
}

.challenge-description {
  margin: 0 0 var(--spacing-md) 0;
  font-size: 0.9rem;
  color: var(--text-secondary);
  line-height: 1.4;
}

.challenge-progress-section {
  margin-top: var(--spacing-md);
}

.challenge-dates {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  color: var(--text-tertiary);
  margin-top: var(--spacing-xs);
}

.challenge-card-footer {
  display: flex;
  justify-content: flex-end;
}

.complete-challenge-button {
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-xs) var(--spacing-md);
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.complete-challenge-button:disabled {
  background: linear-gradient(145deg, var(--background-panel-dark), var(--background-panel));
  color: var(--text-tertiary);
  cursor: not-allowed;
}

.challenge-completed-info {
  font-size: 0.8rem;
  color: var(--jade-green);
  font-weight: 600;
}

/* 挑战状态样式 */
.challenge-active {
  border-left: 4px solid var(--imperial-blue);
}

.challenge-completed {
  border-left: 4px solid var(--jade-green);
}

.challenge-expired {
  border-left: 4px solid var(--cinnabar-red);
  opacity: 0.7;
}

.challenge-upcoming {
  border-left: 4px solid var(--imperial-gold);
}

/* 挑战难度样式 */
.difficulty-easy {
  color: var(--jade-green);
}

.difficulty-medium {
  color: var(--imperial-blue);
}

.difficulty-hard {
  color: var(--imperial-gold);
}

.difficulty-expert {
  color: var(--cinnabar-red);
}

/* 挑战列表 */
.challenge-list {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

/* 挑战页面 */
.challenges-page {
  padding: var(--spacing-md);
}

.page-header {
  position: relative;
  margin-bottom: var(--spacing-md);
  display: flex;
  align-items: center;
  justify-content: center;
}

.page-title {
  font-family: var(--font-accent);
  font-size: 1.8rem;
  color: var(--deep-green);
  text-align: center;
}

/* 生成测试数据按钮 */
.generate-test-data-button {
  background-color: var(--imperial-gold);
  color: white;
  border: none;
  border-radius: var(--radius-md);
  padding: 8px 16px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.3s ease;
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
}

.generate-test-data-button:hover {
  background-color: #FFA000;
  transform: translateY(-50%) translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.generate-test-data-button:disabled {
  background-color: var(--ink-gray);
  cursor: not-allowed;
  transform: translateY(-50%);
  box-shadow: none;
}

.filter-section {
  margin-bottom: var(--spacing-lg);
  background-color: var(--background-panel-light);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  box-shadow: var(--shadow-sm);
}

.filter-group {
  margin-bottom: var(--spacing-md);
}

.filter-title {
  margin: 0 0 var(--spacing-xs) 0;
  font-size: 1rem;
  font-weight: 600;
  color: var(--text-primary);
}

.filter-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-xs);
}

.filter-actions {
  display: flex;
  justify-content: flex-end;
  margin-top: var(--spacing-md);
}

.clear-filters-button {
  font-size: 0.9rem;
}

/* 挑战详情 */
.challenge-details {
  padding: var(--spacing-md);
}

.challenge-header {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-md);
}

.challenge-icon-large {
  width: 64px;
  height: 64px;
  border-radius: var(--radius-md);
  margin-right: var(--spacing-md);
  border: 2px solid var(--border-color);
}

.challenge-meta-details {
  flex: 1;
}

.challenge-description-full {
  margin-bottom: var(--spacing-md);
  line-height: 1.6;
}

.challenge-progress-details {
  margin-bottom: var(--spacing-md);
}

.progress-bar-container {
  height: 12px;
  background-color: var(--background-panel-dark);
  border-radius: var(--radius-full);
  overflow: hidden;
}

.progress-bar-fill {
  height: 100%;
  background: linear-gradient(to right, var(--jade-green), var(--imperial-blue));
  border-radius: var(--radius-full);
}

.challenge-dates-details {
  margin-bottom: var(--spacing-md);
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.complete-challenge-button-large {
  width: 100%;
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-top: var(--spacing-md);
}

/* 及时奖励卡片 */
.timely-reward-card {
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  padding: 16px;
  margin-bottom: 16px;
  transition: all 0.3s ease;
  border-left: 4px solid #ccc;
  overflow: hidden;
  position: relative;
}

.timely-reward-card:hover {
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
  transform: translateY(-2px);
}

/* 状态样式 */
.timely-reward-card.reward-active {
  border-left-color: var(--bamboo-green);
}

.timely-reward-card.reward-completed {
  border-left-color: var(--rosewood-purple);
}

.timely-reward-card.reward-expired {
  border-left-color: var(--ink-gray);
  opacity: 0.8;
}

.timely-reward-card.reward-upcoming {
  border-left-color: var(--porcelain-blue);
}

/* 卡片头部 */
.reward-card-header {
  display: flex;
  align-items: center;
  margin-bottom: 12px;
}

.reward-icon {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  overflow: hidden;
  margin-right: 12px;
  background-color: #f5f5f5;
  display: flex;
  align-items: center;
  justify-content: center;
}

.reward-icon img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.reward-title-section {
  flex: 1;
}

.reward-title {
  margin: 0 0 4px 0;
  font-size: 18px;
  font-weight: 600;
}

.reward-meta {
  display: flex;
  align-items: center;
  font-size: 12px;
  color: var(--text-secondary);
}

.reward-type {
  margin-right: 8px;
  padding: 2px 6px;
  background-color: #f5f5f5;
  border-radius: 4px;
}

.reward-status {
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: 500;
}

.reward-status.reward-active {
  background-color: rgba(136, 176, 75, 0.1);
  color: var(--bamboo-green);
}

.reward-status.reward-completed {
  background-color: rgba(93, 57, 84, 0.1);
  color: var(--rosewood-purple);
}

.reward-status.reward-expired {
  background-color: rgba(138, 141, 145, 0.1);
  color: var(--ink-gray);
}

.reward-status.reward-upcoming {
  background-color: rgba(26, 109, 176, 0.1);
  color: var(--porcelain-blue);
}

/* 卡片内容 */
.reward-card-body {
  margin-bottom: 12px;
}

.reward-description {
  margin: 0 0 12px 0;
  font-size: 14px;
  color: var(--text-secondary);
  line-height: 1.5;
}

.reward-progress-section {
  margin-bottom: 8px;
}

.reward-time-info {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: var(--text-secondary);
  margin-top: 4px;
}

/* 卡片底部 */
.reward-card-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 8px;
  border-top: 1px solid #f0f0f0;
}

.reward-points {
  display: flex;
  align-items: center;
  font-size: 14px;
  font-weight: 500;
}

.lucky-points-icon {
  margin-right: 4px;
}

.lucky-points-value {
  color: var(--amber-yellow);
}

.complete-reward-button {
  padding: 6px 12px;
  background-color: var(--bamboo-green);
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.complete-reward-button:hover:not(:disabled) {
  background-color: var(--royal-jade);
}

.complete-reward-button:disabled {
  background-color: #e0e0e0;
  color: var(--ink-gray);
  cursor: not-allowed;
}

.reward-completed-info {
  font-size: 12px;
  color: var(--rosewood-purple);
}

/* 动画效果 */
@keyframes glow {
  0% {
    box-shadow: 0 0 5px rgba(136, 176, 75, 0.5);
  }
  50% {
    box-shadow: 0 0 15px rgba(136, 176, 75, 0.8);
  }
  100% {
    box-shadow: 0 0 5px rgba(136, 176, 75, 0.5);
  }
}

.timely-reward-card.reward-active:hover {
  animation: glow 2s infinite;
}
</file>

<file path="src/hooks/useDataRefresh.ts">
// src/hooks/useDataRefresh.ts
import { useEffect, useState, useCallback, useRef } from 'react';
import { useDataRefreshContext } from '@/context/DataRefreshProvider';
import { DataRefreshEvent } from '@/types/dataRefresh';

/**
 * 自定义 Hook，用于监听数据刷新事件
 *
 * @param tables 要监听的表名数组
 * @param callback 数据刷新时的回调函数
 * @returns 最近一次刷新的数据
 */
export function useDataRefresh(
  tables: string[],
  callback?: (event: DataRefreshEvent) => void
): DataRefreshEvent | null {
  const [lastRefresh, setLastRefresh] = useState<DataRefreshEvent | null>(null);
  const { registerRefreshListener } = useDataRefreshContext();

  useEffect(() => {
    // 为每个表注册监听器
    const unregisterFunctions = tables.map(table => {
      return registerRefreshListener(table, (data) => {
        const event = { table, data };
        setLastRefresh(event);

        if (callback) {
          callback(event);
        }
      });
    });

    // 清理函数
    return () => {
      unregisterFunctions.forEach(unregister => unregister());
    };
  }, [tables, callback, registerRefreshListener]);

  return lastRefresh;
}

/**
 * 自定义 Hook，用于监听特定表的数据刷新事件
 *
 * @param table 要监听的表名
 * @param callback 数据刷新时的回调函数
 * @returns 最近一次刷新的数据
 */
export function useTableRefresh(
  table: string,
  callback?: (data: any) => void
): any | null {
  const [lastData, setLastData] = useState<any | null>(null);
  const { registerRefreshListener } = useDataRefreshContext();

  useEffect(() => {
    // 注册表监听器
    const unregister = registerRefreshListener(table, (data) => {
      setLastData(data);

      if (callback) {
        callback(data);
      }
    });

    // 清理函数
    return unregister;
  }, [table, callback, registerRefreshListener]);

  return lastData;
}

/**
 * 自定义 Hook，用于注册表数据刷新监听器
 *
 * @param table 要监听的表名
 * @param callback 数据刷新时的回调函数
 * @returns 取消注册的函数
 */
export function useRegisterTableRefresh(
  table: string,
  callback: (data: any) => void
): () => void {
  const { registerRefreshListener } = useDataRefreshContext();
  const callbackRef = useRef(callback);
  const unregisterFuncRef = useRef<(() => void) | null>(null);

  // Update callbackRef when the callback prop changes
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  // Effect for registering and unregistering the listener
  useEffect(() => {
    // Define a stable callback function that always uses the latest callback from ref
    const stableCallback = (data: any) => {
      callbackRef.current(data);
    };

    // Register the listener
    const unregister = registerRefreshListener(table, stableCallback);
    unregisterFuncRef.current = unregister; // Store the unregister function

    // Cleanup function: This is called when the component unmounts or dependencies change
    return () => {
      unregister();
      unregisterFuncRef.current = null; // Clear the ref after unregistering
    };
  }, [table, registerRefreshListener]); // Dependencies: re-run if table or registerRefreshListener changes

  // Return a memoized function that the caller can use to manually unregister.
  // This function is stable and safe to call multiple times (will only unregister once).
  const manualUnregister = useCallback(() => {
    if (unregisterFuncRef.current) {
      unregisterFuncRef.current();
      unregisterFuncRef.current = null; // Ensure it's only called once via this manual path
    }
  }, []); // This useCallback has no dependencies, so manualUnregister is stable.

  return manualUnregister;
}

/**
 * 手动触发数据刷新事件
 * 注意：此函数必须在React组件内部使用
 *
 * @param table 表名
 * @param data 数据
 */
export function useDataRefreshTrigger() {
  const { refreshTable } = useDataRefreshContext();

  return (table: string, data?: any): void => {
    refreshTable(table, data);
  };
}

/**
 * 直接触发数据刷新事件（不使用hook，可以在任何地方调用）
 *
 * @param table 表名
 * @param data 数据
 */
export function triggerDataRefresh(table: string, data?: any): void {
  const refreshEvent = new CustomEvent('dataRefresh', {
    detail: { table, data }
  });
  window.dispatchEvent(refreshEvent);
}
</file>

<file path="src/index.css">
/* 基本样式已移至game-theme.css */

/* 页面内容样式 */

.page-content, section.page-content { /* Allow section to also use page-content style */
  background-color: transparent;
  padding: 15px;
  margin-bottom: 20px;
  width: 100%;
  box-sizing: border-box;
}
section + section { margin-top: 25px; }


hr {
  border: 0;
  height: 1px;
  background-color: rgba(136, 176, 75, 0.3); /* 使用竹绿色 */
  margin: 25px 0;
}

ul {
  list-style-type: disc;
  padding-left: 20px;
}
li { margin-bottom: 5px; }


/* Common Components */
.button-common {
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1em;
  font-weight: 500;
  transition: background-color 0.2s, opacity 0.2s;
  margin-right: 10px; /* Default spacing for buttons */
}
.button-common:last-child { margin-right: 0; }

.button-common:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.button-primary {
  background-color: #3498db;
  color: white;
}
.button-primary:hover:not(:disabled) {
  background-color: #2980b9;
}
.button-secondary {
  background-color: #95a5a6;
  color: white;
}
.button-secondary:hover:not(:disabled) {
  background-color: #7f8c8d;
}


select {
  padding: 10px;
  border-radius: 4px;
  border: 1px solid #bdc3c7;
  margin-right: 10px;
  font-size: 1em;
  background-color: white;
}

.loading-spinner-overlay {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  min-height: 100px;
}
.loading-spinner {
  border: 4px solid #ecf0f1; /* Light grey */
  border-top: 4px solid #3498db; /* Blue */
  border-radius: 50%;
  width: 30px;
  height: 30px;
  animation: spin 0.8s linear infinite;
}
.loading-spinner-text { margin-top: 10px; font-style: italic; color: #555; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.error-container {
  border: 1px solid #e74c3c; /* Red */
  padding: 15px;
  border-radius: 5px;
  background-color: #fdedec; /* Light red */
  margin-bottom: 15px;
}
.error-container h3 { color: #c0392b; margin-bottom: 8px;}
.error-text { color: #c0392b; }
.error-code-text { font-size: 0.85em; color: #7f8c8d; margin-top: 5px; }
</file>

<file path="src/pages/AbilitiesPage.tsx">
// src/pages/AbilitiesPage.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { usePandaState } from '@/context/PandaStateProvider';
import AbilityList from '@/components/game/AbilityList';
import AbilityUnlockNotification from '@/components/game/AbilityUnlockNotification';
import PageTransition from '@/components/animation/PageTransition';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { PandaAbilityRecord } from '@/services/pandaAbilityService';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchAbilitiesPageView } from '@/services';
import { AbilitiesPageViewLabelsBundle } from '@/types';

/**
 * Panda Abilities Page
 * Displays all panda abilities and allows activation of unlocked abilities
 */
const AbilitiesPage: React.FC = () => {
  const {
    pandaState,
    abilities,
    unlockedAbilities,
    isLoading: isPandaLoading,
    activateAbility,
    checkNewAbilities
  } = usePandaState();

  const [newlyUnlockedAbilities, setNewlyUnlockedAbilities] = useState<PandaAbilityRecord[]>([]);
  const [showUnlockNotification, setShowUnlockNotification] = useState(false);

  // 获取本地化标签
  const {
    labels: pageLabels,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<null, AbilitiesPageViewLabelsBundle>(
    'abilitiesPageViewContent',
    fetchAbilitiesPageView
  );

  // 合并加载状态
  const isLoading = isPandaLoading || isPending;

  // 检查新解锁的能力
  useEffect(() => {
    const checkForNewAbilities = async () => {
      const newAbilities = await checkNewAbilities();
      if (newAbilities.length > 0) {
        setNewlyUnlockedAbilities(newAbilities);
        setShowUnlockNotification(true);
      }
    };

    checkForNewAbilities();
  }, [checkNewAbilities]);

  // 关闭解锁通知
  const handleCloseUnlockNotification = () => {
    setShowUnlockNotification(false);
    setNewlyUnlockedAbilities([]);
  };

  // 激活能力
  const handleActivateAbility = async (abilityId: number) => {
    await activateAbility(abilityId);
  };

  // 显示错误状态
  if (isError) {
    return (
      <PageTransition>
        <div className="page-content">
          <ErrorDisplay
            error={error}
            title={pageLabels?.errorTitle || "Failed to Load Abilities"}
            messageTemplate={pageLabels?.errorMessage || "Unable to load ability data: {message}"}
            onRetry={refetch}
            retryButtonText={pageLabels?.retryButtonText || "Retry"}
          />
        </div>
      </PageTransition>
    );
  }

  return (
    <PageTransition>
      <div className="page-content">
        <div className="bamboo-frame">
          <h2>{pageLabels?.pageTitle || "Panda Abilities"}</h2>

          {isLoading ? (
            <div className="loading-container">
              <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "Loading abilities..."} />
            </div>
          ) : (
            <>
              <div className="abilities-header">
                <motion.div
                  className="panda-level-info"
                  initial={{ opacity: 0, y: -20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.5 }}
                >
                  <h3>{pageLabels?.pandaLevelLabel || "Panda Level"}: {pandaState?.level || 1}</h3>
                  <p>{pageLabels?.unlockedAbilitiesLabel || "Unlocked Abilities"}: {unlockedAbilities.length} / {abilities.length}</p>
                </motion.div>

                <motion.div
                  className="abilities-description"
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.5, delay: 0.2 }}
                >
                  <p>
                    {pageLabels?.abilitiesDescription ||
                      "Panda abilities help you complete tasks more efficiently and earn more rewards. As your panda levels up, you'll unlock more powerful abilities."}
                  </p>
                </motion.div>
              </div>

              <AbilityList
                abilities={abilities}
                unlockedAbilities={unlockedAbilities}
                onActivateAbility={handleActivateAbility}
                pandaLevel={pandaState?.level || 1}
                labels={{
                  filters: pageLabels?.filters,
                  card: pageLabels?.abilityCard,
                  detail: pageLabels?.abilityDetail,
                  noAbilitiesMessage: pageLabels?.noAbilitiesMessage
                }}
              />
            </>
          )}
        </div>

        {/* Ability unlock notification */}
        {showUnlockNotification && (
          <AbilityUnlockNotification
            newlyUnlockedAbilities={newlyUnlockedAbilities}
            onClose={handleCloseUnlockNotification}
            labels={pageLabels?.abilityUnlockNotification}
          />
        )}
      </div>
    </PageTransition>
  );
};

export default AbilitiesPage;
</file>

<file path="src/pages/ChallengesPage.tsx">
// src/pages/ChallengesPage.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import {
  ChallengeStatus,
  ChallengeType,
  ChallengeDifficulty,
  initializeChallengeCategories,
  generateTestChallengeData
} from '@/services/challengeService';
import ChallengeList from '@/components/game/ChallengeList';
import PageTransition from '@/components/animation/PageTransition';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import AnimatedButton from '@/components/animation/AnimatedButton';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { fetchChallengesPageView } from '@/services';
import type { ChallengesPageViewLabelsBundle } from '@/types';

/**
 * Challenges Page
 * Displays challenge list and filter options
 */
const ChallengesPage: React.FC = () => {
  const [filter, setFilter] = useState<{
    status?: ChallengeStatus;
    type?: ChallengeType;
    difficulty?: ChallengeDifficulty;
  }>({
    status: ChallengeStatus.ACTIVE
  });

  const [isGeneratingData, setIsGeneratingData] = useState(false);

  const {
    labels: pageLabels,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<null, ChallengesPageViewLabelsBundle>(
    'challengesPageViewContent',
    fetchChallengesPageView
  );

  // Initialize challenge categories
  useEffect(() => {
    initializeChallengeCategories();
  }, []);

  // Handle status filter
  const handleStatusFilter = (status?: ChallengeStatus) => {
    setFilter(prev => ({ ...prev, status }));
  };

  // Handle type filter
  const handleTypeFilter = (type?: ChallengeType) => {
    setFilter(prev => ({ ...prev, type }));
  };

  // Handle difficulty filter
  const handleDifficultyFilter = (difficulty?: ChallengeDifficulty) => {
    setFilter(prev => ({ ...prev, difficulty }));
  };

  // Clear all filters
  const clearAllFilters = () => {
    setFilter({});
  };

  // Generate test data
  const handleGenerateTestData = async () => {
    try {
      setIsGeneratingData(true);
      await generateTestChallengeData();
      // Refresh the page to show new data
      window.location.reload();
    } catch (error) {
      console.error('Error generating test data:', error);
    } finally {
      setIsGeneratingData(false);
    }
  };

  // Show loading state
  if (isPending) {
    return (
      <PageTransition>
        <div className="challenges-page">
          <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "Loading challenges..."} />
        </div>
      </PageTransition>
    );
  }

  // Show error state
  if (isError) {
    return (
      <PageTransition>
        <div className="challenges-page">
          <ErrorDisplay
            error={error}
            title={pageLabels?.errorTitle || "Challenge Page Error"}
            messageTemplate={pageLabels?.errorMessage || "Failed to load challenges: {message}"}
            onRetry={refetch}
            retryButtonText={pageLabels?.retryButtonText || "Retry"}
          />
        </div>
      </PageTransition>
    );
  }

  return (
    <PageTransition>
      <motion.div
        className="challenges-page"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
      >
        <div className="page-header">
          <h1 className="page-title">{pageLabels?.pageTitle || 'Challenges'}</h1>
          <button
            className="generate-test-data-button"
            onClick={handleGenerateTestData}
            disabled={isGeneratingData}
          >
            {isGeneratingData ? 'Generating...' : 'Generate Test Data'}
          </button>
        </div>

        <div className="filter-section">
          <div className="filter-group">
            <h3 className="filter-title">{pageLabels?.statusFilterLabel || 'Status'}</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleStatusFilter(undefined)}
                className={!filter.status ? 'active' : ''}
              >
                {pageLabels?.filters?.allLabel || 'All'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(ChallengeStatus.ACTIVE)}
                className={filter.status === ChallengeStatus.ACTIVE ? 'active' : ''}
              >
                {pageLabels?.filters?.activeLabel || 'Active'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(ChallengeStatus.COMPLETED)}
                className={filter.status === ChallengeStatus.COMPLETED ? 'active' : ''}
              >
                {pageLabels?.filters?.completedLabel || 'Completed'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(ChallengeStatus.UPCOMING)}
                className={filter.status === ChallengeStatus.UPCOMING ? 'active' : ''}
              >
                {pageLabels?.filters?.upcomingLabel || 'Upcoming'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-group">
            <h3 className="filter-title">{pageLabels?.typeFilterLabel || 'Type'}</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleTypeFilter(undefined)}
                className={!filter.type ? 'active' : ''}
              >
                {pageLabels?.filters?.typeAllLabel || 'All'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(ChallengeType.DAILY)}
                className={filter.type === ChallengeType.DAILY ? 'active' : ''}
              >
                {pageLabels?.filters?.typeDailyLabel || 'Daily'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(ChallengeType.WEEKLY)}
                className={filter.type === ChallengeType.WEEKLY ? 'active' : ''}
              >
                {pageLabels?.filters?.typeWeeklyLabel || 'Weekly'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(ChallengeType.EVENT)}
                className={filter.type === ChallengeType.EVENT ? 'active' : ''}
              >
                {pageLabels?.filters?.typeEventLabel || 'Event'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(ChallengeType.ONGOING)}
                className={filter.type === ChallengeType.ONGOING ? 'active' : ''}
              >
                {pageLabels?.filters?.typeOngoingLabel || 'Ongoing'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-group">
            <h3 className="filter-title">{pageLabels?.difficultyFilterLabel || 'Difficulty'}</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleDifficultyFilter(undefined)}
                className={!filter.difficulty ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyAllLabel || 'All'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleDifficultyFilter(ChallengeDifficulty.EASY)}
                className={filter.difficulty === ChallengeDifficulty.EASY ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyEasyLabel || 'Easy'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleDifficultyFilter(ChallengeDifficulty.MEDIUM)}
                className={filter.difficulty === ChallengeDifficulty.MEDIUM ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyMediumLabel || 'Medium'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleDifficultyFilter(ChallengeDifficulty.HARD)}
                className={filter.difficulty === ChallengeDifficulty.HARD ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyHardLabel || 'Hard'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleDifficultyFilter(ChallengeDifficulty.EXPERT)}
                className={filter.difficulty === ChallengeDifficulty.EXPERT ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyExpertLabel || 'Expert'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-actions">
            <AnimatedButton onClick={clearAllFilters} className="clear-filters-button">
              {pageLabels?.filters?.clearFiltersLabel || 'Clear All Filters'}
            </AnimatedButton>
          </div>
        </div>

        <div className="challenges-container">
          <ChallengeList
            filter={filter}
            labels={{
              ...pageLabels?.challengeCard,
              statusLabel: pageLabels?.statusFilterLabel,
              typeLabel: pageLabels?.typeFilterLabel,
              difficultyLabel: pageLabels?.difficultyFilterLabel,
              noItemsMessage: pageLabels?.noChallengesMessage
            }}
          />
        </div>
      </motion.div>
    </PageTransition>
  );
};

export default ChallengesPage;
</file>

<file path="src/pages/HomePage.tsx">
// src/pages/HomePage.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchHomePageView } from '@/services';
import WelcomeSection from '@/features/home/WelcomeSection';
import MoodsSection from '@/features/home/MoodsSection';
import PandaSection from '@/features/home/PandaSection';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import AnimatedButton from '@/components/animation/AnimatedButton';
import { pageTransition } from '@/utils/animation';
import { initializeGameData } from '@/services/gameInitService';
import type { HomePageViewDataPayload, HomePageViewLabelsBundle, ApiError } from '@/types';

const HomePage: React.FC = () => {
  const [isInitializing, setIsInitializing] = useState(false);

  const {
    data: pageData, labels: pageLabels, isPending, isError, error, refetch, isFetching
  } = useLocalizedView<HomePageViewDataPayload, HomePageViewLabelsBundle>(
    'homePageViewContent',
    fetchHomePageView
  );

  const handleInitializeGame = async () => {
    try {
      setIsInitializing(true);
      await initializeGameData();
      // Refresh the page to show new data
      window.location.reload();
    } catch (error) {
      console.error('Error initializing game data:', error);
      alert('Failed to initialize game data. Please try again.');
    } finally {
      setIsInitializing(false);
    }
  };

  if (isPending && !pageLabels) { // Full page initial load
    return <LoadingSpinner variant="jade" text="Loading Home Page Content..." />;
  }

  if (isError && !pageLabels) { // Critical: Page labels failed
    return (
      <div className="page-content">
        <ErrorDisplay error={error} title="Home Page Error" onRetry={refetch} />
      </div>
    );
  }

  // If labels are partially/fully loaded, but an error occurred or still pending data
  // We can render the page shell with what we have.
  const isLoadingData = isPending || (isFetching && !pageData); // True if data is still being fetched/refetched

  return (
    <motion.div
      className="page-container"
      variants={pageTransition}
      initial="hidden"
      animate="visible"
      exit="exit"
    >
      <div className="bamboo-frame"> {/* Wrap content in bamboo-frame */}
        <h2>{pageLabels?.pageTitle || "Dashboard"}</h2>

        <WelcomeSection labels={pageLabels?.welcomeSection} username={pageData?.username} />

        <PandaSection labels={pageLabels?.pandaSection} />

        <MoodsSection
          labels={pageLabels?.moodsSection}
          moods={pageData?.moods}
          onRefresh={refetch}
          isFetching={isFetching}
        />

        {/* Initialize Game Data Button */}
        <div className="init-game-container" style={{marginTop: '20px', textAlign: 'center'}}>
          <AnimatedButton
            variant="gold"
            onClick={handleInitializeGame}
            disabled={isInitializing}
            style={{marginTop: '20px'}}
          >
            {isInitializing ? 'Initializing...' : 'Initialize Game Data'}
          </AnimatedButton>
          <p className="text-sm text-gray-500 mt-2">
            This will create sample data for all game systems
          </p>
        </div>

        {/* Example of a page-level button using a page-level label with jade style */}
        {pageLabels?.someActionText && (
          <AnimatedButton
            variant="jade"
            onClick={() => alert('Action Confirmed!')}
            style={{marginTop: '20px'}}
          >
            {pageLabels.someActionText}
          </AnimatedButton>
        )}

        {/* Show specific data error if labels loaded but data part failed */}
        {isError && pageData === undefined && pageLabels && (
           <ErrorDisplay
              error={error}
              title={pageLabels.moodsSection?.sectionTitle || "Data Fetch Error"}
              messageTemplate="Could not load mood data. Details: {message}"
              onRetry={refetch}
           />
         )}
         {isLoadingData && pageLabels && ( // Show spinner for data if labels are present
             <LoadingSpinner variant="jade" text="Fetching latest data..." />
         )}
      </div>
    </motion.div>
  );
};
export default HomePage;
</file>

<file path="src/pages/SettingsPage.tsx">
// src/pages/SettingsPage.tsx
import React from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchSettingsPageView } from '@/services';
import LanguageSettingsSection from '@/features/settings/LanguageSettingsSection';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import PageTransition from '@/components/animation/PageTransition';
import DialogDemo from '@/components/game/DialogDemo';
import type { SettingsPageViewLabelsBundle, ApiError } from '@/types';

const SettingsPage: React.FC = () => {
  const {
    labels: pageLabels, isPending, isError, error, refetch, isFetching
  } = useLocalizedView<null, SettingsPageViewLabelsBundle>(
    'settingsPageViewContent',
    fetchSettingsPageView
  );

  if (isPending && !pageLabels) { // Full page initial load
    return <LoadingSpinner variant="jade" text="Loading Settings Page Content..." />;
  }

  if (isError || !pageLabels) { // Critical: Page labels failed
     return (
      <div className="page-content">
        <ErrorDisplay
          error={error}
          title={pageLabels?.pageTitle || "Settings Load Error"}
          messageTemplate="Could not load settings. Details: {message}"
          onRetry={refetch}
        />
      </div>
    );
  }

  return (
    <PageTransition>
      <div className="page-content"> {/* Use regular container first */}
        <div className="bamboo-frame"> {/* Wrap content in bamboo-frame */}
          <h2>{pageLabels.pageTitle || "Settings"}</h2>
          <LanguageSettingsSection
            labels={pageLabels.languageSection}
            isUpdatingPage={isFetching && !!pageLabels} // Page is fetching if labels are present but still fetching
          />

          {/* 对话框演示部分 */}
          <div style={{ marginTop: '30px', borderTop: '1px solid var(--border-color)', paddingTop: '20px' }}>
            <h3>UI组件演示</h3>
            <DialogDemo />
          </div>
        </div>
      </div>
    </PageTransition>
  );
};
export default SettingsPage;
</file>

<file path="src/pages/TasksPage.tsx">
// src/pages/TasksPage.tsx
import React, { useEffect } from 'react';
import { motion } from 'framer-motion';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchTasksPageView } from '@/services';
import TaskManager from '@/features/tasks/TaskManager';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { pageTransition } from '@/utils/animation';
import type { TasksPageViewLabelsBundle } from '@/types';
import TaskReminderNotification from '@/components/task/TaskReminderNotification';
import { checkDueSoonTasks, checkOverdueTasks } from '@/services/taskReminderService';

const TasksPage: React.FC = () => {
  const {
    labels: pageLabels, isPending, isError, error, refetch
  } = useLocalizedView<null, TasksPageViewLabelsBundle>(
    'tasksPageViewContent',
    fetchTasksPageView
  );

  // 检查任务提醒
  useEffect(() => {
    const checkReminders = async () => {
      try {
        // 检查即将到期的任务
        await checkDueSoonTasks();

        // 检查已过期的任务
        await checkOverdueTasks();
      } catch (err) {
        console.error('Failed to check task reminders:', err);
      }
    };

    // 立即检查一次
    checkReminders();

    // 设置定时检查（每小时检查一次）
    const intervalId = setInterval(checkReminders, 60 * 60 * 1000);

    // 清理函数
    return () => {
      clearInterval(intervalId);
    };
  }, []);

  if (isPending) { // 完整页面初始加载
    return <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "加载任务页面内容..."} />;
  }

  if (isError) { // 关键错误：页面标签加载失败
    return (
      <div className="page-content">
        <ErrorDisplay
          error={error}
          title={pageLabels?.errorTitle || "任务页面错误"}
          messageTemplate={pageLabels?.errorMessage || "无法加载任务数据: {message}"}
          onRetry={refetch}
          retryButtonText={pageLabels?.retryButtonText || "重试"}
        />
      </div>
    );
  }

  return (
    <>
      <motion.div
        className="page-container"
        variants={pageTransition}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <div className="bamboo-frame">
          <h2>{pageLabels?.pageTitle || "任务管理"}</h2>

          <TaskManager labels={pageLabels?.taskManager} />
        </div>
      </motion.div>

      {/* 任务提醒通知 */}
      <TaskReminderNotification
        onTaskClick={(taskId) => {
          // 这里可以添加导航到任务详情的逻辑
          console.log('Navigate to task:', taskId);
        }}
      />
    </>
  );
};

export default TasksPage;
</file>

<file path="src/pages/TimelyRewardsPage.tsx">
// src/pages/TimelyRewardsPage.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import {
  TimelyRewardStatus,
  TimelyRewardType,
  initializeTimelyRewards
} from '@/services/timelyRewardService';
import TimelyRewardList from '@/components/game/TimelyRewardList';
import LuckyDraw from '@/components/game/LuckyDraw';
import PageTransition from '@/components/animation/PageTransition';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import AnimatedButton from '@/components/animation/AnimatedButton';
import ScrollDialog from '@/components/game/ScrollDialog';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { fetchTimelyRewardsPageView } from '@/services';
import type { TimelyRewardsPageViewLabelsBundle } from '@/types';

/**
 * Timely Rewards Page
 * Displays timely rewards list and lucky draw
 */
const TimelyRewardsPage: React.FC = () => {
  const [filter, setFilter] = useState<{
    status?: TimelyRewardStatus;
    type?: TimelyRewardType;
  }>({
    status: TimelyRewardStatus.ACTIVE
  });
  const [showLuckyDraw, setShowLuckyDraw] = useState(false);

  const {
    labels: pageLabels,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<null, TimelyRewardsPageViewLabelsBundle>(
    'timelyRewardsPageViewContent',
    fetchTimelyRewardsPageView
  );

  // Initialize timely rewards
  useEffect(() => {
    initializeTimelyRewards();
  }, []);

  // Handle status filter
  const handleStatusFilter = (status?: TimelyRewardStatus) => {
    setFilter(prev => ({ ...prev, status }));
  };

  // Handle type filter
  const handleTypeFilter = (type?: TimelyRewardType) => {
    setFilter(prev => ({ ...prev, type }));
  };

  // Clear all filters
  const clearAllFilters = () => {
    setFilter({});
  };

  // Open lucky draw
  const openLuckyDraw = () => {
    setShowLuckyDraw(true);
  };

  // Close lucky draw
  const closeLuckyDraw = () => {
    setShowLuckyDraw(false);
  };

  if (isPending && !pageLabels) { // Full page initial loading
    return <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "Loading rewards..."} />;
  }

  if (isError && !pageLabels) { // Critical error: page labels failed to load
    return (
      <div className="page-content">
        <ErrorDisplay error={error} title={pageLabels?.errorTitle || "Timely Rewards Page Error"} onRetry={refetch} />
      </div>
    );
  }

  return (
    <PageTransition>
      <motion.div
        className="timely-rewards-page"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
      >
        <div className="page-header">
          <h1 className="page-title">{pageLabels?.pageTitle || 'Timely Rewards'}</h1>
          <AnimatedButton
            onClick={openLuckyDraw}
            className="lucky-draw-button"
          >
            {pageLabels?.luckyDraw?.buttonText || 'Lucky Draw'}
          </AnimatedButton>
        </div>

        <div className="filter-section">
          <div className="filter-group">
            <h3 className="filter-title">{pageLabels?.filters?.statusLabel || 'Status'}</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleStatusFilter(undefined)}
                className={!filter.status ? 'active' : ''}
              >
                {pageLabels?.filters?.allLabel || 'All'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(TimelyRewardStatus.ACTIVE)}
                className={filter.status === TimelyRewardStatus.ACTIVE ? 'active' : ''}
              >
                {pageLabels?.filters?.activeLabel || 'Active'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(TimelyRewardStatus.COMPLETED)}
                className={filter.status === TimelyRewardStatus.COMPLETED ? 'active' : ''}
              >
                {pageLabels?.filters?.completedLabel || 'Completed'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(TimelyRewardStatus.UPCOMING)}
                className={filter.status === TimelyRewardStatus.UPCOMING ? 'active' : ''}
              >
                {pageLabels?.filters?.upcomingLabel || 'Upcoming'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-group">
            <h3 className="filter-title">{pageLabels?.filters?.typeLabel || 'Type'}</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleTypeFilter(undefined)}
                className={!filter.type ? 'active' : ''}
              >
                {pageLabels?.filters?.typeAllLabel || 'All'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(TimelyRewardType.DAILY)}
                className={filter.type === TimelyRewardType.DAILY ? 'active' : ''}
              >
                {pageLabels?.filters?.typeDailyLabel || 'Daily Reward'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(TimelyRewardType.MORNING)}
                className={filter.type === TimelyRewardType.MORNING ? 'active' : ''}
              >
                {pageLabels?.filters?.typeMorningLabel || 'Early Bird Reward'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(TimelyRewardType.STREAK)}
                className={filter.type === TimelyRewardType.STREAK ? 'active' : ''}
              >
                {pageLabels?.filters?.typeStreakLabel || 'Streak Reward'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(TimelyRewardType.SPECIAL)}
                className={filter.type === TimelyRewardType.SPECIAL ? 'active' : ''}
              >
                {pageLabels?.filters?.typeSpecialLabel || 'Special Reward'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-actions">
            <AnimatedButton onClick={clearAllFilters} className="clear-filters-button">
              {pageLabels?.filters?.clearFiltersLabel || 'Clear All Filters'}
            </AnimatedButton>
          </div>
        </div>

        <div className="rewards-container">
          <TimelyRewardList
            filter={filter}
            labels={pageLabels?.rewardCard}
          />
        </div>

        {/* Lucky Draw Modal */}
        {showLuckyDraw && (
          <ScrollDialog
            isOpen={showLuckyDraw}
            title={pageLabels?.luckyDraw?.title || 'Lucky Draw'}
            onClose={closeLuckyDraw}
          >
            <div className="lucky-draw-dialog">
              <LuckyDraw onClose={closeLuckyDraw} />
            </div>
          </ScrollDialog>
        )}
      </motion.div>
    </PageTransition>
  );
};

export default TimelyRewardsPage;
</file>

<file path="src/services/pandaStateService.ts">
// src/services/pandaStateService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import type { PandaMood, EnergyLevel } from '@/components/game/PandaAvatar';

// 熊猫状态记录类型
export interface PandaStateRecord {
  id?: number;
  mood: PandaMood;
  energy: EnergyLevel;
  lastUpdated: Date;
  experience: number; // 经验值
  level: number; // 等级
}

// 扩展的熊猫状态（用于游戏初始化）
export interface PandaState extends Omit<PandaStateRecord, 'lastUpdated'> {
  name?: string;
  outfit?: string;
  accessories?: string[];
}

// 默认熊猫状态
const DEFAULT_PANDA_STATE: PandaStateRecord = {
  mood: 'normal',
  energy: 'medium',
  lastUpdated: new Date(),
  experience: 0,
  level: 1
};


export async function getPandaMood(): Promise<PandaMood> {
  const pandaState = await getPandaState();
  return pandaState.mood;
}

/**
 * 获取当前熊猫状态
 * 如果不存在，则创建默认状态
 */
export async function getPandaState(): Promise<PandaStateRecord> {
  // 检查数据库中是否已有熊猫状态记录
  const pandaState = await db.table('pandaState').toArray();

  if (pandaState.length === 0) {
    // 如果没有记录，创建默认状态
    const id = await db.table('pandaState').add(DEFAULT_PANDA_STATE);
    return { ...DEFAULT_PANDA_STATE, id };
  }

  return pandaState[0];
}

/**
 * 更新熊猫情绪状态
 * @param mood 新的情绪状态
 */
export async function updatePandaMood(mood: PandaMood): Promise<PandaStateRecord> {
  const currentState = await getPandaState();
  const updatedState = {
    ...currentState,
    mood,
    lastUpdated: new Date()
  };

  // 更新数据库
  await db.table('pandaState').update(currentState.id!, updatedState);

  // 添加同步项目
  await addSyncItem('pandaState', 'update', updatedState);

  return updatedState;
}

/**
 * 更新熊猫能量级别
 * @param energy 新的能量级别
 */
export async function updatePandaEnergy(energy: EnergyLevel): Promise<PandaStateRecord> {
  const currentState = await getPandaState();
  const updatedState = {
    ...currentState,
    energy,
    lastUpdated: new Date()
  };

  // 更新数据库
  await db.table('pandaState').update(currentState.id!, updatedState);

  // 添加同步项目
  await addSyncItem('pandaState', 'update', updatedState);

  return updatedState;
}

/**
 * 增加熊猫经验值
 * @param amount 增加的经验值数量
 */
export async function addPandaExperience(amount: number): Promise<PandaStateRecord> {
  const currentState = await getPandaState();
  const newExperience = currentState.experience + amount;

  // 简单的等级计算逻辑：每100点经验升一级
  const newLevel = Math.floor(newExperience / 100) + 1;

  const updatedState = {
    ...currentState,
    experience: newExperience,
    level: newLevel,
    lastUpdated: new Date()
  };

  // 如果升级了，更新情绪为开心
  if (newLevel > currentState.level) {
    updatedState.mood = 'happy';
  }

  // 更新数据库
  await db.table('pandaState').update(currentState.id!, updatedState);

  // 添加同步项目
  await addSyncItem('pandaState', 'update', updatedState);

  return updatedState;
}

/**
 * 重置熊猫状态（用于测试或重新开始）
 */
export async function resetPandaState(): Promise<PandaStateRecord> {
  const currentState = await getPandaState();
  const resetState = {
    ...DEFAULT_PANDA_STATE,
    id: currentState.id,
    lastUpdated: new Date()
  };

  // 更新数据库
  await db.table('pandaState').update(currentState.id!, resetState);

  // 添加同步项目
  await addSyncItem('pandaState', 'update', resetState);

  return resetState;
}

/**
 * 更新熊猫状态（用于游戏初始化）
 * @param state 新的熊猫状态
 */
export async function updatePandaState(state: PandaState): Promise<PandaStateRecord> {
  const currentState = await getPandaState();

  // 创建更新后的状态
  const updatedState = {
    ...currentState,
    mood: state.mood || currentState.mood,
    energy: typeof state.energy === 'number' ? state.energy : currentState.energy,
    experience: state.experience !== undefined ? state.experience : currentState.experience,
    level: state.level || currentState.level,
    lastUpdated: new Date()
  };

  // 更新数据库
  await db.table('pandaState').update(currentState.id!, updatedState);

  // 添加同步项目
  await addSyncItem('pandaState', 'update', updatedState);

  // 如果提供了名称、装扮或配件，可以在这里处理
  // 这里假设有一个单独的表来存储这些信息
  if (state.name || state.outfit || state.accessories) {
    console.log('Additional panda customization:', {
      name: state.name,
      outfit: state.outfit,
      accessories: state.accessories
    });
    // 在实际应用中，这里可以更新相应的表
  }

  return updatedState;
}
</file>

<file path="src/services/rewardService.ts">
// src/services/rewardService.ts
import { db } from '@/db';
import { TaskType, TaskPriority, TaskRecord } from './taskService';
import { addSyncItem } from './dataSyncService';

// 奖励类型枚举
export enum RewardType {
  EXPERIENCE = 'experience',   // 经验值
  COIN = 'coin',               // 金币
  ITEM = 'item',               // 物品
  BADGE = 'badge',             // 徽章
  ABILITY = 'ability'          // 熊猫能力
}

// 奖励稀有度枚举
export enum RewardRarity {
  COMMON = 'common',           // 普通
  UNCOMMON = 'uncommon',       // 不常见
  RARE = 'rare',               // 稀有
  EPIC = 'epic',               // 史诗
  LEGENDARY = 'legendary'      // 传说
}

// 奖励记录类型
export interface RewardRecord {
  id?: number;
  type: RewardType;
  rarity: RewardRarity;
  amount: number;
  name: string;
  description: string;
  iconPath: string;
  taskId?: number;
  obtainedAt: Date;
  isNew: boolean;
  isViewed: boolean;
}

// 物品类型枚举
export enum ItemType {
  FOOD = 'food',               // 食物
  TOY = 'toy',                 // 玩具
  DECORATION = 'decoration',   // 装饰
  SCROLL = 'scroll',           // 卷轴
  POTION = 'potion'            // 药水
}

// 物品记录类型
export interface ItemRecord {
  id?: number;
  type: ItemType;
  name: string;
  description: string;
  rarity: RewardRarity;
  iconPath: string;
  quantity: number;
  isUsable: boolean;
  effectDescription?: string;
  obtainedAt: Date;
}

// 徽章记录类型
export interface BadgeRecord {
  id?: number;
  name: string;
  description: string;
  rarity: RewardRarity;
  iconPath: string;
  obtainedAt: Date;
  isEquipped: boolean;
}

// 熊猫能力记录类型
export interface AbilityRecord {
  id?: number;
  name: string;
  description: string;
  rarity: RewardRarity;
  iconPath: string;
  obtainedAt: Date;
  isUnlocked: boolean;
  isActive: boolean;
  cooldownMinutes?: number;
  lastUsedAt?: Date;
}

/**
 * 根据任务生成奖励
 * @param task 完成的任务
 * @returns 生成的奖励
 */
export async function generateRewardsForTask(task: TaskRecord): Promise<RewardRecord[]> {
  const rewards: RewardRecord[] = [];
  const now = new Date();

  // 基础经验值奖励（已在taskService中处理）
  let experienceAmount = 10;

  // 根据优先级调整经验值
  switch (task.priority) {
    case TaskPriority.HIGH:
      experienceAmount += 15;
      break;
    case TaskPriority.MEDIUM:
      experienceAmount += 10;
      break;
    case TaskPriority.LOW:
      experienceAmount += 5;
      break;
  }

  // 根据任务类型调整经验值
  switch (task.type) {
    case TaskType.MAIN:
      experienceAmount += 20;
      break;
    case TaskType.DAILY:
      experienceAmount += 5;
      break;
    case TaskType.SIDE:
      experienceAmount += 10;
      break;
  }

  // 添加经验值奖励
  rewards.push({
    type: RewardType.EXPERIENCE,
    rarity: RewardRarity.COMMON,
    amount: experienceAmount,
    name: '经验值',
    description: '增加熊猫的经验值',
    iconPath: '/assets/rewards/experience.svg',
    taskId: task.id,
    obtainedAt: now,
    isNew: true,
    isViewed: false
  });

  // 添加金币奖励
  const coinAmount = calculateCoinReward(task);
  rewards.push({
    type: RewardType.COIN,
    rarity: RewardRarity.COMMON,
    amount: coinAmount,
    name: '竹币',
    description: '可用于购买物品和升级',
    iconPath: '/assets/rewards/coin.svg',
    taskId: task.id,
    obtainedAt: now,
    isNew: true,
    isViewed: false
  });

  // 随机物品奖励（概率性）
  if (shouldGetItemReward(task)) {
    const itemReward = generateRandomItemReward(task);
    rewards.push({
      ...itemReward,
      taskId: task.id,
      obtainedAt: now,
      isNew: true,
      isViewed: false
    });
  }

  // 保存奖励记录
  await saveRewards(rewards);

  return rewards;
}

/**
 * 计算金币奖励
 */
function calculateCoinReward(task: TaskRecord): number {
  let baseAmount = 5;

  // 根据优先级调整金币数量
  switch (task.priority) {
    case TaskPriority.HIGH:
      baseAmount += 15;
      break;
    case TaskPriority.MEDIUM:
      baseAmount += 10;
      break;
    case TaskPriority.LOW:
      baseAmount += 5;
      break;
  }

  // 根据任务类型调整金币数量
  switch (task.type) {
    case TaskType.MAIN:
      baseAmount += 20;
      break;
    case TaskType.DAILY:
      baseAmount += 5;
      break;
    case TaskType.SIDE:
      baseAmount += 10;
      break;
  }

  // 添加随机波动（±20%）
  const randomFactor = 0.8 + Math.random() * 0.4; // 0.8 到 1.2 之间
  return Math.round(baseAmount * randomFactor);
}

/**
 * 判断是否应该获得物品奖励
 */
function shouldGetItemReward(task: TaskRecord): boolean {
  let chance = 0.1; // 基础概率10%

  // 根据优先级调整概率
  switch (task.priority) {
    case TaskPriority.HIGH:
      chance += 0.2;
      break;
    case TaskPriority.MEDIUM:
      chance += 0.1;
      break;
    case TaskPriority.LOW:
      chance += 0.05;
      break;
  }

  // 根据任务类型调整概率
  switch (task.type) {
    case TaskType.MAIN:
      chance += 0.3;
      break;
    case TaskType.DAILY:
      chance += 0.05;
      break;
    case TaskType.SIDE:
      chance += 0.15;
      break;
  }

  return Math.random() < chance;
}

/**
 * 生成随机物品奖励
 */
function generateRandomItemReward(task: TaskRecord): RewardRecord {
  // 随机选择物品类型
  const itemTypes = [
    { type: ItemType.FOOD, weight: 0.4 },
    { type: ItemType.TOY, weight: 0.3 },
    { type: ItemType.DECORATION, weight: 0.1 },
    { type: ItemType.SCROLL, weight: 0.1 },
    { type: ItemType.POTION, weight: 0.1 }
  ];

  // 随机选择稀有度
  const rarityTypes = [
    { rarity: RewardRarity.COMMON, weight: 0.6 },
    { rarity: RewardRarity.UNCOMMON, weight: 0.25 },
    { rarity: RewardRarity.RARE, weight: 0.1 },
    { rarity: RewardRarity.EPIC, weight: 0.04 },
    { rarity: RewardRarity.LEGENDARY, weight: 0.01 }
  ];

  // 根据权重随机选择物品类型
  const randomTypeObj = weightedRandom(itemTypes);
  const randomType = randomTypeObj.type;

  // 根据权重随机选择稀有度
  const randomRarityObj = weightedRandom(rarityTypes);
  const randomRarity = randomRarityObj.rarity;

  // 根据类型和稀有度生成物品
  return generateItemByTypeAndRarity(randomType, randomRarity);
}

/**
 * 根据权重随机选择
 */
function weightedRandom<T>(items: Array<T & { weight: number }>): T {
  const totalWeight = items.reduce((sum, item) => sum + item.weight, 0);
  let random = Math.random() * totalWeight;

  for (const item of items) {
    random -= item.weight;
    if (random <= 0) {
      return item;
    }
  }

  return items[0]; // 默认返回第一个
}

/**
 * 根据类型和稀有度生成物品
 */
function generateItemByTypeAndRarity(itemType: ItemType, rarity: RewardRarity): RewardRecord {
  // 这里可以根据类型和稀有度从预定义的物品列表中选择
  // 简化版本，直接生成
  const itemNames: Record<ItemType, string[]> = {
    [ItemType.FOOD]: ['竹笋', '竹叶', '竹芽', '竹果', '竹糖'],
    [ItemType.TOY]: ['竹球', '竹环', '竹哑铃', '竹摇铃', '竹陀螺'],
    [ItemType.DECORATION]: ['竹帽', '竹围巾', '竹眼镜', '竹项链', '竹手镯'],
    [ItemType.SCROLL]: ['初级卷轴', '中级卷轴', '高级卷轴', '大师卷轴', '宗师卷轴'],
    [ItemType.POTION]: ['小型药水', '中型药水', '大型药水', '特效药水', '神奇药水']
  };

  const rarityDescriptions: Record<RewardRarity, string> = {
    [RewardRarity.COMMON]: '普通',
    [RewardRarity.UNCOMMON]: '不常见',
    [RewardRarity.RARE]: '稀有',
    [RewardRarity.EPIC]: '史诗',
    [RewardRarity.LEGENDARY]: '传说'
  };

  // 随机选择物品名称
  const names = itemNames[itemType];
  const name = names[Math.floor(Math.random() * names.length)];

  // 生成物品描述
  const description = `${rarityDescriptions[rarity]}的${name}`;

  // 生成图标路径
  const iconPath = `/assets/rewards/${itemType.toLowerCase()}_${rarity.toLowerCase()}.svg`;

  return {
    type: RewardType.ITEM,
    rarity,
    amount: 1,
    name,
    description,
    iconPath,
    obtainedAt: new Date(),
    isNew: true,
    isViewed: false
  };
}

/**
 * 保存奖励记录
 */
async function saveRewards(rewards: RewardRecord[]): Promise<void> {
  await db.table('rewards').bulkAdd(rewards);
}

/**
 * 获取未查看的奖励
 */
export async function getUnviewedRewards(): Promise<RewardRecord[]> {
  return db.table('rewards')
    .filter(reward => reward.isViewed === false)
    .toArray();
}

/**
 * 标记奖励为已查看
 */
export async function markRewardsAsViewed(rewardIds: number[]): Promise<void> {
  await Promise.all(
    rewardIds.map(id =>
      db.table('rewards')
        .update(id, { isViewed: true, isNew: false })
    )
  );
}

/**
 * 获取玩家的金币数量
 */
export async function getPlayerCoins(): Promise<number> {
  const coinRewards = await db.table('rewards')
    .where('type')
    .equals(RewardType.COIN)
    .toArray();

  return coinRewards.reduce((total, reward) => total + reward.amount, 0);
}

/**
 * 添加物品到用户库存
 * @param item 物品数据
 */
export async function addItem(item: Omit<ItemRecord, 'id'>): Promise<ItemRecord> {
  const id = await db.table('items').add(item);
  const newItem = { ...item, id: id as number };

  // 添加到同步队列
  await addSyncItem('items', 'create', newItem);

  return newItem;
}

/**
 * 生成指定数量和稀有度的奖励
 * @param count 奖励数量
 * @param rarity 奖励稀有度
 * @returns 生成的奖励列表
 */
export async function generateRewards(count: number, rarity: RewardRarity): Promise<RewardRecord[]> {
  const rewards: RewardRecord[] = [];
  const now = new Date();

  for (let i = 0; i < count; i++) {
    // 随机选择物品类型
    const itemTypes = [
      { type: ItemType.FOOD, weight: 0.4 },
      { type: ItemType.TOY, weight: 0.3 },
      { type: ItemType.DECORATION, weight: 0.1 },
      { type: ItemType.SCROLL, weight: 0.1 },
      { type: ItemType.POTION, weight: 0.1 }
    ];

    // 根据权重随机选择物品类型
    const randomTypeObj = weightedRandom(itemTypes);
    const randomType = randomTypeObj.type;

    // 生成物品
    const reward = generateItemByTypeAndRarity(randomType, rarity);

    rewards.push({
      ...reward,
      obtainedAt: now,
      isNew: true,
      isViewed: false
    });
  }

  // 保存奖励记录
  await saveRewards(rewards);

  return rewards;
}

/**
 * 为挑战生成奖励
 * @param challenge 完成的挑战
 * @returns 生成的奖励列表
 */
export async function generateRewardsForChallenge(challenge: any): Promise<RewardRecord[]> {
  // 根据挑战难度决定奖励稀有度
  let rarity = RewardRarity.COMMON;

  if (challenge.difficulty === 'hard') {
    rarity = RewardRarity.RARE;
  } else if (challenge.difficulty === 'medium') {
    rarity = RewardRarity.UNCOMMON;
  } else if (challenge.difficulty === 'expert') {
    rarity = RewardRarity.EPIC;
  }

  // 生成2-4个奖励
  const count = 2 + Math.floor(Math.random() * 3);

  return generateRewards(count, rarity);
}
</file>

<file path="src/services/taskService.ts">
// src/services/taskService.ts
import { db } from '@/db';
import { addPandaExperience, updatePandaMood } from './pandaStateService';
import { generateRewardsForTask, RewardRecord } from './rewardService';
import { addSyncItem } from './dataSyncService';
import { checkTaskForTimelyReward, TimelyRewardRecord } from './timelyRewardService';

// 任务状态枚举
export enum TaskStatus {
  TODO = 'todo',
  IN_PROGRESS = 'in_progress',
  COMPLETED = 'completed',
  ARCHIVED = 'archived'
}

// 任务优先级枚举
export enum TaskPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high'
}

// 任务类型枚举
export enum TaskType {
  DAILY = 'daily',    // 日常任务
  MAIN = 'main',      // 主线任务
  SIDE = 'side'       // 支线任务
}

// 任务类别枚举
export enum TaskCategory {
  WORK = 'work',
  PERSONAL = 'personal',
  HEALTH = 'health',
  LEARNING = 'learning',
  ERRANDS = 'errands'
}

// 任务记录类型
export interface TaskRecord {
  id?: number;
  title: string;
  description?: string;
  categoryId: number;
  type: TaskType;
  priority: TaskPriority;
  status: TaskStatus;
  dueDate?: Date;
  reminderTime?: Date;
  estimatedMinutes?: number;
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
  repeatPattern?: string; // 例如: "daily", "weekly:1,3,5", "monthly:15"
  tags?: string[];
}

// 任务类别记录类型
export interface TaskCategoryRecord {
  id?: number;
  name: string;
  description?: string;
  color: string;
  icon?: string;
  isDefault: boolean;
  createdAt: Date;
}

// 任务完成记录类型
export interface TaskCompletionRecord {
  id?: number;
  taskId: number;
  completedAt: Date;
  experienceGained: number;
  notes?: string;
}

// 默认任务类别
const DEFAULT_CATEGORIES: Omit<TaskCategoryRecord, 'id'>[] = [
  {
    name: 'Work',
    description: 'Work related tasks',
    color: '#4A6FA5',
    icon: 'briefcase',
    isDefault: true,
    createdAt: new Date()
  },
  {
    name: 'Personal',
    description: 'Personal tasks',
    color: '#6B8F71',
    icon: 'user',
    isDefault: true,
    createdAt: new Date()
  },
  {
    name: 'Health',
    description: 'Health and fitness tasks',
    color: '#D98580',
    icon: 'heart',
    isDefault: true,
    createdAt: new Date()
  },
  {
    name: 'Learning',
    description: 'Learning and education tasks',
    color: '#B4A7D6',
    icon: 'book',
    isDefault: true,
    createdAt: new Date()
  }
];

/**
 * 初始化任务类别
 * 如果没有任务类别，则创建默认类别
 */
export async function initializeTaskCategories(): Promise<void> {
  const count = await db.taskCategories.count();
  if (count === 0) {
    console.log('Initializing default task categories...');
    await db.taskCategories.bulkAdd(DEFAULT_CATEGORIES);
  }
}

/**
 * 获取所有任务类别
 */
export async function getAllTaskCategories(): Promise<TaskCategoryRecord[]> {
  return db.taskCategories.toArray();
}

/**
 * 创建新的任务类别
 */
export async function createTaskCategory(category: Omit<TaskCategoryRecord, 'id' | 'createdAt'>): Promise<number> {
  const newCategory = {
    ...category,
    createdAt: new Date()
  };
  return db.taskCategories.add(newCategory);
}

/**
 * 获取单个任务
 * @param id 任务ID
 */
export async function getTask(id: number): Promise<TaskRecord | undefined> {
  return db.tasks.get(id);
}

/**
 * 获取所有任务
 * @param filter 可选的过滤条件
 */
export async function getAllTasks(filter?: {
  status?: TaskStatus;
  categoryId?: number;
  type?: TaskType;
  priority?: TaskPriority;
}): Promise<TaskRecord[]> {
  let query = db.tasks.toCollection();

  if (filter) {
    if (filter.status) {
      query = query.filter(task => task.status === filter.status);
    }
    if (filter.categoryId) {
      query = query.filter(task => task.categoryId === filter.categoryId);
    }
    if (filter.type) {
      query = query.filter(task => task.type === filter.type);
    }
    if (filter.priority) {
      query = query.filter(task => task.priority === filter.priority);
    }
  }

  return query.toArray();
}

/**
 * 创建新任务
 */
export async function createTask(task: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'>): Promise<number> {
  const now = new Date();
  const newTask = {
    ...task,
    status: TaskStatus.TODO,
    createdAt: now,
    updatedAt: now
  };

  // 添加任务到数据库
  const id = await db.tasks.add(newTask);

  // 添加同步项目
  await addSyncItem('tasks', 'create', { ...newTask, id });

  return id;
}

/**
 * 更新任务
 */
export async function updateTask(id: number, updates: Partial<Omit<TaskRecord, 'id' | 'createdAt'>>): Promise<void> {
  const task = await db.tasks.get(id);
  if (!task) {
    throw new Error(`Task with id ${id} not found`);
  }

  const updatedTask = {
    ...task,
    ...updates,
    updatedAt: new Date()
  };

  // 更新数据库
  await db.tasks.update(id, updatedTask);

  // 添加同步项目
  await addSyncItem('tasks', 'update', updatedTask);
}

/**
 * 完成任务
 * 更新任务状态为已完成，创建完成记录，生成奖励，并增加熊猫经验值
 * @returns 生成的奖励列表和及时奖励（如果有）
 */
export async function completeTask(id: number, notes?: string): Promise<{
  rewards: RewardRecord[];
  timelyReward?: TimelyRewardRecord | null;
}> {
  const task = await db.tasks.get(id);
  if (!task) {
    throw new Error(`Task with id ${id} not found`);
  }

  const now = new Date();

  // 计算获得的经验值（基于任务优先级和类型）
  let experienceGained = 10; // 基础经验值

  // 根据优先级增加经验值
  switch (task.priority) {
    case TaskPriority.HIGH:
      experienceGained += 15;
      break;
    case TaskPriority.MEDIUM:
      experienceGained += 10;
      break;
    case TaskPriority.LOW:
      experienceGained += 5;
      break;
  }

  // 根据任务类型增加经验值
  switch (task.type) {
    case TaskType.MAIN:
      experienceGained += 20;
      break;
    case TaskType.DAILY:
      experienceGained += 5;
      break;
    case TaskType.SIDE:
      experienceGained += 10;
      break;
  }

  // 更新任务状态
  await updateTask(id, {
    status: TaskStatus.COMPLETED,
    completedAt: now
  });

  // 创建完成记录
  await db.taskCompletions.add({
    taskId: id,
    completedAt: now,
    experienceGained,
    notes
  });

  // 增加熊猫经验值
  await addPandaExperience(experienceGained);

  // 更新熊猫心情为开心
  await updatePandaMood('happy');

  // 生成任务奖励
  const rewards = await generateRewardsForTask(task);

  // 检查是否符合及时奖励条件
  const timelyReward = await checkTaskForTimelyReward({
    ...task,
    status: TaskStatus.COMPLETED,
    completedAt: now
  });

  return {
    rewards,
    timelyReward
  };
}

/**
 * 获取任务统计信息
 */
export async function getTaskStats(): Promise<{
  total: number;
  completed: number;
  inProgress: number;
  todo: number;
  byCategory: Record<number, number>;
  byPriority: Record<TaskPriority, number>;
}> {
  const tasks = await db.tasks.toArray();

  const stats = {
    total: tasks.length,
    completed: tasks.filter(t => t.status === TaskStatus.COMPLETED).length,
    inProgress: tasks.filter(t => t.status === TaskStatus.IN_PROGRESS).length,
    todo: tasks.filter(t => t.status === TaskStatus.TODO).length,
    byCategory: {} as Record<number, number>,
    byPriority: {
      [TaskPriority.LOW]: 0,
      [TaskPriority.MEDIUM]: 0,
      [TaskPriority.HIGH]: 0
    }
  };

  // 按类别统计
  tasks.forEach(task => {
    if (!stats.byCategory[task.categoryId]) {
      stats.byCategory[task.categoryId] = 0;
    }
    stats.byCategory[task.categoryId]++;

    // 按优先级统计
    stats.byPriority[task.priority]++;
  });

  return stats;
}

/**
 * 获取任务完成历史
 */
export async function getTaskCompletionHistory(): Promise<TaskCompletionRecord[]> {
  return db.taskCompletions.toArray();
}

/**
 * 获取今日待办任务
 */
export async function getTodayTasks(): Promise<TaskRecord[]> {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);

  return db.tasks
    .where('dueDate')
    .between(today, tomorrow, true, false)
    .and(task => task.status !== TaskStatus.COMPLETED && task.status !== TaskStatus.ARCHIVED)
    .toArray();
}

/**
 * 获取逾期任务
 */
export async function getOverdueTasks(): Promise<TaskRecord[]> {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  return db.tasks
    .where('dueDate')
    .below(today)
    .and(task => task.status !== TaskStatus.COMPLETED && task.status !== TaskStatus.ARCHIVED)
    .toArray();
}

/**
 * 删除任务
 */
export async function deleteTask(id: number): Promise<void> {
  const task = await db.tasks.get(id);
  if (!task) {
    throw new Error(`Task with id ${id} not found`);
  }

  // 从数据库中删除
  await db.tasks.delete(id);

  // 添加同步项目
  await addSyncItem('tasks', 'delete', task);
}

/**
 * 归档任务
 */
export async function archiveTask(id: number): Promise<void> {
  await updateTask(id, { status: TaskStatus.ARCHIVED });
}
</file>

<file path="development-tasks-updated.md">
# PandaHabit 开发任务文档：华丽游戏风格实现

## 1. 项目设置

### 1.1 环境配置
- [x] 设置开发环境（使用Vite）
- [ ] 设置测试和生产环境
- [ ] 为不同部署阶段配置环境变量
- [ ] 设置CI/CD管道，用于自动测试和部署
- [x] 配置代码检查和格式化工具（ESLint已配置）
- [x] 设置华丽游戏风格的设计系统和组件库（已实现基本主题和移动应用布局）

### 1.2 依赖管理
- [x] 安装和配置所需依赖：
  - [x] React和React DOM
  - [x] TypeScript
  - [x] React Router用于导航
  - [x] Dexie.js用于本地数据库
  - [x] React Query用于数据获取
  - [ ] 动画库（Framer Motion或React Spring）用于华丽动效
  - [🔄] 中文字体库（已添加Google Fonts，但需要添加更多中文字体）
  - [ ] 粒子效果库（用于华丽特效）
- [x] 使用npm设置包管理
- [ ] 为生产构建配置依赖优化
- [ ] 集成中国风素材库和图标系统

### 1.3 项目结构组织
- [x] 按照现有架构模式组织项目
- [ ] 为游戏特定组件创建专用目录
- [x] 设置资产管理结构，用于图像、动画和声音（已创建public/assets目录和SVG资源）
- [x] 建立样式组织（使用CSS文件）
- [x] 配置TypeScript路径以实现清晰导入（已配置@路径别名）
- [x] 创建华丽游戏风格的主题文件和变量（已完善game-theme.css，添加了中国风元素）

## 2. 核心基础设施开发

### 2.1 数据库架构实现
- [✅] 扩展现有Dexie.js架构，包括：
  - [x] 基本UI标签数据（已实现UILabelRecord）
  - [x] 用户配置文件和进度数据（已实现PandaStateRecord）
  - [x] 熊猫状态和定制数据（已实现PandaStateRecord和PandaAbilityRecord）
  - [x] 任务和挑战数据（已实现TaskRecord和TaskCompletionRecord）
  - [x] 资源和库存数据（已实现RewardRecord和ItemRecord）
  - [x] 成就和里程碑数据（已实现BadgeRecord）
- [x] 实现基本数据填充策略（已实现populateDB函数）
- [x] 实现数据迁移策略以进行更新（已实现数据库版本升级）
- [x] 创建数据验证实用程序（已实现各种服务中的验证逻辑）
- [x] 设置数据备份和同步机制（已实现dataSyncService）

### 2.2 API端点实现
- [✅] 实现模拟API服务：
  - [x] 创建基本服务层结构（已实现localizedContentService）
  - [🔄] 用户认证和配置文件管理
  - [x] 熊猫状态和互动（已实现pandaStateService）
  - [x] 任务管理和完成（已实现taskService）
  - [x] 挑战跟踪和奖励（已实现rewardService）
  - [x] 及时奖励和幸运抽奖（已实现rewardService中的随机奖励生成）
  - [x] 熊猫能力系统（已实现pandaAbilityService）
- [x] 创建具有基本错误处理的API服务层
- [x] 实现基本请求缓存（通过React Query）
- [x] 为开发和测试设置模拟API（使用Dexie.js）
- [x] 实现数据同步机制（已实现dataSyncService）

### 2.3 认证系统
- [ ] 实现用户注册和登录流程
- [ ] 设置安全的基于令牌的认证
- [ ] 创建账户管理功能
- [ ] 实现社交登录选项（如需要）
- [ ] 设置密码恢复机制
- [ ] 配置隐私和数据保护功能

### 2.4 国际化系统
- [x] 实现基本i18n系统（已实现LanguageProvider）
- [🔄] 扩展现有i18n系统以支持游戏特定内容
- [x] 为基本支持的语言创建翻译文件（英文和中文）
- [x] 实现基于语言选择的动态内容加载（通过useLocalizedView钩子）
- [ ] 设置更完善的翻译管理工作流程
- [ ] 确保正确处理RTL语言（如支持）
- [ ] 为日期、数字和货币实现特定于语言的格式化
- [ ] 确保华丽游戏风格元素在所有语言中保持一致

## 3. UI组件开发

### 3.1 通用组件
- [x] 设计并实现华丽版本的：
  - [x] 按钮（已实现基本按钮和游戏风格的jade-button、gold-button）
  - [ ] 输入字段和表单元素，添加水墨动效和传统纹饰
  - [x] 卡片和容器（已实现bamboo-frame样式）
  - [x] 模态框和对话框组件，设计为古代卷轴或窗棂样式
  - [x] 加载器和进度指示器（已实现jade-spinner和bamboo-progress）
  - [ ] 工具提示和弹出框，添加云纹装饰和优雅过渡
- [ ] 创建全面的组件库，并附带文档
- [x] 为所有组件实现响应式行为（已针对移动设备优化）
- [x] 添加动画和过渡效果（已使用Framer Motion实现）
- [x] 实现中国风特效系统（已实现水墨、金光、竹叶等特效）

### 3.2 布局组件
- [x] 实现基本AppShell组件
- [x] 使用华丽风格增强AppShell（已添加中国风装饰元素）
- [x] 创建基本Header组件
- [x] 增强Header组件（已针对移动应用优化，移除了顶部标题）
- [x] 设计Navigation组件（已实现移动应用风格的底部导航栏）
- [x] 开发基本页面布局模板
- [x] 实现针对不同屏幕尺寸的响应式布局调整（已针对移动设备优化）
- [x] 创建布局状态之间的过渡效果（已使用Framer Motion实现页面过渡）
- [x] 添加中国风背景和装饰元素（已添加中国风边框和装饰）

### 3.3 特定功能组件
- [x] 开发PandaAvatar组件，具有不同状态和动画（已实现基本熊猫头像组件）
- [x] 创建TaskCard组件（已实现带动画效果的任务卡片）
- [✅] 实现ChallengeCard组件，具有进度跟踪（已实现挑战卡片和列表组件）
- [ ] 设计各种资源类型的ResourceDisplay组件
- [ ] 开发不同奖励场景的RewardAnimation组件
- [ ] 创建具有引人入胜动画的LuckyDraw组件
- [ ] 实现具有支持性UI的ReflectionModule组件
- [x] 为所有组件添加华丽的中国风视觉元素和动效（已添加水墨、金光等特效）

## 4. 功能实现

### 4.1 熊猫伙伴系统
- [x] 实现熊猫状态管理（情绪、成长、能量）（已实现PandaStateProvider）
- [x] 创建熊猫互动机制（喂食、玩耍、训练）（已实现基本互动功能）
- [x] 开发熊猫定制系统，包括传统中国风装饰元素（已实现PandaCustomizationPanel组件和装饰系统）
- [x] 实现熊猫成长和进化逻辑（已实现基本经验和等级系统）
- [x] 创建熊猫能力解锁系统（已实现能力解锁和激活功能）
- [x] 开发熊猫动画控制器，用于不同状态和动作（已实现基本状态动画）
- [x] 实现环境定制和互动，融入中国园林元素（已实现PandaEnvironmentPanel组件和环境系统）

### 4.2 任务管理系统
- [x] 实现任务创建和编辑功能（已实现TaskForm组件）
- [x] 创建任务分类（日常、主线、支线）（已实现TaskType枚举和类别系统）
- [x] 开发任务调度和重复逻辑（已实现基本任务管理）
- [x] 实现任务完成和验证（已实现completeTask功能）
- [✅] 创建任务提醒系统，使用熊猫信使主题（已实现TaskReminderService和相关组件）
- [✅] 开发复杂目标的任务分解（已实现SubtaskService和子任务管理）
- [x] 实现任务过滤和排序（已实现基本过滤功能）
- [x] 添加华丽的任务完成动画和特效（已实现任务完成奖励系统）

### 4.3 挑战系统
- [✅] 创建挑战定义和管理（已实现挑战数据模型和服务）
- [✅] 实现挑战类型（日常、每周、活动、持续）（已实现ChallengeType枚举）
- [✅] 开发挑战生命周期和进度跟踪（已实现挑战状态和进度管理）
- [✅] 创建与日常任务的子任务集成（已实现SubtaskList组件和TaskDetailDialog）
- [✅] 实现挑战奖励和完成逻辑（已实现completeChallenge功能）
- [✅] 开发挑战发现和推荐系统（已实现ChallengeDiscoveryService和相关组件）
- [✅] 创建合作社交挑战（已实现SocialChallengeService和相关组件）
- [✅] 设计华丽的挑战地图和进度可视化（已实现挑战卡片和过滤界面）

### 4.4 及时奖励系统
- [✅] 实现符合条件任务的时间窗口跟踪（已实现timelyRewardService）
- [✅] 创建及时性进度条系统，设计为华丽卷轴（已实现TimelyRewardCard组件）
- [✅] 开发幸运点累积和管理（已实现LuckyPointsDisplay组件）
- [✅] 实现带有奖品层级的幸运抽奖机制（已实现LuckyDraw组件）
- [✅] 创建奖励分配和库存管理（已实现奖励生成和分发逻辑）
- [✅] 开发及时完成的视觉反馈（已实现及时奖励模态框）
- [✅] 实现"早起鸟"奖励机制（已实现早起鸟奖励类型）
- [✅] 添加华丽的抽奖动画和奖励展示效果（已实现抽奖动画和特效）

### 4.5 反思模块
- [✅] 创建反思机会的触发检测（已实现ReflectionTriggerType和触发检测机制）
- [✅] 实现温和、非判断性的对话系统（已实现EnhancedReflectionModule组件）
- [✅] 开发用户输入收集和处理（已实现反思输入和标签系统）
- [✅] 创建支持性反馈生成（已实现基于反思内容的支持性反馈）
- [✅] 实现可行建议系统（已实现基于反思内容和标签的建议行动）
- [✅] 开发情绪跟踪和模式识别（已实现MoodTracker组件和情绪记录）
- [✅] 创建自我同情强化机制（已实现温和语言和支持性反馈）
- [✅] 设计静心茶室环境和相关视觉效果（已实现TeaRoomPage页面）

### 4.6 商店和货币化
- [✅] 实现带有物品类别的商店界面（已实现StorePage和StoreCategoryList组件）
- [✅] 创建物品预览和购买流程（已实现StoreItemCard和StoreItemPreview组件）
- [✅] 开发VIP订阅管理（已实现VipSubscriptionCard组件和相关服务）
- [✅] 实现应用内购买集成（已实现基本购买流程）
- [✅] 创建VIP福利激活和跟踪（已实现VIP订阅和福利系统）
- [✅] 开发促销功能（已实现销售和限时物品功能）
- [✅] 实现收据验证和购买恢复（已实现基本购买记录系统）
- [✅] 设计华丽的商店环境和购买动画（已实现动画效果和视觉设计）

### 4.7 图片素材
生成csv管理所有页面的spirate、icon、图片、模型等素材，包含页面名称、素材文件名称，路径，大小，生成素材图片/icon等的提示词。

## 5. 集成和测试

### 5.1 组件集成
- [✅] 将UI组件与数据服务集成（已实现DataLoader组件和数据同步服务）
- [✅] 连接功能系统以创建连贯的游戏循环（已连接任务系统、奖励系统和熊猫伙伴系统）
- [✅] 实现功能之间的状态同步（已实现dataSyncService和状态同步机制）
- [✅] 实现数据同步后的局部UI更新（已实现useDataRefresh Hook和事件驱动的UI更新）
- [x] 创建不同应用部分之间的流畅过渡（已使用Framer Motion实现页面过渡）
- [✅] 开发错误处理和恢复机制（已实现错误处理和同步恢复机制）
- [x] 实现加载状态和占位符（已实现LoadingSpinner组件）
- [x] 确保华丽视觉风格在所有集成点保持一致（已实现统一的游戏风格）

### 5.2 端到端测试
- [ ] 为关键用户旅程创建全面的测试套件
- [ ] 实现核心功能的自动化测试
- [ ] 开发UI组件的视觉回归测试
- [ ] 创建性能基准和测试
- [ ] 实现跨浏览器和跨设备测试
- [ ] 开发可访问性测试程序
- [ ] 测试华丽动画和特效的性能影响

### 5.3 性能优化
- [x] 实现代码分割和延迟加载（已通过React.lazy实现）
- [✅] 优化资产加载和缓存（已优化SVG资源和实现数据缓存）
- [x] 实现高效渲染策略（已使用Framer Motion的性能优化特性）
- [ ] 创建性能监控工具
- [✅] 优化数据库查询和数据管理（已实现高效的数据库查询和同步机制）
- [✅] 实现内存管理最佳实践（已实现数据缓存和内存管理）
- [x] 优化华丽视觉效果和动画的性能（已使用Framer Motion的性能优化特性）

### 5.4 用户验收测试
- [ ] 创建beta测试计划
- [ ] 开发反馈收集机制
- [ ] 实现用户行为跟踪分析
- [ ] 创建功能优化的A/B测试框架
- [ ] 开发用户满意度测量
- [ ] 实现基于反馈的迭代改进过程
- [ ] 收集华丽游戏风格的用户体验反馈

## 6. 部署和维护

### 6.1 部署策略
- [x] 为生产创建构建优化（已实现Vite构建配置）
- [ ] 实现渐进式推出策略
- [ ] 开发功能标记，用于受控发布
- [ ] 创建关键问题的回滚机制
- [ ] 实现监控和警报系统
- [ ] 开发自动部署验证
- [x] 确保华丽视觉资产的高效交付（已优化SVG资源和动画性能）

### 6.2 监控和分析
- [ ] 实现错误跟踪和报告
- [ ] 创建性能监控仪表板
- [ ] 开发用户参与度分析
- [ ] 实现转化和留存跟踪
- [ ] 创建功能使用分析
- [ ] 开发货币化性能指标
- [ ] 监控华丽游戏元素的用户互动数据

### 6.3 更新计划
- [ ] 创建内容更新管道
- [ ] 实现季节性活动框架
- [ ] 开发功能扩展路线图
- [ ] 创建更新的用户沟通渠道
- [ ] 实现基于反馈的优先级排序
- [ ] 开发长期可持续性规划
- [ ] 规划华丽游戏风格的季节性更新和主题活动

## 7. 技术债务和文档

### 7.1 代码质量和维护
- [x] 实现代码文档（已为所有组件添加详细注释）
- [ ] 创建架构决策记录
- [x] 开发编码标准和最佳实践（已配置ESLint规则和TypeScript类型检查）
- [ ] 实现定期代码审查流程
- [ ] 创建技术债务跟踪和解决计划
- [ ] 开发知识共享机制
- [🔄] 建立华丽游戏风格实现的设计规范（已创建基本设计规范）

### 7.2 用户文档
- [ ] 创建应用内教程和帮助系统
- [ ] 开发用户指南和常见问题解答
- [ ] 实现上下文帮助和工具提示
- [ ] 创建入职材料
- [ ] 开发故障排除指南
- [ ] 实现反馈和支持渠道
- [ ] 提供华丽游戏风格元素的解释和背景故事

### 7.3 开发者文档
- [x] 创建项目文档（已实现详细的README和任务进度文档）
- [🔄] 创建全面的API文档（已为主要服务添加文档）
- [🔄] 开发组件库文档（已为主要组件添加文档）
- [✅] 实现系统架构文档（已创建数据同步与局部刷新架构文档）
- [x] 创建开发环境设置指南（已在README中提供）
- [ ] 开发贡献指南
- [ ] 实现版本控制和分支策略文档
- [🔄] 提供华丽游戏风格设计系统的详细说明（已在game-theme.css中提供基本说明）

## 8. 未来考虑

### 8.1 高级功能
- [ ] 规划高级熊猫互动和迷你游戏
- [ ] 开发复杂的习惯分析和见解
- [ ] 创建更深入的社交功能和责任小组
- [ ] 规划可穿戴设备集成
- [ ] 开发扩展的引导练习
- [ ] 创建主题季节性活动框架
- [ ] 设计更多华丽的游戏化元素和互动体验

### 8.2 平台扩展
- [ ] 规划网页版开发
- [ ] 考虑桌面应用可能性
- [ ] 评估智能手表伴侣应用
- [ ] 研究语音助手集成
- [ ] 考虑用于熊猫互动的AR/VR体验
- [ ] 评估跨平台同步
- [ ] 探索中国特色平台的集成（如微信小程序）

### 8.3 业务发展
- [ ] 创建合作伙伴关系和协作框架
- [ ] 开发内容创建者计划
- [ ] 规划本地化到其他市场
- [ ] 研究企业/组织版本
- [ ] 开发品牌扩展机会
- [ ] 创建长期可持续性模型
- [ ] 探索与中国传统文化品牌的合作机会

## 9. 进度总结

### 9.1 已完成项目（✓）
- 基本项目设置（Vite、React、TypeScript）
- 基本依赖安装（React Router、Dexie.js、React Query）
- 基本项目结构组织
- 基本国际化系统实现
- 基本数据库结构和填充策略
- 华丽游戏风格的UI组件（按钮、加载器、卡片等）
- 基本路由系统
- 移动应用布局优化（底部导航、响应式设计）
- 中国风视觉元素集成（装饰、边框、SVG资源）
- 游戏风格的主题系统（颜色、字体、间距等）
- 熊猫伙伴系统的基本功能（PandaAvatar组件、状态管理、互动机制）
- 任务管理系统的核心功能（任务创建、编辑、完成、分类、过滤）
- 动画系统集成（Framer Motion）
- 中国风特效组件（水墨、金光、竹叶等）
- 页面过渡动画
- 数据服务与UI组件的集成（DataLoader组件、数据同步服务）
- 熊猫能力解锁系统（能力定义、解锁和激活功能）
- 任务完成奖励系统（奖励生成和展示）
- 数据同步后的局部UI更新（useDataRefresh Hook和事件驱动的UI更新）
- 挑战系统的基本功能（挑战定义、过滤、完成和奖励）
- 及时奖励系统（时间窗口内完成任务获得额外奖励）
- 幸运点和幸运抽奖系统（累积幸运点进行抽奖）
- 反思模块系统（情绪追踪、反思触发、支持性反馈、静心茶室）
- 社交挑战系统（合作挑战、挑战发现和推荐）
- 子任务系统（任务分解、子任务管理）
- 任务提醒系统（熊猫信使主题、自动检测和提醒）
- 商店和货币化系统（商店界面、物品购买、VIP订阅）

### 9.2 进行中项目（🔄）
- 用户认证和配置文件管理

### 9.3 下一步优先事项
1. ✅ 实现熊猫伙伴系统的基本功能（PandaAvatar组件）
2. ✅ 开发任务管理系统的核心功能（TaskManager组件）
3. ✅ 添加动画库（Framer Motion）
4. ✅ 实现中国风特效系统（水墨、金光、竹叶等）
5. ✅ 开发模态框和对话框组件（古代卷轴或窗棂样式）
6. ✅ 实现任务完成奖励系统
7. ✅ 开发熊猫能力解锁系统
8. ✅ 添加更多中文字体和视觉资源
9. ✅ 实现数据同步后的局部UI更新（useDataRefresh Hook）
10. ✅ 开发挑战系统的基本功能（挑战定义、过滤、完成和奖励）
11. ✅ 实现及时奖励系统（已实现及时奖励和幸运抽奖功能）
12. ✅ 开发反思模块（已实现反思触发、情绪追踪和静心茶室）
13. ✅ 完善任务管理系统（已实现任务提醒和任务分解功能）
14. ✅ 开发商店和货币化系统（已实现商店界面、物品购买和VIP订阅）
15. [ ] 开发认证系统（用户注册、登录和账户管理）
</file>

<file path="package.json">
{
  "name": "minimal-dexie-i18n-v3-final",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.32.0",
    "@types/node": "^22.15.17",
    "dexie": "^3.2.7",
    "framer-motion": "^12.11.0",
    "react": "^18.2.0",
    "react-beautiful-dnd": "^13.1.1",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.23.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@types/react-router-dom": "^5.3.3",
    "@typescript-eslint/eslint-plugin": "^7.2.0",
    "@typescript-eslint/parser": "^7.2.0",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "typescript": "^5.2.2",
    "vite": "^5.2.0"
  }
}
</file>

<file path="src/components/layout/Navigation.tsx">
// src/components/layout/Navigation.tsx
import React from 'react';
import { NavLink } from 'react-router-dom';
import type { GlobalLayoutLabelsBundle } from '@/types';

interface NavigationProps {
  labels: GlobalLayoutLabelsBundle | undefined;
  variant?: 'default' | 'bamboo';
}

/**
 * Navigation component with support for game-themed style
 *
 * @param labels - Text labels for navigation items
 * @param variant - 'default' or 'bamboo' (game-themed)
 */
const Navigation: React.FC<NavigationProps> = ({
  labels,
  variant = 'bamboo' // Default to bamboo style for game theme
}) => {
  // Provide fallbacks for label properties
  const navHomeText = labels?.navHome || "Home";
  const navTasksText = labels?.navTasks || "Tasks";
  const navAbilitiesText = labels?.navAbilities || "Abilities";
  const navChallengesText = labels?.navChallenges || "Challenges";
  const navRewardsText = labels?.navRewards || "Rewards";
  const navTeaRoomText = labels?.navTeaRoom || "Tea Room";
  const navStoreText = labels?.navStore || "Store";
  const navSettingsText = labels?.navSettings || "Settings";

  if (!labels) { // Can show a minimal loading state or just render with fallbacks
    return <nav className={variant === 'bamboo' ? 'bamboo-nav' : ''}>Loading navigation...</nav>;
  }

  const navClass = variant === 'bamboo' ? 'bamboo-nav' : '';

  return (
    <nav className={navClass}>
      <NavLink
        to="/"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navHomeText}
      </NavLink>
      <NavLink
        to="/tasks"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navTasksText}
      </NavLink>
      <NavLink
        to="/abilities"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navAbilitiesText}
      </NavLink>
      <NavLink
        to="/challenges"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navChallengesText}
      </NavLink>
      <NavLink
        to="/rewards"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navRewardsText}
      </NavLink>
      <NavLink
        to="/tearoom"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navTeaRoomText}
      </NavLink>
      <NavLink
        to="/store"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navStoreText}
      </NavLink>
      <NavLink
        to="/settings"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navSettingsText}
      </NavLink>
    </nav>
  );
};

export default Navigation;
</file>

<file path="src/db.ts">
// src/db.ts
import Dexie, { Table } from 'dexie';
import type { UILabelRecord } from '@/types';
import type { PandaStateRecord } from '@/services/pandaStateService';
import type {
  TaskRecord,
  TaskCategoryRecord,
  TaskCompletionRecord
} from '@/services/taskService';
import type { RewardRecord, ItemRecord, BadgeRecord, AbilityRecord as RewardAbilityRecord } from '@/services/rewardService';
import type { PandaAbilityRecord } from '@/services/pandaAbilityService';
import type { SyncItem } from '@/services/dataSyncService';
import type { ChallengeRecord, ChallengeCompletionRecord } from '@/services/challengeService';
import type { TimelyRewardRecord, LuckyPointRecord, LuckyDrawRecord } from '@/services/timelyRewardService';
import type { SubtaskRecord } from '@/services/subtaskService';
import type { ChallengeDiscovery } from '@/services/challengeDiscoveryService';
import type { SocialChallengeRecord, SocialChallengeParticipation, SocialChallengeMilestone } from '@/services/socialChallengeService';
import type { ReflectionRecord, ReflectionTriggerRecord, MoodRecord } from '@/services/reflectionService';
import type { TaskReminderRecord } from '@/services/taskReminderService';
import type { StoreItemRecord, StoreCategoryRecord, PurchaseRecord, VipSubscriptionRecord, UserCurrencyRecord } from '@/services/storeService';
import type { PandaAccessoryRecord, PandaEnvironmentRecord } from '@/services/pandaCustomizationService';

export class AppDB extends Dexie {
  uiLabels!: Table<UILabelRecord, number>;
  pandaState!: Table<PandaStateRecord, number>;
  tasks!: Table<TaskRecord, number>;
  taskCategories!: Table<TaskCategoryRecord, number>;
  taskCompletions!: Table<TaskCompletionRecord, number>;
  subtasks!: Table<SubtaskRecord, number>;
  taskReminders!: Table<TaskReminderRecord, number>;
  rewards!: Table<RewardRecord, number>;
  items!: Table<ItemRecord, number>;
  badges!: Table<BadgeRecord, number>;
  abilities!: Table<PandaAbilityRecord, number>;
  rewardAbilities!: Table<RewardAbilityRecord, number>;
  pandaAccessories!: Table<PandaAccessoryRecord, number>;
  pandaEnvironments!: Table<PandaEnvironmentRecord, number>;
  syncQueue!: Table<SyncItem, string>;
  challenges!: Table<ChallengeRecord, number>;
  challengeCategories!: Table<any, number>;
  challengeCompletions!: Table<ChallengeCompletionRecord, number>;
  challengeDiscoveries!: Table<ChallengeDiscovery, number>;
  socialChallenges!: Table<SocialChallengeRecord, number>;
  socialChallengeParticipations!: Table<SocialChallengeParticipation, number>;
  socialChallengeMilestones!: Table<SocialChallengeMilestone, number>;
  reflections!: Table<ReflectionRecord, number>;
  reflectionTriggers!: Table<ReflectionTriggerRecord, number>;
  moods!: Table<MoodRecord, number>;
  storeItems!: Table<StoreItemRecord, number>;
  storeCategories!: Table<StoreCategoryRecord, number>;
  purchases!: Table<PurchaseRecord, number>;
  vipSubscriptions!: Table<VipSubscriptionRecord, number>;
  userCurrencies!: Table<UserCurrencyRecord, number>;
  timelyRewards!: Table<TimelyRewardRecord, number>;
  luckyPoints!: Table<LuckyPointRecord, number>;
  luckyDraws!: Table<LuckyDrawRecord, number>;

  constructor() {
    super('PandaHabitDB_V13'); // 更新数据库版本
    this.version(13).stores({
      uiLabels: '++id, scopeKey, labelKey, languageCode, &[scopeKey+labelKey+languageCode]',
      pandaState: '++id, mood, energy, lastUpdated, level',
      tasks: '++id, title, categoryId, priority, status, dueDate, createdAt',
      taskCategories: '++id, name, color, icon, isDefault',
      taskCompletions: '++id, taskId, completedAt, experienceGained',
      subtasks: '++id, parentTaskId, title, status, order, createdAt',
      taskReminders: '++id, taskId, userId, reminderTime, isViewed, isCompleted, createdAt',
      rewards: '++id, type, rarity, taskId, obtainedAt, isViewed',
      items: '++id, type, rarity, quantity, obtainedAt',
      badges: '++id, rarity, obtainedAt, isEquipped',
      abilities: '++id, name, type, effectType, requiredLevel, isUnlocked, isActive',
      rewardAbilities: '++id, rarity, obtainedAt, isUnlocked, isActive',
      pandaAccessories: '++id, name, type, isEquipped, isOwned, obtainedAt, rarity, themeType',
      pandaEnvironments: '++id, name, isActive, isOwned, obtainedAt, rarity, themeType',
      syncQueue: 'id, table, action, timestamp, status',
      challenges: '++id, title, type, difficulty, status, progress, startDate, endDate, createdAt',
      challengeCategories: '++id, name, description, iconPath',
      challengeCompletions: '++id, challengeId, userId, completedDate, createdAt',
      challengeDiscoveries: '++id, userId, challengeId, discoveredAt, isViewed, isAccepted, expiresAt',
      socialChallenges: '++id, title, type, difficulty, status, creatorId, isPublic, inviteCode, createdAt',
      socialChallengeParticipations: '++id, challengeId, userId, joinedAt, status, contribution',
      socialChallengeMilestones: '++id, challengeId, title, targetValue, currentValue, isCompleted, order',
      reflections: '++id, userId, taskId, mood, reflection, action, createdAt, isCompleted',
      reflectionTriggers: '++id, userId, type, createdAt, isViewed, isCompleted',
      moods: '++id, userId, mood, intensity, createdAt',
      storeItems: '++id, name, type, rarity, price, priceType, isAvailable, isFeatured, isOnSale, categoryId, createdAt',
      storeCategories: '++id, name, order, isVisible, createdAt',
      purchases: '++id, userId, storeItemId, price, priceType, purchaseDate, isRefunded',
      vipSubscriptions: '++id, userId, tier, startDate, endDate, isActive, createdAt',
      userCurrencies: '++id, userId, coins, jade, lastUpdated',
      timelyRewards: '++id, title, type, status, startTime, endTime, createdAt',
      luckyPoints: '++id, userId, amount, isSpent, expiryDate, createdAt',
      luckyDraws: '++id, userId, pointsSpent, timestamp, createdAt'
    });
  }
}
export const db = new AppDB();

let hasAttemptedPopulation = false;

export async function populateDB() {
  if (hasAttemptedPopulation) return;
  hasAttemptedPopulation = true;

  const count = await db.uiLabels.count();
  if (count > 0) { /* console.log("DB V3 already populated."); */ return; }
  console.log("Populating Final V3 Dexie DB...");

  const labels: UILabelRecord[] = [
    // GlobalLayout scope
    { scopeKey: 'globalLayout', labelKey: 'appTitle', languageCode: 'en', translatedText: 'App V3 - Consistent' },
    { scopeKey: 'globalLayout', labelKey: 'appTitle', languageCode: 'zh', translatedText: '应用 V3 - 一致性' },
    { scopeKey: 'globalLayout', labelKey: 'navHome', languageCode: 'en', translatedText: 'Home' },
    { scopeKey: 'globalLayout', labelKey: 'navHome', languageCode: 'zh', translatedText: '主页' },
    { scopeKey: 'globalLayout', labelKey: 'navTasks', languageCode: 'en', translatedText: 'Tasks' },
    { scopeKey: 'globalLayout', labelKey: 'navTasks', languageCode: 'zh', translatedText: '任务' },
    { scopeKey: 'globalLayout', labelKey: 'navSettings', languageCode: 'en', translatedText: 'Settings' },
    { scopeKey: 'globalLayout', labelKey: 'navSettings', languageCode: 'zh', translatedText: '设定' },
    { scopeKey: 'globalLayout', labelKey: 'footerText', languageCode: 'en', translatedText: '© 2024 Final Demo App' },
    { scopeKey: 'globalLayout', labelKey: 'footerText', languageCode: 'zh', translatedText: '© 2024 最终演示应用' },
    { scopeKey: 'globalLayout', labelKey: 'loadingGeneric', languageCode: 'en', translatedText: 'Loading, one moment...' },
    { scopeKey: 'globalLayout', labelKey: 'loadingGeneric', languageCode: 'zh', translatedText: '加载中，请稍候...' },
    { scopeKey: 'globalLayout', labelKey: 'errorGeneric', languageCode: 'en', translatedText: 'An unexpected error occurred.' },
    { scopeKey: 'globalLayout', labelKey: 'errorGeneric', languageCode: 'zh', translatedText: '发生了一个意外错误。' },

    // homeView scope
    { scopeKey: 'homeView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'My Dashboard' },
    { scopeKey: 'homeView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '我的仪表板' },
    { scopeKey: 'homeView.welcomeSection', labelKey: 'welcomeMessage', languageCode: 'en', translatedText: 'Greetings, {user}! Have a productive day.' },
    { scopeKey: 'homeView.welcomeSection', labelKey: 'welcomeMessage', languageCode: 'zh', translatedText: '你好 {user}，祝你拥有高效的一天！' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Recent Mood Entries' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: '近期心情记录' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'noMoodsMessage', languageCode: 'en', translatedText: 'No moods logged. Why not add one?' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'noMoodsMessage', languageCode: 'zh', translatedText: '暂无心情记录。要不要添加一条？' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'refreshButtonText', languageCode: 'en', translatedText: 'Refresh Moods' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'refreshButtonText', languageCode: 'zh', translatedText: '刷新心情' },

    // 熊猫区域标签
    { scopeKey: 'homeView.pandaSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Panda Companion' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: '熊猫伙伴' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'levelLabel', languageCode: 'en', translatedText: 'Level' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'levelLabel', languageCode: 'zh', translatedText: '等级' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'experienceLabel', languageCode: 'en', translatedText: 'Experience' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'experienceLabel', languageCode: 'zh', translatedText: '经验' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'interactButtonText', languageCode: 'en', translatedText: 'Interact' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'interactButtonText', languageCode: 'zh', translatedText: '互动' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'feedButtonText', languageCode: 'en', translatedText: 'Feed' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'feedButtonText', languageCode: 'zh', translatedText: '喂食' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'playButtonText', languageCode: 'en', translatedText: 'Play' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'playButtonText', languageCode: 'zh', translatedText: '玩耍' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'trainButtonText', languageCode: 'en', translatedText: 'Train' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'trainButtonText', languageCode: 'zh', translatedText: '训练' },

    { scopeKey: 'homeView', labelKey: 'someActionText', languageCode: 'en', translatedText: 'Perform Action' },
    { scopeKey: 'homeView', labelKey: 'someActionText', languageCode: 'zh', translatedText: '执行操作' },

    // settingsView scope
    { scopeKey: 'settingsView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Configuration Panel' },
    { scopeKey: 'settingsView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '配置面板' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Display Language' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: '显示语言' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'selectLanguagePrompt', languageCode: 'en', translatedText: 'Select your preferred language:' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'selectLanguagePrompt', languageCode: 'zh', translatedText: '请选择您的偏好语言：' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'currentLanguageIs', languageCode: 'en', translatedText: 'Currently using: {lang}' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'currentLanguageIs', languageCode: 'zh', translatedText: '当前使用：{lang}' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameEn', languageCode: 'en', translatedText: 'English (US)' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameEn', languageCode: 'zh', translatedText: '美式英语' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameZh', languageCode: 'en', translatedText: 'Chinese (Simplified)' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameZh', languageCode: 'zh', translatedText: '简体中文' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'saveButtonText', languageCode: 'en', translatedText: 'Save Preferences' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'saveButtonText', languageCode: 'zh', translatedText: '保存偏好' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'successMessage', languageCode: 'en', translatedText: 'Preferences have been updated!' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'successMessage', languageCode: 'zh', translatedText: '偏好设置已更新！' },

    // tasksView scope
    { scopeKey: 'tasksView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Task Management' },
    { scopeKey: 'tasksView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '任务管理' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'My Tasks' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: '我的任务' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'createTaskButton', languageCode: 'en', translatedText: 'Create New Task' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'createTaskButton', languageCode: 'zh', translatedText: '创建新任务' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterAllLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterAllLabel', languageCode: 'zh', translatedText: '全部' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterTodoLabel', languageCode: 'en', translatedText: 'To Do' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterTodoLabel', languageCode: 'zh', translatedText: '待办' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterInProgressLabel', languageCode: 'en', translatedText: 'In Progress' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterInProgressLabel', languageCode: 'zh', translatedText: '进行中' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterCompletedLabel', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterCompletedLabel', languageCode: 'zh', translatedText: '已完成' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'noTasksMessage', languageCode: 'en', translatedText: 'No tasks found' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'noTasksMessage', languageCode: 'zh', translatedText: '暂无任务' },

    // challengesView scope
    { scopeKey: 'challengesView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Challenges' },
    { scopeKey: 'challengesView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '挑战' },
    { scopeKey: 'challengesView', labelKey: 'statusFilterLabel', languageCode: 'en', translatedText: 'Status' },
    { scopeKey: 'challengesView', labelKey: 'statusFilterLabel', languageCode: 'zh', translatedText: '状态' },
    { scopeKey: 'challengesView', labelKey: 'typeFilterLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'challengesView', labelKey: 'typeFilterLabel', languageCode: 'zh', translatedText: '类型' },
    { scopeKey: 'challengesView', labelKey: 'difficultyFilterLabel', languageCode: 'en', translatedText: 'Difficulty' },
    { scopeKey: 'challengesView', labelKey: 'difficultyFilterLabel', languageCode: 'zh', translatedText: '难度' },
    { scopeKey: 'challengesView', labelKey: 'filterAllLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'challengesView', labelKey: 'filterAllLabel', languageCode: 'zh', translatedText: '全部' },
    { scopeKey: 'challengesView', labelKey: 'filterActiveLabel', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'challengesView', labelKey: 'filterActiveLabel', languageCode: 'zh', translatedText: '进行中' },
    { scopeKey: 'challengesView', labelKey: 'filterCompletedLabel', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'challengesView', labelKey: 'filterCompletedLabel', languageCode: 'zh', translatedText: '已完成' },
    { scopeKey: 'challengesView', labelKey: 'filterUpcomingLabel', languageCode: 'en', translatedText: 'Upcoming' },
    { scopeKey: 'challengesView', labelKey: 'filterUpcomingLabel', languageCode: 'zh', translatedText: '即将开始' },
    { scopeKey: 'challengesView', labelKey: 'clearFiltersButton', languageCode: 'en', translatedText: 'Clear All Filters' },
    { scopeKey: 'challengesView', labelKey: 'clearFiltersButton', languageCode: 'zh', translatedText: '清除所有过滤器' },
    { scopeKey: 'challengesView', labelKey: 'noChallengesMessage', languageCode: 'en', translatedText: 'No challenges found' },
    { scopeKey: 'challengesView', labelKey: 'noChallengesMessage', languageCode: 'zh', translatedText: '暂无挑战' },

    // 挑战页面过滤器标签 - 类型
    { scopeKey: 'challengesView.filters', labelKey: 'typeAllLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeAllLabel', languageCode: 'zh', translatedText: '全部' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeDailyLabel', languageCode: 'en', translatedText: 'Daily' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeDailyLabel', languageCode: 'zh', translatedText: '每日' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeWeeklyLabel', languageCode: 'en', translatedText: 'Weekly' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeWeeklyLabel', languageCode: 'zh', translatedText: '每周' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeEventLabel', languageCode: 'en', translatedText: 'Event' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeEventLabel', languageCode: 'zh', translatedText: '活动' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeOngoingLabel', languageCode: 'en', translatedText: 'Ongoing' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeOngoingLabel', languageCode: 'zh', translatedText: '持续' },

    // 挑战页面过滤器标签 - 难度
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyAllLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyAllLabel', languageCode: 'zh', translatedText: '全部' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyEasyLabel', languageCode: 'en', translatedText: 'Easy' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyEasyLabel', languageCode: 'zh', translatedText: '简单' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyMediumLabel', languageCode: 'en', translatedText: 'Medium' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyMediumLabel', languageCode: 'zh', translatedText: '中等' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyHardLabel', languageCode: 'en', translatedText: 'Hard' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyHardLabel', languageCode: 'zh', translatedText: '困难' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyExpertLabel', languageCode: 'en', translatedText: 'Expert' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyExpertLabel', languageCode: 'zh', translatedText: '专家' },

    // 挑战页面错误和加载消息
    { scopeKey: 'challengesView', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading challenges...' },
    { scopeKey: 'challengesView', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: '加载挑战中...' },
    { scopeKey: 'challengesView', labelKey: 'errorTitle', languageCode: 'en', translatedText: 'Challenge Page Error' },
    { scopeKey: 'challengesView', labelKey: 'errorTitle', languageCode: 'zh', translatedText: '挑战页面错误' },
    { scopeKey: 'challengesView', labelKey: 'errorMessage', languageCode: 'en', translatedText: 'Failed to load challenges: {message}' },
    { scopeKey: 'challengesView', labelKey: 'errorMessage', languageCode: 'zh', translatedText: '加载挑战失败: {message}' },
    { scopeKey: 'challengesView', labelKey: 'retryButtonText', languageCode: 'en', translatedText: 'Retry' },
    { scopeKey: 'challengesView', labelKey: 'retryButtonText', languageCode: 'zh', translatedText: '重试' },

    // 及时奖励页面标签
    { scopeKey: 'timelyRewardsPageView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Timely Rewards' },
    { scopeKey: 'timelyRewardsPageView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '及时奖励' },
    { scopeKey: 'timelyRewardsPageView', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading rewards...' },
    { scopeKey: 'timelyRewardsPageView', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: '加载奖励中...' },
    { scopeKey: 'timelyRewardsPageView', labelKey: 'errorTitle', languageCode: 'en', translatedText: 'Timely Rewards Page Error' },
    { scopeKey: 'timelyRewardsPageView', labelKey: 'errorTitle', languageCode: 'zh', translatedText: '及时奖励页面错误' },

    // 及时奖励页面过滤器标签
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'statusLabel', languageCode: 'en', translatedText: 'Status' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'statusLabel', languageCode: 'zh', translatedText: '状态' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'allLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'allLabel', languageCode: 'zh', translatedText: '全部' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'activeLabel', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'activeLabel', languageCode: 'zh', translatedText: '进行中' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'completedLabel', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'completedLabel', languageCode: 'zh', translatedText: '已完成' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'upcomingLabel', languageCode: 'en', translatedText: 'Upcoming' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'upcomingLabel', languageCode: 'zh', translatedText: '即将开始' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeLabel', languageCode: 'zh', translatedText: '类型' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeAllLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeAllLabel', languageCode: 'zh', translatedText: '全部' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeDailyLabel', languageCode: 'en', translatedText: 'Daily Reward' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeDailyLabel', languageCode: 'zh', translatedText: '每日奖励' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeMorningLabel', languageCode: 'en', translatedText: 'Early Bird Reward' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeMorningLabel', languageCode: 'zh', translatedText: '早起鸟奖励' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeStreakLabel', languageCode: 'en', translatedText: 'Streak Reward' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeStreakLabel', languageCode: 'zh', translatedText: '连续完成奖励' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeSpecialLabel', languageCode: 'en', translatedText: 'Special Reward' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeSpecialLabel', languageCode: 'zh', translatedText: '特殊奖励' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'clearFiltersLabel', languageCode: 'en', translatedText: 'Clear All Filters' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'clearFiltersLabel', languageCode: 'zh', translatedText: '清除所有过滤器' },

    // 及时奖励卡片标签
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeDaily', languageCode: 'en', translatedText: 'Daily Reward' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeDaily', languageCode: 'zh', translatedText: '每日奖励' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeMorning', languageCode: 'en', translatedText: 'Early Bird Reward' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeMorning', languageCode: 'zh', translatedText: '早起鸟奖励' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeStreak', languageCode: 'en', translatedText: 'Streak Reward' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeStreak', languageCode: 'zh', translatedText: '连续完成奖励' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeSpecial', languageCode: 'en', translatedText: 'Special Reward' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeSpecial', languageCode: 'zh', translatedText: '特殊奖励' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusActive', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusActive', languageCode: 'zh', translatedText: '进行中' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusCompleted', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusCompleted', languageCode: 'zh', translatedText: '已完成' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusExpired', languageCode: 'en', translatedText: 'Expired' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusExpired', languageCode: 'zh', translatedText: '已过期' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusUpcoming', languageCode: 'en', translatedText: 'Upcoming' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusUpcoming', languageCode: 'zh', translatedText: '即将开始' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'timeEnded', languageCode: 'en', translatedText: 'Ended' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'timeEnded', languageCode: 'zh', translatedText: '已结束' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'hourUnit', languageCode: 'en', translatedText: 'h' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'hourUnit', languageCode: 'zh', translatedText: '小时' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'minuteUnit', languageCode: 'en', translatedText: 'm' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'minuteUnit', languageCode: 'zh', translatedText: '分钟' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'remainingTimeLabel', languageCode: 'en', translatedText: 'Remaining time' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'remainingTimeLabel', languageCode: 'zh', translatedText: '剩余时间' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'luckyPointsLabel', languageCode: 'en', translatedText: 'Lucky Points' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'luckyPointsLabel', languageCode: 'zh', translatedText: '幸运点' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'claimRewardButton', languageCode: 'en', translatedText: 'Claim Reward' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'claimRewardButton', languageCode: 'zh', translatedText: '领取奖励' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'inProgressButton', languageCode: 'en', translatedText: 'In Progress...' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'inProgressButton', languageCode: 'zh', translatedText: '进行中...' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'completedOnLabel', languageCode: 'en', translatedText: 'Completed on' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'completedOnLabel', languageCode: 'zh', translatedText: '完成于' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'noRewardsMessage', languageCode: 'en', translatedText: 'No timely rewards available' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'noRewardsMessage', languageCode: 'zh', translatedText: '暂无及时奖励' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeLabel', languageCode: 'zh', translatedText: '类型' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusLabel', languageCode: 'en', translatedText: 'Status' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusLabel', languageCode: 'zh', translatedText: '状态' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'progressLabel', languageCode: 'en', translatedText: 'Progress' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'progressLabel', languageCode: 'zh', translatedText: '进度' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'startTimeLabel', languageCode: 'en', translatedText: 'Start Time' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'startTimeLabel', languageCode: 'zh', translatedText: '开始时间' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'endTimeLabel', languageCode: 'en', translatedText: 'End Time' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'endTimeLabel', languageCode: 'zh', translatedText: '结束时间' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'completedTimeLabel', languageCode: 'en', translatedText: 'Completed Time' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'completedTimeLabel', languageCode: 'zh', translatedText: '完成时间' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'continueEffortButton', languageCode: 'en', translatedText: 'Keep Going' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'continueEffortButton', languageCode: 'zh', translatedText: '继续努力' },

    // 幸运抽奖标签
    { scopeKey: 'timelyRewardsPageView.luckyDraw', labelKey: 'title', languageCode: 'en', translatedText: 'Lucky Draw' },
    { scopeKey: 'timelyRewardsPageView.luckyDraw', labelKey: 'title', languageCode: 'zh', translatedText: '幸运抽奖' },
    { scopeKey: 'timelyRewardsPageView.luckyDraw', labelKey: 'buttonText', languageCode: 'en', translatedText: 'Lucky Draw' },
    { scopeKey: 'timelyRewardsPageView.luckyDraw', labelKey: 'buttonText', languageCode: 'zh', translatedText: '幸运抽奖' },

    // 幸运点显示组件标签
    { scopeKey: 'luckyPointsDisplay', labelKey: 'label', languageCode: 'en', translatedText: 'Lucky Points' },
    { scopeKey: 'luckyPointsDisplay', labelKey: 'label', languageCode: 'zh', translatedText: '幸运点' },
    { scopeKey: 'luckyPointsDisplay', labelKey: 'loadingText', languageCode: 'en', translatedText: 'Loading...' },
    { scopeKey: 'luckyPointsDisplay', labelKey: 'loadingText', languageCode: 'zh', translatedText: '加载中...' },

    // 幸运抽奖组件标签
    { scopeKey: 'luckyDraw', labelKey: 'title', languageCode: 'en', translatedText: 'Lucky Draw' },
    { scopeKey: 'luckyDraw', labelKey: 'title', languageCode: 'zh', translatedText: '幸运抽奖' },
    { scopeKey: 'luckyDraw', labelKey: 'basicDrawLabel', languageCode: 'en', translatedText: 'Basic Draw' },
    { scopeKey: 'luckyDraw', labelKey: 'basicDrawLabel', languageCode: 'zh', translatedText: '基础抽奖' },
    { scopeKey: 'luckyDraw', labelKey: 'basicDrawDescription', languageCode: 'en', translatedText: 'Chance to get common rewards' },
    { scopeKey: 'luckyDraw', labelKey: 'basicDrawDescription', languageCode: 'zh', translatedText: '获得普通奖励的机会' },
    { scopeKey: 'luckyDraw', labelKey: 'premiumDrawLabel', languageCode: 'en', translatedText: 'Premium Draw' },
    { scopeKey: 'luckyDraw', labelKey: 'premiumDrawLabel', languageCode: 'zh', translatedText: '高级抽奖' },
    { scopeKey: 'luckyDraw', labelKey: 'premiumDrawDescription', languageCode: 'en', translatedText: 'Higher chance to get rare rewards' },
    { scopeKey: 'luckyDraw', labelKey: 'premiumDrawDescription', languageCode: 'zh', translatedText: '获得稀有奖励的更高机会' },
    { scopeKey: 'luckyDraw', labelKey: 'deluxeDrawLabel', languageCode: 'en', translatedText: 'Deluxe Draw' },
    { scopeKey: 'luckyDraw', labelKey: 'deluxeDrawLabel', languageCode: 'zh', translatedText: '豪华抽奖' },
    { scopeKey: 'luckyDraw', labelKey: 'deluxeDrawDescription', languageCode: 'en', translatedText: 'Highest chance to get epic and legendary rewards' },
    { scopeKey: 'luckyDraw', labelKey: 'deluxeDrawDescription', languageCode: 'zh', translatedText: '获得史诗和传说奖励的最高机会' },
    { scopeKey: 'luckyDraw', labelKey: 'notEnoughPointsError', languageCode: 'en', translatedText: 'Not enough lucky points' },
    { scopeKey: 'luckyDraw', labelKey: 'notEnoughPointsError', languageCode: 'zh', translatedText: '幸运点不足' },
    { scopeKey: 'luckyDraw', labelKey: 'loadPointsError', languageCode: 'en', translatedText: 'Failed to load lucky points, please try again' },
    { scopeKey: 'luckyDraw', labelKey: 'loadPointsError', languageCode: 'zh', translatedText: '加载幸运点失败，请重试' },
    { scopeKey: 'luckyDraw', labelKey: 'drawError', languageCode: 'en', translatedText: 'Failed to perform lucky draw, please try again' },
    { scopeKey: 'luckyDraw', labelKey: 'drawError', languageCode: 'zh', translatedText: '抽奖失败，请重试' },
    { scopeKey: 'luckyDraw', labelKey: 'continueDrawingButton', languageCode: 'en', translatedText: 'Continue Drawing' },
    { scopeKey: 'luckyDraw', labelKey: 'continueDrawingButton', languageCode: 'zh', translatedText: '继续抽奖' },
    { scopeKey: 'luckyDraw', labelKey: 'closeButton', languageCode: 'en', translatedText: 'Close' },
    { scopeKey: 'luckyDraw', labelKey: 'closeButton', languageCode: 'zh', translatedText: '关闭' },
    { scopeKey: 'luckyDraw', labelKey: 'drawingButton', languageCode: 'en', translatedText: 'Drawing...' },
    { scopeKey: 'luckyDraw', labelKey: 'drawingButton', languageCode: 'zh', translatedText: '抽奖中...' },
    { scopeKey: 'luckyDraw', labelKey: 'drawButton', languageCode: 'en', translatedText: 'Draw' },
    { scopeKey: 'luckyDraw', labelKey: 'drawButton', languageCode: 'zh', translatedText: '抽奖' },

    // Challenge Discovery Card Labels
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'closeButtonAriaLabel', languageCode: 'en', translatedText: 'Close' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'closeButtonAriaLabel', languageCode: 'zh', translatedText: '关闭' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading challenge...' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: '加载挑战中...' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'errorLoadingChallenge', languageCode: 'en', translatedText: 'Failed to load challenge, please try again' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'errorLoadingChallenge', languageCode: 'zh', translatedText: '加载挑战失败，请重试' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'cannotLoadChallenge', languageCode: 'en', translatedText: 'Unable to load challenge data' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'cannotLoadChallenge', languageCode: 'zh', translatedText: '无法加载挑战数据' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'startDateLabel', languageCode: 'en', translatedText: 'Start Date' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'startDateLabel', languageCode: 'zh', translatedText: '开始日期' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'endDateLabel', languageCode: 'en', translatedText: 'End Date' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'endDateLabel', languageCode: 'zh', translatedText: '结束日期' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'laterButton', languageCode: 'en', translatedText: 'Maybe Later' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'laterButton', languageCode: 'zh', translatedText: '稍后再说' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'acceptButton', languageCode: 'en', translatedText: 'Accept Challenge' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'acceptButton', languageCode: 'zh', translatedText: '接受挑战' },

    // Challenge Recommendation Card Labels
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'matchScoreLabel', languageCode: 'en', translatedText: 'Match Score' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'matchScoreLabel', languageCode: 'zh', translatedText: '匹配度' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyEasy', languageCode: 'en', translatedText: 'Easy' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyEasy', languageCode: 'zh', translatedText: '简单' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyMedium', languageCode: 'en', translatedText: 'Medium' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyMedium', languageCode: 'zh', translatedText: '中等' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyHard', languageCode: 'en', translatedText: 'Hard' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyHard', languageCode: 'zh', translatedText: '困难' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyExpert', languageCode: 'en', translatedText: 'Expert' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyExpert', languageCode: 'zh', translatedText: '专家' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyUnknown', languageCode: 'en', translatedText: 'Unknown' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyUnknown', languageCode: 'zh', translatedText: '未知' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'startDateLabel', languageCode: 'en', translatedText: 'Start Date' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'startDateLabel', languageCode: 'zh', translatedText: '开始日期' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'endDateLabel', languageCode: 'en', translatedText: 'End Date' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'endDateLabel', languageCode: 'zh', translatedText: '结束日期' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'viewDetailsButton', languageCode: 'en', translatedText: 'View Details' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'viewDetailsButton', languageCode: 'zh', translatedText: '查看详情' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'acceptButton', languageCode: 'en', translatedText: 'Accept Challenge' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'acceptButton', languageCode: 'zh', translatedText: '接受挑战' },

    // 商店页面标签
    { scopeKey: 'storeView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Store' },
    { scopeKey: 'storeView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '商店' },
    { scopeKey: 'storeView', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading store content...' },
    { scopeKey: 'storeView', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: '加载商店内容...' },
    { scopeKey: 'storeView', labelKey: 'errorTitle', languageCode: 'en', translatedText: 'Store Page Error' },
    { scopeKey: 'storeView', labelKey: 'errorTitle', languageCode: 'zh', translatedText: '商店页面错误' },
    { scopeKey: 'storeView', labelKey: 'retryButtonText', languageCode: 'en', translatedText: 'Retry' },
    { scopeKey: 'storeView', labelKey: 'retryButtonText', languageCode: 'zh', translatedText: '重试' },
    { scopeKey: 'storeView.vipToggleButton', labelKey: 'showVip', languageCode: 'en', translatedText: 'View VIP Membership' },
    { scopeKey: 'storeView.vipToggleButton', labelKey: 'showVip', languageCode: 'zh', translatedText: '查看VIP会员' },
    { scopeKey: 'storeView.vipToggleButton', labelKey: 'backToStore', languageCode: 'en', translatedText: 'Back to Store' },
    { scopeKey: 'storeView.vipToggleButton', labelKey: 'backToStore', languageCode: 'zh', translatedText: '返回商店' },
    { scopeKey: 'storeView', labelKey: 'featuredItemsTitle', languageCode: 'en', translatedText: 'Featured Items' },
    { scopeKey: 'storeView', labelKey: 'featuredItemsTitle', languageCode: 'zh', translatedText: '特色物品' },
    { scopeKey: 'storeView', labelKey: 'saleItemsTitle', languageCode: 'en', translatedText: 'Sale Items' },
    { scopeKey: 'storeView', labelKey: 'saleItemsTitle', languageCode: 'zh', translatedText: '促销物品' },
    { scopeKey: 'storeView', labelKey: 'categoryItemsTitle', languageCode: 'en', translatedText: 'Category Items' },
    { scopeKey: 'storeView', labelKey: 'categoryItemsTitle', languageCode: 'zh', translatedText: '分类物品' },
    { scopeKey: 'storeView', labelKey: 'noItemsMessage', languageCode: 'en', translatedText: 'No items in this category' },
    { scopeKey: 'storeView', labelKey: 'noItemsMessage', languageCode: 'zh', translatedText: '该类别暂无物品' },

    // 茶室页面标签
    { scopeKey: 'teaRoomView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Tea Room' },
    { scopeKey: 'teaRoomView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '静心茶室' },
    { scopeKey: 'teaRoomView', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading tea room content...' },
    { scopeKey: 'teaRoomView', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: '加载茶室内容...' },
    { scopeKey: 'teaRoomView', labelKey: 'errorTitle', languageCode: 'en', translatedText: 'Tea Room Page Error' },
    { scopeKey: 'teaRoomView', labelKey: 'errorTitle', languageCode: 'zh', translatedText: '茶室页面错误' },
    { scopeKey: 'teaRoomView', labelKey: 'retryButtonText', languageCode: 'en', translatedText: 'Retry' },
    { scopeKey: 'teaRoomView', labelKey: 'retryButtonText', languageCode: 'zh', translatedText: '重试' },
    { scopeKey: 'teaRoomView.moodTrackingSection', labelKey: 'title', languageCode: 'en', translatedText: 'Mood Tracking' },
    { scopeKey: 'teaRoomView.moodTrackingSection', labelKey: 'title', languageCode: 'zh', translatedText: '情绪追踪' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'title', languageCode: 'en', translatedText: 'Reflection' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'title', languageCode: 'zh', translatedText: '反思' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'description', languageCode: 'en', translatedText: 'Take some time to reflect on your experiences, feelings, and thoughts to better understand yourself and find direction.' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'description', languageCode: 'zh', translatedText: '花点时间反思你的经历、感受和想法，可以帮助你更好地了解自己，并找到前进的方向。' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'startReflectionButton', languageCode: 'en', translatedText: 'Start Reflection' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'startReflectionButton', languageCode: 'zh', translatedText: '开始反思' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'viewHistoryButton', languageCode: 'en', translatedText: 'View Reflection History' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'viewHistoryButton', languageCode: 'zh', translatedText: '查看历史反思' },
    { scopeKey: 'teaRoomView.dailyTipSection', labelKey: 'title', languageCode: 'en', translatedText: 'Daily Wisdom' },
    { scopeKey: 'teaRoomView.dailyTipSection', labelKey: 'title', languageCode: 'zh', translatedText: '每日智慧' },
    { scopeKey: 'teaRoomView.dailyTipSection', labelKey: 'content', languageCode: 'en', translatedText: 'Self-compassion is an essential part of mental health. When facing difficulties, try to treat yourself as you would a good friend, with understanding and kindness.' },
    { scopeKey: 'teaRoomView.dailyTipSection', labelKey: 'content', languageCode: 'zh', translatedText: '自我关怀是心理健康的重要组成部分。面对困难时，试着像对待好朋友一样对待自己，给予理解和善意。' },

    // 能力页面标签
    { scopeKey: 'abilitiesView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Panda Abilities' },
    { scopeKey: 'abilitiesView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '熊猫能力' },
    { scopeKey: 'abilitiesView', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading abilities...' },
    { scopeKey: 'abilitiesView', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: '加载能力中...' },
    { scopeKey: 'abilitiesView', labelKey: 'errorTitle', languageCode: 'en', translatedText: 'Abilities Page Error' },
    { scopeKey: 'abilitiesView', labelKey: 'errorTitle', languageCode: 'zh', translatedText: '能力页面错误' },
    { scopeKey: 'abilitiesView', labelKey: 'errorMessage', languageCode: 'en', translatedText: 'Failed to load abilities' },
    { scopeKey: 'abilitiesView', labelKey: 'errorMessage', languageCode: 'zh', translatedText: '加载能力失败' },
    { scopeKey: 'abilitiesView', labelKey: 'retryButtonText', languageCode: 'en', translatedText: 'Retry' },
    { scopeKey: 'abilitiesView', labelKey: 'retryButtonText', languageCode: 'zh', translatedText: '重试' },
    { scopeKey: 'abilitiesView', labelKey: 'pandaLevelLabel', languageCode: 'en', translatedText: 'Panda Level' },
    { scopeKey: 'abilitiesView', labelKey: 'pandaLevelLabel', languageCode: 'zh', translatedText: '熊猫等级' },
    { scopeKey: 'abilitiesView', labelKey: 'unlockedAbilitiesLabel', languageCode: 'en', translatedText: 'Unlocked Abilities' },
    { scopeKey: 'abilitiesView', labelKey: 'unlockedAbilitiesLabel', languageCode: 'zh', translatedText: '已解锁能力' },
    { scopeKey: 'abilitiesView', labelKey: 'abilitiesDescription', languageCode: 'en', translatedText: 'Abilities are special powers that your panda can use to help you in your tasks.' },
    { scopeKey: 'abilitiesView', labelKey: 'abilitiesDescription', languageCode: 'zh', translatedText: '能力是熊猫可以使用的特殊力量，可以帮助你完成任务。' },
    { scopeKey: 'abilitiesView', labelKey: 'noAbilitiesMessage', languageCode: 'en', translatedText: 'No abilities found' },
    { scopeKey: 'abilitiesView', labelKey: 'noAbilitiesMessage', languageCode: 'zh', translatedText: '暂无能力' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'statusLabel', languageCode: 'en', translatedText: 'Status' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'statusLabel', languageCode: 'zh', translatedText: '状态' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'typeLabel', languageCode: 'zh', translatedText: '类型' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'allLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'allLabel', languageCode: 'zh', translatedText: '全部' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'unlockedLabel', languageCode: 'en', translatedText: 'Unlocked' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'unlockedLabel', languageCode: 'zh', translatedText: '已解锁' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'activeLabel', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'activeLabel', languageCode: 'zh', translatedText: '已激活' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'lockedLabel', languageCode: 'en', translatedText: 'Locked' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'lockedLabel', languageCode: 'zh', translatedText: '已锁定' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'passiveLabel', languageCode: 'en', translatedText: 'Passive' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'passiveLabel', languageCode: 'zh', translatedText: '被动' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'ultimateLabel', languageCode: 'en', translatedText: 'Ultimate' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'ultimateLabel', languageCode: 'zh', translatedText: '终极' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'clearFiltersLabel', languageCode: 'en', translatedText: 'Clear All Filters' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'clearFiltersLabel', languageCode: 'zh', translatedText: '清除所有过滤器' },

    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typePassive', languageCode: 'en', translatedText: 'Passive' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typePassive', languageCode: 'zh', translatedText: '被动' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typeActive', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typeActive', languageCode: 'zh', translatedText: '主动' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typeUltimate', languageCode: 'en', translatedText: 'Ultimate' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typeUltimate', languageCode: 'zh', translatedText: '终极' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typeUnknown', languageCode: 'en', translatedText: 'Unknown' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typeUnknown', languageCode: 'zh', translatedText: '未知' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityCommon', languageCode: 'en', translatedText: 'Common' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityCommon', languageCode: 'zh', translatedText: '普通' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityUncommon', languageCode: 'en', translatedText: 'Uncommon' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityUncommon', languageCode: 'zh', translatedText: '不常见' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityRare', languageCode: 'en', translatedText: 'Rare' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityRare', languageCode: 'zh', translatedText: '稀有' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityEpic', languageCode: 'en', translatedText: 'Epic' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityEpic', languageCode: 'zh', translatedText: '史诗' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityLegendary', languageCode: 'en', translatedText: 'Legendary' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityLegendary', languageCode: 'zh', translatedText: '传说' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'requiredLevelLabel', languageCode: 'en', translatedText: 'Required Level' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'requiredLevelLabel', languageCode: 'zh', translatedText: '需要等级' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'cooldownLabel', languageCode: 'en', translatedText: 'Cooldown' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'cooldownLabel', languageCode: 'zh', translatedText: '冷却时间' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'cooldownRemainingLabel', languageCode: 'en', translatedText: 'Cooling down' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'cooldownRemainingLabel', languageCode: 'zh', translatedText: '冷却中' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'activateButtonText', languageCode: 'en', translatedText: 'Activate Ability' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'activateButtonText', languageCode: 'zh', translatedText: '激活能力' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'alreadyActivatedText', languageCode: 'en', translatedText: 'Already Activated' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'alreadyActivatedText', languageCode: 'zh', translatedText: '已激活' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'minutesUnit', languageCode: 'en', translatedText: 'min' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'minutesUnit', languageCode: 'zh', translatedText: '分钟' },

    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'title', languageCode: 'en', translatedText: 'Ability Details' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'title', languageCode: 'zh', translatedText: '能力详情' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'requiredLevelLabel', languageCode: 'en', translatedText: 'Required Level' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'requiredLevelLabel', languageCode: 'zh', translatedText: '解锁等级' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'levelsNeededText', languageCode: 'en', translatedText: 'Need' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'levelsNeededText', languageCode: 'zh', translatedText: '还需' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'cooldownLabel', languageCode: 'en', translatedText: 'Cooldown' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'cooldownLabel', languageCode: 'zh', translatedText: '冷却时间' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'rarityLabel', languageCode: 'en', translatedText: 'Rarity' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'rarityLabel', languageCode: 'zh', translatedText: '稀有度' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'typeLabel', languageCode: 'zh', translatedText: '类型' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'effectLabel', languageCode: 'en', translatedText: 'Effect Value' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'effectLabel', languageCode: 'zh', translatedText: '效果值' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'activateButtonText', languageCode: 'en', translatedText: 'Activate Ability' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'activateButtonText', languageCode: 'zh', translatedText: '激活能力' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'alreadyActivatedText', languageCode: 'en', translatedText: 'Already Activated' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'alreadyActivatedText', languageCode: 'zh', translatedText: '已激活' },

    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'title', languageCode: 'en', translatedText: 'Ability Unlocked' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'title', languageCode: 'zh', translatedText: '能力解锁' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'newAbilityTitle', languageCode: 'en', translatedText: 'New Ability Unlocked!' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'newAbilityTitle', languageCode: 'zh', translatedText: '解锁新能力！' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'nextButtonText', languageCode: 'en', translatedText: 'Next Ability' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'nextButtonText', languageCode: 'zh', translatedText: '下一个能力' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'viewAllButtonText', languageCode: 'en', translatedText: 'View All Abilities' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'viewAllButtonText', languageCode: 'zh', translatedText: '查看所有能力' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'allUnlockedTitle', languageCode: 'en', translatedText: 'Newly Unlocked Abilities' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'allUnlockedTitle', languageCode: 'zh', translatedText: '新解锁的能力' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'closeButtonText', languageCode: 'en', translatedText: 'Close' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'closeButtonText', languageCode: 'zh', translatedText: '关闭' },

    // Ability names and descriptions
    { scopeKey: 'abilities', labelKey: 'bambooHeart.name', languageCode: 'en', translatedText: 'Bamboo Heart' },
    { scopeKey: 'abilities', labelKey: 'bambooHeart.name', languageCode: 'zh', translatedText: '竹林之心' },
    { scopeKey: 'abilities', labelKey: 'bambooHeart.description', languageCode: 'en', translatedText: 'Passive: Increases experience gained from completing tasks by 10%' },
    { scopeKey: 'abilities', labelKey: 'bambooHeart.description', languageCode: 'zh', translatedText: '被动：完成任务时获得的经验值增加10%' },

    { scopeKey: 'abilities', labelKey: 'pandaVitality.name', languageCode: 'en', translatedText: 'Panda Vitality' },
    { scopeKey: 'abilities', labelKey: 'pandaVitality.name', languageCode: 'zh', translatedText: '熊猫活力' },
    { scopeKey: 'abilities', labelKey: 'pandaVitality.description', languageCode: 'en', translatedText: 'Passive: Increases panda energy recovery rate by 15%' },
    { scopeKey: 'abilities', labelKey: 'pandaVitality.description', languageCode: 'zh', translatedText: '被动：熊猫能量恢复速度提高15%' },

    { scopeKey: 'abilities', labelKey: 'bambooFocus.name', languageCode: 'en', translatedText: 'Bamboo Focus' },
    { scopeKey: 'abilities', labelKey: 'bambooFocus.name', languageCode: 'zh', translatedText: '竹影专注' },
    { scopeKey: 'abilities', labelKey: 'bambooFocus.description', languageCode: 'en', translatedText: 'Active: When activated, increases experience gained from completing tasks by 25% for 1 hour' },
    { scopeKey: 'abilities', labelKey: 'bambooFocus.description', languageCode: 'zh', translatedText: '主动：激活后，1小时内完成任务获得的经验值增加25%' },

    { scopeKey: 'abilities', labelKey: 'pandaWisdom.name', languageCode: 'en', translatedText: 'Panda Wisdom' },
    { scopeKey: 'abilities', labelKey: 'pandaWisdom.name', languageCode: 'zh', translatedText: '熊猫智慧' },
    { scopeKey: 'abilities', labelKey: 'pandaWisdom.description', languageCode: 'en', translatedText: 'Active: When activated, increases rewards from completed tasks by 20% for 2 hours' },
    { scopeKey: 'abilities', labelKey: 'pandaWisdom.description', languageCode: 'zh', translatedText: '主动：激活后，2小时内任务完成奖励数量增加20%' },

    { scopeKey: 'abilities', labelKey: 'bambooMaster.name', languageCode: 'en', translatedText: 'Bamboo Master' },
    { scopeKey: 'abilities', labelKey: 'bambooMaster.name', languageCode: 'zh', translatedText: '竹林大师' },
    { scopeKey: 'abilities', labelKey: 'bambooMaster.description', languageCode: 'en', translatedText: 'Ultimate: When activated, increases all ability effects by 50% for 4 hours' },
    { scopeKey: 'abilities', labelKey: 'bambooMaster.description', languageCode: 'zh', translatedText: '终极：激活后，4小时内所有能力效果提升50%' },

    // 及时奖励页面标签
    { scopeKey: 'timelyRewardsView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Timely Rewards' },
    { scopeKey: 'timelyRewardsView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: '及时奖励' },
    { scopeKey: 'timelyRewardsView', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading rewards...' },
    { scopeKey: 'timelyRewardsView', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: '加载奖励中...' },
    { scopeKey: 'timelyRewardsView', labelKey: 'errorTitle', languageCode: 'en', translatedText: 'Timely Rewards Page Error' },
    { scopeKey: 'timelyRewardsView', labelKey: 'errorTitle', languageCode: 'zh', translatedText: '及时奖励页面错误' },
    { scopeKey: 'timelyRewardsView', labelKey: 'noRewardsMessage', languageCode: 'en', translatedText: 'No rewards found' },
    { scopeKey: 'timelyRewardsView', labelKey: 'noRewardsMessage', languageCode: 'zh', translatedText: '暂无奖励' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusLabel', languageCode: 'en', translatedText: 'Status' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusLabel', languageCode: 'zh', translatedText: '状态' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'allLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'allLabel', languageCode: 'zh', translatedText: '全部' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusActiveLabel', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusActiveLabel', languageCode: 'zh', translatedText: '进行中' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusCompletedLabel', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusCompletedLabel', languageCode: 'zh', translatedText: '已完成' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusExpiredLabel', languageCode: 'en', translatedText: 'Expired' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusExpiredLabel', languageCode: 'zh', translatedText: '已过期' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeLabel', languageCode: 'zh', translatedText: '类型' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeDailyLabel', languageCode: 'en', translatedText: 'Daily' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeDailyLabel', languageCode: 'zh', translatedText: '每日' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeWeeklyLabel', languageCode: 'en', translatedText: 'Weekly' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeWeeklyLabel', languageCode: 'zh', translatedText: '每周' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeStreakLabel', languageCode: 'en', translatedText: 'Streak' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeStreakLabel', languageCode: 'zh', translatedText: '连续完成' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeSpecialLabel', languageCode: 'en', translatedText: 'Special' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeSpecialLabel', languageCode: 'zh', translatedText: '特殊' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'clearFiltersLabel', languageCode: 'en', translatedText: 'Clear All Filters' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'clearFiltersLabel', languageCode: 'zh', translatedText: '清除所有过滤器' },
    { scopeKey: 'timelyRewardsView.luckyDraw', labelKey: 'buttonText', languageCode: 'en', translatedText: 'Lucky Draw' },
    { scopeKey: 'timelyRewardsView.luckyDraw', labelKey: 'buttonText', languageCode: 'zh', translatedText: '幸运抽奖' },
    { scopeKey: 'timelyRewardsView.luckyDraw', labelKey: 'title', languageCode: 'en', translatedText: 'Lucky Draw' },
    { scopeKey: 'timelyRewardsView.luckyDraw', labelKey: 'title', languageCode: 'zh', translatedText: '幸运抽奖' },

    // TimelyRewardCard 组件标签
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeLabel', languageCode: 'zh', translatedText: '类型' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeDaily', languageCode: 'en', translatedText: 'Daily Reward' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeDaily', languageCode: 'zh', translatedText: '每日奖励' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeMorning', languageCode: 'en', translatedText: 'Early Bird Reward' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeMorning', languageCode: 'zh', translatedText: '早起鸟奖励' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeStreak', languageCode: 'en', translatedText: 'Streak Reward' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeStreak', languageCode: 'zh', translatedText: '连续完成奖励' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeSpecial', languageCode: 'en', translatedText: 'Special Reward' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeSpecial', languageCode: 'zh', translatedText: '特殊奖励' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusLabel', languageCode: 'en', translatedText: 'Status' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusLabel', languageCode: 'zh', translatedText: '状态' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusActive', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusActive', languageCode: 'zh', translatedText: '进行中' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusCompleted', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusCompleted', languageCode: 'zh', translatedText: '已完成' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusExpired', languageCode: 'en', translatedText: 'Expired' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusExpired', languageCode: 'zh', translatedText: '已过期' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusUpcoming', languageCode: 'en', translatedText: 'Upcoming' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusUpcoming', languageCode: 'zh', translatedText: '即将开始' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'remainingTimeLabel', languageCode: 'en', translatedText: 'Remaining time' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'remainingTimeLabel', languageCode: 'zh', translatedText: '剩余时间' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'timeEnded', languageCode: 'en', translatedText: 'Ended' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'timeEnded', languageCode: 'zh', translatedText: '已结束' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'hourUnit', languageCode: 'en', translatedText: 'h' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'hourUnit', languageCode: 'zh', translatedText: '小时' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'minuteUnit', languageCode: 'en', translatedText: 'm' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'minuteUnit', languageCode: 'zh', translatedText: '分钟' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'luckyPointsLabel', languageCode: 'en', translatedText: 'Lucky Points' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'luckyPointsLabel', languageCode: 'zh', translatedText: '幸运点' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'claimRewardButton', languageCode: 'en', translatedText: 'Claim Reward' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'claimRewardButton', languageCode: 'zh', translatedText: '领取奖励' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'inProgressButton', languageCode: 'en', translatedText: 'In Progress...' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'inProgressButton', languageCode: 'zh', translatedText: '进行中...' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedOnLabel', languageCode: 'en', translatedText: 'Completed on' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedOnLabel', languageCode: 'zh', translatedText: '完成于' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'progressLabel', languageCode: 'en', translatedText: 'Progress' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'progressLabel', languageCode: 'zh', translatedText: '进度' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'startTimeLabel', languageCode: 'en', translatedText: 'Start Time' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'startTimeLabel', languageCode: 'zh', translatedText: '开始时间' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'endTimeLabel', languageCode: 'en', translatedText: 'End Time' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'endTimeLabel', languageCode: 'zh', translatedText: '结束时间' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedTimeLabel', languageCode: 'en', translatedText: 'Completed Time' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedTimeLabel', languageCode: 'zh', translatedText: '完成时间' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'continueEffortButton', languageCode: 'en', translatedText: 'Keep Going' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'continueEffortButton', languageCode: 'zh', translatedText: '继续努力' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'noRewardsMessage', languageCode: 'en', translatedText: 'No timely rewards available' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'noRewardsMessage', languageCode: 'zh', translatedText: '暂无及时奖励' },
  ];
  await db.uiLabels.bulkAdd(labels);
  console.log("Final V3 DB populated.");
}
</file>

<file path="src/router.tsx">
// src/router.tsx
import React, { Suspense, lazy } from 'react';
import { Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { AnimatePresence } from 'framer-motion';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// Lazy load page components
const HomePage = lazy(() => import('@/pages/HomePage'));
const SettingsPage = lazy(() => import('@/pages/SettingsPage'));
const TasksPage = lazy(() => import('@/pages/TasksPage'));
const AbilitiesPage = lazy(() => import('@/pages/AbilitiesPage'));
const ChallengesPage = lazy(() => import('@/pages/ChallengesPage'));
const TimelyRewardsPage = lazy(() => import('@/pages/TimelyRewardsPage'));
const TeaRoomPage = lazy(() => import('@/pages/TeaRoomPage'));
const StorePage = lazy(() => import('@/pages/StorePage'));

const AppRouter: React.FC = () => {
  const location = useLocation();

  return (
    <Suspense fallback={<LoadingSpinner variant="jade" text="Loading view..." />}>
      <Routes location={location}>
        <Route path="/" element={<HomePage />} />
        <Route path="/tasks" element={<TasksPage />} />
        <Route path="/abilities" element={<AbilitiesPage />} />
        <Route path="/challenges" element={<ChallengesPage />} />
        <Route path="/rewards" element={<TimelyRewardsPage />} />
        <Route path="/tearoom" element={<TeaRoomPage />} />
        <Route path="/store" element={<StorePage />} />
        <Route path="/settings" element={<SettingsPage />} />
        <Route path="*" element={<Navigate to="/" replace />} /> {/* Fallback route */}
      </Routes>
    </Suspense>
  );
};
export default AppRouter;
</file>

<file path="src/services/localizedContentService.ts">
import { db } from '@/db';
import type {
  Language, LocalizedContent,
  HomePageViewLabelsBundle, HomePageViewDataPayload, MoodItem,
  SettingsPageViewLabelsBundle,
  TasksPageViewLabelsBundle,
  ChallengesPageViewLabelsBundle,
  TimelyRewardsPageViewLabelsBundle,
  AbilitiesPageViewLabelsBundle,
  StorePageViewLabelsBundle,
  TeaRoomPageViewLabelsBundle,
  GlobalLayoutLabelsBundle,
  ComponentsLabelsBundle,
  UILabelRecord, ApiError,
  FetchHomePageViewResult, FetchSettingsPageViewResult, FetchGlobalLayoutViewResult,
  FetchTasksPageViewResult, FetchChallengesPageViewResult, FetchTimelyRewardsPageViewResult,
  FetchAbilitiesPageViewResult, FetchStorePageViewResult, FetchTeaRoomPageViewResult,
  FetchComponentsLabelsResult
} from '@/types';

const SIMULATED_DELAY_MS = 150;

function buildLabelsObject<TLabelsBundle>(records: UILabelRecord[], baseScope: string): TLabelsBundle {
  const labels = {} as any;
  records.forEach(record => {
    let keyPath = record.labelKey;
    if (record.scopeKey.startsWith(baseScope + '.') && record.scopeKey.length > baseScope.length) {
        const sectionPath = record.scopeKey.substring(baseScope.length + 1);
        keyPath = `${sectionPath}.${record.labelKey}`;
    } else if (record.scopeKey !== baseScope) {
        // This label is not directly under baseScope or a direct sub-scope path, might be an issue or intended for a different structure.
        // For this demo, we'll assume labels fetched by getScopedLabels are correctly targeted.
        // console.warn(`Label with key ${record.labelKey} has scope ${record.scopeKey} which is not directly under or part of ${baseScope}`);
    }

    const keys = keyPath.split('.');
    let current = labels;
    keys.forEach((key, index) => {
      if (index === keys.length - 1) {
        current[key] = record.translatedText;
      } else {
        current[key] = current[key] || {};
        current = current[key];
      }
    });
  });
  return labels as TLabelsBundle;
}

async function getScopedLabels<TLabelsBundle>(baseScopeKey: string, lang: Language): Promise<TLabelsBundle> {
  let labelRecords = await db.uiLabels
    .where('languageCode').equals(lang)
    .and((record: UILabelRecord) => record.scopeKey.startsWith(baseScopeKey))
    .toArray();

  if (!labelRecords.length && lang !== 'en') {
    console.warn(`No '${lang}' labels for scope ${baseScopeKey}, falling back to 'en'`);
    labelRecords = await db.uiLabels
      .where('languageCode').equals('en')
      .and((record: UILabelRecord) => record.scopeKey.startsWith(baseScopeKey))
      .toArray();
  }

  if (!labelRecords.length) {
    const errorMessage = `CRITICAL: No labels found for essential scope ${baseScopeKey} (lang: ${lang} or fallback 'en').`;
    console.error(errorMessage);
    // In a real app, you might throw an error or have a more robust fallback
    return {} as TLabelsBundle;
  }
  return buildLabelsObject<TLabelsBundle>(labelRecords, baseScopeKey);
}

export async function fetchGlobalLayoutView(lang: Language): Promise<FetchGlobalLayoutViewResult> {
  console.log(`SVC_DEXIE: Fetching GLOBAL LAYOUT VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<GlobalLayoutLabelsBundle>('globalLayout', lang);
  return { labels, data: null };
}

export async function fetchHomePageView(lang: Language): Promise<FetchHomePageViewResult> {
  console.log(`SVC_DEXIE: Fetching HOME PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS));
  const labels = await getScopedLabels<HomePageViewLabelsBundle>('homeView', lang);

  const moods: MoodItem[] = [
    { id: 1, name: labels.moodsSection?.sectionTitle || (lang === 'zh' ? '心情' : 'Moods'), feeling: lang === 'zh' ? '专注的' : 'Focused' },
    { id: 2, name: lang === 'zh' ? '锻炼会议' : 'Workout Session', feeling: lang === 'zh' ? '精力充沛的' : 'Energized' },
  ];
  const data: HomePageViewDataPayload = { username: "DevUser", moods };
  return { labels, data };
}

export async function fetchSettingsPageView(lang: Language): Promise<FetchSettingsPageViewResult> {
  console.log(`SVC_DEXIE: Fetching SETTINGS PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<SettingsPageViewLabelsBundle>('settingsView', lang);
  return { labels, data: null };
}

export async function fetchTasksPageView(lang: Language): Promise<FetchTasksPageViewResult> {
  console.log(`SVC_DEXIE: Fetching TASKS PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<TasksPageViewLabelsBundle>('tasksView', lang);
  return { labels, data: null };
}

export async function fetchChallengesPageView(lang: Language): Promise<FetchChallengesPageViewResult> {
  console.log(`SVC_DEXIE: Fetching CHALLENGES PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<ChallengesPageViewLabelsBundle>('challengesView', lang);
  return { labels, data: null };
}

export async function fetchTimelyRewardsPageView(lang: Language): Promise<FetchTimelyRewardsPageViewResult> {
  console.log(`SVC_DEXIE: Fetching TIMELY REWARDS PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<TimelyRewardsPageViewLabelsBundle>('timelyRewardsView', lang);
  return { labels, data: null };
}

export async function fetchAbilitiesPageView(lang: Language): Promise<FetchAbilitiesPageViewResult> {
  console.log(`SVC_DEXIE: Fetching ABILITIES PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<AbilitiesPageViewLabelsBundle>('abilitiesView', lang);
  return { labels, data: null };
}

export async function fetchStorePageView(lang: Language): Promise<FetchStorePageViewResult> {
  console.log(`SVC_DEXIE: Fetching STORE PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<StorePageViewLabelsBundle>('storeView', lang);
  return { labels, data: null };
}

export async function fetchTeaRoomPageView(lang: Language): Promise<FetchTeaRoomPageViewResult> {
  console.log(`SVC_DEXIE: Fetching TEA ROOM PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<TeaRoomPageViewLabelsBundle>('teaRoomView', lang);
  return { labels, data: null };
}

/**
 * Fetches localized labels for common UI components
 *
 * @param lang - The language to fetch labels for
 * @returns A promise that resolves to the localized component labels
 */
export async function fetchComponentsLabels(lang: Language): Promise<FetchComponentsLabelsResult> {
  console.log(`SVC_DEXIE: Fetching COMPONENTS LABELS for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<ComponentsLabelsBundle>('components', lang);
  return { labels, data: null };
}
</file>

<file path="src/types/index.ts">
// src/types/index.ts
export type Language = "en" | "zh";

export interface LanguageContextType {
  language: Language;
  setLanguage: (lang: Language) => void;
}

export interface ApiError extends Error { errorCode?: string; statusCode?: number; }

// Structure for Dexie uiLabels store
export interface UILabelRecord {
  id?: number;
  scopeKey: string; // e.g., "globalLayout", "homeView", "homeView.welcomeSection", "components.button"
  labelKey: string; // e.g., "appTitle", "welcomeMessage", "confirmText"
  languageCode: Language;
  translatedText: string;
}

// --- Generic Localized Content Structure (from services) ---
export interface LocalizedContent<TDataPayload, TLabelsBundle> {
  labels: TLabelsBundle;
  data: TDataPayload | null;
}

// --- Common Components Labels ---
export interface ButtonLabels {
  loading: string;
  retry: string;
  confirm: string;
  cancel: string;
  save: string;
  close: string;
  submit: string;
  edit: string;
  delete: string;
  back: string;
  next: string;
}

export interface LoadingLabels {
  generic: string;
  data: string;
  content: string;
  saving: string;
  processing: string;
}

export interface ErrorLabels {
  generic: string;
  title: string;
  retry: string;
  details: string;
  networkError: string;
  serverError: string;
  unknownError: string;
}

export interface EmptyStateLabels {
  generic: string;
  noData: string;
  noResults: string;
  noItems: string;
}

export interface ModalLabels {
  close: string;
  confirm: string;
  cancel: string;
}

export interface TaskReminderLabels {
  title: string;
  subtitle: string;
  defaultMessage: string;
  reminderTimeLabel: string;
  dismissButton: string;
  laterButton: string;
  viewTaskButton: string;
  unknownTask: string;
}

export interface ComponentsLabelsBundle {
  button: ButtonLabels;
  loading: LoadingLabels;
  error: ErrorLabels;
  emptyState: EmptyStateLabels;
  modal: ModalLabels;
  taskReminder: TaskReminderLabels;
}

export type FetchComponentsLabelsResult = LocalizedContent<null, ComponentsLabelsBundle>;

// --- Global / Layout Content Types ---
export interface GlobalLayoutLabelsBundle {
  appTitle: string;
  navHome: string;
  navTasks: string;
  navAbilities: string;
  navRewards: string;
  navChallenges: string;
  navSettings: string;
  footerText: string;
  loadingGeneric: string;
  errorGeneric: string;
  appErrorHeading?: string;
  appErrorGeneralMessage?: string;
}
export type FetchGlobalLayoutViewResult = LocalizedContent<null, GlobalLayoutLabelsBundle>;

// --- Home Page/View Specific Types ---
export interface HomeWelcomeSectionLabels {
  welcomeMessage: string;
}
export interface MoodItem { readonly id: number; readonly name: string; readonly feeling: string; }
export interface HomeMoodsSectionLabels {
  sectionTitle: string;
  noMoodsMessage: string;
  refreshButtonText: string;
}
export interface HomePandaSectionLabels {
  sectionTitle: string;
  levelLabel: string;
  experienceLabel: string;
  interactButtonText: string;
  feedButtonText: string;
  playButtonText: string;
  trainButtonText: string;
}
export interface HomePageViewLabelsBundle {
  pageTitle: string;
  welcomeSection: HomeWelcomeSectionLabels;
  moodsSection: HomeMoodsSectionLabels;
  pandaSection: HomePandaSectionLabels;
  someActionText: string; // Example of a page-level label for a generic action
}
export interface HomePageViewDataPayload {
  username: string;
  moods: readonly MoodItem[];
}
export type FetchHomePageViewResult = LocalizedContent<HomePageViewDataPayload, HomePageViewLabelsBundle>;

// --- Settings Page/View Specific Types ---
export interface SettingsLanguageSectionLabels {
  sectionTitle: string;
  selectLanguagePrompt: string;
  currentLanguageIs: string;
  langNameEn: string;
  langNameZh: string;
  saveButtonText: string;
  successMessage: string;
}
export interface SettingsPageViewLabelsBundle {
  pageTitle: string;
  languageSection: SettingsLanguageSectionLabels;
}
export type FetchSettingsPageViewResult = LocalizedContent<null, SettingsPageViewLabelsBundle>;

// --- Tasks Page/View Specific Types ---
export interface TaskManagerLabels {
  sectionTitle: string;
  createTaskButton: string;
  filterAllLabel: string;
  filterTodoLabel: string;
  filterInProgressLabel: string;
  filterCompletedLabel: string;
  noTasksMessage: string;
}
export interface TasksPageViewLabelsBundle {
  pageTitle: string;
  taskManager: TaskManagerLabels;
  loadingMessage?: string;
  errorTitle?: string;
  errorMessage?: string;
  retryButtonText?: string;
}
export type FetchTasksPageViewResult = LocalizedContent<null, TasksPageViewLabelsBundle>;

// --- Challenges Page/View Specific Types ---
export interface ChallengeFilterLabels {
  statusLabel: string;
  typeLabel: string;
  difficultyLabel: string;
  allLabel: string;
  activeLabel: string;
  completedLabel: string;
  upcomingLabel: string;
  typeAllLabel: string;
  typeDailyLabel: string;
  typeWeeklyLabel: string;
  typeEventLabel: string;
  typeOngoingLabel: string;
  difficultyAllLabel: string;
  difficultyEasyLabel: string;
  difficultyMediumLabel: string;
  difficultyHardLabel: string;
  difficultyExpertLabel: string;
  clearFiltersLabel: string;
}

export interface ChallengeCardLabels {
  statusActive?: string;
  statusCompleted?: string;
  statusExpired?: string;
  statusUpcoming?: string;
  difficultyEasy?: string;
  difficultyMedium?: string;
  difficultyHard?: string;
  difficultyExpert?: string;
  startLabel?: string;
  endLabel?: string;
  completedOnLabel?: string;
  completeButtonText?: string;
  inProgressText?: string;
}

export interface ChallengeDiscoveryCardLabels {
  closeButtonAriaLabel?: string;
  loadingMessage?: string;
  errorLoadingChallenge?: string;
  cannotLoadChallenge?: string;
  startDateLabel?: string;
  endDateLabel?: string;
  laterButton?: string;
  acceptButton?: string;
}

export interface ChallengeRecommendationCardLabels {
  matchRateLabel?: string;
  startDateLabel?: string;
  endDateLabel?: string;
  viewDetailsButton?: string;
  acceptButton?: string;
}

export interface SocialChallengeCardLabels {
  progressLabel?: string;
  shareButton?: string;
  leaveButton?: string;
  joinButton?: string;
}

export interface ChallengesPageViewLabelsBundle {
  pageTitle: string;
  filters: ChallengeFilterLabels;
  statusFilterLabel?: string;
  typeFilterLabel?: string;
  difficultyFilterLabel?: string;
  noChallengesMessage: string;
  loadingMessage?: string;
  errorTitle?: string;
  errorMessage?: string;
  retryButtonText?: string;
  challengeCard?: ChallengeCardLabels;
  challengeDiscoveryCard?: ChallengeDiscoveryCardLabels;
  challengeRecommendationCard?: ChallengeRecommendationCardLabels;
  socialChallengeCard?: SocialChallengeCardLabels;
}
export type FetchChallengesPageViewResult = LocalizedContent<null, ChallengesPageViewLabelsBundle>;

// --- Timely Rewards Page/View Specific Types ---
export interface TimelyRewardFilterLabels {
  allLabel: string;
  activeLabel: string;
  completedLabel: string;
  upcomingLabel: string;
  typeAllLabel: string;
  typeDailyLabel: string;
  typeMorningLabel: string;
  typeStreakLabel: string;
  typeSpecialLabel: string;
  clearFiltersLabel: string;
}

export interface LuckyDrawLabels {
  title: string;
  buttonText: string;
  basicDrawLabel: string;
  advancedDrawLabel: string;
  premiumDrawLabel: string;
  basicDrawDescription: string;
  advancedDrawDescription: string;
  premiumDrawDescription: string;
  insufficientPointsLabel: string;
  drawingLabel: string;
  closeLabel: string;
  continueLabel: string;
}

export interface TimelyRewardCardLabels {
  typeDaily: string;
  typeMorning: string;
  typeStreak: string;
  typeSpecial: string;
  statusActive: string;
  statusCompleted: string;
  statusExpired: string;
  statusUpcoming: string;
  remainingTimeLabel: string;
  timeEnded: string;
  hourUnit: string;
  minuteUnit: string;
  luckyPointsLabel: string;
  claimRewardButton: string;
  inProgressButton: string;
  completedOnLabel: string;
  typeLabel?: string;
  statusLabel?: string;
  progressLabel?: string;
  startTimeLabel?: string;
  endTimeLabel?: string;
  completedTimeLabel?: string;
  continueEffortButton?: string;
  noRewardsMessage?: string;
}

export interface TimelyRewardsPageViewLabelsBundle {
  pageTitle: string;
  filters: TimelyRewardFilterLabels;
  luckyDraw: LuckyDrawLabels;
  noRewardsMessage: string;
  rewardCard: TimelyRewardCardLabels;
  loadingMessage?: string;
  errorTitle?: string;
  errorMessage?: string;
}
export type FetchTimelyRewardsPageViewResult = LocalizedContent<null, TimelyRewardsPageViewLabelsBundle>;

// --- Abilities Page/View Specific Types ---
export interface AbilityFilterLabels {
  statusLabel: string;
  typeLabel: string;
  allLabel: string;
  unlockedLabel: string;
  lockedLabel: string;
  passiveLabel: string;
  activeLabel: string;
  ultimateLabel: string;
  clearFiltersLabel: string;
}

export interface AbilityCardLabels {
  typePassive: string;
  typeActive: string;
  typeUltimate: string;
  typeUnknown: string;
  rarityCommon: string;
  rarityUncommon: string;
  rarityRare: string;
  rarityEpic: string;
  rarityLegendary: string;
  requiredLevelLabel: string;
  cooldownLabel: string;
  cooldownRemainingLabel: string;
  activateButtonText: string;
  alreadyActivatedText: string;
  minutesUnit: string;
}

export interface AbilityDetailLabels {
  title: string;
  requiredLevelLabel: string;
  levelsNeededText: string;
  cooldownLabel: string;
  rarityLabel: string;
  typeLabel: string;
  effectLabel: string;
  activateButtonText: string;
  alreadyActivatedText: string;
}

export interface AbilityUnlockNotificationLabels {
  title: string;
  newAbilityTitle: string;
  nextButtonText: string;
  viewAllButtonText: string;
  allUnlockedTitle: string;
  closeButtonText: string;
}

export interface AbilitiesPageViewLabelsBundle {
  pageTitle: string;
  filters: AbilityFilterLabels;
  noAbilitiesMessage: string;
  loadingMessage?: string;
  errorTitle?: string;
  errorMessage?: string;
  retryButtonText?: string;
  pandaLevelLabel?: string;
  unlockedAbilitiesLabel?: string;
  abilitiesDescription?: string;
  abilityCard?: AbilityCardLabels;
  abilityDetail?: AbilityDetailLabels;
  abilityUnlockNotification?: AbilityUnlockNotificationLabels;
}
export type FetchAbilitiesPageViewResult = LocalizedContent<null, AbilitiesPageViewLabelsBundle>;

// --- Store Page/View Specific Types ---
export interface StorePageViewLabelsBundle {
  pageTitle: string;
  loadingMessage?: string;
  errorTitle?: string;
  retryButtonText?: string;
  currencySection?: {
    coinsLabel?: string;
    jadeLabel?: string;
    vipLabel?: string;
  };
  vipToggleButton?: {
    showVip?: string;
    backToStore?: string;
  };
  vipSection?: {
    description?: string;
    tierLabels?: {
      basic?: string;
      premium?: string;
      deluxe?: string;
    }
  };
  categoriesTitle?: string;
  featuredItemsTitle?: string;
  saleItemsTitle?: string;
  categoryItemsTitle?: string;
  noCategoriesMessage?: string;
  noItemsMessage?: string;
}
export type FetchStorePageViewResult = LocalizedContent<null, StorePageViewLabelsBundle>;

// --- Tea Room Page/View Specific Types ---
export interface TeaRoomPageViewLabelsBundle {
  pageTitle: string;
  loadingMessage?: string;
  errorTitle?: string;
  retryButtonText?: string;
  moodTrackingSection?: {
    title?: string;
    description?: string;
    currentMoodQuestion?: string;
    recordMoodButton?: string;
    intensityLabel?: string;
    noteLabel?: string;
    historyLabel?: string;
  };
  reflectionSection?: {
    title?: string;
    description?: string;
    startReflectionButton?: string;
    viewHistoryButton?: string;
  };
  dailyTipSection?: {
    title?: string;
    content?: string;
  };
  reflectionTriggers?: {
    title?: string;
    description?: string;
  };
}
export type FetchTeaRoomPageViewResult = LocalizedContent<null, TeaRoomPageViewLabelsBundle>;
</file>

</files>
