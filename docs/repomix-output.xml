This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
app-design-brief -v1.md
app-design-brief.md
boost-sub.md
checklist.md
component-multilingual-examples.md
development-tasks-updated.md
docs/component-development-guide.md
docs/data-sync-architecture.md
docs/multilingual-support-fixes.md
germini.md
index.html
issue.md
multilingual-implementation-guide.md
multilingual-support-fixes.md
package.json
page-design-document.md
prd.md
prompt.md
public/assets/abilities/bamboo-focus.svg
public/assets/abilities/bamboo-heart.svg
public/assets/abilities/bamboo-master.svg
public/assets/abilities/default-ability.svg
public/assets/abilities/panda-vitality.svg
public/assets/abilities/panda-wisdom.svg
public/assets/accessories/bamboo-hat.svg
public/assets/accessories/default.svg
public/assets/accessories/gold-frame.svg
public/assets/accessories/red-ribbon.svg
public/assets/bamboo-bg-pattern.svg
public/assets/bamboo-leaves.svg
public/assets/chinese-cloud.svg
public/assets/chinese-knot.svg
public/assets/chinese-lantern.svg
public/assets/chinese-pattern.svg
public/assets/environments/bamboo-path.svg
public/assets/environments/chinese-garden.svg
public/assets/environments/default.svg
public/assets/ink-splash.svg
public/assets/lattice-pattern.svg
public/assets/lotus-flower.svg
public/assets/mountain-landscape.svg
public/assets/panda-focused.svg
public/assets/panda-happy.svg
public/assets/panda-normal.svg
public/assets/panda-tired.svg
public/assets/paper-texture.svg
public/assets/rewards/coin.svg
public/assets/rewards/decoration_common.svg
public/assets/rewards/experience.svg
public/assets/rewards/food_common.svg
public/assets/rewards/food_uncommon.svg
public/assets/rewards/item_common.svg
public/assets/rewards/potion_common.svg
public/assets/rewards/scroll_common.svg
public/assets/rewards/toy_common.svg
public/assets/rewards/toy_uncommon.svg
public/assets/scroll-edge.svg
public/assets/sounds/README.md
README.md
screens.md
src/App.tsx
src/components/animation/AnimatedButton.tsx
src/components/animation/AnimatedContainer.tsx
src/components/animation/AnimatedItem.tsx
src/components/animation/AnimatedTaskCard.tsx
src/components/animation/AnimatedTaskList.tsx
src/components/animation/ChallengeCompletionAnimation.tsx
src/components/animation/GoldenGlow.tsx
src/components/animation/InkSplash.tsx
src/components/animation/PageTransition.tsx
src/components/animation/README.md
src/components/animation/RewardAnimation.tsx
src/components/animation/TaskCompletionAnimation.tsx
src/components/common/Button.tsx
src/components/common/DataLoader.tsx
src/components/common/ErrorDisplay.tsx
src/components/common/LoadingSpinner.tsx
src/components/common/Modal.tsx
src/components/common/ProgressBar.tsx
src/components/common/SyncStatusIndicator.tsx
src/components/decoration/ChineseDecoration.tsx
src/components/decoration/InkAnimation.tsx
src/components/decoration/LanternDecoration.tsx
src/components/game/AbilityCard.tsx
src/components/game/AbilityList.tsx
src/components/game/AbilityUnlockNotification.tsx
src/components/game/ChallengeCard.tsx
src/components/game/ChallengeDiscoveryCard.tsx
src/components/game/ChallengeDiscoverySection.tsx
src/components/game/ChallengeList.tsx
src/components/game/ChallengeRecommendationCard.tsx
src/components/game/DialogDemo.tsx
src/components/game/LatticeDialog.tsx
src/components/game/LuckyDraw.tsx
src/components/game/LuckyDrawWheel.tsx
src/components/game/LuckyPointsDisplay.tsx
src/components/game/PandaAvatar.tsx
src/components/game/README.md
src/components/game/ReflectionModule.tsx
src/components/game/ResourceDisplay.tsx
src/components/game/ResourceInventory.tsx
src/components/game/ResourceList.tsx
src/components/game/RewardModal.tsx
src/components/game/ScrollDialog.tsx
src/components/game/SocialChallengeCard.tsx
src/components/game/SocialChallengeDetailDialog.tsx
src/components/game/SocialChallengeForm.tsx
src/components/game/SocialChallengeList.tsx
src/components/game/TaskCard.tsx
src/components/game/TaskDetailDialog.tsx
src/components/game/TaskForm.tsx
src/components/game/TaskList.tsx
src/components/game/TimelyRewardCard.tsx
src/components/game/TimelyRewardList.tsx
src/components/layout/AppShell.tsx
src/components/layout/Header.tsx
src/components/layout/Navigation.tsx
src/components/panda/PandaCustomizationPanel.tsx
src/components/panda/PandaEnvironmentPanel.tsx
src/components/reflection/EnhancedReflectionModule.tsx
src/components/reflection/MoodTracker.tsx
src/components/reflection/README.md
src/components/reflection/ReflectionHistory.tsx
src/components/reflection/ReflectionTriggerNotification.tsx
src/components/store/CurrencyDisplay.tsx
src/components/store/StoreCategoryList.tsx
src/components/store/StoreItemCard.tsx
src/components/store/StoreItemPreview.tsx
src/components/store/VipSubscriptionCard.tsx
src/components/task/TaskCard.tsx
src/components/task/TaskDetailDialog.tsx
src/components/task/TaskReminderForm.tsx
src/components/task/TaskReminderNotification.tsx
src/components/tasks/SubtaskList.tsx
src/context/DataRefreshProvider.tsx
src/context/LanguageProvider.tsx
src/context/PandaStateProvider.tsx
src/db-turso.ts
src/db.ts
src/features/home/MoodsSection.tsx
src/features/home/PandaSection.tsx
src/features/home/WelcomeSection.tsx
src/features/settings/LanguageSettingsSection.tsx
src/features/tasks/TaskManager.tsx
src/game-theme.css
src/hooks/useComponentLabels.ts
src/hooks/useDataRefresh.ts
src/hooks/useInternationalizedQuery.ts
src/hooks/useLocalizedView.ts
src/index.css
src/main.tsx
src/pages/AbilitiesPage.tsx
src/pages/ChallengesPage.tsx
src/pages/HomePage.tsx
src/pages/SettingsPage.tsx
src/pages/StorePage.tsx
src/pages/TasksPage.tsx
src/pages/TeaRoomPage.tsx
src/pages/TimelyRewardsPage.tsx
src/router.tsx
src/scripts/addTimelyRewardCardLabels.js
src/services/abilityService.ts
src/services/challengeDiscoveryService.ts
src/services/challengeService.ts
src/services/dataSyncService.ts
src/services/gameInitService.ts
src/services/index.ts
src/services/localizedContentService.ts
src/services/pandaAbilityService.ts
src/services/pandaCustomizationService.ts
src/services/pandaStateService.ts
src/services/queryClient.ts
src/services/reflectionService.ts
src/services/rewardService.ts
src/services/socialChallengeService.ts
src/services/storeService.ts
src/services/subtaskService.ts
src/services/taskReminderService.ts
src/services/taskService.ts
src/services/timelyRewardService.ts
src/types/dataRefresh.ts
src/types/index.ts
src/utils/animation.ts
src/utils/dateUtils.ts
src/utils/localization.ts
src/utils/sound.ts
src/vite-env.d.ts
task.md
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app-design-brief -v1.md">
# PandaHabit App Design Brief: åä¸½æ¸¸æˆé£æ ¼

## 1. Introduction

### 1.1 Overview
PandaHabitæ˜¯ä¸€æ¬¾ç§»åŠ¨åº”ç”¨ï¼Œé€šè¿‡å¼•äººå…¥èƒœä¸”æ”¯æŒæ€§çš„è™šæ‹Ÿå® ç‰©ä½“éªŒï¼Œå¸®åŠ©ç”¨æˆ·å»ºç«‹ç§¯æçš„ä¹ æƒ¯ï¼Œæ”¹å–„è‡ªæˆ‘æŠ¤ç†ï¼Œæå‡å¿ƒç†å¥åº·ã€‚ç”¨æˆ·é€šè¿‡å®Œæˆç°å®ç”Ÿæ´»ä¸­çš„ä»»åŠ¡å’Œä¹ æƒ¯æ¥åŸ¹å…»è™šæ‹Ÿç†ŠçŒ«ï¼Œåˆ›é€ ä¸€ç§å…±ç”Ÿå…³ç³»ï¼Œç…§é¡¾è‡ªå·±ç›´æ¥æœ‰ç›Šäºå® ç‰©ï¼Œè€Œå® ç‰©åˆ™æä¾›é™ªä¼´ã€åŠ¨åŠ›å’Œæ¸©å’Œçš„æŒ‡å¯¼ã€‚

### 1.2 åä¸½æ¸¸æˆé£æ ¼è®¾è®¡ç†å¿µ
PandaHabitçš„è®¾è®¡ç†å¿µå›´ç»•åˆ›é€ ä¸€ç§**åä¸½å¥¢åçš„æ¸¸æˆä½“éªŒ**ï¼Œç»™äººä»¥é«˜çº§æ„Ÿã€æ²‰æµ¸æ„Ÿå’Œæƒ…æ„Ÿæ»¡è¶³æ„Ÿã€‚åº”ç”¨æ—¨åœ¨é€šè¿‡åˆ©ç”¨ç²¾ç¾ç»šä¸½çš„è§†è§‰æ•ˆæœã€ç²¾å¿ƒè®¾è®¡çš„äº¤äº’å’Œä»¤äººæƒŠå¹çš„åŠ¨ç”»æ•ˆæœï¼Œå°†è‡ªæˆ‘æŠ¤ç†ä»ä¸€é¡¹çäº‹è½¬å˜ä¸ºä¸€æ®µæ„‰æ‚¦çš„æ—…ç¨‹ã€‚æˆ‘ä»¬é‡‡ç”¨äº†ä¸œæ–¹ç¾å­¦ä¸ç°ä»£æ¸¸æˆè®¾è®¡ç›¸ç»“åˆçš„æ–¹å¼ï¼Œæ‰“é€ å‡ºä¸€ä¸ªæ—¢åä¸½å£®è§‚åˆæ¸©é¦¨èˆ’é€‚çš„æ•°å­—ç©ºé—´ã€‚

### 1.3 ç›®æ ‡ç”¨æˆ·
- å¯»æ±‚ä¹ æƒ¯å…»æˆå’Œè‡ªæˆ‘æŠ¤ç†å·¥å…·çš„ä¸ªäºº
- å–œæ¬¢æ¸¸æˆåŒ–å’Œè™šæ‹Ÿå® ç‰©ä½“éªŒçš„ç”¨æˆ·
- æ¸´æœ›è·å¾—æ”¯æŒæ€§ã€æ¸©å’Œæ–¹å¼è¿›è¡Œä¸ªäººå‘å±•çš„äººç¾¤
- å¹´é¾„èŒƒå›´ï¼š18-45å²ï¼Œé‡ç‚¹å…³æ³¨å¹´è½»ä¸“ä¸šäººå£«å’Œå­¦ç”Ÿ
- æ¬£èµé«˜å“è´¨æ•°å­—ä½“éªŒå¹¶æ„¿æ„æŠ•èµ„ä¼˜è´¨åº”ç”¨çš„ç”¨æˆ·
- å¯¹ä¸œæ–¹ç¾å­¦å’Œåä¸½è§†è§‰é£æ ¼æœ‰åå¥½çš„ç©å®¶

## 2. åä¸½æ¸¸æˆé£æ ¼åˆ†æ

### 2.1 åä¸½æ¸¸æˆé£æ ¼å®šä¹‰
å¯¹äºPandaHabitï¼Œ"åä¸½æ¸¸æˆé£æ ¼"çš„å®šä¹‰åŒ…æ‹¬ï¼š
- **ç»šä¸½åç¾çš„è§†è§‰æ•ˆæœ**ï¼ŒåŒ…å«ç²¾ç»†çš„æ’ç”»å’ŒåŠ¨ç”»ï¼Œçµæ„Ÿæ¥æºäºä¸œæ–¹ç¾å­¦å’Œä¼ ç»Ÿä¸­å›½è‰ºæœ¯
- **é‡‘ç¢§è¾‰ç…Œçš„è‰²å½©æ­é…**ï¼Œèåˆæ·±æ²‰çš„å®çŸ³è‰²è°ƒã€é‡‘è‰²ç‚¹ç¼€ã€ç²¾è‡´çš„æ¸å˜å’Œä¼ ç»Ÿä¸­å›½è‰²å½©
- **ç²¾é›•ç»†ç¢çš„UIå…ƒç´ **ï¼Œæ³¨é‡é˜´å½±ã€é«˜å…‰å’Œçº¹ç†ç»†èŠ‚ï¼Œé‡‡ç”¨ä¼ ç»Ÿä¸­å›½è£…é¥°å…ƒç´ ï¼ˆå¦‚äº‘çº¹ã€å¦‚æ„çº¹ï¼‰
- **æµç•…åä¸½çš„åŠ¨ç”»æ•ˆæœ**ï¼Œæä¾›è§†è§‰åé¦ˆå’Œæ„‰æ‚¦æ„Ÿï¼ŒåŠ¨ç”»é£æ ¼èåˆç°ä»£æ¸¸æˆä¸ä¼ ç»Ÿæ°´å¢¨ç”»åŠ¨æ€ç¾æ„Ÿ
- **æ²‰æµ¸å¼éŸ³æ•ˆè®¾è®¡**ï¼Œç»“åˆå¹³é™çš„è‡ªç„¶å£°éŸ³ã€ä¼ ç»Ÿä¸­å›½ä¹å™¨å’Œæ¸©æŸ”çš„éŸ³ä¹å…ƒç´ 
- **ç²¾å¿ƒè®¾è®¡çš„å­—ä½“æ’ç‰ˆ**ï¼Œå¹³è¡¡å¯è¯»æ€§ä¸ç¾å­¦å¸å¼•åŠ›ï¼Œä¸­æ–‡ä½¿ç”¨ä¼˜é›…çš„ä¹¦æ³•é£æ ¼å­—ä½“

### 2.2 è§†è§‰å‚è€ƒä¸çµæ„Ÿæ¥æº
- **é«˜å“è´¨ç§»åŠ¨æ¸¸æˆ**ï¼šã€ŠåŸç¥ã€‹(æ•´ä½“UIé£æ ¼ä¸åŠ¨æ•ˆ)ã€ã€Šå¤©æ¶¯æ˜æœˆåˆ€ã€‹(ä¸­å›½é£å…ƒç´ )ã€ã€Šé˜´é˜³å¸ˆã€‹(åä¸½ç‰¹æ•ˆ)
- **ä¸­å›½ä¼ ç»Ÿè‰ºæœ¯**ï¼šæ°´å¢¨ç”»ã€ç«¹å­å›¾æ¡ˆã€å±±æ°´ç”»ã€ä¼ ç»Ÿçº¹é¥°ã€å‰ªçº¸è‰ºæœ¯ã€äº¬å‰§è„¸è°±å…ƒç´ 
- **å¥¢ä¾ˆå“ç‰Œåº”ç”¨**ï¼šä¸Šæµ·æ»©ã€æ•…å®«æ–‡åˆ›ã€Louis Vuittonä¸­å›½ç‰ˆ
- **è‡ªç„¶å¯å‘è®¾è®¡**ï¼šå›½å®¶åœ°ç†ã€é«˜ç«¯åº¦å‡æ‘ç½‘ç«™ã€ä¸­å›½å›­æ—è®¾è®¡
- **å¤å…¸æ¸¸æˆç¾å­¦**ï¼šã€Šè½©è¾•å‰‘ã€‹ç³»åˆ—ã€ã€Šä»™å‰‘å¥‡ä¾ ä¼ ã€‹ç³»åˆ—çš„è§†è§‰é£æ ¼
- **ç°ä»£ä¸­å›½é£è®¾è®¡**ï¼šå½“ä»£ä¸­å›½æ’ç”»å¸ˆä½œå“ã€æ–°ä¸­å¼è®¾è®¡å…ƒç´ 

### 2.3 åä¸½è‰²å½©æ–¹æ¡ˆ
- **ä¸»è¦è‰²å½©**:
  - çš‡å®¶ç¿¡ç¿ ç»¿ (#1A5F4A)ï¼šä»£è¡¨æˆé•¿ã€å®é™ä¸è‡ªç„¶ï¼Œçµæ„Ÿæ¥è‡ªä¼ ç»Ÿä¸­å›½ç‰å™¨
  - å¯Œè´µç«¹ç»¿ (#88B04B)ï¼šè±¡å¾ç†ŠçŒ«çš„é£Ÿç‰©å’Œæ´»åŠ›ï¼Œä¼ é€’ç”Ÿæœºä¸å¸Œæœ›
  - ç‘é›ªç™½ (#F7F9F9)ï¼šæä¾›è§†è§‰å‘¼å¸ç©ºé—´å’Œæ¸…æ™°åº¦ï¼Œè±¡å¾çº¯å‡€ä¸å’Œè°
  - æœ±ç ‚çº¢ (#D73E35)ï¼šä¼ ç»Ÿä¸­å›½çº¢ï¼Œè±¡å¾å–œåº†ã€æ´»åŠ›ä¸å¥½è¿

- **ç‚¹ç¼€è‰²å½©**:
  - åè´µé‡‘ (#D4AF37)ï¼šçªå‡ºæˆå°±å’Œé«˜çº§å…ƒç´ ï¼Œçµæ„Ÿæ¥è‡ªå¤ä»£ä¸­å›½é‡‘é¥°
  - é’èŠ±è“ (#1A6DB0)ï¼šä»£è¡¨æ°´åˆ†å’ŒæµåŠ¨ï¼Œçµæ„Ÿæ¥è‡ªé’èŠ±ç“·
  - ç‰¡ä¸¹ç²‰ (#F8C8DC)ï¼šå¢æ·»æ¸©æš–å’Œæƒ…æ„Ÿè¿æ¥ï¼Œçµæ„Ÿæ¥è‡ªä¸­å›½ä¼ ç»ŸèŠ±å‰
  - ç´«æª€ç´« (#5D3954)ï¼šå¢æ·»ç¥ç§˜æ„Ÿå’Œé«˜è´µæ„Ÿï¼Œçµæ„Ÿæ¥è‡ªä¼ ç»Ÿå®¶å…·

- **åŠŸèƒ½è‰²å½©**:
  - å¦‚æ„ç»¿ (#2E8B57)ï¼šè¡¨ç¤ºå®Œæˆå’Œç§¯ææˆæœï¼Œçµæ„Ÿæ¥è‡ªå¦‚æ„ç‰å™¨
  - ç¥ç€é»„ (#FFA500)ï¼šå¼•èµ·æ³¨æ„ä½†ä¸åˆºçœ¼ï¼Œçµæ„Ÿæ¥è‡ªå¤ä»£ç¥ç€é¥°å“
  - å¢¨ç° (#8A8D91)ï¼šç”¨äºæ¬¡è¦æ–‡æœ¬å’Œéæ´»åŠ¨å…ƒç´ ï¼Œçµæ„Ÿæ¥è‡ªæ°´å¢¨ç”»

### 2.4 å­—ä½“è®¾è®¡
- **ä¸»æ ‡é¢˜å­—ä½“**:
  - ä¸­æ–‡ï¼š**"æ–¹æ­£æ¸…åˆ»æœ¬æ‚¦å®‹"**ï¼Œä¼ é€’å…¸é›…ä¸æ°¸æ’æ„Ÿ
  - è‹±æ–‡ï¼š**"Playfair Display"**ï¼Œä¸ä¸­æ–‡å­—ä½“é£æ ¼ç›¸åè°ƒ
  - ç”¨äºé¡µé¢æ ‡é¢˜ã€æˆå°±åç§°å’Œé‡è¦æ ‡ç­¾ï¼Œé…ä»¥é‡‘è‰²æè¾¹å¢å¼ºåä¸½æ„Ÿ

- **æ­£æ–‡å­—ä½“**:
  - ä¸­æ–‡ï¼š**"æ€æºå®‹ä½“"**ï¼Œé«˜å¯è¯»æ€§ï¼Œå¸¦æœ‰å‹å¥½ã€å¹³æ˜“è¿‘äººçš„æ„Ÿè§‰
  - è‹±æ–‡ï¼š**"Nunito Sans"**ï¼Œä¸ä¸­æ–‡å­—ä½“æ­é…å’Œè°
  - ç”¨äºä»»åŠ¡æè¿°ã€è¯´æ˜å’Œä¸€èˆ¬å†…å®¹ï¼Œä¿æŒæ¸…æ™°æ˜“è¯»

- **è£…é¥°å­—ä½“**:
  - ä¸­æ–‡ï¼š**"åºé—¨æ­£é“è¡Œä¹¦"**ï¼Œå¢æ·»ä¸ªäººã€äº²å¯†çš„è§¦æ„Ÿï¼Œæ¨¡ä»¿ä¼ ç»Ÿä¹¦æ³•
  - è‹±æ–‡ï¼š**"Caveat"**ï¼Œæ‰‹å†™é£æ ¼å…ƒç´ 
  - è°¨æ…ä½¿ç”¨äºå¼•è¨€ã€åæ€å’Œæ¥è‡ªç†ŠçŒ«çš„ç‰¹æ®Šä¿¡æ¯ï¼Œå¢æ·»æƒ…æ„Ÿè¿æ¥

### 2.5 UIç»„ä»¶è®¾è®¡æŒ‡å—
- **æŒ‰é’®**ï¼šä¼ ç»Ÿä¸­å›½é£æ ¼å…ƒç´ ï¼ˆå¦‚äº‘çº¹ã€å¦‚æ„çº¹ï¼‰è£…é¥°çš„è½¯åœ†è§’çŸ©å½¢ï¼Œé…ä»¥ç²¾è‡´æ¸å˜å’Œé‡‘è‰²ç‚¹ç¼€ï¼Œç‚¹å‡»æ—¶æœ‰åä¸½ç²’å­æ•ˆæœ
- **å¡ç‰‡**ï¼šå±‚å è®¾è®¡ï¼Œå¸¦æœ‰ç²¾è‡´é˜´å½±å’Œçº¹ç†èƒŒæ™¯ï¼Œè¾¹æ¡†é‡‡ç”¨ä¼ ç»Ÿä¸­å›½çº¹é¥°ï¼Œé‡è¦å¡ç‰‡æœ‰é‡‘è‰²æˆ–çº¢è‰²æè¾¹
- **å›¾æ ‡**ï¼šæ°´å¢¨ç”»é£æ ¼ï¼Œç¬”è§¦ä¸€è‡´ï¼Œåœ†æ¶¦è¾¹è§’ï¼Œèå…¥ä¼ ç»Ÿä¸­å›½å…ƒç´ ï¼ˆå¦‚ç«¹ã€å±±æ°´ã€èŠ±é¸Ÿï¼‰
- **è¿›åº¦æŒ‡ç¤ºå™¨**ï¼šä¼˜é›…çš„ç¯å½¢æˆ–çº¿æ€§è®¾è®¡ï¼ŒåŠ¨ç”»å¡«å……æ•ˆæœæ¨¡ä»¿æ°´å¢¨æ™•æŸ“ï¼Œé‡è¦è¿›åº¦æ¡é‡‡ç”¨å·è½´æˆ–ç«¹ç®€å½¢å¼
- **è¾“å…¥æ¡†**ï¼šç®€çº¦è®¾è®¡ï¼Œå¸¦æœ‰å¾®å¦™è¾¹æ¡†å’Œç„¦ç‚¹çŠ¶æ€ï¼Œè¾¹æ¡†é‡‡ç”¨ä¼ ç»Ÿçº¹é¥°ï¼Œæ¿€æ´»æ—¶æœ‰æ°´å¢¨æ‰©æ•£æ•ˆæœ
- **å¼¹çª—**ï¼šå±…ä¸­è®¾è®¡ï¼Œè£…é¥°æ€§æ¡†æ¶é‡‡ç”¨ä¼ ç»Ÿçª—æ£‚æ ·å¼ï¼ŒåŠé€æ˜èƒŒæ™¯æ¨¡ä»¿å®£çº¸è´¨æ„Ÿï¼Œé‡è¦å¼¹çª—æœ‰çº¢è‰²æˆ–é‡‘è‰²è£…é¥°

## 3. ä¿¡æ¯æ¶æ„

### 3.1 å¯¼èˆªç»“æ„
åŸºäºPRDï¼ŒPandaHabitå°†ä½¿ç”¨åº•éƒ¨æ ‡ç­¾å¯¼èˆªï¼Œå…·æœ‰ä»¥ä¸‹ä¸»è¦éƒ¨åˆ†ï¼Œæ¯ä¸ªå¯¼èˆªå›¾æ ‡éƒ½é‡‡ç”¨åä¸½çš„ä¸­å›½é£è®¾è®¡ï¼š

1. **ä¸»é¡µï¼ˆç«¹æ—å®¶å›­ï¼‰**ï¼šä¸»ä»ªè¡¨ç›˜ï¼Œå±•ç¤ºç†ŠçŒ«ã€åŠæ—¶å¥–åŠ±è¿›åº¦æ¡å’Œå¿«é€Ÿæ“ä½œï¼ŒèƒŒæ™¯ä¸ºåŠ¨æ€ç«¹æ—åœºæ™¯
2. **ä»»åŠ¡ï¼ˆä¿®è¡Œä¹‹è·¯ï¼‰**ï¼šæ—¥å¸¸ä»»åŠ¡åˆ—è¡¨å’Œç®¡ç†ï¼Œè®¾è®¡ä¸ºå¤ä»£å·è½´æ ·å¼
3. **æŒ‘æˆ˜ï¼ˆæ±Ÿæ¹–å†ç»ƒï¼‰**ï¼šé•¿æœŸç›®æ ‡å’Œç‰¹åˆ«æ´»åŠ¨ï¼Œè®¾è®¡ä¸ºåœ°å›¾æ¢é™©é£æ ¼
4. **æ—…ç¨‹ï¼ˆæˆé•¿ä¹‹é“ï¼‰**ï¼šç†ŠçŒ«æˆé•¿è·¯å¾„å’Œé‡Œç¨‹ç¢‘ï¼Œè®¾è®¡ä¸ºä¼ ç»Ÿå±±æ°´ç”»å·
5. **å•†åº—ï¼ˆçå®é˜ï¼‰**ï¼šè£…é¥°ç‰©å“ã€èµ„æºå’ŒVIPè®¢é˜…ï¼Œè®¾è®¡ä¸ºå¤ä»£å•†é“ºé£æ ¼

æ¬¡è¦å¯¼èˆªåŒ…æ‹¬ï¼š
- **ç†ŠçŒ«äº’åŠ¨ï¼ˆå¿ƒçµç›¸é€šï¼‰**ï¼šé€šè¿‡ç‚¹å‡»ä¸»é¡µä¸Šçš„ç†ŠçŒ«è®¿é—®ï¼Œè®¾è®¡ä¸ºç²¾ç¾çš„äº’åŠ¨åœºæ™¯
- **å¹¸è¿æŠ½å¥–ï¼ˆç¦ç¼˜æŠ½ç­¾ï¼‰**ï¼šé€šè¿‡é¡¶éƒ¨å¯¼èˆªä¸­çš„ä¸“ç”¨å›¾æ ‡è®¿é—®ï¼Œè®¾è®¡ä¸ºä¼ ç»ŸæŠ½ç­¾ä¸å®ç®±ç›¸ç»“åˆçš„å½¢å¼
- **è®¾ç½®ï¼ˆç‰ç®€è®¾å®šï¼‰**ï¼šé€šè¿‡å³ä¸Šè§’çš„é½¿è½®å›¾æ ‡è®¿é—®ï¼Œå›¾æ ‡è®¾è®¡ä¸ºå¤ä»£ç‰ç®€
- **åæ€æ¨¡å—ï¼ˆé™å¿ƒèŒ¶å®¤ï¼‰**ï¼šæ ¹æ®ç”¨æˆ·è¡Œä¸ºæƒ…å¢ƒè§¦å‘ï¼Œè®¾è®¡ä¸ºå®é™çš„ä¼ ç»ŸèŒ¶å®¤ç¯å¢ƒ

### 3.2 ç”¨æˆ·æµç¨‹å›¾
å…³é”®ç”¨æˆ·æµç¨‹åŒ…æ‹¬ï¼Œæ¯ä¸ªæµç¨‹éƒ½é…æœ‰åä¸½çš„è¿‡æ¸¡åŠ¨ç”»å’Œè§†è§‰å¼•å¯¼ï¼š

1. **æ–°ç”¨æˆ·å¼•å¯¼ï¼ˆåˆå…¥ä»™å¢ƒï¼‰**ï¼š
   - åº”ç”¨ä»‹ç»ï¼ˆå¤å·å±•å¼€åŠ¨ç”»ï¼‰â†’ ç†ŠçŒ«å®šåˆ¶ï¼ˆæ°´å¢¨æ¸²æŸ“æ•ˆæœï¼‰â†’ é¦–ä¸ªä»»åŠ¡è®¾ç½®ï¼ˆå·è½´ä¹¦å†™åŠ¨ç”»ï¼‰â†’ ä»»åŠ¡å®Œæˆï¼ˆé‡‘å…‰ç‰¹æ•ˆï¼‰â†’ å¥–åŠ±ï¼ˆå®ç®±å¼€å¯åŠ¨ç”»ï¼‰â†’ ä¸»é¡µï¼ˆç«¹æ—å±•å¼€æ•ˆæœï¼‰

2. **æ—¥å¸¸ä¹ æƒ¯æ‰“å¡ï¼ˆæ¯æ—¥ä¿®è¡Œï¼‰**ï¼š
   - é€šçŸ¥ï¼ˆç†ŠçŒ«ä¿¡ä½¿åŠ¨ç”»ï¼‰â†’ ä»»åŠ¡é¡µé¢ï¼ˆå·è½´å±•å¼€ï¼‰â†’ ä»»åŠ¡å®Œæˆï¼ˆå¢¨è¿¹æ¸²æŸ“åŠ¨ç”»ï¼‰â†’ åŠæ—¶å¥–åŠ±ï¼ˆé‡‘å¸é£èˆæ•ˆæœï¼‰â†’ ç†ŠçŒ«äº’åŠ¨ï¼ˆç†ŠçŒ«æ¬¢å–œåŠ¨ç”»ï¼‰

3. **æŒ‘æˆ˜å‚ä¸ï¼ˆæ±Ÿæ¹–æ¢ç´¢ï¼‰**ï¼š
   - æŒ‘æˆ˜é¡µé¢ï¼ˆåœ°å›¾å±•å¼€åŠ¨ç”»ï¼‰â†’ æŒ‘æˆ˜é€‰æ‹©ï¼ˆåœ°ç‚¹ç‚¹äº®æ•ˆæœï¼‰â†’ æ—¥å¸¸å­ä»»åŠ¡ï¼ˆå°å·è½´å±•å¼€ï¼‰â†’ è¿›åº¦è·Ÿè¸ªï¼ˆåœ°å›¾è·¯å¾„ç‚¹äº®ï¼‰â†’ å®Œæˆå¥–åŠ±ï¼ˆå®ç®±åä¸½å¼€å¯ï¼‰

4. **åæ€è¿‡ç¨‹ï¼ˆèŒ¶é“é™å¿ƒï¼‰**ï¼š
   - è§¦å‘äº‹ä»¶ï¼ˆèŒ¶æ¯å›¾æ ‡å‡ºç°ï¼‰â†’ æ¸©å’Œæç¤ºï¼ˆç†ŠçŒ«é‚€è¯·åŠ¨ç”»ï¼‰â†’ åæ€é—®é¢˜ï¼ˆæ°´å¢¨æ‰©æ•£æ•ˆæœï¼‰â†’ æ”¯æŒæ€§åé¦ˆï¼ˆç†ŠçŒ«å®‰æ…°åŠ¨ç”»ï¼‰â†’ è¡ŒåŠ¨å»ºè®®ï¼ˆç«¹ç®€å±•å¼€æ•ˆæœï¼‰

5. **VIPè½¬åŒ–ï¼ˆé£å‡ä¹‹è·¯ï¼‰**ï¼š
   - åŠŸèƒ½äº’åŠ¨ï¼ˆé‡‘è‰²å…‰èŠ’æç¤ºï¼‰â†’ VIPæç¤ºï¼ˆåä¸½å·è½´å±•å¼€ï¼‰â†’ ç¦åˆ©å±•ç¤ºï¼ˆé‡‘å…‰ç‰¹æ•ˆå±•ç¤ºï¼‰â†’ è®¢é˜…é€‰æ‹©ï¼ˆç‰ç’§é€‰æ‹©ç•Œé¢ï¼‰â†’ è´­ä¹°ç¡®è®¤ï¼ˆç¥¥äº‘ç¯ç»•åŠ¨ç”»ï¼‰

### 3.3 å±å¹•å±‚æ¬¡ç»“æ„
å±å¹•å±‚æ¬¡ç»“æ„éµå¾ªä»ä¸€èˆ¬åˆ°ç‰¹å®šçš„é€»è¾‘è¿›å±•ï¼Œæ¯ä¸€å±‚éƒ½æœ‰ç‹¬ç‰¹çš„è§†è§‰é£æ ¼ï¼š

- **ç¬¬ä¸€å±‚**ï¼šä¸»æ ‡ç­¾å±å¹•ï¼ˆç«¹æ—å®¶å›­ã€ä¿®è¡Œä¹‹è·¯ã€æ±Ÿæ¹–å†ç»ƒã€æˆé•¿ä¹‹é“ã€çå®é˜ï¼‰ï¼Œè®¾è®¡ä¸ºå®Œæ•´çš„åœºæ™¯ç”»é¢
- **ç¬¬äºŒå±‚**ï¼šç‰¹å®šåŠŸèƒ½å±å¹•ï¼ˆå¿ƒçµç›¸é€šã€ç¦ç¼˜æŠ½ç­¾ã€ç‰ç®€è®¾å®šï¼‰ï¼Œè®¾è®¡ä¸ºä¸»åœºæ™¯çš„ç‰¹å†™æˆ–å˜ä½“
- **ç¬¬ä¸‰å±‚**ï¼šè¯¦æƒ…å±å¹•ï¼ˆä»»åŠ¡è¯¦æƒ…ã€æŒ‘æˆ˜è¯¦æƒ…ã€ç‰©å“è¯¦æƒ…ï¼‰ï¼Œè®¾è®¡ä¸ºç²¾ç¾çš„å·è½´æˆ–ç‰ç®€å±•å¼€
- **ç¬¬å››å±‚**ï¼šæµç¨‹å±å¹•ï¼ˆé™å¿ƒèŒ¶å®¤ã€VIPè´­ä¹°ã€ä»»åŠ¡åˆ›å»ºï¼‰ï¼Œè®¾è®¡ä¸ºç‰¹æ®Šäº’åŠ¨åœºæ™¯

## 4. Detailed UI/UX Design

### 4.1 ä¸»é¡µï¼ˆç«¹æ—å®¶å›­ï¼‰
ä¸»é¡µæ˜¯æƒ…æ„Ÿä¸­å¿ƒå’Œä¸»è¦ä»ªè¡¨ç›˜ï¼Œéœ€å¼ºåŒ–â€œåä¸½æ¸¸æˆé£æ ¼â€ä¸äº’åŠ¨ä½“éªŒï¼š

- **é¡¶éƒ¨åŒºåŸŸ**ï¼š
  - ç”¨æˆ·å¤´åƒ/èµ„æ–™ï¼ˆå·¦ä¸Šï¼‰ï¼ŒVIPç”¨æˆ·æœ‰ä¸“å±å¾½ç« ä¸åŠ¨ç”»å…‰æ•ˆ
  - è´§å¸æ˜¾ç¤ºï¼ˆé‡‘å¸ã€é’»çŸ³ã€å¹¸è¿ç‚¹ï¼‰ï¼Œé‡‡ç”¨ç«‹ä½“é‡‘å±è´¨æ„Ÿä¸ç²’å­ç‰¹æ•ˆ
  - è®¾ç½®é½¿è½®ï¼ˆå³ä¸Šï¼‰ï¼Œä»¥ç‰ç®€æˆ–ç¥¥äº‘ä¸ºé€ å‹ï¼Œå¸¦å…¥åœºåŠ¨ç”»
  - å¹¸è¿æŠ½å¥–å…¥å£ï¼Œå¸¸é©»é—ªçƒç²’å­ä¸åŠ¨æ€é«˜äº®

- **ä¸­å¤®åŒºåŸŸ**ï¼š
  - å¤§å¹…ç²¾ç¾ç†ŠçŒ«æ’ç”»ï¼Œåˆ†é˜¶æ®µæˆé•¿ï¼ŒçŠ¶æ€ä¸äº’åŠ¨å‡æœ‰ä¸°å¯ŒåŠ¨ç”»ï¼ˆå¦‚çœ¨çœ¼ã€ä¼¸æ‡’è…°ã€æ’’å¨‡ï¼‰
  - ç¯å¢ƒä¸ºåŠ¨æ€ç«¹æ—ï¼Œéšæ—¶é—´å˜åŒ–å…‰å½±ï¼ŒåŠ å…¥è´è¶ã€ç«¹å¶é£˜è½ç­‰ç²’å­åŠ¨æ•ˆ
  - åŠæ—¶æ€§è¿›åº¦æ¡è®¾è®¡ä¸ºåä¸½å·è½´æˆ–ç«¹ç®€ï¼Œå¡«å……åŠ¨ç”»æœ‰æ°´å¢¨æ™•æŸ“ä¸é‡‘å…‰ç²’å­
  - å¥–åŠ±é¢„è§ˆé‡‡ç”¨å®ç®±/å·è½´å±•å¼€åŠ¨ç”»ï¼Œå¥–åŠ±å›¾æ ‡æœ‰é«˜å…‰ä¸å¼¹è·³ç‰¹æ•ˆ

- **åº•éƒ¨åŒºåŸŸ**ï¼š
  - æ´»è·ƒä»»åŠ¡å¿«æ·å…¥å£ï¼Œå¡ç‰‡é‡‡ç”¨æµ®é›•ã€é‡‘è¾¹ã€äº‘çº¹ç­‰è£…é¥°ï¼Œå®Œæˆæ—¶æœ‰ç²’å­çˆ†å‘åŠ¨ç”»
  - æœ€è¿‘å¥–åŠ±æ—¥å¿—ï¼Œå›¾æ ‡é€æ¡æ»šåŠ¨å‡ºç°ï¼Œå¸¦æœ‰æ·¡å…¥æ·¡å‡ºä¸ç²’å­ç‚¹ç¼€
  - åº•éƒ¨å¯¼èˆªæ ä¸ºè‡ªå®šä¹‰ä¸­å›½é£å›¾æ ‡ï¼Œé€‰ä¸­æœ‰ç¥¥äº‘æµåŠ¨ä¸é«˜äº®ç‰¹æ•ˆï¼Œæ•´ä½“é‡‡ç”¨åŠé€æ˜ç‰çŸ³è´¨æ„Ÿ

### 4.2 ä»»åŠ¡é¡µï¼ˆä¿®è¡Œä¹‹è·¯ï¼‰
ä»»åŠ¡é¡µéœ€çªå‡ºâ€œå¤å·â€ä¸â€œåä¸½åŠ¨æ•ˆâ€ä¸»é¢˜ï¼Œæå‡äº¤äº’ä»ªå¼æ„Ÿï¼š

- **é¡¶éƒ¨åŒºåŸŸ**ï¼š
  - æ—¥æœŸå±•ç¤ºé‡‡ç”¨ä¹¦æ³•å­—ä½“ä¸ç¥¥äº‘è£…é¥°ï¼ŒèƒŒæ™¯ä¸ºæ·¡é›…å®£çº¸çº¹ç†
  - æ¯æ—¥è¿›åº¦æ¡ä¸ºå·è½´å±•å¼€åŠ¨ç”»ï¼Œå¡«å……æ—¶æœ‰æ°´å¢¨æ™•æŸ“ä¸é‡‘å…‰ç²’å­
  - ç­›é€‰/æ’åºä¸‹æ‹‰èœå•ä¸ºç‰ä½©/ç«¹ç®€é€ å‹ï¼Œå±•å¼€æœ‰å¼¹æ€§åŠ¨ç”»

- **ä»»åŠ¡åˆ—è¡¨**ï¼š
  - æ»šåŠ¨åˆ—è¡¨ï¼Œæ¯ä¸ªä»»åŠ¡å¡ç‰‡ä¸ºç«‹ä½“æµ®é›•å·è½´ï¼Œè¾¹æ¡†æœ‰é‡‘è‰²æè¾¹ä¸äº‘çº¹
  - ä»»åŠ¡ç±»å‹å›¾æ ‡ä¸ºæ°´å¢¨é£ï¼Œä»»åŠ¡åç”¨å®‹ä½“/ä¹¦æ³•å­—ä½“ï¼Œé‡è¦ä»»åŠ¡æœ‰ç‰¹æ®Šé«˜äº®
  - å¥–åŠ±é¢„è§ˆå›¾æ ‡æœ‰å¼¹è·³ä¸é«˜å…‰åŠ¨ç”»
  - åŠæ—¶æ€§ä»»åŠ¡æœ‰â°/âœ¨ç‰¹æ•ˆï¼Œå®Œæˆæ—¶æœ‰ç²’å­çˆ†å‘ä¸å·è½´å°ç« åŠ¨ç”»
  - æ—¶é—´çª—å£å€’è®¡æ—¶ä¸ºåŠ¨æ€æ²™æ¼/æ°´æ»´ï¼ŒæŒ‘æˆ˜/è‡ªå®šä¹‰ç›®æ ‡æœ‰ä¸“å±æ ‡è¯†ï¼ˆå¦‚ç«ç„°/ç†ŠçŒ«å¤´åƒï¼‰

- **æ–°å¢ä»»åŠ¡æŒ‰é’®**ï¼š
  - æ‚¬æµ®é‡‘è‰²åœ†å½¢æŒ‰é’®ï¼Œä¸­å¿ƒä¸ºåŠ å·ï¼ŒæŒ‰é’®æœ‰è„‰å†²å…‰åœˆä¸ç²’å­ç¯ç»•

### 4.3 æŒ‘æˆ˜é¡µï¼ˆæ±Ÿæ¹–å†ç»ƒï¼‰
æŒ‘æˆ˜é¡µéœ€å¼ºåŒ–â€œåœ°å›¾æ¢é™©â€ä¸â€œæˆå°±æ„Ÿâ€è§†è§‰ï¼š

- **é¡¶éƒ¨åŒºåŸŸ**ï¼š
  - æŒ‘æˆ˜åˆ†ç±»Tabä¸ºå¤ä»£ä»¤ç‰Œ/ç«¹ç®€é€ å‹ï¼Œåˆ‡æ¢æœ‰ç¿»è½¬/å·è½´å±•å¼€åŠ¨ç”»
  - é¡¶éƒ¨è£…é¥°éšæŒ‘æˆ˜ä¸»é¢˜å˜æ¢ï¼ˆå¦‚å±±æ°´ã€ç«ç„°ã€ç¥¥äº‘ï¼‰

- **æŒ‘æˆ˜å¡ç‰‡**ï¼š
  - å¡ç‰‡ä¸ºç«‹ä½“æµ®é›•ï¼ŒèƒŒæ™¯ä¸ºåœ°å›¾/å±±æ°´ç”»å·ï¼Œä¸»æ ‡é¢˜ç”¨é‡‘è‰²æè¾¹å­—ä½“
  - å…³é”®å¥–åŠ±æœ‰å®ç®±/ç‰ç’§é«˜äº®å±•ç¤ºï¼Œå¥–åŠ±å›¾æ ‡æœ‰å…‰æ™•ä¸ç²’å­ç‰¹æ•ˆ
  - è¿›åº¦æ¡ä¸ºç«¹èŠ‚/å·è½´ï¼Œå¡«å……æœ‰æ°´å¢¨æµåŠ¨åŠ¨ç”»
  - æ—¶é—´é™åˆ¶ä¸ºåŠ¨æ€å€’è®¡æ—¶ï¼Œæœªå®Œæˆæ—¶æœ‰è½»å¾®é—ªçƒ
  - å­ä»»åŠ¡å¯å±•å¼€ï¼Œå®Œæˆæœ‰å°ç« /ç¥¥äº‘åŠ¨ç”»
  - æ¥å—/é¢†å–æŒ‰é’®ä¸ºç‰ä½©é€ å‹ï¼Œç‚¹å‡»æœ‰å¼¹è·³ä¸ç²’å­çˆ†å‘

### 4.4 æˆé•¿ä¹‹é“ï¼ˆæ—…ç¨‹é¡µï¼‰
æˆé•¿ä¹‹é“éœ€çªå‡ºâ€œè¿›åŒ–ä»ªå¼æ„Ÿâ€ä¸â€œä¸œæ–¹ç¾å­¦â€ï¼š

- **æˆé•¿è·¯å¾„å¯è§†åŒ–**ï¼š
  - é‡‡ç”¨å±±æ°´ç”»å·å¼æ—¶é—´è½´æˆ–æ ‘çŠ¶ç»“æ„ï¼ŒèŠ‚ç‚¹é—´ç”¨ç¥¥äº‘/ç«¹èŠ‚è¿æ¥
  - æ¯ä¸ªèŠ‚ç‚¹ä¸ºç†ŠçŒ«ä¸åŒæˆé•¿é˜¶æ®µå°åƒï¼Œå®ŒæˆèŠ‚ç‚¹æœ‰é‡‘å…‰é«˜äº®ä¸ç²’å­åº†ç¥
  - å½“å‰èŠ‚ç‚¹è„‰å†²åŠ¨ç”»ï¼Œæœªè§£é”èŠ‚ç‚¹åŠé€æ˜å¹¶æœ‰ç¥ç§˜å…‰æ•ˆ
  - å¥–åŠ±é¢„è§ˆä¸ºç‰ç®€/å®ç®±å±•å¼€ï¼Œå¥–åŠ±å›¾æ ‡æœ‰é«˜å…‰ä¸å¼¹è·³

- **Milestone Log**:
  - Scrollable timeline with rich visual treatment
  - Achievement cards with decorative frames
  - Date stamps with elegant typography
  - Reward recap with animated icons

### 4.5 å•†åº—é¡µï¼ˆçå®é˜ï¼‰
å•†åº—é¡µéœ€è¥é€ â€œå¥¢åè´­ç‰©â€ä¸â€œæ”¶è—å±•ç¤ºâ€æ°›å›´ï¼š

- **é¡¶éƒ¨åŒºåŸŸ**ï¼š
  - æœç´¢æ ä¸ºç‰ç®€/ç¥¥äº‘é€ å‹ï¼Œè¾“å…¥æ—¶æœ‰å…‰æ•ˆæµåŠ¨
  - åˆ†ç±»ç­›é€‰ä¸ºç«‹ä½“ç‰ä½©/å·è½´ï¼Œé€‰ä¸­æœ‰é«˜äº®ä¸ç²’å­ç¯ç»•
  - ç‰¹è‰²å•†å“è½®æ’­ä¸ºå®ç®±/ç‰ç’§å±•ç¤ºï¼Œåˆ‡æ¢æœ‰ç¿»è½¬åŠ¨ç”»

- **å•†å“ç½‘æ ¼**ï¼š
  - å•†å“å¡ç‰‡ä¸ºæµ®é›•é‡‘è¾¹ï¼Œæ’ç”»é«˜ç²¾åº¦å¹¶å¸¦æœ‰å¾®åŠ¨ç”»
  - ä»·æ ¼ç”¨é‡‘è‰²å­—ä½“ä¸ç«‹ä½“è´§å¸å›¾æ ‡ï¼ŒVIPå•†å“æœ‰ä¸“å±å…‰æ•ˆä¸æ ‡è¯†

- **å•†å“è¯¦æƒ…**ï¼š
  - å¤§å›¾é¢„è§ˆæ”¯æŒ3Dæ—‹è½¬ï¼Œæè¿°åŒºç”¨å®‹ä½“/ä¹¦æ³•å­—ä½“
  - ç†ŠçŒ«å®šåˆ¶ç±»å•†å“æœ‰å‰åå¯¹æ¯”åŠ¨ç”»
  - è´­ä¹°æŒ‰é’®ä¸ºç‰ç’§/ç¥¥äº‘é€ å‹ï¼Œç‚¹å‡»æœ‰ç²’å­çˆ†å‘
  - ç›¸å…³å•†å“æ¨ªå‘æ»šåŠ¨ï¼Œå¡ç‰‡æœ‰å¼¹è·³ä¸é«˜å…‰

### 4.6 ç†ŠçŒ«äº’åŠ¨é¡µï¼ˆå¿ƒçµç›¸é€šï¼‰
å¼ºåŒ–â€œäº²å¯†äº’åŠ¨â€ä¸â€œåŠ¨æ€ç¯å¢ƒâ€ä½“éªŒï¼š

- **ç¯å¢ƒè®¾è®¡**ï¼š
  - èƒŒæ™¯ä¸ºé«˜ç²¾åº¦ä¸­å›½å›­æ—ï¼Œéšæ—¶é—´å˜åŒ–å…‰å½±ï¼ŒåŠ å…¥åŠ¨æ€æ°´é¢ã€ç«¹å¶ã€ç¥¥äº‘ç­‰ç²’å­
  - ç¯å¢ƒå…ƒç´ å¯äº¤äº’ï¼ˆå¦‚ç‚¹å‡»æ°´æ± æœ‰æ¶Ÿæ¼ªï¼Œç«¹å¶å¯é£˜è½ï¼‰

- **ç†ŠçŒ«å¯è§†åŒ–**ï¼š
  - ç†ŠçŒ«å¤§å¹…åŠ¨æ€æ’ç”»ï¼Œæƒ…ç»ªé€šè¿‡è¡¨æƒ…ã€åŠ¨ä½œã€ç‰¹æ•ˆå±•ç°ï¼ˆå¦‚å¼€å¿ƒæ—¶æœ‰é‡‘å…‰ã€æ’’å¨‡æ—¶æœ‰çˆ±å¿ƒç²’å­ï¼‰
  - å®šåˆ¶è£…é¥°é«˜ç²¾åº¦æ¸²æŸ“ï¼Œç¨€æœ‰ç‰©å“æœ‰ç‰¹æ®Šå…‰æ•ˆ

- **äº’åŠ¨æ§ä»¶**ï¼š
  - æŒ‰é’®ä¸ºç‰ä½©/ç¥¥äº‘é€ å‹ï¼Œç‚¹å‡»æœ‰å¼¹è·³ä¸ç²’å­åŠ¨ç”»
  - å–‚é£Ÿã€ç©è€ã€è®­ç»ƒå‡æœ‰ä¸“å±åŠ¨ç”»ä¸å¥–åŠ±åé¦ˆ
  - åæ€æç¤ºä¸ºæ¸©æŸ”å¼¹çª—ï¼ŒèƒŒæ™¯è™šåŒ–å¹¶æœ‰ç¥¥äº‘ç¯ç»•

### 4.7 å¹¸è¿æŠ½å¥–é¡µï¼ˆç¦ç¼˜æŠ½ç­¾ï¼‰
çªå‡ºâ€œä»ªå¼æ„Ÿâ€ä¸â€œæƒŠå–œæ„Ÿâ€è§†è§‰ï¼š

- **é¡¶éƒ¨åŒºåŸŸ**ï¼š
  - å¹¸è¿ç‚¹ä½™é¢ä¸ºç«‹ä½“ç‰ç’§è®¡æ•°å™¨ï¼Œå‘¨å›´å¸¸é©»é—ªçƒç²’å­

- **æŠ½å¥–æœºåˆ¶**ï¼š
  - æŠ½å¥–åŠ¨ç”»ä¸ºåä¸½å®ç®±/è½¬ç›˜/ç«¹ç®€å±•å¼€ï¼Œç²’å­ä¸éŸ³æ•ˆè¥é€ æœŸå¾…æ°›å›´
  - æŠ½å¥–æŒ‰é’®ä¸ºé‡‘è‰²ç¥¥äº‘é€ å‹ï¼Œç‚¹å‡»æœ‰é«˜å…‰ä¸ç²’å­çˆ†å‘
  - ç»“æœæ­æ™“æœ‰å·è½´å±•å¼€ã€å®ç®±å¼€å¯ç­‰åº†ç¥åŠ¨ç”»

- **å¥–æ± å±•ç¤º**ï¼š
  - å¥–å“ä»¥ç”»å»Šå½¢å¼å±•ç¤ºï¼Œç¨€æœ‰åº¦ç”¨é‡‘å…‰/ç¥¥äº‘ç‰¹æ•ˆåŒºåˆ†
  - æ¦‚ç‡ç”¨ç²¾ç¾æ•°æ®å¯è§†åŒ–ï¼Œè¿‘æœŸä¸­å¥–æœ‰æ—¶é—´è½´åŠ¨ç”»

### 4.8 åæ€æ¨¡å—ï¼ˆé™å¿ƒèŒ¶å®¤ï¼‰
è¥é€ â€œé™è°§æ²»æ„ˆâ€ä¸â€œæ¸©æŸ”æ”¯æŒâ€æ°›å›´ï¼š

- **è§†è§‰è®¾è®¡**ï¼š
  - èƒŒæ™¯ä¸ºæ·¡é›…èŒ¶å®¤/å±±æ°´ï¼Œç¥¥äº‘ã€èŒ¶çƒŸç­‰æŸ”å’ŒåŠ¨ç”»ï¼Œæ•´ä½“è‰²è°ƒæ¸©æš–æŸ”å’Œ
  - UIå…ƒç´ æç®€ï¼Œå‡å°‘å¹²æ‰°ï¼Œè¾“å…¥åŒºä¸ºå®£çº¸/ç«¹ç®€é€ å‹

- **äº¤äº’è®¾è®¡**ï¼š
  - ç†ŠçŒ«å¤´åƒæœ‰åŒç†å¿ƒè¡¨æƒ…ï¼Œæ–‡å­—å¯¹è¯é‡‡ç”¨é€å­—æ·¡å…¥åŠ¨ç”»
  - è¾“å…¥æ–¹å¼ä¸ºå®šåˆ¶æŒ‰é’®/æ¸©æŸ”æ–‡æœ¬æ¡†ï¼Œåé¦ˆæœ‰æ°´å¢¨æ‰©æ•£åŠ¨ç”»
  - é˜¶æ®µåˆ‡æ¢ä¸ºå·è½´å±•å¼€/ç¥¥äº‘æµåŠ¨ï¼Œæ•´ä½“è¿‡æ¸¡å¹³æ»‘

## 5. Core Gameplay Elements

### 5.1 Panda Companion Visualization
The Panda companion is the emotional heart of the app and features:

- **Growth Stages**:
  - Infant: Small, extra fluffy with large eyes and playful movements
  - Youth: More active, curious expressions, developing unique personality
  - Adult: Graceful, wise appearance with confident posture
  - Perfect Form: Majestic presence with subtle glow effects and special animations

- **Emotional States**:
  - Happy: Bright eyes, smiling expression, energetic movements
  - Neutral: Calm demeanor, regular breathing animation
  - Concerned: Gentle head tilt, softer movements, attentive gaze

- **Customization Visualization**:
  - Seamless integration of accessories and clothing
  - Environment decorations that the Panda interacts with
  - Special effects for rare or VIP items

### 5.2 Resource System Visualization
Resources are presented with premium visual treatment:

- **Resource Icons**:
  - Bamboo: Detailed, realistic bamboo stalks with subtle shine
  - Water: Crystal-clear droplets with light refraction effects
  - Coins: Ornate gold coins with embossed panda design
  - Diamonds: Multi-faceted gems with light reflection and sparkle

- **Resource Animations**:
  - Collection: Satisfying gather animation with particle effects
  - Spending: Elegant transfer animation from inventory to use
  - Low resources: Subtle visual indicator without being punitive
  - Resource milestone: Special celebration animation

### 5.3 Timely Reward System Visualization
The Timely Reward System features premium visual elements:

- **Timeliness Bar**:
  - Elegant scroll or bamboo-themed progress indicator
  - Rich fill animation with particle effects
  - Reward preview with subtle highlight animation
  - Completion celebration with luxurious visual effects

- **Luck Points**:
  - Premium counter with sparkle animation
  - Earning visualization with floating point animation
  - Accumulation milestone effects with special visual treatment

- **On-Time Completion**:
  - Satisfying visual feedback for timely task completion
  - Special animation for "Early Bird" bonus
  - Elegant visual connection between task completion and rewards

### 5.4 Challenge System Visualization
Challenges are presented with immersive visual elements:

- **Challenge Categories**:
  - Visual theming for different challenge types
  - Custom illustrations for challenge backgrounds
  - Animated transitions between categories

- **Progress Tracking**:
  - Rich progress bar design with milestone markers
  - Sub-task completion visualization with elegant checkmarks
  - Time remaining indicator with premium countdown design

- **Reward Presentation**:
  - Treasure chest or gift box animation for claiming rewards
  - Particle effects and sound design for celebration
  - Reward showcase with detailed item presentation

## 6. Monetization Design

### 6.1 VIP Subscription UI/UX
The VIP subscription is presented with a premium, value-focused approach:

- **VIP Badge Design**:
  - Elegant, non-intrusive badge with subtle animation
  - Tiered designs for different subscription levels
  - Special visual effects for VIP users' avatars

- **VIP Benefits Visualization**:
  - Clear, visually rich comparison between free and VIP
  - Animated demonstrations of enhanced features
  - Before/after visualizations of rewards and progression

- **Subscription Flow**:
  - Elegant, distraction-free purchase screen
  - Tiered options with visual hierarchy based on value
  - Secure payment visualization with premium styling
  - Thank you/confirmation screen with celebratory animation

### 6.2 Shop Design
The Shop provides a luxurious shopping experience:

- **Item Categories**:
  - Visual theming for different item types
  - Elegant category icons with selection effects
  - Featured items carousel with premium presentation

- **Item Presentation**:
  - High-quality item illustrations with subtle animations
  - 3D preview capability for certain items
  - Try-before-buy visualization for Panda customizations
  - Limited-time items with special visual treatment

- **Purchase Experience**:
  - Smooth, satisfying purchase animation
  - Elegant confirmation screen with item showcase
  - Gift wrapping animation for new acquisitions
  - Inventory update visualization

### 6.3 Conversion Optimization
Conversion points are designed to be compelling yet non-intrusive:

- **Feature Discovery**:
  - Elegant "VIP Feature" indicators on locked content
  - Subtle glow or highlight effects to draw attention
  - Preview capabilities with "Upgrade to Access" messaging

- **Value Demonstration**:
  - Visual comparisons showing enhanced rewards
  - Progress acceleration visualizations
  - Exclusive item showcases with premium presentation

- **Contextual Prompts**:
  - Thoughtfully timed upgrade suggestions
  - Elegant modal design for upgrade prompts
  - Clear value proposition with visual support

## 7. Technical Implementation Guidelines

### 7.1 Integration with Existing Codebase
The implementation will build upon the existing React/TypeScript architecture:

- Leverage the current component structure while enhancing visual elements
- Maintain the existing data flow patterns while adding new features
- Extend the current state management approach to include new game elements

### 7.2 Internationalization Approach
Building on the existing i18n infrastructure:

- Extend the current language system to include game-specific terminology
- Ensure all new UI elements support multiple languages
- Implement culturally appropriate visual elements for different regions

### 7.3 Component Structure
The component architecture will follow a modular approach:

- **Atomic Design Methodology**:
  - Atoms: Basic UI elements (buttons, inputs, icons)
  - Molecules: Compound components (task cards, reward displays)
  - Organisms: Feature sections (task list, panda interaction area)
  - Templates: Page layouts with placeholder content
  - Pages: Complete screens with real content

- **Game-Specific Components**:
  - PandaAvatar: Handles rendering and animating the Panda
  - ResourceDisplay: Manages resource visualization
  - RewardAnimation: Controls reward presentation effects
  - ChallengeTracker: Visualizes challenge progress

### 7.4 State Management
The state management approach will handle game-specific requirements:

- User progress and achievements stored in persistent state
- Real-time interactions managed with local state
- Animation states controlled with dedicated hooks
- Game mechanics (timers, random events) managed with specialized services

## 8. Appendices

### 8.1 Asset Requirements
- High-resolution Panda illustrations in various poses and growth stages
- Premium UI element designs (buttons, cards, icons)
- Environmental elements and backgrounds
- Resource and reward visualizations
- Animation sequences for key interactions

### 8.2 Animation Specifications
- Micro-interactions for UI elements (button presses, switches, sliders)
- Character animations for the Panda (idle, happy, concerned, interactions)
- Reward and achievement celebrations
- Transition effects between screens and states

### 8.3 Accessibility Considerations
- Color contrast compliance for all UI elements
- Alternative text for decorative elements
- Keyboard navigation support
- Screen reader compatibility
- Motion reduction options for animations
</file>

<file path="boost-sub.md">
å¥½çš„ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸æ£’çš„ä¼˜åŒ–åçš„è®¢é˜…ä»˜è´¹å¼•å¯¼Checklistï¼å®ƒç¡®å®æ›´å…·æˆ˜ç•¥æ€§ï¼Œå¹¶ä¸”èå…¥äº†å¾ˆå¤šé«˜çº§çš„ç”¨æˆ·å¢é•¿å’Œæ¸¸æˆåŒ–ç†å¿µã€‚

ç°åœ¨ï¼Œè®©æˆ‘ä»¬åŸºäºè¿™ä»½ **ã€æ¸¸æˆåŒ–Appè®¢é˜…å¢é•¿é»„é‡‘æ³•åˆ™ï¼šChecklist 2.0ã€‘**ï¼Œä¸ºæ‚¨çš„ **PandaHabit** App è®¾è®¡ç›¸å…³çš„ç•Œé¢å’Œäº¤äº’æµç¨‹ã€‚

**æ ¸å¿ƒå‰æï¼š** PandaHabit çš„æ ¸å¿ƒæ˜¯â€œå¥åº·ç”Ÿæ´»ä¼´ä¾£â€å’Œâ€œä¹ æƒ¯å…»æˆåŠ©æ‰‹â€ï¼Œå› æ­¤ä»˜è´¹å¼•å¯¼åº”å§‹ç»ˆå›´ç»•â€œæ›´å¥½åœ°æ”¯æŒç”¨æˆ·è¾¾æˆç›®æ ‡â€å’Œâ€œæ›´æ„‰å¿«åœ°ä¸ç†ŠçŒ«äº’åŠ¨â€å±•å¼€ï¼Œé¿å…å¼ºè¿«æ„Ÿã€‚

---

**PandaHabit è®¢é˜…ä»˜è´¹å¼•å¯¼ç•Œé¢è®¾è®¡ä¸äº¤äº’æµç¨‹**

**ç›®æ ‡ï¼š** å°†Checklist 2.0ä¸­çš„ç­–ç•¥è½¬åŒ–ä¸ºPandaHabitä¸­çš„å…·ä½“ç•Œé¢å’Œç”¨æˆ·ä½“éªŒã€‚

---

### **ä¸€ã€æ¸…æ™°çš„ä»·å€¼ä¸»å¼  (Clear Value Proposition)**

*â€œè®©ç©å®¶ä¸€çœ¼çœ‹æ‡‚â€˜æˆ‘ä¸ºä»€ä¹ˆéœ€è¦è¿™ä¸ªï¼Ÿâ€™å¹¶æ„Ÿåˆ°ç‰©è¶…æ‰€å€¼ã€‚â€*

**1.1. æ ¸å¿ƒç‰¹æƒå¯è§†åŒ–ä¸å·®å¼‚åŒ–**

*   **ç•Œé¢A1ï¼šVIPç‰¹æƒæ€»è§ˆé¡µé¢ (VIP Benefits Overview Page)**
    *   **è§¦å‘ç‚¹ï¼š** ç‚¹å‡»ä¸»ç•Œé¢çš„â€œVIPâ€å…¥å£ã€ç‰¹å®šåŠŸèƒ½å¼•å¯¼å¼¹çª—çš„â€œäº†è§£è¯¦æƒ…â€æŒ‰é’®ã€‚
    *   **å¸ƒå±€ï¼š**
        *   **é¡¶éƒ¨é†’ç›® Bannerï¼š** â€œæˆä¸ºç†ŠçŒ«å®ˆæŠ¤è€…ï¼Œè§£é”ä¸“å±ç‰¹æƒï¼â€ æˆ– â€œå‡çº§VIPï¼ŒåŠ é€Ÿä½ çš„å¥åº·æˆé•¿ä¹‹æ—…ï¼â€ã€‚
        *   **å¯¹æ¯”åˆ—è¡¨/å¡ç‰‡ï¼š** æ¸…æ™°å¹¶åˆ—å±•ç¤º **å…è´¹ç‰ˆ (Free Panda Friend)** vs **VIPç†ŠçŒ«å®ˆæŠ¤è€… (VIP Panda Guardian)** çš„æ ¸å¿ƒæƒç›Šå·®å¼‚ã€‚
            *   **èº«ä»½å½°æ˜¾ï¼š**
                *   **å…è´¹ç‰ˆï¼š** æ™®é€šç†ŠçŒ«å¤´åƒæ¡†ã€‚
                *   **VIPç‰ˆï¼š** **[åŠ¨æ€é—ªè€€ç«¹å¶å¤´åƒæ¡†]**ã€**[â€œå®ˆæŠ¤è€…â€ä¸“å±ç§°å·æ˜¾ç¤ºåœ¨æ˜µç§°æ—]**ã€**[èŠå¤©æ°”æ³¡ï¼ˆè‹¥æœ‰ç¤¾äº¤ï¼‰å¸¦æœ‰å°çš‡å† ]**ã€‚é…æœ‰å¯¹æ¯”å›¾ã€‚
            *   **åŠŸèƒ½/æ•ˆç‡å¯¹æ¯”ï¼š**
                *   **ä»»åŠ¡èµ„æºè·å–ï¼š** å…è´¹ç‰ˆï¼šç«¹å­x1ï¼›VIPç‰ˆï¼šç«¹å­x2 **[é¢å¤–éƒ¨åˆ†ç”¨é‡‘è‰²é«˜äº®]**ã€‚
                *   **ç†ŠçŒ«æˆé•¿é€Ÿåº¦ï¼š** å…è´¹ç‰ˆï¼šæ­£å¸¸é€Ÿåº¦ï¼›VIPç‰ˆï¼šæˆé•¿ç»éªŒ+50% **[ç»éªŒæ¡åŠ¨ç”»å¯¹æ¯”]**ã€‚
                *   **æ¯æ—¥å¹¸è¿æŠ½å¥–ï¼š** å…è´¹ç‰ˆï¼š1æ¬¡ï¼›VIPç‰ˆï¼š3æ¬¡ **[é¢å¤–æ¬¡æ•°é«˜äº®]**ã€‚
                *   **è‡ªå®šä¹‰ç›®æ ‡(Goal)æ•°é‡ï¼š** å…è´¹ç‰ˆï¼š1ä¸ªï¼›VIPç‰ˆï¼š5ä¸ªã€‚
            *   **ä¸“å±å†…å®¹è§£é”ï¼š**
                *   **ç†ŠçŒ«å¤–è§‚ï¼š** å…è´¹ç‰ˆï¼šåŸºç¡€å¤–è§‚ï¼›VIPç‰ˆï¼š**[è§£é”ä¸“å±VIPé™å®šç†ŠçŒ«çš®è‚¤/é¥°å“]** (å±•ç¤ºé¢„è§ˆå›¾)ã€‚
                *   **ç‰¹æ®Šæ”¯çº¿ä»»åŠ¡ï¼š** å…è´¹ç‰ˆï¼šæ— ï¼›VIPç‰ˆï¼š**[è§£é”â€œç†ŠçŒ«çš„ç§˜å¯†èŠ±å›­â€ç³»åˆ—ä¸“å±æ”¯çº¿ä»»åŠ¡ï¼Œå¥–åŠ±ä¸°åš]**ã€‚
                *   **é«˜çº§å†¥æƒ³/å‘¼å¸è¯¾ç¨‹ï¼š** å…è´¹ç‰ˆï¼šåŸºç¡€è¯¾ç¨‹ï¼›VIPç‰ˆï¼š**[è§£é”æ‰€æœ‰é«˜çº§/ä¸»é¢˜å†¥æƒ³ä¸å‘¼å¸è¯¾ç¨‹]**ã€‚
        *   **è¡ŒåŠ¨æŒ‰é’®ï¼š** â€œç«‹å³å‡çº§æˆä¸ºå®ˆæŠ¤è€…â€ã€â€œæŸ¥çœ‹è®¢é˜…é€‰é¡¹â€ã€‚
*   **ç•Œé¢A2ï¼šä»»åŠ¡/æˆé•¿èŠ‚ç‚¹å³æ—¶æ”¶ç›Šåé¦ˆ**
    *   **è§¦å‘ç‚¹ï¼š** å®Œæˆä»»åŠ¡ã€ç†ŠçŒ«å‡çº§ã€å¹¸è¿æŠ½å¥–è·å¾—å¥–åŠ±æ—¶ã€‚
    *   **äº¤äº’ï¼š**
        *   **ä»»åŠ¡å®Œæˆå¼¹çª—ï¼š**
            *   åŸºç¡€å¥–åŠ±ï¼šç«¹å­ +10, æ°´ +5
            *   **[VIPé¢å¤–å¥–åŠ±ï¼šç«¹å­ +10 (é‡‘è‰²é«˜äº®ï¼Œæ—è¾¹æœ‰å°çš‡å† æ ‡è®°)ï¼Œå¹¸è¿ç‚¹æ•° +5 (é‡‘è‰²é«˜äº®)]**
            *   å¦‚æœæœªè®¢é˜…ï¼Œé¢å¤–å¥–åŠ±éƒ¨åˆ†æ˜¾ç¤ºä¸ºç°è‰²ï¼Œå¹¶æœ‰å°å­—æç¤ºï¼šâ€œæˆä¸ºå®ˆæŠ¤è€…å¯è·å¾—æ­¤é¢å¤–å¥–åŠ±ï¼â€
        *   **ç†ŠçŒ«å‡çº§åŠ¨ç”»ï¼š** å‡çº§åï¼Œé™¤äº†åŸºç¡€å±æ€§æå‡ï¼Œè‹¥ç”¨æˆ·æ˜¯VIPï¼Œåˆ™å¼¹å‡ºï¼šâ€œæ­å–œï¼ä½œä¸ºå®ˆæŠ¤è€…ï¼Œç†ŠçŒ«é¢å¤–è·å¾—XXç‚¹æˆé•¿ç¥ç¦ï¼â€
*   **ç•Œé¢A3ï¼šâ€œè§£é”â€å‹æ¿€åŠ±å¼¹çª—**
    *   **è§¦å‘ç‚¹ï¼š** ç”¨æˆ·å°è¯•è®¿é—®VIPä¸“å±åŠŸèƒ½/å†…å®¹æ—¶ï¼ˆå¦‚ç‚¹å‡»é”å®šçš„é«˜çº§å†¥æƒ³è¯¾ç¨‹ã€å°è¯•åˆ›å»ºç¬¬äºŒä¸ªè‡ªå®šä¹‰ç›®æ ‡ï¼‰ã€‚
    *   **å¸ƒå±€ï¼š**
        *   **æ ‡é¢˜ï¼š** â€œè§£é”[åŠŸèƒ½åç§°]çš„å…¨éƒ¨æ½œåŠ›ï¼â€
        *   **å†…å®¹ï¼š** ç®€æ´è¯´æ˜æ­¤åŠŸèƒ½çš„VIPä¼˜åŠ¿ï¼Œä¾‹å¦‚ï¼šâ€œæˆä¸ºå®ˆæŠ¤è€…ï¼Œå³å¯æ— é™åˆ¶åˆ›å»ºè‡ªå®šä¹‰ç›®æ ‡ï¼Œå¹¶è·å¾—ç†ŠçŒ«çš„æ™ºèƒ½æ‹†è§£å»ºè®®ï¼â€æˆ–â€œè§£é”è¿™é—¨æ·±åº¦ç¡çœ å†¥æƒ³è¯¾ç¨‹ï¼Œè®©ç†ŠçŒ«é™ªä¼´ä½ å®‰ç„¶å…¥æ¢¦ã€‚â€
        *   **è¡ŒåŠ¨æŒ‰é’®ï¼š** â€œäº†è§£å®ˆæŠ¤è€…ç‰¹æƒâ€ã€â€œæš‚æ—¶ä¸ç”¨â€ã€‚

**1.2. è¥é€ â€œæ‹¥æœ‰æ„Ÿâ€ä¸â€œæŸå¤±è§„é¿â€å¿ƒç†**

*   **ç•Œé¢B1ï¼šVIPç‰¹æƒé™æ—¶ä½“éªŒ**
    *   **è§¦å‘ç‚¹ï¼š** æ–°ç”¨æˆ·å®Œæˆç‰¹å®šé‡Œç¨‹ç¢‘ï¼ˆå¦‚ç†ŠçŒ«é¦–æ¬¡è¿›åŒ–ã€è¿ç»­ç™»å½•3å¤©ï¼‰æˆ–ç‰¹å®šæ´»åŠ¨æœŸé—´ã€‚
    *   **å¼¹çª—è®¾è®¡ï¼š**
        *   **æ ‡é¢˜ï¼š** â€œé™æ—¶ç¦åˆ©ï¼šå…è´¹ä½“éªŒ3å¤©ç†ŠçŒ«å®ˆæŠ¤è€…ç‰¹æƒï¼â€
        *   **å†…å®¹ï¼š** ç®€è¦åˆ—å‡ºå¯ä½“éªŒçš„æ ¸å¿ƒç‰¹æƒï¼ˆå¦‚åŒå€èµ„æºã€ä¸“å±å¤–è§‚è¯•ç©¿ã€é«˜çº§è¯¾ç¨‹ä½“éªŒï¼‰ã€‚
        *   **è¡ŒåŠ¨æŒ‰é’®ï¼š** â€œç«‹å³å…è´¹ä½“éªŒâ€ã€â€œä»¥åå†è¯´â€ã€‚
        *   **ä½“éªŒæœŸé—´ï¼š** ç”¨æˆ·ç•Œé¢ä¸Šä¼šä¸´æ—¶æ˜¾ç¤ºVIPæ ‡è¯†ï¼Œç›¸å…³åŠŸèƒ½ä¸´æ—¶è§£é”ã€‚
*   **ç•Œé¢B2ï¼šèµ„æº/æ—¶é—´èŠ‚çœæç¤º**
    *   **è§¦å‘ç‚¹ï¼š** ç”¨æˆ·ç†ŠçŒ«ä½“åŠ›ä¸è¶³æ— æ³•è¿›è¡Œæ¢ç´¢ã€å¹¸è¿ç‚¹æ•°ä¸è¶³æ— æ³•æŠ½å¥–ã€æˆ–è‡ªå®šä¹‰ç›®æ ‡è§„åˆ’é‡åˆ°å›°éš¾æ—¶ã€‚
    *   **äº¤äº’ï¼š**
        *   **æƒ…æ™¯æç¤ºæ¡/å°æ°”æ³¡ï¼š** â€œç†ŠçŒ«ä½“åŠ›ä¸è¶³å•¦ï¼å®ˆæŠ¤è€…æ¯æ—¥å¯é¢å¤–é¢†å–ç†ŠçŒ«èƒ½é‡é›¶é£Ÿå“¦ï¼â€ æˆ– â€œæƒ³æ›´å¿«è¾¾æˆç›®æ ‡å—ï¼Ÿå®ˆæŠ¤è€…å¯ä»¥åˆ›å»ºæ›´å¤šè‡ªå®šä¹‰ç›®æ ‡ï¼Œå¹¶è·å¾—ç†ŠçŒ«çš„è§„åˆ’æ”¯æŒï¼â€
        *   **è¡ŒåŠ¨æŒ‰é’®ï¼š** â€œäº†è§£å®ˆæŠ¤è€…ç‰¹æƒâ€ã€‚
*   **ç•Œé¢B3ï¼šè®¢é˜…åˆ°æœŸæé†’**
    *   **è§¦å‘ç‚¹ï¼š** VIPè®¢é˜…åˆ°æœŸå‰3å¤©ã€1å¤©ã€‚
    *   **å¼¹çª—/é€šçŸ¥è®¾è®¡ï¼š**
        *   **æ ‡é¢˜ï¼š** â€œç†ŠçŒ«å®ˆæŠ¤è€…ç‰¹æƒå³å°†åˆ°æœŸï¼â€
        *   **å†…å®¹ï¼š**
            *   è§†è§‰åŒ–å€’è®¡æ—¶ï¼ˆå¦‚æ²™æ¼åŠ¨ç”»ï¼‰ã€‚
            *   å›é¡¾è®¢é˜…æœŸå†…å·²äº«å—çš„æ ¸å¿ƒä»·å€¼ï¼šâ€œåœ¨å®ˆæŠ¤æœŸé—´ï¼Œæ‚¨å·²é¢å¤–è·å¾—äº†XXXç«¹å­ï¼Œæ‚¨çš„ç†ŠçŒ«æˆé•¿é€Ÿåº¦æå‡äº†XX%ï¼Œå®Œæˆäº†Xä¸ªå®ˆæŠ¤è€…ä¸“å±ä»»åŠ¡â€¦â€
            *   å¼ºè°ƒç»­è®¢çš„å¥½å¤„ï¼šâ€œç»­è®¢å³å¯ç»§ç»­äº«å—è¿™äº›ç‰¹æƒï¼Œå¹¶è§£é”ä¸‹ä¸ªæœˆçš„å®ˆæŠ¤è€…ä¸“å±ç¤¼åŒ…ï¼â€
            *   éƒ¨åˆ†åŸVIPç‰¹æƒå›¾æ ‡åœ¨ä¸»ç•Œé¢å¼€å§‹**[é€æ¸å˜ç°æˆ–åŠ ä¸Šé”çš„è§’æ ‡]**ä½œä¸ºè§†è§‰æé†’ã€‚
        *   **è¡ŒåŠ¨æŒ‰é’®ï¼š** â€œç«‹å³ç»­è®¢â€ã€â€œæŸ¥çœ‹ç»­è®¢é€‰é¡¹â€ã€â€œæš‚ä¸ç»­è®¢â€ã€‚

---

### **äºŒã€æ™ºèƒ½åŒ–çš„ä»˜è´¹åœºæ™¯ (Intelligent Payment Scenarios)**

*â€œåœ¨ç©å®¶æœ€éœ€è¦ã€æœ€æ¸´æœ›æˆ–æƒ…ç»ªæœ€é«˜æ¶¨çš„æ—¶åˆ»ï¼Œè‡ªç„¶åœ°å‘ˆç°æœºä¼šã€‚â€*

**2.1. å…³é”®æ—¶åˆ»ä¸æƒ…æ„Ÿè¿æ¥**

*   **ç•Œé¢C1ï¼šé«˜å…‰æ—¶åˆ»åŠ©æ¨å¼¹çª—**
    *   **è§¦å‘ç‚¹ï¼š** ç”¨æˆ·ç†ŠçŒ«è¾¾æˆé‡è¦è¿›åŒ–ã€å®Œæˆä¸€ä¸ªé•¿æœŸæŒ‘æˆ˜ã€å¹¸è¿æŠ½å¥–è·å¾—ç¨€æœ‰ç‰©å“ã€é¦–æ¬¡å¡«æ»¡å‡†æ—¶è¿›åº¦æ¡æ—¶ã€‚
    *   **å¼¹çª—è®¾è®¡ï¼š**
        *   **æ ‡é¢˜ï¼š** â€œå¤ªæ£’äº†ï¼[æˆå°±æè¿°]â€ æˆ– â€œå¹¸è¿é™ä¸´ï¼â€
        *   **å†…å®¹ï¼š** åº†ç¥ç”¨æˆ·çš„æˆå°±ï¼Œç„¶åå…³è”è®¢é˜…ä»·å€¼ï¼šâ€œæƒ³è¦æ›´å¤šè¿™æ ·çš„æƒŠå–œå—ï¼Ÿæˆä¸ºå®ˆæŠ¤è€…ï¼Œæœªæ¥å®ŒæˆæŒ‘æˆ˜å¯è·å¾—åŒå€å¹¸è¿ç‚¹æ•°ï¼Œç¨€æœ‰ç‰©å“æ‰ç‡æå‡ï¼â€ æˆ– â€œä½œä¸ºå®ˆæŠ¤è€…ï¼Œæ¯æ¬¡ç†ŠçŒ«è¿›åŒ–éƒ½èƒ½è·å¾—é¢å¤–çš„æˆé•¿ç¥ç¦ç¤¼åŒ…å“¦ï¼â€
        *   **è¡ŒåŠ¨æŒ‰é’®ï¼š** â€œäº†è§£å®ˆæŠ¤è€…ç¦åˆ©â€ã€â€œç»§ç»­åŠªåŠ›â€ã€‚
*   **ç•Œé¢C2ï¼šç—›ç‚¹è§£å†³æ–¹æ¡ˆæç¤º**
    *   **è§¦å‘ç‚¹ï¼š** ç”¨æˆ·è¿ç»­å‡ å¤©æœªå®Œæˆæ ¸å¿ƒä¹ æƒ¯ä»»åŠ¡ã€æƒ…ç»ªæ‰“å¡æŒç»­ä½è¿·ã€è‡ªå®šä¹‰ç›®æ ‡è¿›å±•ç¼“æ…¢æ—¶ã€‚
    *   **äº¤äº’ï¼ˆé€šè¿‡ç†ŠçŒ«çš„å¯¹è¯æ°”æ³¡æˆ–æƒ…ç»ªåæ€æ¨¡å—ï¼‰ï¼š**
        *   **ç†ŠçŒ«å¯¹è¯ï¼š** â€œæ„Ÿè§‰æœ€è¿‘[ä¹ æƒ¯åç§°]æœ‰ç‚¹éš¾åšæŒå‘¢â€¦ å®ˆæŠ¤è€…å¯ä»¥è§£é”ç†ŠçŒ«çš„â€˜ä¹ æƒ¯å†²åˆºè®¡åˆ’â€™ï¼Œæˆ‘ä»¬ä¸€èµ·åˆ¶å®šæ›´å®¹æ˜“è¾¾æˆçš„å°æ­¥éª¤å§ï¼â€ æˆ– â€œå¿ƒæƒ…æœ‰ç‚¹ä½è½å—ï¼Ÿå®ˆæŠ¤è€…å¯ä»¥è§£é”ä¸“å±çš„â€˜é˜³å…‰å¿ƒæƒ…å†¥æƒ³ç³»åˆ—â€™ï¼Œè®©ç†ŠçŒ«é™ªä½ æ‰¾å›æ´»åŠ›ã€‚â€
        *   **è¡ŒåŠ¨æŒ‰é’®/é€‰é¡¹ï¼š** â€œäº†è§£å®ˆæŠ¤è€…ä¸“å±æ”¯æŒâ€ã€â€œæˆ‘å†è¯•è¯•â€ã€‚
*   **ç•Œé¢C3ï¼šç¤¾äº¤å¯¹æ¯”ä¸å‘å¾€ï¼ˆè‹¥æœ‰æ’è¡Œæ¦œ/å¥½å‹åŠŸèƒ½ï¼‰**
    *   **æ’è¡Œæ¦œç•Œé¢ï¼š**
        *   VIPç”¨æˆ·æ‹¥æœ‰**[é†’ç›®çš„åŠ¨æ€å¤´åƒæ¡†å’Œå®ˆæŠ¤è€…å¾½ç« ]**ã€‚
        *   æ’è¡Œæ¦œä¸‹æ–¹å¯èƒ½æœ‰å°æç¤ºï¼šâ€œæƒ³å’Œä»–ä»¬ä¸€æ ·é—ªè€€å—ï¼Ÿæˆä¸ºç†ŠçŒ«å®ˆæŠ¤è€…ï¼Œå½°æ˜¾ä½ çš„ç‹¬ç‰¹èº«ä»½ï¼â€
    *   **å¥½å‹è¯¦æƒ…é¡µ/ç†ŠçŒ«å®¶å›­æ‹œè®¿ï¼š**
        *   æ¸…æ™°å±•ç¤ºå¥½å‹çš„VIPçŠ¶æ€å’Œå…¶æ‹¥æœ‰çš„VIPä¸“å±ç†ŠçŒ«å¤–è§‚/å®¶å›­è£…é¥°ã€‚
        *   å°æç¤ºï¼šâ€œä½ çš„å¥½å‹[XXX]å·²ç»æ˜¯ç†ŠçŒ«å®ˆæŠ¤è€…äº†ï¼Œå¿«åŠ å…¥è¡Œåˆ—ï¼Œä¸€èµ·äº«å—ç‰¹æƒå§ï¼â€

**2.2. é™æ—¶ç¨€ç¼ºä¸é¦–è´­æ¿€åŠ±**

*   **ç•Œé¢D1ï¼šåŠ¨æ€åŒ–é™æ—¶ä¼˜æƒ å¼¹çª—/å•†åŸæ¨¡å—**
    *   **è§¦å‘ç‚¹ï¼š** æ–°ç”¨æˆ·æ³¨å†Œåç‰¹å®šæ—¶é—´ï¼ˆå¦‚24å°æ—¶å†…ï¼‰ã€ç‰¹å®šèŠ‚æ—¥æ´»åŠ¨æœŸé—´ã€‚
    *   **è®¾è®¡ï¼š**
        *   **å•†åŸé¦–é¡µBanner/å¼¹çª—ï¼š** â€œæ–°æ‰‹å¯ç¨‹ç¤¼ï¼šä»…é™72å°æ—¶ï¼è®¢é˜…é¦–æœˆäº«5æŠ˜ä¼˜æƒ ï¼Œå¹¶ç«‹å³è·èµ [æ–°æ‰‹ç†ŠçŒ«ç¤¼åŒ…]ï¼â€
        *   **[åŠ¨æ€å€’è®¡æ—¶å™¨]** æ˜¾è‘—æ˜¾ç¤ºå‰©ä½™æ—¶é—´ã€‚
        *   ç¤¼åŒ…å†…å®¹å¯è§†åŒ–å±•ç¤ºã€‚
*   **ç•Œé¢D2ï¼šé‡Œç¨‹ç¢‘å¼é¦–è´­ç¤¼åŒ…**
    *   **è§¦å‘ç‚¹ï¼š** ç”¨æˆ·å®Œæˆæ–°æ‰‹å¼•å¯¼ç³»åˆ—ä»»åŠ¡åï¼Œæˆ–ç†ŠçŒ«è¾¾åˆ°ç‰¹å®šç­‰çº§ï¼ˆå¦‚5çº§ï¼‰ã€‚
    *   **å¼¹çª—è®¾è®¡ï¼š**
        *   **æ ‡é¢˜ï¼š** â€œæ­å–œå®Œæˆæ–°æ‰‹è¯•ç‚¼ï¼è§£é”æ‚¨çš„ä¸“å±é¦–è´­è®¢é˜…ç¦åˆ©ï¼â€
        *   **å†…å®¹ï¼š** æä¾›ä¸€ä¸ªä¸€æ¬¡æ€§çš„é«˜æ€§ä»·æ¯”è®¢é˜…åŒ…ï¼Œä¾‹å¦‚ï¼šâ€œè®¢é˜…æœˆå¡ï¼Œä¸ä»…äº«å—æ‰€æœ‰å®ˆæŠ¤è€…ç‰¹æƒï¼Œè¿˜å°†é¢å¤–è·å¾—[ç»ç‰ˆç†ŠçŒ«å¹¼å´½æœŸçºªå¿µè£…é¥°]ï¼â€
*   **ç•Œé¢D3ï¼šè®¢é˜…ä¸“äº«å†…å®¹/æ´»åŠ¨å…¥å£**
    *   **ä¸»ç•Œé¢æ´»åŠ¨ä¸­å¿ƒ/ä»»åŠ¡åˆ—è¡¨ï¼š**
        *   VIPä¸“å±æ´»åŠ¨/ä»»åŠ¡å¸¦æœ‰**[é†’ç›®çš„VIPçš‡å† æ ‡è®°]**ã€‚
        *   å…è´¹ç”¨æˆ·ç‚¹å‡»æ—¶ï¼Œå¼¹å‡ºæç¤ºï¼šâ€œæ­¤ä¸ºç†ŠçŒ«å®ˆæŠ¤è€…ä¸“å±[æ´»åŠ¨/ä»»åŠ¡]ï¼Œè®¢é˜…å³å¯å‚ä¸ï¼Œèµ¢å–ä¸°åšå¥–åŠ±ï¼â€
        *   **å…è®¸â€œé¢„è§ˆâ€ï¼š** ä¾‹å¦‚ï¼Œå¯ä»¥æŸ¥çœ‹æ´»åŠ¨ä»‹ç»å’Œå¥–åŠ±åˆ—è¡¨ï¼Œä½†å‚ä¸æŒ‰é’®ç½®ç°ï¼Œæ—è¾¹æœ‰â€œæˆä¸ºå®ˆæŠ¤è€…å‚ä¸â€çš„é“¾æ¥ã€‚

---

### **ä¸‰ã€çµæ´»çš„è®¢é˜…ä½“ç³» (Flexible Subscription System)**

*â€œæä¾›é€‰æ‹©ï¼Œä½†å·§å¦™å¼•å¯¼ï¼›é‡è§†é¦–è´­ï¼Œæ›´è¦åŸ¹å…»é•¿æœŸå¿ è¯šã€‚â€*

**3.1. å¤šå±‚æ¬¡ä¸å¢å€¼é€‰é¡¹**

*   **ç•Œé¢E1ï¼šè®¢é˜…é€‰æ‹©é¡µé¢ (Subscription Options Page)**
    *   **è§¦å‘ç‚¹ï¼š** ç‚¹å‡»â€œäº†è§£VIPç‰¹æƒâ€æˆ–â€œå‡çº§â€ç­‰æŒ‰é’®åè·³è½¬ã€‚
    *   **å¸ƒå±€ï¼š**
        *   **è‡³å°‘2-3æ¡£é€‰é¡¹å¡ç‰‡å¼å¹¶åˆ—å±•ç¤ºï¼š**
            *   **æœˆå¡ (Monthly Guardian):** [ä»·æ ¼]ï¼Œåˆ—å‡ºæ ¸å¿ƒæƒç›Šã€‚
            *   **å­£å¡ (Seasonal Guardian):** [ä»·æ ¼] (é€šå¸¸æ¯”æœˆå¡å•æœˆä»·æ ¼ç•¥ä½)ï¼Œåˆ—å‡ºæ ¸å¿ƒæƒç›Š + [é¢å¤–å­£åº¦ç¤¼åŒ…]ã€‚**[æ ‡è®°â€œæ¨èâ€æˆ–â€œPopular Choiceâ€]**
            *   **å¹´å¡ (Annual Guardian):** [ä»·æ ¼] (å•æœˆä»·æ ¼æœ€ä½)ï¼Œåˆ—å‡ºæ ¸å¿ƒæƒç›Š + [ä¸°åšå¹´åº¦å¤§ç¤¼åŒ…ï¼Œå¦‚ç»ç‰ˆçš®è‚¤ã€å¤§é‡é’»çŸ³] + [æ¯æœˆé¢å¤–å®ˆæŠ¤è€…ç¦åˆ©]ã€‚**[æ ‡è®°â€œæœ€ä½³ä»·å€¼â€æˆ–â€œBest Valueâ€]**
        *   æ¯å¼ å¡ç‰‡æ¸…æ™°æ ‡æ³¨**â€œå¹³å‡æ¯æœˆèŠ±è´¹â€**ï¼Œä¾¿äºå¯¹æ¯”ã€‚
        *   æƒç›Šåˆ—è¡¨ä½¿ç”¨**[âœ“ å›¾æ ‡å’Œç®€æ´æ–‡å­—]**ï¼Œçªå‡ºå·®å¼‚ç‚¹ã€‚
        *   **é»˜è®¤é€‰ä¸­â€œæ¨èâ€æ¡£ä½ã€‚**
        *   åº•éƒ¨æœ‰â€œç¡®è®¤è®¢é˜…â€æŒ‰é’®å’Œâ€œæ¢å¤è´­ä¹°â€é“¾æ¥ã€‚
*   **ç•Œé¢E2ï¼šå åŠ å¼/ä¸»é¢˜å¼å°é¢è®¢é˜…å…¥å£ (å¯é€‰)**
    *   **è§¦å‘ç‚¹ï¼š** åœ¨ç‰¹å®šåŠŸèƒ½ä½¿ç”¨åœºæ™¯ä¸‹ã€‚
    *   **ä¾‹å¦‚ï¼Œåœ¨â€œè‡ªå®šä¹‰ç›®æ ‡â€åˆ›å»ºç•Œé¢ï¼š** å¦‚æœç”¨æˆ·æƒ³åˆ›å»ºæ›´å¤šç›®æ ‡ä½†å·²è¾¾å…è´¹ä¸Šé™ï¼Œæç¤ºï¼šâ€œæƒ³æ— é™åˆ¶åˆ›å»ºç›®æ ‡å—ï¼Ÿè¯•è¯•â€˜ç›®æ ‡å¤§å¸ˆæœˆç¥¨â€™(å°é¢)ï¼Œæˆ–å‡çº§æˆä¸ºå…¨èƒ½ç†ŠçŒ«å®ˆæŠ¤è€…ï¼â€
    *   **æ­¤ç±»å°é¢è®¢é˜…åº”æ˜ç¡®è¯´æ˜æ˜¯ä¸»è®¢é˜…çš„è¡¥å……æˆ–ç‰¹å®šåŠŸèƒ½çš„è§£é”ï¼Œé¿å…æ··æ·†ã€‚**

**3.2. ä½é—¨æ§›è¯•ç”¨ä¸ç²¾ç»†åŒ–æŒ½ç•™**

*   **ç•Œé¢F1ï¼šâ€œæ— é£é™©â€å…è´¹è¯•ç”¨å¼•å¯¼ (è§ç•Œé¢B1)**
*   **ç•Œé¢F2ï¼šè¯•ç”¨æœŸä»·å€¼å›é¡¾å¼¹çª—**
    *   **è§¦å‘ç‚¹ï¼š** å…è´¹è¯•ç”¨æœŸç»“æŸå‰1-2å¤©ã€‚
    *   **å¼¹çª—è®¾è®¡ï¼š**
        *   **æ ‡é¢˜ï¼š** â€œæ‚¨çš„ç†ŠçŒ«å®ˆæŠ¤è€…ä½“éªŒå³å°†ç»“æŸï¼â€
        *   **å†…å®¹ï¼ˆæ•°æ®åŒ–æ€»ç»“ï¼‰ï¼š**
            *   â€œåœ¨è¿‡å»çš„Xå¤©é‡Œï¼Œæ‚¨ï¼šâ€
            *   â€œé¢å¤–è·å¾—äº† [XXX] ç«¹å­å’Œ [YYY] æ°´ï¼â€
            *   â€œç†ŠçŒ«æˆé•¿é€Ÿåº¦æå‡äº† [ZZ]%ï¼â€
            *   â€œè§£é”å¹¶ä½“éªŒäº† [N] ä¸ªé«˜çº§å†¥æƒ³è¯¾ç¨‹ï¼â€
            *   â€œèŠ‚çœäº†å¤§çº¦ [M] åˆ†é’Ÿçš„ç­‰å¾…æ—¶é—´ï¼ˆè‹¥æœ‰åŠ é€ŸåŠŸèƒ½ï¼‰ï¼â€
        *   **è¡ŒåŠ¨æŒ‰é’®ï¼š** â€œç«‹å³è®¢é˜…ï¼Œä¿ç•™æ‰€æœ‰ç‰¹æƒï¼â€ã€â€œæŸ¥çœ‹è®¢é˜…é€‰é¡¹â€ã€â€œæš‚æ—¶ä¸äº†â€ã€‚
*   **ç•Œé¢F3ï¼šäººæ€§åŒ–æŒ½ç•™ç­–ç•¥é¡µé¢/å¼¹çª—**
    *   **è§¦å‘ç‚¹ï¼š** ç”¨æˆ·åœ¨App Storeç®¡ç†è®¢é˜…ï¼Œå°è¯•å–æ¶ˆPandaHabitçš„VIPæ—¶ï¼ˆé€šè¿‡æœåŠ¡å™¨ç«¯éªŒè¯å®ç°ï¼Œæˆ–åœ¨åº”ç”¨å†…æä¾›â€œç®¡ç†è®¢é˜…â€å…¥å£ï¼Œè‹¥ç”¨æˆ·ç‚¹å‡»â€œå–æ¶ˆâ€åˆ™è§¦å‘ï¼‰ã€‚
    *   **å¼¹çª—è®¾è®¡ï¼ˆå¤šé˜¶æ®µï¼‰ï¼š**
        *   **ç¬¬ä¸€å±‚ï¼ˆç¡®è®¤å–æ¶ˆï¼‰ï¼š** â€œçœŸçš„è¦ç¦»å¼€ç†ŠçŒ«å®ˆæŠ¤è€…è¡Œåˆ—å—ï¼Ÿ[ç†ŠçŒ«åšå‡ºå§”å±ˆè¡¨æƒ…]â€ -> â€œç¡®è®¤å–æ¶ˆâ€ / â€œå†è€ƒè™‘ä¸€ä¸‹â€
        *   **ç¬¬äºŒå±‚ï¼ˆæä¾›é™çº§/æŠ˜æ‰£ï¼Œè‹¥ç”¨æˆ·ç¡®è®¤å–æ¶ˆï¼‰ï¼š** â€œæˆ‘ä»¬å¾ˆé—æ†¾æ‚¨è¦ç¦»å¼€ã€‚æˆ‘ä»¬ä¸ºæ‚¨å‡†å¤‡äº†ä¸€ä¸ªç‰¹åˆ«ä¼˜æƒ ï¼š**[ç»­è®¢ä¸‹ä¸ªæœˆäº«7æŠ˜ä¼˜æƒ ]**ï¼Œæˆ–è€…æ‚¨å¯ä»¥é€‰æ‹©**[ä¿ç•™æ ¸å¿ƒç‰¹æƒçš„åŸºç¡€ç‰ˆå®ˆæŠ¤è€…ï¼ˆä»·æ ¼æ›´ä½ï¼‰]**ï¼Ÿâ€ -> â€œæ¥å—ä¼˜æƒ â€ / â€œæŸ¥çœ‹åŸºç¡€ç‰ˆâ€ / â€œä»ç„¶å–æ¶ˆâ€
        *   **ç¬¬ä¸‰å±‚ï¼ˆä¼‘çœ /é—®å·ï¼Œè‹¥ä»å–æ¶ˆï¼‰ï¼š** â€œå¥½å§ï¼Œç†ŠçŒ«ä¼šæƒ³ä½ çš„ã€‚æ‚¨å¯ä»¥é€‰æ‹©**[æš‚åœè®¢é˜…1ä¸ªæœˆï¼Œæ‰€æœ‰æƒç›Šå’Œè¿›åº¦å°†ä¸ºæ‚¨ä¿ç•™]**ï¼Œæœªæ¥éšæ—¶å¯ä»¥å›æ¥ã€‚æˆ–è€…ï¼Œå¯ä»¥èŠ±1åˆ†é’Ÿå‘Šè¯‰æˆ‘ä»¬ç¦»å¼€çš„åŸå› å—ï¼Ÿè¿™å°†å¸®åŠ©æˆ‘ä»¬æ”¹è¿›ã€‚â€ -> â€œæš‚åœè®¢é˜…â€ / â€œå¡«å†™é—®å·â€ / â€œç›´æ¥å–æ¶ˆâ€
        *   **é¿å…æ­»ç¼ çƒ‚æ‰“ï¼Œæä¾›æ¸…æ™°çš„é€€å‡ºè·¯å¾„ã€‚**

---

### **å››ã€ç¤¾äº¤è®¤åŒä¸ç«äº‰æ°›å›´ (Social Proof & Competitive Atmosphere)**

*(ä¸»è¦é€‚ç”¨äºæœ‰ç¤¾äº¤åŠŸèƒ½çš„æƒ…å†µ)*

**4.1. å¯è§çš„ç¤¾äº¤å½±å“åŠ›**

*   **ç•Œé¢G1ï¼šå®æ—¶åŠ¨æ€è®¢é˜…ä¿¡æ¯ (å¯é€‰ï¼Œè°¨æ…ä½¿ç”¨)**
    *   **ä½ç½®ï¼š** å•†åº—é¡µé¢åº•éƒ¨æ»šåŠ¨æ¡ï¼Œæˆ–ä¸»åŸå…¬å‘Šæ¿ï¼ˆè‹¥æœ‰ï¼‰ã€‚
    *   **å†…å®¹ï¼š** â€œ[ç©å®¶æ˜µç§°] åˆšåˆšåŠ å…¥äº†ç†ŠçŒ«å®ˆæŠ¤è€…è¡Œåˆ—ï¼Œè·å¾—äº†[ä¸“å±ç†ŠçŒ«å¤´é¥°]ï¼â€ (éœ€çœŸå®ï¼Œä½é¢‘ï¼Œé¿å…æ‰“æ‰°)ã€‚
*   **ç•Œé¢G2ï¼šå›¢é˜Ÿå¢ç›Šæç¤º**
    *   **è§¦å‘ç‚¹ï¼š** ç»„é˜Ÿå‚ä¸åˆä½œæŒ‘æˆ˜æ—¶ã€‚
    *   **ç•Œé¢æç¤ºï¼š** è‹¥é˜Ÿä¼ä¸­æœ‰VIPï¼šâ€œé˜Ÿä¼ä¸­æœ‰å®ˆæŠ¤è€…æˆå‘˜ï¼æœ¬æ¬¡æŒ‘æˆ˜å…¨é˜Ÿç«¹å­è·å–+5%ï¼â€
*   **ç•Œé¢G3ï¼šåˆ†äº«è£‚å˜æ¿€åŠ±**
    *   **è§¦å‘ç‚¹ï¼š** ç”¨æˆ·è·å¾—é‡è¦æˆå°±ã€ç¨€æœ‰ç‰©å“ï¼Œæˆ–å®Œæˆé•¿æœŸæŒ‘æˆ˜ã€‚
    *   **åˆ†äº«å¼¹çª—ï¼š** é™¤äº†åˆ†äº«æˆå°±æœ¬èº«ï¼Œå¢åŠ ä¸€ä¸ªé€‰é¡¹ï¼šâ€œé‚€è¯·å¥½å‹ä½“éªŒPandaHabitï¼ŒTAå¯è·å¾—3å¤©å®ˆæŠ¤è€…è¯•ç”¨ï¼Œæ‚¨å°†è·å¾—[XXX]ç«¹å­å¥–åŠ±ï¼â€ åˆ†äº«å‡ºå»çš„é“¾æ¥å¸¦æœ‰ä¸“å±é‚€è¯·ç ã€‚

**4.2. è£èª‰ä¸åœ°ä½å½°æ˜¾**

*   **ç•Œé¢H1ï¼šæ’è¡Œæ¦œå·®å¼‚åŒ–å±•ç¤º (è§ç•Œé¢C3)**
*   **ç•Œé¢H2ï¼šå¤šç»´åº¦æ’è¡Œæ¦œ**
    *   **æ’è¡Œæ¦œé¡µé¢ï¼š** é™¤äº†å¸¸è§„è¿›åº¦æ¦œï¼Œå¯å¢åŠ â€œç†ŠçŒ«çˆ±å¿ƒæ¦œâ€ï¼ˆæ ¹æ®å–‚å…»ã€äº’åŠ¨é¢‘ç‡ï¼ŒVIPæœ‰åŠ æˆï¼‰ã€â€œä¹ æƒ¯æ¯…åŠ›æ¦œâ€ï¼ˆè¿ç»­å®Œæˆä»»åŠ¡å¤©æ•°ï¼ŒVIPæœ‰ç‰¹æ®Šæ ‡è¯†ï¼‰ã€‚
*   **ç•Œé¢H3ï¼šè®¢é˜…ä¸“å±æˆå°±ä¸ç§°å·**
    *   **æˆå°±é¡µé¢/ä¸ªäººèµ„æ–™é¡µï¼š**
        *   **æˆå°±åˆ—è¡¨ï¼š** åŒ…å«â€œæœˆåº¦å®ˆæŠ¤è€…â€ã€â€œå¹´åº¦å®ˆæŠ¤è€…â€ã€â€œçš‡å®¶èµåŠ©äººâ€ç­‰ä¸è®¢é˜…ç›¸å…³çš„æˆå°±ã€‚
        *   **ç§°å·ç³»ç»Ÿï¼š** ç”¨æˆ·å¯è£…å¤‡è·å¾—çš„ç§°å·ï¼ŒVIPç§°å·å¸¦æœ‰ç‰¹æ®Šè§†è§‰æ•ˆæœã€‚

---

### **äº”ã€æ•°æ®é©±åŠ¨ä¸ç”¨æˆ·ä½“éªŒä¿éšœ (Data-Driven & User Experience Assurance)**

*(è¿™éƒ¨åˆ†ä¸»è¦ä½“ç°åœ¨åå°æ•°æ®åˆ†æå’Œäº§å“è¿­ä»£ç­–ç•¥ä¸Šï¼Œå‰ç«¯ç•Œé¢ä½“ç°è¾ƒå°‘ï¼Œä½†å¯¹å¼•å¯¼ç­–ç•¥çš„åˆ¶å®šè‡³å…³é‡è¦ã€‚)*

**5.1. ç²¾ç»†åŒ–åŸ‹ç‚¹ä¸æ¼æ–—åˆ†æ**
    *   **åå°æ•°æ®çœ‹æ¿ï¼š** å±•ç¤ºå„ä»˜è´¹å¼•å¯¼å…¥å£çš„æ›å…‰é‡ã€ç‚¹å‡»ç‡ã€è½¬åŒ–ç‡ï¼›æ”¯ä»˜é¡µé¢å„æ¡£ä½é€‰æ‹©æ¯”ä¾‹ï¼›è¯•ç”¨ç”¨æˆ·å…³é”®è¡Œä¸ºè·¯å¾„ï¼›æµå¤±èŠ‚ç‚¹ç­‰ã€‚

**5.2. å…¬å¹³æ€§ä¸é•¿æœŸç”Ÿæ€ç»´æŠ¤**
    *   **æ¸¸æˆå†…å¸®åŠ©/FAQé¡µé¢ï¼š** æ¸…æ™°è¯´æ˜å…è´¹ç‰ˆä¸VIPç‰ˆçš„æƒç›ŠåŒºåˆ«ï¼Œå¼ºè°ƒæ ¸å¿ƒç©æ³•å¯¹æ‰€æœ‰ç”¨æˆ·å¼€æ”¾ã€‚
    *   **ä»˜è´¹å¼•å¯¼æ–‡æ¡ˆï¼š** æªè¾æ¸©å’Œã€é€æ˜ï¼Œå¼ºè°ƒâ€œæ”¯æŒâ€å’Œâ€œå¢å€¼â€ï¼Œè€Œéâ€œå¿…éœ€â€æˆ–â€œä¸ä»˜è´¹å°±ç©ä¸ä¸‹å»â€ã€‚
    *   **é¿å…PVPå¤±è¡¡ï¼ˆè‹¥æœ‰PVPï¼‰ï¼š** ä»˜è´¹ä¼˜åŠ¿ä¸åº”ç¢¾å‹æŠ€å·§å’Œç­–ç•¥ã€‚

---

### **å…­ã€å‰ç»æ€§æ¢ç´¢ (Forward-Looking Exploration)**

*(è¿™éƒ¨åˆ†å±äºè¿œæœŸè§„åˆ’ï¼ŒåˆæœŸç•Œé¢å¯èƒ½ä¸æ¶‰åŠï¼Œä½†å¯é¢„ç•™æ¥å£æˆ–æ€è·¯)*

**6.1. Web3/å…ƒå®‡å®™æ•´åˆ**
    *   **ä¸ªäººèµ„æ–™é¡µ/æˆå°±é¡µï¼š** å¯é¢„ç•™å±•ç¤ºNFTå¾½ç« /æ•°å­—è—å“çš„åŒºåŸŸã€‚
**6.2. å†…å®¹å…±åˆ›ä¸æ¿€åŠ±**
    *   **UGCå†…å®¹æäº¤/å±•ç¤ºåŒºï¼š** è‹¥æœ‰UGCåŠŸèƒ½ï¼ˆå¦‚è‡ªå®šä¹‰å†¥æƒ³å¼•å¯¼åˆ†äº«ï¼‰ï¼ŒVIPç”¨æˆ·å¯äº«æœ‰æ›´é«˜çº§çš„ç¼–è¾‘å·¥å…·ï¼Œå…¶ä½œå“æ—å¯æœ‰ç‰¹æ®Šæ ‡è¯†ã€‚
**6.3. ç°å®è”åŠ¨ä¸å“ç‰Œå»¶ä¼¸**
    *   **æ´»åŠ¨ä¸­å¿ƒ/æ¶ˆæ¯æ¨é€ï¼š** å‘å¸ƒçº¿ä¸‹æ´»åŠ¨ä¿¡æ¯ï¼ŒVIPç”¨æˆ·æŠ¥åå…¥å£å¯æœ‰ä¼˜å…ˆæ ‡è¯†æˆ–æŠ˜æ‰£æç¤ºã€‚

---

**âš¡ å®æ–½æ ¸å¿ƒåŸåˆ™ä¸ç­–ç•¥ (ä½“ç°åœ¨æ•´ä½“è®¾è®¡ä¸­) âš¡**

1.  **ç”¨æˆ·æ´å¯Ÿå…ˆè¡Œï¼š** æ‰€æœ‰å¼•å¯¼æ–‡æ¡ˆã€æ—¶æœºã€ä»·å€¼ç‚¹éƒ½åŸºäºå¯¹PandaHabitç”¨æˆ·ï¼ˆå¸Œæœ›å…»æˆå¥½ä¹ æƒ¯ã€éœ€è¦æƒ…æ„Ÿæ”¯æŒï¼‰çš„ç†è§£ã€‚
2.  **ä»·å€¼å‰ç½®ï¼Œä»˜è´¹åç½®ï¼š** å…è´¹è¯•ç”¨ã€åŠŸèƒ½é¢„è§ˆã€æ¸…æ™°çš„ä»·å€¼å¯¹æ¯”éƒ½æ˜¯è¿™ä¸€åŸåˆ™çš„ä½“ç°ã€‚
3.  **A/Bæµ‹è¯•æ–‡åŒ–ï¼š**
    *   **å¯æµ‹è¯•ç‚¹ï¼š** ä»˜è´¹å¼¹çª—çš„æ–‡æ¡ˆã€æŒ‰é’®é¢œè‰²/æ–‡å­—ã€ä¼˜æƒ åŠ›åº¦ã€è§¦å‘æ—¶æœºã€è®¢é˜…æ¡£ä½é»˜è®¤æ¨èç­‰ã€‚
4.  **MVPä¸å¿«é€Ÿè¿­ä»£ï¼š** å…ˆä¸Šçº¿æ ¸å¿ƒçš„ä»˜è´¹åœºæ™¯å’Œä»·å€¼å±•ç¤ºï¼Œæ ¹æ®æ•°æ®åé¦ˆè°ƒæ•´å’Œå¢åŠ æ›´ç²¾ç»†åŒ–çš„å¼•å¯¼ã€‚
5.  **é•¿æœŸè§†è§’ï¼š** æŒ½ç•™ç­–ç•¥ã€å…¬å¹³æ€§ä¿éšœã€é¿å…çŸ­æœŸæ¦¨å–ï¼Œéƒ½æ˜¯ä¸ºäº†LTVã€‚
6.  **çº¢çº¿è‡ªæŸ¥ï¼š** ç¡®ä¿æ‰€æœ‰ä»˜è´¹å¼•å¯¼ä¸ç ´åæ ¸å¿ƒå…è´¹ä½“éªŒçš„å®Œæ•´æ€§ã€‚

---

**ğŸ“ˆ æ ¸å¿ƒè¿½è¸ªæŒ‡æ ‡ (åå°æ•°æ®é‡ç‚¹å…³æ³¨) ğŸ“ˆ**
*(åŒChecklist 2.0)*

---

è¿™ä»½ç•Œé¢è®¾è®¡å’Œäº¤äº’æµç¨‹çš„æ„æƒ³ï¼ŒåŠ›æ±‚å°†Checklist 2.0çš„æˆ˜ç•¥æ€æƒ³è½åœ°åˆ°PandaHabitçš„å…·ä½“ç”¨æˆ·ä½“éªŒä¸­ã€‚å®é™…æ‰§è¡Œæ—¶ï¼Œè¿˜éœ€è¦é…åˆä¼˜ç§€çš„è§†è§‰è®¾è®¡ã€æµç•…çš„åŠ¨ç”»æ•ˆæœä»¥åŠç²¾å‡†çš„æ–‡æ¡ˆæ‰“ç£¨ï¼Œæ‰èƒ½è¾¾åˆ°æœ€ä½³æ•ˆæœã€‚
</file>

<file path="component-multilingual-examples.md">
# PandaHabit ç»„ä»¶å¤šè¯­è¨€æ”¯æŒç¤ºä¾‹

æœ¬æ–‡æ¡£æä¾›äº† PandaHabit åº”ç”¨ä¸­å¸¸è§ç»„ä»¶çš„å¤šè¯­è¨€æ”¯æŒå®ç°ç¤ºä¾‹ï¼Œå¯ä½œä¸ºå¼€å‘è€…çš„å‚è€ƒæŒ‡å—ã€‚

## ç›®å½•

1. [åŸºç¡€ç»„ä»¶](#åŸºç¡€ç»„ä»¶)
2. [æ¸¸æˆç»„ä»¶](#æ¸¸æˆç»„ä»¶)
3. [ä»»åŠ¡ç»„ä»¶](#ä»»åŠ¡ç»„ä»¶)
4. [å•†åº—ç»„ä»¶](#å•†åº—ç»„ä»¶)
5. [åæ€ç»„ä»¶](#åæ€ç»„ä»¶)

## åŸºç¡€ç»„ä»¶

### Button ç»„ä»¶

```typescript
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'jade' | 'gold';
  size?: 'small' | 'medium' | 'large';
  onClick?: () => void;
  disabled?: boolean;
  className?: string;
  children: React.ReactNode;
  // ä¸éœ€è¦ labels å±æ€§ï¼Œå› ä¸ºæŒ‰é’®æ–‡æœ¬é€šè¿‡ children ä¼ å…¥
}

const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'medium',
  onClick,
  disabled = false,
  className = '',
  children
}) => {
  // å®ç°...
};
```

### LoadingSpinner ç»„ä»¶

```typescript
interface LoadingSpinnerProps {
  variant?: 'primary' | 'secondary' | 'jade' | 'white';
  size?: 'small' | 'medium' | 'large';
  text?: string; // åŠ è½½æ–‡æœ¬
  className?: string;
}

const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  variant = 'primary',
  size = 'medium',
  text, // å¯ä»¥ä¼ å…¥æœ¬åœ°åŒ–çš„åŠ è½½æ–‡æœ¬
  className = ''
}) => {
  return (
    <div className={`loading-spinner-container ${className}`}>
      <div className={`spinner spinner-${variant} spinner-${size}`}>
        {/* åŠ è½½åŠ¨ç”» */}
      </div>
      {text && <div className="loading-text">{text}</div>}
    </div>
  );
};
```

## æ¸¸æˆç»„ä»¶

### ChallengeCard ç»„ä»¶

```typescript
interface ChallengeCardProps {
  challenge: ChallengeRecord;
  onClick?: (challenge: ChallengeRecord) => void;
  onComplete?: (challengeId: number) => void;
  labels?: {
    statusActive?: string;
    statusCompleted?: string;
    statusExpired?: string;
    statusUpcoming?: string;
    startLabel?: string;
    endLabel?: string;
    completedOnLabel?: string;
    completeButtonText?: string;
    inProgressText?: string;
  };
}

const ChallengeCard: React.FC<ChallengeCardProps> = ({
  challenge,
  onClick,
  onComplete,
  labels
}) => {
  // è·å–æŒ‘æˆ˜çŠ¶æ€å¯¹åº”çš„æ–‡æœ¬
  const getStatusText = () => {
    switch (challenge.status) {
      case ChallengeStatus.ACTIVE:
        return labels?.statusActive || 'Active';
      case ChallengeStatus.COMPLETED:
        return labels?.statusCompleted || 'Completed';
      case ChallengeStatus.EXPIRED:
        return labels?.statusExpired || 'Expired';
      case ChallengeStatus.UPCOMING:
        return labels?.statusUpcoming || 'Upcoming';
      default:
        return '';
    }
  };

  // å¤„ç†ç‚¹å‡»äº‹ä»¶
  const handleClick = () => {
    if (onClick) {
      onClick(challenge);
    }
  };

  // å¤„ç†å®ŒæˆæŒ‘æˆ˜äº‹ä»¶
  const handleComplete = (e: React.MouseEvent) => {
    e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
    if (onComplete && challenge.status === ChallengeStatus.ACTIVE) {
      onComplete(challenge.id!);
    }
  };

  return (
    <motion.div
      className={`challenge-card ${getStatusClass()} ${getDifficultyClass()}`}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={handleClick}
    >
      {/* æŒ‘æˆ˜å¡ç‰‡å¤´éƒ¨ */}
      <div className="challenge-card-header">
        {/* ... */}
        <div className="challenge-meta">
          <span className={`challenge-status ${getStatusClass()}`}>
            {getStatusText()}
          </span>
        </div>
      </div>

      {/* æŒ‘æˆ˜å¡ç‰‡å†…å®¹ */}
      <div className="challenge-card-body">
        <p className="challenge-description">{challenge.description}</p>
        <div className="challenge-dates">
          <span>{labels?.startLabel || 'Start'}: {formatTime(challenge.startDate, false)}</span>
          {challenge.endDate && (
            <span>{labels?.endLabel || 'End'}: {formatTime(challenge.endDate, false)}</span>
          )}
        </div>
      </div>

      {/* æŒ‘æˆ˜å¡ç‰‡åº•éƒ¨ */}
      <div className="challenge-card-footer">
        {challenge.status === ChallengeStatus.ACTIVE && (
          <button
            className="complete-challenge-button"
            onClick={handleComplete}
            disabled={challenge.progress < 100}
          >
            {challenge.progress >= 100 
              ? (labels?.completeButtonText || 'Complete Challenge') 
              : (labels?.inProgressText || 'In Progress...')}
          </button>
        )}
        {challenge.status === ChallengeStatus.COMPLETED && (
          <div className="challenge-completed-info">
            <span className="completion-date">
              {labels?.completedOnLabel || 'Completed on'}: {formatTime(challenge.completedDate!, false)}
            </span>
          </div>
        )}
      </div>
    </motion.div>
  );
};
```

## ä»»åŠ¡ç»„ä»¶

### SubtaskList ç»„ä»¶

```typescript
interface SubtaskListProps {
  parentTaskId: number;
  onSubtasksChange?: (hasSubtasks: boolean) => void;
  labels?: {
    loadErrorMessage?: string;
    addErrorMessage?: string;
    completeErrorMessage?: string;
    deleteErrorMessage?: string;
    reorderErrorMessage?: string;
    addSubtaskPlaceholder?: string;
    addButtonText?: string;
    noSubtasksMessage?: string;
    deleteSubtaskAriaLabel?: string;
  };
}

const SubtaskList: React.FC<SubtaskListProps> = ({ 
  parentTaskId, 
  onSubtasksChange,
  labels 
}) => {
  const [subtasks, setSubtasks] = useState<SubtaskRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [newSubtaskTitle, setNewSubtaskTitle] = useState('');
  const [isAddingSubtask, setIsAddingSubtask] = useState(false);

  // åŠ è½½å­ä»»åŠ¡
  const loadSubtasks = async () => {
    try {
      setIsLoading(true);
      setError(null);
      const loadedSubtasks = await getSubtasks(parentTaskId);
      setSubtasks(loadedSubtasks);
      
      // é€šçŸ¥çˆ¶ç»„ä»¶å­ä»»åŠ¡çŠ¶æ€å˜åŒ–
      if (onSubtasksChange) {
        onSubtasksChange(loadedSubtasks.length > 0);
      }
    } catch (err) {
      console.error('Failed to load subtasks:', err);
      setError(labels?.loadErrorMessage || 'Failed to load subtasks, please try again');
    } finally {
      setIsLoading(false);
    }
  };

  // å¤„ç†æ·»åŠ å­ä»»åŠ¡
  const handleAddSubtask = async () => {
    if (!newSubtaskTitle.trim()) return;

    try {
      setIsAddingSubtask(true);
      await createSubtask({
        parentTaskId,
        title: newSubtaskTitle.trim()
      });
      setNewSubtaskTitle('');
      playSound(SoundType.BUTTON_CLICK, 0.3);
      await loadSubtasks();
    } catch (err) {
      console.error('Failed to add subtask:', err);
      setError(labels?.addErrorMessage || 'Failed to add subtask, please try again');
    } finally {
      setIsAddingSubtask(false);
    }
  };

  // JSX éƒ¨åˆ†
  return (
    <div className="subtasks-list">
      {/* å­ä»»åŠ¡åˆ—è¡¨ */}
      {/* ... */}
      
      {/* æ·»åŠ å­ä»»åŠ¡è¡¨å• */}
      <div className="add-subtask-form mt-4">
        <div className="flex">
          <input
            type="text"
            value={newSubtaskTitle}
            onChange={(e) => setNewSubtaskTitle(e.target.value)}
            placeholder={labels?.addSubtaskPlaceholder || "Add new subtask..."}
            className="flex-grow p-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-2 focus:ring-jade-500"
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                handleAddSubtask();
              }
            }}
          />
          <Button
            variant="jade"
            onClick={handleAddSubtask}
            disabled={!newSubtaskTitle.trim() || isAddingSubtask}
            className="rounded-l-none"
          >
            {isAddingSubtask ? (
              <LoadingSpinner variant="white" size="small" />
            ) : (
              labels?.addButtonText || 'Add'
            )}
          </Button>
        </div>
      </div>
    </div>
  );
};
```

## å•†åº—ç»„ä»¶

### StoreItemCard ç»„ä»¶

```typescript
interface StoreItemCardProps {
  item: StoreItemRecord;
  onPurchase?: (item: StoreItemRecord) => void;
  onPreview?: (item: StoreItemRecord) => void;
  userCoins?: number;
  userJade?: number;
  isVip?: boolean;
  labels?: {
    vipRequiredError?: string;
    insufficientCoinsError?: string;
    insufficientJadeError?: string;
    purchaseError?: string;
    rarityLabels?: {
      common?: string;
      uncommon?: string;
      rare?: string;
      epic?: string;
      legendary?: string;
    };
    vipExclusiveLabel?: string;
    saleLabel?: string;
    buyButtonText?: string;
  };
}

const StoreItemCard: React.FC<StoreItemCardProps> = ({
  item,
  onPurchase,
  onPreview,
  userCoins = 0,
  userJade = 0,
  isVip = false,
  labels
}) => {
  const [isPurchasing, setIsPurchasing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // å¤„ç†è´­ä¹°ç‰©å“
  const handlePurchase = async (e: React.MouseEvent) => {
    e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦VIP
    if (item.vipRequired && !isVip) {
      setError(labels?.vipRequiredError || 'VIP membership required');
      return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„è´§å¸
    const price = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;
    if (item.priceType === PriceType.COINS && userCoins < price) {
      setError(labels?.insufficientCoinsError || 'Not enough coins');
      return;
    }
    if (item.priceType === PriceType.JADE && userJade < price) {
      setError(labels?.insufficientJadeError || 'Not enough jade');
      return;
    }
    
    // è´­ä¹°ç‰©å“
    try {
      setIsPurchasing(true);
      setError(null);
      
      // è°ƒç”¨è´­ä¹°API
      await purchaseStoreItem(item.id!);
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onPurchase) {
        onPurchase(item);
      }
    } catch (err) {
      console.error('Failed to purchase item:', err);
      setError(labels?.purchaseError || 'Failed to purchase item');
    } finally {
      setIsPurchasing(false);
    }
  };
  
  // JSX éƒ¨åˆ†
  return (
    <motion.div className="store-item-card">
      {/* ç‰©å“å›¾ç‰‡ */}
      <div className="item-image-container relative">
        {/* ... */}
        
        {/* VIPæ ‡ç­¾ */}
        {item.vipRequired && (
          <div className="vip-badge absolute top-2 left-2 px-2 py-1 rounded-full text-xs bg-amber-100 text-amber-800 border border-amber-300">
            {labels?.vipExclusiveLabel || 'VIP Exclusive'}
          </div>
        )}
        
        {/* ä¿ƒé”€æ ‡ç­¾ */}
        {item.isOnSale && item.salePrice !== undefined && (
          <div className="sale-badge absolute bottom-2 left-2 px-2 py-1 rounded-full text-xs bg-red-100 text-red-800 border border-red-300">
            {labels?.saleLabel || 'Sale'}
          </div>
        )}
      </div>
      
      {/* è´­ä¹°æŒ‰é’® */}
      <Button
        variant="jade"
        size="small"
        onClick={handlePurchase}
        disabled={isPurchasing || !canAfford() || (item.vipRequired && !isVip)}
      >
        {isPurchasing ? (
          <LoadingSpinner variant="white" size="small" />
        ) : (
          labels?.buyButtonText || 'Buy'
        )}
      </Button>
    </motion.div>
  );
};
```

## åæ€ç»„ä»¶

### MoodTracker ç»„ä»¶

```typescript
interface MoodTrackerProps {
  onMoodRecorded?: (mood: MoodRecord) => void;
  compact?: boolean;
  className?: string;
  labels?: {
    title?: string;
    currentMoodQuestion?: string;
    intensityLabel?: string;
    noteLabel?: string;
    notePlaceholder?: string;
    recordMoodButton?: string;
    historyLabel?: string;
    backLabel?: string;
    noMoodsMessage?: string;
    intensityStrength?: {
      veryMild?: string;
      mild?: string;
      moderate?: string;
      strong?: string;
      veryStrong?: string;
    };
  };
}

const MoodTracker: React.FC<MoodTrackerProps> = ({
  onMoodRecorded,
  compact = false,
  className = '',
  labels
}) => {
  // çŠ¶æ€å’Œé€»è¾‘...
  
  // è·å–å¼ºåº¦æ ‡ç­¾
  const getIntensityLabel = (intensity: MoodIntensity) => {
    switch (intensity) {
      case 1: return labels?.intensityStrength?.veryMild || 'Very Mild';
      case 2: return labels?.intensityStrength?.mild || 'Mild';
      case 3: return labels?.intensityStrength?.moderate || 'Moderate';
      case 4: return labels?.intensityStrength?.strong || 'Strong';
      case 5: return labels?.intensityStrength?.veryStrong || 'Very Strong';
      default: return 'Unknown';
    }
  };
  
  // JSX éƒ¨åˆ†
  return (
    <div className={`mood-tracker ${className}`}>
      <div className="mood-tracker-header flex justify-between items-center mb-4">
        <h2 className="text-xl font-bold text-jade-700">
          <span className="mr-2">ğŸµ</span>
          {labels?.title || "Mood Tracking"}
        </h2>
        <Button
          variant="secondary"
          size="small"
          onClick={() => setShowHistory(!showHistory)}
        >
          {showHistory ? (labels?.backLabel || "Back") : (labels?.historyLabel || "History")}
        </Button>
      </div>
      
      {/* æƒ…ç»ªé€‰æ‹©å™¨ */}
      <div className="mood-selector">
        <h3 className="text-lg font-bold mb-3">
          {labels?.currentMoodQuestion || "How are you feeling right now?"}
        </h3>
        {/* æƒ…ç»ªé€‰é¡¹ */}
      </div>
      
      {/* å¼ºåº¦é€‰æ‹©å™¨ */}
      <div className="intensity-selector mt-4">
        <h3 className="text-lg font-bold mb-2">
          {labels?.intensityLabel || "How intense is this feeling?"}
        </h3>
        {/* å¼ºåº¦æ»‘å— */}
      </div>
      
      {/* ç¬”è®°è¾“å…¥æ¡† */}
      <div className="note-input mt-4">
        <h3 className="text-lg font-bold mb-2">
          {labels?.noteLabel || "Anything you'd like to note? (optional)"}
        </h3>
        <textarea
          value={note}
          onChange={(e) => setNote(e.target.value)}
          className="w-full p-3 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500 h-24"
          placeholder={labels?.notePlaceholder || "Write down your thoughts..."}
        />
      </div>
      
      {/* æäº¤æŒ‰é’® */}
      <div className="form-actions mt-4 flex justify-end">
        <Button
          variant="jade"
          onClick={handleSubmit}
          disabled={isSubmitting}
        >
          {labels?.recordMoodButton || "Record Mood"}
        </Button>
      </div>
    </div>
  );
};
```

## ç»“è®º

é€šè¿‡ä»¥ä¸Šç¤ºä¾‹ï¼Œå¯ä»¥çœ‹åˆ°å¦‚ä½•ä¸ºä¸åŒç±»å‹çš„ç»„ä»¶å®ç°å¤šè¯­è¨€æ”¯æŒã€‚å…³é”®ç‚¹åŒ…æ‹¬ï¼š

1. ä¸ºç»„ä»¶æ·»åŠ  `labels` å±æ€§ï¼ŒåŒ…å«æ‰€æœ‰éœ€è¦æœ¬åœ°åŒ–çš„æ–‡æœ¬
2. ä¸ºæ¯ä¸ªæ–‡æœ¬æä¾›è‹±æ–‡é»˜è®¤å€¼ä½œä¸ºå›é€€
3. ç¡®ä¿é”™è¯¯æ¶ˆæ¯å’ŒçŠ¶æ€æ–‡æœ¬ä¹Ÿä½¿ç”¨æœ¬åœ°åŒ–æ ‡ç­¾
4. åœ¨çˆ¶ç»„ä»¶ä¸­æ­£ç¡®ä¼ é€’æ ‡ç­¾ç»™å­ç»„ä»¶

éµå¾ªè¿™äº›æ¨¡å¼å¯ä»¥ç¡®ä¿ PandaHabit åº”ç”¨æä¾›ä¸€è‡´çš„å¤šè¯­è¨€ä½“éªŒã€‚
</file>

<file path="docs/component-development-guide.md">
# ç»„ä»¶å¼€å‘æŒ‡å—

æœ¬æ–‡æ¡£æä¾›äº†PandaHabitåº”ç”¨ä¸­ç»„ä»¶å¼€å‘çš„æŒ‡å—å’Œæœ€ä½³å®è·µï¼Œç‰¹åˆ«å…³æ³¨å¤šè¯­è¨€æ”¯æŒå’Œç»„ä»¶å¤ç”¨ã€‚

## ç›®å½•

1. [å¤šè¯­è¨€æ”¯æŒ](#å¤šè¯­è¨€æ”¯æŒ)
2. [ç»„ä»¶è®¾è®¡åŸåˆ™](#ç»„ä»¶è®¾è®¡åŸåˆ™)
3. [é€šç”¨ç»„ä»¶](#é€šç”¨ç»„ä»¶)
4. [æ•°æ®åˆ·æ–°ä¸å±€éƒ¨æ›´æ–°](#æ•°æ®åˆ·æ–°ä¸å±€éƒ¨æ›´æ–°)
5. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

## å¤šè¯­è¨€æ”¯æŒ

PandaHabitåº”ç”¨æ”¯æŒä¸­æ–‡å’Œè‹±æ–‡ä¸¤ç§è¯­è¨€ï¼Œæ‰€æœ‰é¢å‘ç”¨æˆ·çš„æ–‡æœ¬éƒ½åº”è¯¥ä½¿ç”¨å¤šè¯­è¨€æ”¯æŒæœºåˆ¶ã€‚

### å¤šè¯­è¨€æ¶æ„

åº”ç”¨ä½¿ç”¨ä»¥ä¸‹æ¶æ„å®ç°å¤šè¯­è¨€æ”¯æŒï¼š

1. **LanguageProvider**ï¼šç®¡ç†å…¨å±€è¯­è¨€çŠ¶æ€ï¼ˆ`en` | `zh`ï¼‰
2. **localizedContentService**ï¼šæä¾›æœ¬åœ°åŒ–å†…å®¹çš„æœåŠ¡
3. **useLocalizedView**ï¼šç”¨äºè·å–é¡µé¢çº§åˆ«çš„æœ¬åœ°åŒ–å†…å®¹
4. **useComponentLabels**ï¼šç”¨äºè·å–ç»„ä»¶çº§åˆ«çš„æœ¬åœ°åŒ–å†…å®¹

### ç»„ä»¶ä¸­ä½¿ç”¨å¤šè¯­è¨€

å¯¹äºé€šç”¨ç»„ä»¶ï¼Œåº”ä½¿ç”¨`useComponentLabels`é’©å­è·å–æœ¬åœ°åŒ–æ ‡ç­¾ï¼š

```tsx
import { useComponentLabels } from '@/hooks/useComponentLabels';

const MyComponent = () => {
  const { labels } = useComponentLabels();
  
  return (
    <div>
      <h2>{labels.someSection.title}</h2>
      <p>{labels.someSection.description}</p>
      <button>{labels.button.submit}</button>
    </div>
  );
};
```

å¯¹äºé¡µé¢ç»„ä»¶ï¼Œåº”ä½¿ç”¨`useLocalizedView`é’©å­è·å–é¡µé¢çº§åˆ«çš„æœ¬åœ°åŒ–å†…å®¹ï¼š

```tsx
const {
  labels: pageLabels,
  isPending,
  isError,
  error,
  refetch
} = useLocalizedView<null, PageViewLabelsBundle>(
  'pageViewContent',
  fetchPageView
);

// å¤„ç†åŠ è½½çŠ¶æ€
if (isPending && !pageLabels) {
  return <LoadingSpinner variant="jade" type="content" />;
}

// å¤„ç†é”™è¯¯çŠ¶æ€
if (isError && !pageLabels) {
  return (
    <div className="page-content">
      <ErrorDisplay error={error} onRetry={refetch} />
    </div>
  );
}
```

### æ·»åŠ æ–°çš„æœ¬åœ°åŒ–æ ‡ç­¾

1. åœ¨`src/types/index.ts`ä¸­å®šä¹‰æ ‡ç­¾ç±»å‹
2. åœ¨`src/services/localizedContentService.ts`ä¸­æ·»åŠ è·å–æ ‡ç­¾çš„å‡½æ•°
3. åœ¨æ•°æ®åº“ä¸­æ·»åŠ å¯¹åº”çš„æ ‡ç­¾è®°å½•

## ç»„ä»¶è®¾è®¡åŸåˆ™

### 1. ç»„ä»¶åˆ†ç±»

PandaHabitåº”ç”¨ä¸­çš„ç»„ä»¶åˆ†ä¸ºä»¥ä¸‹å‡ ç±»ï¼š

- **é€šç”¨ç»„ä»¶**ï¼šå¦‚Buttonã€LoadingSpinnerã€ErrorDisplayç­‰ï¼Œä½äº`components/common`ç›®å½•
- **å¸ƒå±€ç»„ä»¶**ï¼šå¦‚AppShellã€Headerã€Navigationç­‰ï¼Œä½äº`components/layout`ç›®å½•
- **åŠŸèƒ½ç»„ä»¶**ï¼šå¦‚TaskListã€PandaAvatarç­‰ï¼Œä½äºå¯¹åº”åŠŸèƒ½çš„ç›®å½•
- **é¡µé¢ç»„ä»¶**ï¼šå¦‚HomePageã€SettingsPageç­‰ï¼Œä½äº`pages`ç›®å½•

### 2. ç»„ä»¶æ¥å£è®¾è®¡

- ç»„ä»¶åº”è¯¥æœ‰æ˜ç¡®çš„æ¥å£å®šä¹‰ï¼ˆTypeScriptæ¥å£ï¼‰
- æä¾›åˆç†çš„é»˜è®¤å€¼å’Œå¯é€‰å‚æ•°
- ä½¿ç”¨è§£æ„èµ‹å€¼æ¥æ”¶props
- ä½¿ç”¨å‡½æ•°ç»„ä»¶å’ŒReact Hooks

### 3. ç»„ä»¶æ–‡æ¡£

æ¯ä¸ªç»„ä»¶éƒ½åº”è¯¥æœ‰æ¸…æ™°çš„æ–‡æ¡£æ³¨é‡Šï¼ŒåŒ…æ‹¬ï¼š

- ç»„ä»¶çš„åŠŸèƒ½æè¿°
- å‚æ•°è¯´æ˜
- ä½¿ç”¨ç¤ºä¾‹

```tsx
/**
 * æŒ‰é’®ç»„ä»¶ï¼Œæ”¯æŒä¸åŒæ ·å¼å’ŒåŠ è½½çŠ¶æ€
 *
 * @param variant - æŒ‰é’®æ ·å¼ï¼š'primary'ï¼ˆé»˜è®¤ï¼‰, 'secondary', 'jade'ï¼ˆæ¸¸æˆé£æ ¼ç»¿è‰²ï¼‰, 'gold'ï¼ˆé«˜çº§ï¼‰
 * @param isLoading - æ˜¯å¦æ˜¾ç¤ºåŠ è½½çŠ¶æ€
 * @param loadingText - åŠ è½½çŠ¶æ€æ˜¾ç¤ºçš„æ–‡æœ¬ï¼ˆè¦†ç›–é»˜è®¤æœ¬åœ°åŒ–æ–‡æœ¬ï¼‰
 */
```

## é€šç”¨ç»„ä»¶

PandaHabitåº”ç”¨æä¾›äº†ä»¥ä¸‹é€šç”¨ç»„ä»¶ï¼Œåº”ä¼˜å…ˆä½¿ç”¨è¿™äº›ç»„ä»¶ä»¥ä¿æŒUIä¸€è‡´æ€§ï¼š

### Button

æŒ‰é’®ç»„ä»¶ï¼Œæ”¯æŒä¸åŒæ ·å¼å’ŒåŠ è½½çŠ¶æ€ã€‚

```tsx
<Button 
  variant="jade" 
  isLoading={isSubmitting} 
  onClick={handleSubmit}
>
  æäº¤
</Button>
```

### LoadingSpinner

åŠ è½½æŒ‡ç¤ºå™¨ç»„ä»¶ï¼Œæ”¯æŒæ¸¸æˆé£æ ¼ã€‚

```tsx
<LoadingSpinner 
  variant="jade" 
  type="data" 
  text="è‡ªå®šä¹‰åŠ è½½æ–‡æœ¬" 
/>
```

### ErrorDisplay

é”™è¯¯æ˜¾ç¤ºç»„ä»¶ï¼Œç”¨äºå±•ç¤ºé”™è¯¯ä¿¡æ¯ã€‚

```tsx
<ErrorDisplay 
  error={error} 
  onRetry={handleRetry} 
  errorType="network" 
/>
```

### DataLoader

æ•°æ®åŠ è½½ç»„ä»¶ï¼Œå¤„ç†åŠ è½½ã€é”™è¯¯å’Œç©ºæ•°æ®çŠ¶æ€ã€‚

```tsx
<DataLoader
  isLoading={isLoading}
  isError={isError}
  error={error}
  data={data}
  onRetry={refetch}
>
  {(data) => (
    // æ¸²æŸ“æ•°æ®
    <div>{data.name}</div>
  )}
</DataLoader>
```

### Modal

æ¨¡æ€æ¡†ç»„ä»¶ï¼Œç”¨äºæ˜¾ç¤ºå¼¹å‡ºå†…å®¹ã€‚

```tsx
<Modal
  isOpen={isOpen}
  onClose={handleClose}
  closeOnOutsideClick={true}
>
  <div>æ¨¡æ€æ¡†å†…å®¹</div>
</Modal>
```

## æ•°æ®åˆ·æ–°ä¸å±€éƒ¨æ›´æ–°

PandaHabitåº”ç”¨ä½¿ç”¨DataRefreshProviderå®ç°æ•°æ®åŒæ­¥åçš„å±€éƒ¨UIæ›´æ–°ã€‚

### ä½¿ç”¨DataRefreshProvider

```tsx
// ç›‘å¬å¤šä¸ªè¡¨
useDataRefresh(['table1', 'table2'], (event) => {
  // å¤„ç†æ•°æ®åˆ·æ–°
});

// æˆ–ç›‘å¬å•ä¸ªè¡¨
useTableRefresh('tableName', (data) => {
  // å¤„ç†è¡¨æ•°æ®åˆ·æ–°
});
```

## æœ€ä½³å®è·µ

### 1. é¿å…ç¡¬ç¼–ç æ–‡æœ¬

âŒ é”™è¯¯ç¤ºä¾‹ï¼š
```tsx
<button>æäº¤</button>
<p>æš‚æ— æ•°æ®</p>
```

âœ… æ­£ç¡®ç¤ºä¾‹ï¼š
```tsx
<button>{labels.button.submit}</button>
<p>{labels.emptyState.noData}</p>
```

### 2. ä½¿ç”¨ç»„ä»¶è€Œéç›´æ¥ä½¿ç”¨HTMLå…ƒç´ 

âŒ é”™è¯¯ç¤ºä¾‹ï¼š
```tsx
<button className="button-primary" onClick={handleClick}>
  {isLoading ? "åŠ è½½ä¸­..." : "æäº¤"}
</button>
```

âœ… æ­£ç¡®ç¤ºä¾‹ï¼š
```tsx
<Button 
  variant="primary" 
  isLoading={isLoading} 
  onClick={handleClick}
>
  æäº¤
</Button>
```

### 3. å¤„ç†åŠ è½½å’Œé”™è¯¯çŠ¶æ€

âŒ é”™è¯¯ç¤ºä¾‹ï¼š
```tsx
if (isLoading) return <div>åŠ è½½ä¸­...</div>;
if (isError) return <div>å‡ºé”™äº†</div>;
```

âœ… æ­£ç¡®ç¤ºä¾‹ï¼š
```tsx
if (isLoading) return <LoadingSpinner type="data" />;
if (isError) return <ErrorDisplay error={error} onRetry={refetch} />;
```

### 4. ä½¿ç”¨DataLoaderç»„ä»¶å¤„ç†æ•°æ®åŠ è½½

âŒ é”™è¯¯ç¤ºä¾‹ï¼š
```tsx
if (isLoading) return <LoadingSpinner />;
if (isError) return <ErrorDisplay error={error} />;
if (!data) return <div>æš‚æ— æ•°æ®</div>;
return <div>{data.name}</div>;
```

âœ… æ­£ç¡®ç¤ºä¾‹ï¼š
```tsx
<DataLoader
  isLoading={isLoading}
  isError={isError}
  error={error}
  data={data}
  onRetry={refetch}
>
  {(data) => <div>{data.name}</div>}
</DataLoader>
```

### 5. ä½¿ç”¨å±€éƒ¨åˆ·æ–°è€Œéæ•´é¡µåˆ·æ–°

âŒ é”™è¯¯ç¤ºä¾‹ï¼š
```tsx
// æ•°æ®å˜åŒ–æ—¶åˆ·æ–°æ•´ä¸ªç»„ä»¶
useEffect(() => {
  fetchData();
}, [someData]);
```

âœ… æ­£ç¡®ç¤ºä¾‹ï¼š
```tsx
// ç›‘å¬ç‰¹å®šè¡¨çš„å˜åŒ–
useTableRefresh('tableName', (updatedData) => {
  // åªæ›´æ–°å—å½±å“çš„éƒ¨åˆ†
  updateLocalState(updatedData);
});
```
</file>

<file path="docs/multilingual-support-fixes.md">
# ç»„ä»¶å¤šè¯­è¨€æ”¯æŒå¼€å‘æŒ‡å—

æœ¬æ–‡æ¡£æä¾›äº†PandaHabitåº”ç”¨ä¸­ç»„ä»¶å¤šè¯­è¨€æ”¯æŒçš„å®ç°æŒ‡å—å’Œæœ€ä½³å®è·µï¼Œå¸®åŠ©å¼€å‘è€…æ­£ç¡®ä½¿ç”¨å¤šè¯­è¨€åŠŸèƒ½å¹¶é¿å…ç¡¬ç¼–ç æ–‡æœ¬ã€‚

## ç›®å½•

1. [å¤šè¯­è¨€æ¶æ„æ¦‚è¿°](#å¤šè¯­è¨€æ¶æ„æ¦‚è¿°)
2. [ç»„ä»¶å¤šè¯­è¨€æ”¯æŒå®ç°](#ç»„ä»¶å¤šè¯­è¨€æ”¯æŒå®ç°)
3. [å¸¸è§ç»„ä»¶çš„å¤šè¯­è¨€æ”¯æŒ](#å¸¸è§ç»„ä»¶çš„å¤šè¯­è¨€æ”¯æŒ)
4. [ç¡¬ç¼–ç æ–‡æœ¬ä¿®å¤æŒ‡å—](#ç¡¬ç¼–ç æ–‡æœ¬ä¿®å¤æŒ‡å—)
5. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

## å¤šè¯­è¨€æ¶æ„æ¦‚è¿°

PandaHabitåº”ç”¨ä½¿ç”¨ä»¥ä¸‹æ¶æ„å®ç°å¤šè¯­è¨€æ”¯æŒï¼š

1. **LanguageProvider**ï¼šç®¡ç†å…¨å±€è¯­è¨€çŠ¶æ€ï¼ˆ`en` | `zh`ï¼‰
   - æä¾›å½“å‰è¯­è¨€å’Œåˆ‡æ¢è¯­è¨€çš„æ–¹æ³•
   - å°†è¯­è¨€é€‰æ‹©ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨

2. **localizedContentService**ï¼šæä¾›æœ¬åœ°åŒ–å†…å®¹çš„æœåŠ¡
   - ä»æ•°æ®åº“è·å–ç‰¹å®šè¯­è¨€çš„æ ‡ç­¾
   - ä¸ºå„ä¸ªé¡µé¢å’Œç»„ä»¶æä¾›æœ¬åœ°åŒ–å†…å®¹

3. **useLocalizedView**ï¼šç”¨äºè·å–é¡µé¢çº§åˆ«çš„æœ¬åœ°åŒ–å†…å®¹
   - è‡ªåŠ¨å¤„ç†è¯­è¨€åˆ‡æ¢
   - æä¾›åŠ è½½çŠ¶æ€å’Œé”™è¯¯å¤„ç†

4. **useComponentLabels**ï¼šç”¨äºè·å–ç»„ä»¶çº§åˆ«çš„æœ¬åœ°åŒ–å†…å®¹
   - æä¾›é€šç”¨ç»„ä»¶æ‰€éœ€çš„æœ¬åœ°åŒ–æ ‡ç­¾
   - åŒ…å«åˆç†çš„é»˜è®¤å€¼ä½œä¸ºåå¤‡

## ç»„ä»¶å¤šè¯­è¨€æ”¯æŒå®ç°

### ç»„ä»¶æ ‡ç­¾ç±»å‹å®šä¹‰

åœ¨`src/types/index.ts`ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰äº†ç»„ä»¶æ ‡ç­¾çš„ç±»å‹ï¼š

```typescript
// æŒ‰é’®æ ‡ç­¾
export interface ButtonLabels {
  loading: string;
  retry: string;
  confirm: string;
  cancel: string;
  save: string;
  close: string;
  submit: string;
  edit: string;
  delete: string;
  back: string;
  next: string;
}

// åŠ è½½çŠ¶æ€æ ‡ç­¾
export interface LoadingLabels {
  generic: string;
  data: string;
  content: string;
  saving: string;
  processing: string;
}

// é”™è¯¯æ ‡ç­¾
export interface ErrorLabels {
  generic: string;
  title: string;
  retry: string;
  details: string;
  networkError: string;
  serverError: string;
  unknownError: string;
}

// ç©ºçŠ¶æ€æ ‡ç­¾
export interface EmptyStateLabels {
  generic: string;
  noData: string;
  noResults: string;
  noItems: string;
}

// æ¨¡æ€æ¡†æ ‡ç­¾
export interface ModalLabels {
  close: string;
  confirm: string;
  cancel: string;
}

// ç»„ä»¶æ ‡ç­¾é›†åˆ
export interface ComponentsLabelsBundle {
  button: ButtonLabels;
  loading: LoadingLabels;
  error: ErrorLabels;
  emptyState: EmptyStateLabels;
  modal: ModalLabels;
}
```

### è·å–ç»„ä»¶æ ‡ç­¾çš„æœåŠ¡

åœ¨`src/services/localizedContentService.ts`ä¸­ï¼Œæˆ‘ä»¬æ·»åŠ äº†è·å–ç»„ä»¶æ ‡ç­¾çš„å‡½æ•°ï¼š

```typescript
/**
 * è·å–ç»„ä»¶æœ¬åœ°åŒ–æ ‡ç­¾
 * 
 * @param lang - è¯­è¨€ä»£ç 
 * @returns ç»„ä»¶æ ‡ç­¾é›†åˆ
 */
export async function fetchComponentsLabels(lang: Language): Promise<FetchComponentsLabelsResult> {
  console.log(`SVC_DEXIE: Fetching COMPONENTS LABELS for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<ComponentsLabelsBundle>('components', lang);
  return { labels, data: null };
}
```

### ç»„ä»¶æ ‡ç­¾Hook

åœ¨`src/hooks/useComponentLabels.ts`ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªä¸“ç”¨Hookæ¥è·å–ç»„ä»¶æ ‡ç­¾ï¼š

```typescript
/**
 * è·å–ç»„ä»¶æœ¬åœ°åŒ–æ ‡ç­¾çš„Hook
 * 
 * @returns ç»„ä»¶æ ‡ç­¾å’ŒåŠ è½½/é”™è¯¯çŠ¶æ€
 */
export function useComponentLabels() {
  const {
    labels: componentLabels,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<null, ComponentsLabelsBundle>(
    'componentsLabels',
    fetchComponentsLabels
  );

  // é»˜è®¤åå¤‡æ ‡ç­¾
  const fallbackLabels: Partial<ComponentsLabelsBundle> = {
    button: {
      loading: 'Loading...',
      retry: 'Retry',
      // ... å…¶ä»–æŒ‰é’®æ ‡ç­¾
    },
    loading: {
      generic: 'Loading...',
      data: 'Loading data...',
      // ... å…¶ä»–åŠ è½½æ ‡ç­¾
    },
    // ... å…¶ä»–æ ‡ç­¾ç±»åˆ«
  } as ComponentsLabelsBundle;

  // åˆå¹¶è·å–çš„æ ‡ç­¾å’Œåå¤‡æ ‡ç­¾ï¼Œä¼˜å…ˆä½¿ç”¨è·å–çš„æ ‡ç­¾
  const mergedLabels = componentLabels
    ? {
        button: { ...fallbackLabels.button, ...componentLabels.button },
        // ... åˆå¹¶å…¶ä»–æ ‡ç­¾ç±»åˆ«
      }
    : fallbackLabels;

  return {
    labels: mergedLabels,
    isPending,
    isError,
    error,
    refetch
  };
}
```

## å¸¸è§ç»„ä»¶çš„å¤šè¯­è¨€æ”¯æŒ

### Buttonç»„ä»¶

```tsx
const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'primary',
  isLoading = false,
  loadingText,
  ...props
}) => {
  // è·å–æœ¬åœ°åŒ–æ ‡ç­¾
  const { labels } = useComponentLabels();
  // ä½¿ç”¨æä¾›çš„loadingTextæˆ–å›é€€åˆ°æœ¬åœ°åŒ–æ ‡ç­¾
  const finalLoadingText = loadingText || labels.button.loading;
  
  return (
    <button
      className={`${baseStyle} ${variantStyle}`.trim()}
      disabled={isLoading || props.disabled}
      {...props}
    >
      {isLoading ? finalLoadingText : children}
    </button>
  );
};
```

### LoadingSpinnerç»„ä»¶

```tsx
const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  text,
  variant = 'default',
  type = 'generic'
}) => {
  const { labels } = useComponentLabels();
  const spinnerClass = variant === 'jade' ? 'jade-spinner' : 'loading-spinner';
  
  // ä½¿ç”¨æä¾›çš„textæˆ–å›é€€åˆ°åŸºäºtypeçš„æœ¬åœ°åŒ–æ ‡ç­¾
  const displayText = text || labels.loading[type];

  return (
    <div className="loading-spinner-overlay">
      <div className={spinnerClass}></div>
      {displayText && <p className="loading-spinner-text">{displayText}</p>}
    </div>
  );
};
```

### ErrorDisplayç»„ä»¶

```tsx
const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  title,
  messageTemplate,
  onRetry,
  retryButtonText,
  errorType = 'generic',
}) => {
  const { labels } = useComponentLabels();
  
  // ä½¿ç”¨æä¾›çš„å€¼æˆ–å›é€€åˆ°æœ¬åœ°åŒ–æ ‡ç­¾
  const displayTitle = title || labels.error.title;
  const displayMessageTemplate = messageTemplate || labels.error.details;
  const displayRetryButtonText = retryButtonText || labels.error.retry;
  
  // ... é”™è¯¯å¤„ç†é€»è¾‘
  
  return (
    <div className="error-container" role="alert">
      <h3>{displayTitle}</h3>
      <p className="error-text">{finalMessage}</p>
      {/* ... å…¶ä»–é”™è¯¯ä¿¡æ¯ */}
      {onRetry && (
        <Button onClick={onRetry} variant="secondary">
          {displayRetryButtonText}
        </Button>
      )}
    </div>
  );
};
```

### DataLoaderç»„ä»¶

```tsx
function DataLoader<T>({
  isLoading,
  isError,
  error,
  data,
  loadingText,
  errorTitle,
  onRetry,
  emptyState,
  children,
  loadingComponent,
  errorComponent
}: DataLoaderProps<T>) {
  // è·å–æœ¬åœ°åŒ–æ ‡ç­¾
  const { labels } = useComponentLabels();
  
  // ... åŠ è½½ã€é”™è¯¯å’Œç©ºæ•°æ®çŠ¶æ€å¤„ç†
  
  // ç©ºæ•°æ®çŠ¶æ€ç¤ºä¾‹
  if (!data) {
    return (
      <motion.div className="data-loader-container">
        {emptyState || (
          <div className="empty-state">
            <p>{labels.emptyState.noData}</p>
          </div>
        )}
      </motion.div>
    );
  }
  
  // æ¸²æŸ“æ•°æ®
  return <>{children(data)}</>;
}
```

## ç¡¬ç¼–ç æ–‡æœ¬ä¿®å¤æŒ‡å—

### è¯†åˆ«ç¡¬ç¼–ç æ–‡æœ¬

ç¡¬ç¼–ç æ–‡æœ¬æ˜¯æŒ‡ç›´æ¥å†™åœ¨ç»„ä»¶ä¸­çš„æ–‡æœ¬å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ï¼š

```tsx
// ç¡¬ç¼–ç æ–‡æœ¬ç¤ºä¾‹
<button>æäº¤</button>
<p>æš‚æ— æ•°æ®</p>
<div>åŠ è½½ä¸­...</div>
```

### ä¿®å¤æ­¥éª¤

1. **è¯†åˆ«ç»„ä»¶ä¸­çš„ç¡¬ç¼–ç æ–‡æœ¬**
   - æŸ¥æ‰¾ç›´æ¥å†™åœ¨JSXä¸­çš„å­—ç¬¦ä¸²
   - æŸ¥æ‰¾é»˜è®¤å€¼ä¸­çš„å­—ç¬¦ä¸²

2. **æ·»åŠ é€‚å½“çš„æ ‡ç­¾ç±»å‹**
   - å¦‚æœæ˜¯é€šç”¨æ–‡æœ¬ï¼ˆå¦‚"åŠ è½½ä¸­"ã€"æäº¤"ç­‰ï¼‰ï¼Œä½¿ç”¨ç°æœ‰çš„ComponentsLabelsBundle
   - å¦‚æœæ˜¯ç‰¹å®šåŠŸèƒ½çš„æ–‡æœ¬ï¼Œæ·»åŠ æ–°çš„æ ‡ç­¾ç±»å‹

3. **ä½¿ç”¨useComponentLabelsè·å–æ ‡ç­¾**
   - åœ¨ç»„ä»¶ä¸­å¯¼å…¥å¹¶ä½¿ç”¨useComponentLabels
   - ä½¿ç”¨æ ‡ç­¾æ›¿æ¢ç¡¬ç¼–ç æ–‡æœ¬

4. **æä¾›åˆç†çš„é»˜è®¤å€¼ä½œä¸ºåå¤‡**
   - ç¡®ä¿å³ä½¿æ ‡ç­¾è·å–å¤±è´¥ä¹Ÿèƒ½æ˜¾ç¤ºåˆç†çš„æ–‡æœ¬

## æœ€ä½³å®è·µ

### 1. é¿å…ç¡¬ç¼–ç æ–‡æœ¬

âŒ é”™è¯¯ç¤ºä¾‹ï¼š
```tsx
<button>æäº¤</button>
<p>æš‚æ— æ•°æ®</p>
```

âœ… æ­£ç¡®ç¤ºä¾‹ï¼š
```tsx
<button>{labels.button.submit}</button>
<p>{labels.emptyState.noData}</p>
```

### 2. ä½¿ç”¨ç»„ä»¶è€Œéç›´æ¥ä½¿ç”¨HTMLå…ƒç´ 

âŒ é”™è¯¯ç¤ºä¾‹ï¼š
```tsx
<button className="button-primary" onClick={handleClick}>
  {isLoading ? "åŠ è½½ä¸­..." : "æäº¤"}
</button>
```

âœ… æ­£ç¡®ç¤ºä¾‹ï¼š
```tsx
<Button 
  variant="primary" 
  isLoading={isLoading} 
  onClick={handleClick}
>
  {labels.button.submit}
</Button>
```

### 3. å¤„ç†åŠ è½½å’Œé”™è¯¯çŠ¶æ€

âŒ é”™è¯¯ç¤ºä¾‹ï¼š
```tsx
if (isLoading) return <div>åŠ è½½ä¸­...</div>;
if (isError) return <div>å‡ºé”™äº†</div>;
```

âœ… æ­£ç¡®ç¤ºä¾‹ï¼š
```tsx
if (isLoading) return <LoadingSpinner type="data" />;
if (isError) return <ErrorDisplay error={error} onRetry={refetch} />;
```

### 4. æä¾›è¦†ç›–é€‰é¡¹ä½†ä½¿ç”¨é»˜è®¤æœ¬åœ°åŒ–æ–‡æœ¬

âŒ é”™è¯¯ç¤ºä¾‹ï¼š
```tsx
<Button loadingText="Loading...">Submit</Button>
```

âœ… æ­£ç¡®ç¤ºä¾‹ï¼š
```tsx
// ä¸æŒ‡å®šloadingTextï¼Œä½¿ç”¨é»˜è®¤æœ¬åœ°åŒ–æ–‡æœ¬
<Button isLoading={isSubmitting}>{labels.button.submit}</Button>

// æˆ–åœ¨éœ€è¦ç‰¹æ®Šæ–‡æœ¬æ—¶æä¾›è¦†ç›–
<Button loadingText={customLoadingText}>Custom Action</Button>
```

### 5. ä½¿ç”¨ç±»å‹ç³»ç»Ÿç¡®ä¿æ ‡ç­¾å®Œæ•´æ€§

âŒ é”™è¯¯ç¤ºä¾‹ï¼š
```tsx
// æœªå®šä¹‰ç±»å‹ï¼Œå¯èƒ½ç¼ºå°‘æ ‡ç­¾
const labels = {
  submit: "æäº¤",
  cancel: "å–æ¶ˆ"
};
```

âœ… æ­£ç¡®ç¤ºä¾‹ï¼š
```tsx
// ä½¿ç”¨æ¥å£ç¡®ä¿æ ‡ç­¾å®Œæ•´æ€§
interface ButtonLabels {
  submit: string;
  cancel: string;
  edit: string;
  // å…¶ä»–å¿…è¦æ ‡ç­¾
}

const labels: ButtonLabels = {
  submit: "æäº¤",
  cancel: "å–æ¶ˆ",
  edit: "ç¼–è¾‘"
  // TypeScriptä¼šæ£€æŸ¥æ˜¯å¦ç¼ºå°‘æ ‡ç­¾
};
```
</file>

<file path="germini.md">
å¥½çš„ï¼Œä»¥ä¸‹æ˜¯PandaHabit App Design Briefçš„ç‹¬ç«‹å®Œæ•´å†…å®¹ï¼Œå·²é¿å…ä½¿ç”¨â€œä¿æŒä¸å˜â€æˆ–â€œä¸ä¸Šç›¸åŒâ€ç­‰è¯è¯­ï¼Œå¹¶ç¡®ä¿æ‰€æœ‰éƒ¨åˆ†éƒ½æ˜¯å…·ä½“å’Œè¯¦ç»†çš„ã€‚

---

**PandaHabit App Design Brief: åä¸½æ¸¸æˆé£æ ¼ (èåˆè®¢é˜…å¢é•¿ä¼˜åŒ–)**

**ç‰ˆæœ¬:** 1.2
**æ—¥æœŸ:** May 15, 2025
**çŠ¶æ€:** æœ€ç»ˆç¨¿

## 1. Introduction

### 1.1 Overview
PandaHabitæ˜¯ä¸€æ¬¾ç§»åŠ¨åº”ç”¨ï¼Œé€šè¿‡å¼•äººå…¥èƒœä¸”æ”¯æŒæ€§çš„è™šæ‹Ÿå® ç‰©ä½“éªŒï¼Œå¸®åŠ©ç”¨æˆ·å»ºç«‹ç§¯æçš„ä¹ æƒ¯ï¼Œæ”¹å–„è‡ªæˆ‘æŠ¤ç†ï¼Œæå‡å¿ƒç†å¥åº·ã€‚ç”¨æˆ·é€šè¿‡å®Œæˆç°å®ç”Ÿæ´»ä¸­çš„ä»»åŠ¡å’Œä¹ æƒ¯æ¥åŸ¹å…»è™šæ‹Ÿç†ŠçŒ«ï¼Œåˆ›é€ ä¸€ç§å…±ç”Ÿå…³ç³»ï¼Œç…§é¡¾è‡ªå·±ç›´æ¥æœ‰ç›Šäºå® ç‰©ï¼Œè€Œå® ç‰©åˆ™æä¾›é™ªä¼´ã€åŠ¨åŠ›å’Œæ¸©å’Œçš„æŒ‡å¯¼ã€‚

### 1.2 åä¸½æ¸¸æˆé£æ ¼è®¾è®¡ç†å¿µ (èåˆä»·å€¼é©±åŠ¨)
PandaHabitçš„è®¾è®¡ç†å¿µå›´ç»•åˆ›é€ ä¸€ç§**åä¸½å¥¢åä¸”ä»·å€¼é©±åŠ¨çš„æ¸¸æˆä½“éªŒ**ï¼Œç»™äººä»¥é«˜çº§æ„Ÿã€æ²‰æµ¸æ„Ÿå’Œæƒ…æ„Ÿæ»¡è¶³æ„Ÿã€‚åº”ç”¨æ—¨åœ¨é€šè¿‡åˆ©ç”¨ç²¾ç¾ç»šä¸½çš„è§†è§‰æ•ˆæœã€ç²¾å¿ƒè®¾è®¡çš„äº¤äº’å’Œä»¤äººæƒŠå¹çš„åŠ¨ç”»æ•ˆæœï¼Œå°†è‡ªæˆ‘æŠ¤ç†ä»ä¸€é¡¹çäº‹è½¬å˜ä¸ºä¸€æ®µæ„‰æ‚¦çš„æ—…ç¨‹ã€‚æˆ‘ä»¬é‡‡ç”¨äº†ä¸œæ–¹ç¾å­¦ä¸ç°ä»£æ¸¸æˆè®¾è®¡ç›¸ç»“åˆçš„æ–¹å¼ï¼Œæ‰“é€ å‡ºä¸€ä¸ªæ—¢åä¸½å£®è§‚åˆæ¸©é¦¨èˆ’é€‚çš„æ•°å­—ç©ºé—´ã€‚æ‰€æœ‰åä¸½çš„è§†è§‰å’Œäº¤äº’ï¼Œéƒ½æœåŠ¡äºæ¸…æ™°åœ°ä¼ é€’PandaHabitä¸ºç”¨æˆ·å¸¦æ¥çš„æ ¸å¿ƒä»·å€¼ï¼Œç‰¹åˆ«æ˜¯VIPè®¢é˜…æ‰€èƒ½æä¾›çš„å“è¶Šæ”¯æŒä¸ä½“éªŒå‡çº§ã€‚

### 1.3 ç›®æ ‡ç”¨æˆ·
-   å¯»æ±‚ä¹ æƒ¯å…»æˆå’Œè‡ªæˆ‘æŠ¤ç†å·¥å…·çš„ä¸ªäººã€‚
-   å–œæ¬¢æ¸¸æˆåŒ–å’Œè™šæ‹Ÿå® ç‰©ä½“éªŒçš„ç”¨æˆ·ã€‚
-   æ¸´æœ›è·å¾—æ”¯æŒæ€§ã€æ¸©å’Œæ–¹å¼è¿›è¡Œä¸ªäººå‘å±•çš„äººç¾¤ã€‚
-   å¹´é¾„èŒƒå›´ï¼š18-45å²ï¼Œé‡ç‚¹å…³æ³¨å¹´è½»ä¸“ä¸šäººå£«å’Œå­¦ç”Ÿã€‚
-   æ¬£èµé«˜å“è´¨æ•°å­—ä½“éªŒå¹¶æ¸…æ™°æ„ŸçŸ¥ä»·å€¼åæ„¿æ„æŠ•èµ„ä¼˜è´¨åº”ç”¨çš„ç”¨æˆ·ã€‚
-   å¯¹ä¸œæ–¹ç¾å­¦å’Œåä¸½è§†è§‰é£æ ¼æœ‰åå¥½çš„ç©å®¶ã€‚

## 2. åä¸½æ¸¸æˆé£æ ¼åˆ†æ (å¼ºè°ƒè®¢é˜…ä»·å€¼çš„è§†è§‰å‘ˆç°)

### 2.1 åä¸½æ¸¸æˆé£æ ¼å®šä¹‰
å¯¹äºPandaHabitï¼Œ"åä¸½æ¸¸æˆé£æ ¼"çš„å®šä¹‰åŒ…æ‹¬ï¼š
-   **ç»šä¸½åç¾çš„è§†è§‰æ•ˆæœ**ï¼ŒåŒ…å«ç²¾ç»†çš„æ’ç”»å’ŒåŠ¨ç”»ï¼Œçµæ„Ÿæ¥æºäºä¸œæ–¹ç¾å­¦å’Œä¼ ç»Ÿä¸­å›½è‰ºæœ¯ã€‚VIPä¸“å±å†…å®¹ï¼ˆå¦‚çš®è‚¤ã€åœºæ™¯ï¼‰å°†é‡‡ç”¨æ›´é«˜çº§åˆ«çš„ç»†èŠ‚å’Œå…‰æ•ˆï¼Œä»¥å½°æ˜¾å…¶ç‹¬ç‰¹æ€§ã€‚
-   **é‡‘ç¢§è¾‰ç…Œçš„è‰²å½©æ­é…**ï¼Œèåˆæ·±æ²‰çš„å®çŸ³è‰²è°ƒã€é‡‘è‰²ç‚¹ç¼€ã€ç²¾è‡´çš„æ¸å˜å’Œä¼ ç»Ÿä¸­å›½è‰²å½©ã€‚é‡‘è‰²å’Œç‰¹å®šå®çŸ³è‰²ï¼ˆå¦‚ç´«æª€ç´«ï¼‰å°†ä¼˜å…ˆç”¨äºVIPç›¸å…³å…ƒç´ ï¼Œè¥é€ å°Šè´µæ„Ÿã€‚
-   **ç²¾é›•ç»†ç¢çš„UIå…ƒç´ **ï¼Œæ³¨é‡é˜´å½±ã€é«˜å…‰å’Œçº¹ç†ç»†èŠ‚ï¼Œé‡‡ç”¨ä¼ ç»Ÿä¸­å›½è£…é¥°å…ƒç´ ï¼ˆå¦‚äº‘çº¹ã€å¦‚æ„çº¹ï¼‰ã€‚VIPç›¸å…³æŒ‰é’®ã€å¡ç‰‡å°†æ‹¥æœ‰æ›´å¤æ‚çš„çº¹é¥°å’Œæ›´æ˜¾è‘—çš„åŠ¨æ€æ•ˆæœã€‚
-   **æµç•…åä¸½çš„åŠ¨ç”»æ•ˆæœ**ï¼Œæä¾›è§†è§‰åé¦ˆå’Œæ„‰æ‚¦æ„Ÿï¼ŒåŠ¨ç”»é£æ ¼èåˆç°ä»£æ¸¸æˆä¸ä¼ ç»Ÿæ°´å¢¨ç”»åŠ¨æ€ç¾æ„Ÿã€‚VIPç‰¹æƒå¸¦æ¥çš„åŠ é€Ÿã€é¢å¤–å¥–åŠ±ç­‰å°†é€šè¿‡æ›´ç‚«ä¸½ã€æ›´å…·å†²å‡»åŠ›çš„åŠ¨ç”»æ¥ä½“ç°ã€‚
-   **æ²‰æµ¸å¼éŸ³æ•ˆè®¾è®¡**ï¼Œç»“åˆå¹³é™çš„è‡ªç„¶å£°éŸ³ã€ä¼ ç»Ÿä¸­å›½ä¹å™¨å’Œæ¸©æŸ”çš„éŸ³ä¹å…ƒç´ ã€‚VIPä¸“å±åœºæ™¯æˆ–äº’åŠ¨å°†é…å¤‡ç‹¬ç‰¹çš„èƒŒæ™¯éŸ³ä¹æˆ–éŸ³æ•ˆã€‚
-   **ç²¾å¿ƒè®¾è®¡çš„å­—ä½“æ’ç‰ˆ**ï¼Œå¹³è¡¡å¯è¯»æ€§ä¸ç¾å­¦å¸å¼•åŠ›ï¼Œä¸­æ–‡ä½¿ç”¨ä¼˜é›…çš„ä¹¦æ³•é£æ ¼å­—ä½“ã€‚VIPèº«ä»½æ ‡è¯†ã€ç‰¹æƒæè¿°å°†ä½¿ç”¨æ›´å…·è‰ºæœ¯æ„Ÿçš„å­—ä½“æˆ–ç‰¹æ®Šæ’ç‰ˆã€‚

### 2.2 è§†è§‰å‚è€ƒä¸çµæ„Ÿæ¥æº
-   **é«˜å“è´¨ç§»åŠ¨æ¸¸æˆ**ï¼šã€ŠåŸç¥ã€‹(æ•´ä½“UIé£æ ¼ä¸åŠ¨æ•ˆ)ã€ã€Šå¤©æ¶¯æ˜æœˆåˆ€ã€‹(ä¸­å›½é£å…ƒç´ )ã€ã€Šé˜´é˜³å¸ˆã€‹(åä¸½ç‰¹æ•ˆ)ã€‚
-   **ä¸­å›½ä¼ ç»Ÿè‰ºæœ¯**ï¼šæ°´å¢¨ç”»ã€ç«¹å­å›¾æ¡ˆã€å±±æ°´ç”»ã€ä¼ ç»Ÿçº¹é¥°ã€å‰ªçº¸è‰ºæœ¯ã€äº¬å‰§è„¸è°±å…ƒç´ ã€‚
-   **å¥¢ä¾ˆå“ç‰Œåº”ç”¨**ï¼šä¸Šæµ·æ»©ã€æ•…å®«æ–‡åˆ›ã€Louis Vuittonä¸­å›½ç‰ˆã€‚
-   **è‡ªç„¶å¯å‘è®¾è®¡**ï¼šå›½å®¶åœ°ç†ã€é«˜ç«¯åº¦å‡æ‘ç½‘ç«™ã€ä¸­å›½å›­æ—è®¾è®¡ã€‚
-   **å¤å…¸æ¸¸æˆç¾å­¦**ï¼šã€Šè½©è¾•å‰‘ã€‹ç³»åˆ—ã€ã€Šä»™å‰‘å¥‡ä¾ ä¼ ã€‹ç³»åˆ—çš„è§†è§‰é£æ ¼ã€‚
-   **ç°ä»£ä¸­å›½é£è®¾è®¡**ï¼šå½“ä»£ä¸­å›½æ’ç”»å¸ˆä½œå“ã€æ–°ä¸­å¼è®¾è®¡å…ƒç´ ã€‚

### 2.3 åä¸½è‰²å½©æ–¹æ¡ˆ (çªå‡ºVIPå°Šè´µæ„Ÿ)
-   **ä¸»è¦è‰²å½©**:
    -   çš‡å®¶ç¿¡ç¿ ç»¿ (#1A5F4A)ï¼šä»£è¡¨æˆé•¿ã€å®é™ä¸è‡ªç„¶ï¼Œçµæ„Ÿæ¥è‡ªä¼ ç»Ÿä¸­å›½ç‰å™¨ã€‚
    -   å¯Œè´µç«¹ç»¿ (#88B04B)ï¼šè±¡å¾ç†ŠçŒ«çš„é£Ÿç‰©å’Œæ´»åŠ›ï¼Œä¼ é€’ç”Ÿæœºä¸å¸Œæœ›ã€‚
    -   ç‘é›ªç™½ (#F7F9F9)ï¼šæä¾›è§†è§‰å‘¼å¸ç©ºé—´å’Œæ¸…æ™°åº¦ï¼Œè±¡å¾çº¯å‡€ä¸å’Œè°ã€‚
    -   æœ±ç ‚çº¢ (#D73E35)ï¼šä¼ ç»Ÿä¸­å›½çº¢ï¼Œè±¡å¾å–œåº†ã€æ´»åŠ›ä¸å¥½è¿ã€‚
-   **ç‚¹ç¼€è‰²å½©**:
    -   **åè´µé‡‘ (#D4AF37):** å¤§é‡ç”¨äºVIPèº«ä»½æ ‡è¯†ã€ç‰¹æƒå¥–åŠ±ã€ä»˜è´¹æŒ‰é’®ã€é‡è¦æˆå°±ç­‰ï¼Œè±¡å¾å°Šè´µä¸ä»·å€¼ã€‚
    -   é’èŠ±è“ (#1A6DB0)ï¼šä»£è¡¨æ°´åˆ†å’ŒæµåŠ¨ï¼Œçµæ„Ÿæ¥è‡ªé’èŠ±ç“·ã€‚
    -   ç‰¡ä¸¹ç²‰ (#F8C8DC)ï¼šå¢æ·»æ¸©æš–å’Œæƒ…æ„Ÿè¿æ¥ï¼Œçµæ„Ÿæ¥è‡ªä¸­å›½ä¼ ç»ŸèŠ±å‰ã€‚
    -   **ç´«æª€ç´« (#5D3954):** å¯ç”¨äºVIPä¸“å±ç•Œé¢çš„èƒŒæ™¯æˆ–é«˜çº§è®¢é˜…æ¡£ä½çš„è§†è§‰å¼ºè°ƒï¼Œå¢æ·»ç¥ç§˜ä¸é«˜è´µã€‚
-   **åŠŸèƒ½è‰²å½©**:
    -   å¦‚æ„ç»¿ (#2E8B57)ï¼šè¡¨ç¤ºå®Œæˆå’Œç§¯ææˆæœï¼Œçµæ„Ÿæ¥è‡ªå¦‚æ„ç‰å™¨ã€‚VIPç”¨æˆ·å®Œæˆä»»åŠ¡æˆ–è·å¾—å¥–åŠ±æ—¶ï¼Œæ­¤ç»¿è‰²å¯å¸¦æœ‰é‡‘è‰²ç²’å­æ•ˆæœã€‚
    -   ç¥ç€é»„ (#FFA500)ï¼šå¼•èµ·æ³¨æ„ä½†ä¸åˆºçœ¼ï¼Œçµæ„Ÿæ¥è‡ªå¤ä»£ç¥ç€é¥°å“ã€‚
    -   å¢¨ç° (#8A8D91)ï¼šç”¨äºæ¬¡è¦æ–‡æœ¬å’Œéæ´»åŠ¨å…ƒç´ ï¼Œçµæ„Ÿæ¥è‡ªæ°´å¢¨ç”»ã€‚

### 2.4 å­—ä½“è®¾è®¡ (åŒºåˆ†æ™®é€šä¸VIPä¿¡æ¯)
-   **ä¸»æ ‡é¢˜å­—ä½“**:
    -   ä¸­æ–‡ï¼š"æ–¹æ­£æ¸…åˆ»æœ¬æ‚¦å®‹"ï¼Œä¼ é€’å…¸é›…ä¸æ°¸æ’æ„Ÿã€‚
    -   è‹±æ–‡ï¼š"Playfair Display"ï¼Œä¸ä¸­æ–‡å­—ä½“é£æ ¼ç›¸åè°ƒã€‚
    -   ç”¨äºé¡µé¢æ ‡é¢˜ã€æˆå°±åç§°å’Œé‡è¦æ ‡ç­¾ï¼Œé…ä»¥é‡‘è‰²æè¾¹å¢å¼ºåä¸½æ„Ÿã€‚
-   **æ­£æ–‡å­—ä½“**:
    -   ä¸­æ–‡ï¼š"æ€æºå®‹ä½“"ï¼Œé«˜å¯è¯»æ€§ï¼Œå¸¦æœ‰å‹å¥½ã€å¹³æ˜“è¿‘äººçš„æ„Ÿè§‰ã€‚
    -   è‹±æ–‡ï¼š"Nunito Sans"ï¼Œä¸ä¸­æ–‡å­—ä½“æ­é…å’Œè°ã€‚
    -   ç”¨äºä»»åŠ¡æè¿°ã€è¯´æ˜å’Œä¸€èˆ¬å†…å®¹ï¼Œä¿æŒæ¸…æ™°æ˜“è¯»ã€‚
-   **è£…é¥°å­—ä½“ / VIPä¸“å±å­—ä½“**:
    -   ä¸­æ–‡ï¼š"åºé—¨æ­£é“è¡Œä¹¦" æˆ– æ›´å…·è¯†åˆ«åº¦çš„ä»˜è´¹ä¹¦æ³•å­—ä½“ï¼ˆå¦‚â€œæ±‰ä»ªå°šå·æ‰‹ä¹¦â€ï¼‰ã€‚
    -   è‹±æ–‡ï¼š"Caveat" æˆ– æ›´ä¼˜é›…çš„è¡¬çº¿æ‰‹å†™ä½“ã€‚
    -   ç”¨äºVIPç‰¹æƒæè¿°ã€ä¸“å±æ´»åŠ¨æ ‡é¢˜ã€ç†ŠçŒ«çš„ç‰¹æ®ŠVIPé—®å€™ç­‰ï¼Œå¢å¼ºç‹¬ç‰¹æ€§å’Œæƒ…æ„Ÿè¿æ¥ã€‚

### 2.5 UIç»„ä»¶è®¾è®¡æŒ‡å— (å¼ºåŒ–VIPå…ƒç´ çš„è§†è§‰å±‚çº§)
-   **æŒ‰é’®**ï¼š
    *   æ™®é€šæŒ‰é’®ï¼šä¼ ç»Ÿä¸­å›½é£æ ¼å…ƒç´ è£…é¥°çš„è½¯åœ†è§’çŸ©å½¢ï¼Œé…ä»¥ç²¾è‡´æ¸å˜ã€‚
    *   VIP/ä»˜è´¹å¼•å¯¼æŒ‰é’®ï¼šé‡‡ç”¨æ›´åä¸½çš„äº‘çº¹ã€å¦‚æ„çº¹æˆ–é¾™çº¹è£…é¥°ï¼Œé¢œè‰²ä»¥åè´µé‡‘ã€æœ±ç ‚çº¢ä¸ºä¸»ï¼Œé…ä»¥åŠ¨æ€å…‰æ•ˆã€æ›´æ˜¾è‘—çš„ç²’å­æ•ˆæœï¼Œç‚¹å‡»åŠ¨ç”»æ›´å…·å†²å‡»åŠ›ã€‚
-   **å¡ç‰‡**ï¼š
    *   æ™®é€šå¡ç‰‡ï¼šå±‚å è®¾è®¡ï¼Œç²¾è‡´é˜´å½±å’Œçº¹ç†èƒŒæ™¯ï¼Œä¼ ç»Ÿçº¹é¥°è¾¹æ¡†ã€‚
    *   VIPç‰¹æƒå±•ç¤ºå¡ç‰‡/è®¢é˜…é€‰é¡¹å¡ç‰‡ï¼šè¾¹æ¡†é‡‡ç”¨æ›´å¤æ‚çš„é‡‘è‰²æˆ–çº¢è‰²æè¾¹ï¼ŒèƒŒæ™¯å¯ä½¿ç”¨ä¸ç»¸æˆ–é”¦ç¼ç­‰é«˜çº§çº¹ç†ï¼Œé‡è¦ä¿¡æ¯åŒºåŸŸå¯æœ‰å¾®å…‰æµ®åŠ¨æ•ˆæœã€‚
-   **å›¾æ ‡**ï¼š
    *   æ™®é€šå›¾æ ‡ï¼šæ°´å¢¨ç”»é£æ ¼ï¼Œç¬”è§¦ä¸€è‡´ï¼Œåœ†æ¶¦è¾¹è§’ã€‚
    *   VIPä¸“å±åŠŸèƒ½å›¾æ ‡ï¼šåœ¨æ°´å¢¨é£æ ¼åŸºç¡€ä¸Šå¢åŠ é‡‘è‰²ç‚¹ç¼€æˆ–å¾®å°åŠ¨æ€å…‰æ•ˆï¼Œä½¿å…¶åœ¨è§†è§‰ä¸Šæ›´çªå‡ºã€‚
-   **è¿›åº¦æŒ‡ç¤ºå™¨**ï¼š
    *   æ™®é€šè¿›åº¦æ¡ï¼šä¼˜é›…ç¯å½¢æˆ–çº¿æ€§ï¼Œæ°´å¢¨æ™•æŸ“å¡«å……ã€‚
    *   åŠæ—¶æ€§è¿›åº¦æ¡/VIPåŠ é€Ÿè¿›åº¦æ¡ï¼šé‡‡ç”¨æ›´åä¸½çš„å·è½´æˆ–é¾™å½¢ç«¹ç®€å½¢å¼ï¼Œå¡«å……åŠ¨ç”»å¯åŠ å…¥é‡‘è‰²ç²’å­æµå…‰æ•ˆæœï¼Œå®Œæˆæ—¶æœ‰æ›´ç››å¤§çš„åº†ç¥åŠ¨ç”»ã€‚
-   **è¾“å…¥æ¡†**ï¼šç®€çº¦è®¾è®¡ï¼Œå¸¦æœ‰å¾®å¦™è¾¹æ¡†å’Œç„¦ç‚¹çŠ¶æ€ï¼Œè¾¹æ¡†é‡‡ç”¨ä¼ ç»Ÿçº¹é¥°ï¼Œæ¿€æ´»æ—¶æœ‰æ°´å¢¨æ‰©æ•£æ•ˆæœã€‚
-   **å¼¹çª—**ï¼š
    *   æ™®é€šå¼¹çª—ï¼šå±…ä¸­è®¾è®¡ï¼Œè£…é¥°æ€§æ¡†æ¶é‡‡ç”¨ä¼ ç»Ÿçª—æ£‚æ ·å¼ï¼ŒåŠé€æ˜èƒŒæ™¯æ¨¡ä»¿å®£çº¸è´¨æ„Ÿã€‚
    *   VIPå¼•å¯¼/ä¼˜æƒ å¼¹çª—ï¼šæ¡†æ¶å¯é‡‡ç”¨æ›´åä¸½çš„é›•èŠ±æˆ–é•¶é‡‘è®¾è®¡ï¼ŒèƒŒæ™¯å¯åŠ å…¥åŠ¨æ€ç¥¥äº‘æˆ–ç‰¡ä¸¹ç››å¼€ç­‰å…ƒç´ ï¼ŒæŒ‰é’®è®¾è®¡å‚ç…§VIPæŒ‰é’®ã€‚

## 3. ä¿¡æ¯æ¶æ„ (èå…¥ä»˜è´¹å¼•å¯¼ç‚¹)

### 3.1 å¯¼èˆªç»“æ„
PandaHabitå°†ä½¿ç”¨åº•éƒ¨æ ‡ç­¾å¯¼èˆªï¼Œå…·æœ‰ä»¥ä¸‹ä¸»è¦éƒ¨åˆ†ï¼Œæ¯ä¸ªå¯¼èˆªå›¾æ ‡éƒ½é‡‡ç”¨åä¸½çš„ä¸­å›½é£è®¾è®¡ï¼š

1.  **ä¸»é¡µï¼ˆç«¹æ—å®¶å›­ï¼‰**ï¼šä¸»ä»ªè¡¨ç›˜ï¼Œå±•ç¤ºç†ŠçŒ«ã€åŠæ—¶å¥–åŠ±è¿›åº¦æ¡å’Œå¿«é€Ÿæ“ä½œã€‚èƒŒæ™¯ä¸ºåŠ¨æ€ç«¹æ—åœºæ™¯ã€‚æ˜¾çœ¼ä½ç½®é¢„ç•™VIPèº«ä»½æ ‡è¯†å’Œå¿«é€Ÿå‡çº§å…¥å£ï¼ˆå¦‚ä¸€ä¸ªé—ªè€€çš„çš‡å† å›¾æ ‡ï¼‰ã€‚
2.  **ä»»åŠ¡ï¼ˆä¿®è¡Œä¹‹è·¯ï¼‰**ï¼šæ—¥å¸¸ä»»åŠ¡åˆ—è¡¨å’Œç®¡ç†ï¼Œè®¾è®¡ä¸ºå¤ä»£å·è½´æ ·å¼ã€‚ä»»åŠ¡å¥–åŠ±é¢„è§ˆæ—¶ï¼Œæ¸…æ™°åŒºåˆ†å…è´¹ä¸VIPé¢å¤–å¥–åŠ±ï¼ˆè§†è§‰ä¸Šç”¨é‡‘è‰²é«˜äº®VIPéƒ¨åˆ†ï¼‰ã€‚
3.  **æŒ‘æˆ˜ï¼ˆæ±Ÿæ¹–å†ç»ƒï¼‰**ï¼šé•¿æœŸç›®æ ‡å’Œç‰¹åˆ«æ´»åŠ¨ï¼Œè®¾è®¡ä¸ºåœ°å›¾æ¢é™©é£æ ¼ã€‚VIPä¸“å±æŒ‘æˆ˜ç”¨ç‰¹æ®Šæ ‡è¯†ï¼ˆå¦‚é‡‘è‰²é¾™çº¹ï¼‰å’Œæ›´åä¸½çš„å¡ç‰‡èƒŒæ™¯ã€‚
4.  **æ—…ç¨‹ï¼ˆæˆé•¿ä¹‹é“ï¼‰**ï¼šç†ŠçŒ«æˆé•¿è·¯å¾„å’Œé‡Œç¨‹ç¢‘ï¼Œè®¾è®¡ä¸ºä¼ ç»Ÿå±±æ°´ç”»å·ã€‚VIPç”¨æˆ·åœ¨æˆé•¿è·¯å¾„ä¸Šå¯è§£é”é¢å¤–çš„å¥–åŠ±èŠ‚ç‚¹æˆ–ä¸“å±çºªå¿µç‰©ã€‚
5.  **å•†åº—ï¼ˆçå®é˜ï¼‰**ï¼šè£…é¥°ç‰©å“ã€èµ„æºå’ŒVIPè®¢é˜…ï¼Œè®¾è®¡ä¸ºå¤ä»£å•†é“ºé£æ ¼ã€‚å•†åº—é¦–é¡µæ˜¾è‘—ä½ç½®å±•ç¤ºâ€œç†ŠçŒ«å®ˆæŠ¤è€…ç‰¹æƒâ€å…¥å£å’Œé™æ—¶è®¢é˜…ä¼˜æƒ ã€‚

æ¬¡è¦å¯¼èˆªåŒ…æ‹¬ï¼š
-   **ç†ŠçŒ«äº’åŠ¨ï¼ˆå¿ƒçµç›¸é€šï¼‰**ï¼šé€šè¿‡ç‚¹å‡»ä¸»é¡µä¸Šçš„ç†ŠçŒ«è®¿é—®ï¼Œè®¾è®¡ä¸ºç²¾ç¾çš„äº’åŠ¨åœºæ™¯ã€‚
-   **å¹¸è¿æŠ½å¥–ï¼ˆç¦ç¼˜æŠ½ç­¾ï¼‰**ï¼šé€šè¿‡é¡¶éƒ¨å¯¼èˆªä¸­çš„ä¸“ç”¨å›¾æ ‡è®¿é—®ï¼Œè®¾è®¡ä¸ºä¼ ç»ŸæŠ½ç­¾ä¸å®ç®±ç›¸ç»“åˆçš„å½¢å¼ã€‚VIPç”¨æˆ·æ¯æ—¥å¯è·å¾—é¢å¤–å…è´¹æŠ½å¥–æ¬¡æ•°ï¼Œç•Œé¢ä¸Šæ¸…æ™°æç¤ºã€‚
-   **è®¾ç½®ï¼ˆç‰ç®€è®¾å®šï¼‰**ï¼šé€šè¿‡å³ä¸Šè§’çš„é½¿è½®å›¾æ ‡è®¿é—®ï¼Œå›¾æ ‡è®¾è®¡ä¸ºå¤ä»£ç‰ç®€ã€‚
-   **åæ€æ¨¡å—ï¼ˆé™å¿ƒèŒ¶å®¤ï¼‰**ï¼šæ ¹æ®ç”¨æˆ·è¡Œä¸ºæƒ…å¢ƒè§¦å‘ï¼Œè®¾è®¡ä¸ºå®é™çš„ä¼ ç»ŸèŒ¶å®¤ç¯å¢ƒã€‚éƒ¨åˆ†é«˜çº§åæ€å¼•å¯¼æˆ–æ·±åº¦å¿ƒç†æ”¯æŒå·¥å…·å¯ä½œä¸ºVIPç‰¹æƒã€‚
-   **VIPä¸­å¿ƒï¼ˆç´«å®¸æ®¿/éº’éºŸé˜ï¼‰**ï¼šé€šè¿‡ä¸»é¡µVIPå›¾æ ‡æˆ–å•†åº—è¿›å…¥ï¼Œé›†ä¸­å±•ç¤ºæ‰€æœ‰VIPç‰¹æƒã€è®¢é˜…é€‰é¡¹ã€ä¸“å±æ´»åŠ¨å’Œç¤¼åŒ…é¢†å–ã€‚è®¾è®¡æä¸ºåä¸½ï¼Œå½°æ˜¾å°Šè´µã€‚

### 3.2 ç”¨æˆ·æµç¨‹å›¾ (é›†æˆè®¢é˜…å¼•å¯¼ç­–ç•¥)
å…³é”®ç”¨æˆ·æµç¨‹åŒ…æ‹¬ï¼Œæ¯ä¸ªæµç¨‹éƒ½é…æœ‰åä¸½çš„è¿‡æ¸¡åŠ¨ç”»å’Œè§†è§‰å¼•å¯¼ï¼š

1.  **æ–°ç”¨æˆ·å¼•å¯¼ï¼ˆåˆå…¥ä»™å¢ƒï¼‰**ï¼š
    *   åº”ç”¨ä»‹ç»ï¼ˆå¤å·å±•å¼€åŠ¨ç”»ï¼‰â†’ ç†ŠçŒ«å®šåˆ¶ï¼ˆæ°´å¢¨æ¸²æŸ“æ•ˆæœï¼‰â†’ é¦–ä¸ªä»»åŠ¡è®¾ç½®ï¼ˆå·è½´ä¹¦å†™åŠ¨ç”»ï¼‰â†’ ä»»åŠ¡å®Œæˆï¼ˆé‡‘å…‰ç‰¹æ•ˆï¼‰â†’ å¥–åŠ±ï¼ˆå®ç®±å¼€å¯åŠ¨ç”»ï¼Œæ¸…æ™°å±•ç¤ºå…è´¹å¥–åŠ±ï¼Œå¹¶ç”¨ç°è‰²æˆ–é”å®šçš„å½¢å¼é¢„è§ˆVIPå¯é¢å¤–è·å¾—çš„å¥–åŠ±ï¼Œé™„å¸¦â€œæˆä¸ºå®ˆæŠ¤è€…è§£é”â€æç¤ºï¼‰â†’ ä¸»é¡µï¼ˆç«¹æ—å±•å¼€æ•ˆæœï¼‰ã€‚
    *   å®Œæˆæ–°æ‰‹å¼•å¯¼ç³»åˆ—ä»»åŠ¡åï¼Œè§¦å‘â€œé‡Œç¨‹ç¢‘å¼é¦–è´­ç¤¼åŒ…â€å¼¹çª—ï¼ˆç•Œé¢D2ï¼‰ã€‚
2.  **æ—¥å¸¸ä¹ æƒ¯æ‰“å¡ï¼ˆæ¯æ—¥ä¿®è¡Œï¼‰**ï¼š
    *   é€šçŸ¥ï¼ˆç†ŠçŒ«ä¿¡ä½¿åŠ¨ç”»ï¼‰â†’ ä»»åŠ¡é¡µé¢ï¼ˆå·è½´å±•å¼€ï¼‰â†’ ä»»åŠ¡å®Œæˆï¼ˆå¢¨è¿¹æ¸²æŸ“åŠ¨ç”»ï¼ŒVIPé¢å¤–å¥–åŠ±éƒ¨åˆ†ç”¨é‡‘è‰²é«˜äº®å¹¶æ’­æ”¾æ›´åä¸½çš„ç²’å­æ•ˆæœï¼‰â†’ åŠæ—¶å¥–åŠ±ï¼ˆé‡‘å¸é£èˆæ•ˆæœï¼‰â†’ ç†ŠçŒ«äº’åŠ¨ï¼ˆç†ŠçŒ«æ¬¢å–œåŠ¨ç”»ï¼‰ã€‚
    *   è‹¥ç†ŠçŒ«ä½“åŠ›ä¸è¶³/å¹¸è¿ç‚¹æ•°ä¸è¶³ï¼Œè§¦å‘â€œèµ„æº/æ—¶é—´èŠ‚çœæç¤ºâ€ï¼ˆç•Œé¢B2ï¼‰ã€‚
3.  **æŒ‘æˆ˜å‚ä¸ï¼ˆæ±Ÿæ¹–æ¢ç´¢ï¼‰**ï¼š
    *   æŒ‘æˆ˜é¡µé¢ï¼ˆåœ°å›¾å±•å¼€åŠ¨ç”»ï¼‰â†’ æŒ‘æˆ˜é€‰æ‹©ï¼ˆåœ°ç‚¹ç‚¹äº®æ•ˆæœï¼Œè‹¥ä¸ºVIPä¸“å±æŒ‘æˆ˜ï¼Œç‚¹å‡»åæç¤ºâ€œæ­¤ä¸ºå®ˆæŠ¤è€…ä¸“å±å†ç»ƒï¼Œç«‹å³åŠ å…¥ï¼Ÿâ€ï¼‰â†’ æ—¥å¸¸å­ä»»åŠ¡ï¼ˆå°å·è½´å±•å¼€ï¼‰â†’ è¿›åº¦è·Ÿè¸ªï¼ˆåœ°å›¾è·¯å¾„ç‚¹äº®ï¼‰â†’ å®Œæˆå¥–åŠ±ï¼ˆå®ç®±åä¸½å¼€å¯ï¼‰ã€‚
    *   å®Œæˆé‡è¦æŒ‘æˆ˜/è·å¾—ç¨€æœ‰æ‰è½ï¼Œè§¦å‘â€œé«˜å…‰æ—¶åˆ»åŠ©æ¨å¼¹çª—â€ï¼ˆç•Œé¢C1ï¼‰ã€‚
4.  **åæ€è¿‡ç¨‹ï¼ˆèŒ¶é“é™å¿ƒï¼‰**ï¼š
    *   è§¦å‘äº‹ä»¶ï¼ˆèŒ¶æ¯å›¾æ ‡å‡ºç°ï¼‰â†’ æ¸©å’Œæç¤ºï¼ˆç†ŠçŒ«é‚€è¯·åŠ¨ç”»ï¼‰â†’ åæ€é—®é¢˜ï¼ˆæ°´å¢¨æ‰©æ•£æ•ˆæœï¼‰â†’ æ”¯æŒæ€§åé¦ˆï¼ˆç†ŠçŒ«å®‰æ…°åŠ¨ç”»ï¼Œè‹¥ç”¨æˆ·æŒç»­ä½è¿·ï¼Œç†ŠçŒ«å¯æ¨èâ€œå®ˆæŠ¤è€…ä¸“å±é˜³å…‰å¿ƒæƒ…å†¥æƒ³ç³»åˆ—â€ï¼‰â†’ è¡ŒåŠ¨å»ºè®®ï¼ˆç«¹ç®€å±•å¼€æ•ˆæœï¼‰ã€‚
5.  **VIPè½¬åŒ–ï¼ˆé£å‡ä¹‹è·¯ï¼‰**ï¼š
    *   æƒ…æ™¯è§¦å‘ç‚¹ (å¦‚ç‚¹å‡»é”å®šçš„VIPåŠŸèƒ½ã€çœ‹åˆ°VIPå¥½å‹çš„ä¸“å±å¤–è§‚ã€é‡åˆ°ç—›ç‚¹æ—¶çš„è§£å†³æ–¹æ¡ˆæç¤º)ã€‚
    *   å¼•å¯¼è‡³â€œVIPç‰¹æƒæ€»è§ˆé¡µâ€ï¼ˆç•Œé¢A1ï¼‰æˆ–ç›´æ¥å¼¹å‡ºâ€œè®¢é˜…é€‰æ‹©é¡µé¢â€ï¼ˆç•Œé¢E1ï¼‰ã€‚
    *   è®¢é˜…é€‰æ‹©é¡µé¢ï¼ˆç•Œé¢E1ï¼‰ï¼šå¼ºè°ƒé”šç‚¹å®šä»·ã€ä»·å€¼æ‰“åŒ…ï¼Œâ€œæœ€ä½³ä»·å€¼â€é€‰é¡¹ä½¿ç”¨æ›´åä¸½çš„è¾¹æ¡†å’ŒåŠ¨æ€å…‰æ•ˆã€‚
    *   è´­ä¹°ç¡®è®¤ï¼ˆç¥¥äº‘ç¯ç»•åŠ¨ç”»ï¼Œä¼´éšâ€œæ­å–œæˆä¸ºç†ŠçŒ«å®ˆæŠ¤è€…ï¼â€çš„åä¸½æ–‡æœ¬å’Œç†ŠçŒ«çš„ç¥è´ºåŠ¨ç”»ï¼‰ã€‚

### 3.3 å±å¹•å±‚æ¬¡ç»“æ„
å±å¹•å±‚æ¬¡ç»“æ„éµå¾ªä»ä¸€èˆ¬åˆ°ç‰¹å®šçš„é€»è¾‘è¿›å±•ï¼Œæ¯ä¸€å±‚éƒ½æœ‰ç‹¬ç‰¹çš„è§†è§‰é£æ ¼ï¼š

-   **ç¬¬ä¸€å±‚**ï¼šä¸»æ ‡ç­¾å±å¹•ï¼ˆç«¹æ—å®¶å›­ã€ä¿®è¡Œä¹‹è·¯ã€æ±Ÿæ¹–å†ç»ƒã€æˆé•¿ä¹‹é“ã€çå®é˜ï¼‰ï¼Œè®¾è®¡ä¸ºå®Œæ•´çš„åœºæ™¯ç”»é¢ã€‚
-   **ç¬¬äºŒå±‚**ï¼šç‰¹å®šåŠŸèƒ½å±å¹•ï¼ˆå¿ƒçµç›¸é€šã€ç¦ç¼˜æŠ½ç­¾ã€ç‰ç®€è®¾å®šã€VIPä¸­å¿ƒï¼‰ï¼Œè®¾è®¡ä¸ºä¸»åœºæ™¯çš„ç‰¹å†™æˆ–å˜ä½“ã€‚
-   **ç¬¬ä¸‰å±‚**ï¼šè¯¦æƒ…å±å¹•ï¼ˆä»»åŠ¡è¯¦æƒ…ã€æŒ‘æˆ˜è¯¦æƒ…ã€ç‰©å“è¯¦æƒ…ã€VIPç‰¹æƒè¯¦æƒ…ï¼‰ï¼Œè®¾è®¡ä¸ºç²¾ç¾çš„å·è½´æˆ–ç‰ç®€å±•å¼€ã€‚
-   **ç¬¬å››å±‚**ï¼šæµç¨‹å±å¹•ï¼ˆé™å¿ƒèŒ¶å®¤ã€VIPè´­ä¹°æµç¨‹ã€ä»»åŠ¡åˆ›å»ºæµç¨‹ï¼‰ï¼Œè®¾è®¡ä¸ºç‰¹æ®Šäº’åŠ¨åœºæ™¯ã€‚

## 4. Detailed UI/UX Design (èå…¥Checklist 2.0ç­–ç•¥çš„ç•Œé¢ç»†èŠ‚)

### 4.1 ä¸»é¡µï¼ˆç«¹æ—å®¶å›­ï¼‰
ä¸»é¡µæ˜¯æƒ…æ„Ÿä¸­å¿ƒå’Œä¸»è¦ä»ªè¡¨ç›˜ï¼Œå¼ºåŒ–â€œåä¸½æ¸¸æˆé£æ ¼â€ä¸äº’åŠ¨ä½“éªŒï¼š

-   **é¡¶éƒ¨åŒºåŸŸ**ï¼š
    *   ç”¨æˆ·å¤´åƒ/èµ„æ–™ï¼ˆå·¦ä¸Šï¼‰ï¼ŒVIPç”¨æˆ·å¤´åƒæ¡†ä¸ºåŠ¨æ€é—ªè€€ç«¹å¶/ç¥¥äº‘æ¡†ï¼Œæ˜µç§°æ—æ˜¾ç¤ºâ€œå®ˆæŠ¤è€…â€é‡‘è‰²ç§°å·ã€‚
    *   è´§å¸æ˜¾ç¤ºï¼ˆé‡‘å¸ã€é’»çŸ³ã€å¹¸è¿ç‚¹ï¼‰ï¼Œé‡‡ç”¨ç«‹ä½“é‡‘å±è´¨æ„Ÿä¸ç²’å­ç‰¹æ•ˆã€‚
    *   è®¾ç½®é½¿è½®ï¼ˆå³ä¸Šï¼‰ï¼Œä»¥ç‰ç®€æˆ–ç¥¥äº‘ä¸ºé€ å‹ï¼Œå¸¦å…¥åœºåŠ¨ç”»ã€‚
    *   å¹¸è¿æŠ½å¥–å…¥å£ï¼Œå¸¸é©»é—ªçƒç²’å­ä¸åŠ¨æ€é«˜äº®ã€‚VIPç”¨æˆ·å¯åœ¨æ­¤çœ‹åˆ°æ¯æ—¥é¢å¤–å…è´¹æŠ½å¥–æ¬¡æ•°çš„æç¤ºã€‚
-   **ä¸­å¤®åŒºåŸŸ**ï¼š
    *   å¤§å¹…ç²¾ç¾ç†ŠçŒ«æ’ç”»ï¼Œåˆ†é˜¶æ®µæˆé•¿ï¼ŒçŠ¶æ€ä¸äº’åŠ¨å‡æœ‰ä¸°å¯ŒåŠ¨ç”»ï¼ˆå¦‚çœ¨çœ¼ã€ä¼¸æ‡’è…°ã€æ’’å¨‡ï¼‰ã€‚
    *   ç¯å¢ƒä¸ºåŠ¨æ€ç«¹æ—ï¼Œéšæ—¶é—´å˜åŒ–å…‰å½±ï¼ŒåŠ å…¥è´è¶ã€ç«¹å¶é£˜è½ç­‰ç²’å­åŠ¨æ•ˆã€‚
    *   åŠæ—¶æ€§è¿›åº¦æ¡è®¾è®¡ä¸ºåä¸½å·è½´æˆ–ç«¹ç®€ï¼Œå¡«å……åŠ¨ç”»æœ‰æ°´å¢¨æ™•æŸ“ä¸é‡‘å…‰ç²’å­ã€‚VIPç”¨æˆ·çš„è¿›åº¦æ¡å¡«å……é€Ÿåº¦å¯æœ‰è§†è§‰ä¸Šçš„åŠ é€Ÿæ„Ÿï¼ˆå¦‚æ›´å¿«çš„ç²’å­æµåŠ¨ï¼‰ï¼Œæˆ–è¿›åº¦æ¡æœ¬èº«è®¾è®¡æ›´åä¸½ã€‚
    *   å¥–åŠ±é¢„è§ˆé‡‡ç”¨å®ç®±/å·è½´å±•å¼€åŠ¨ç”»ï¼Œå¥–åŠ±å›¾æ ‡æœ‰é«˜å…‰ä¸å¼¹è·³ç‰¹æ•ˆã€‚
-   **åº•éƒ¨åŒºåŸŸ**ï¼š
    *   æ´»è·ƒä»»åŠ¡å¿«æ·å…¥å£ï¼Œå¡ç‰‡é‡‡ç”¨æµ®é›•ã€é‡‘è¾¹ã€äº‘çº¹ç­‰è£…é¥°ï¼Œå®Œæˆæ—¶æœ‰ç²’å­çˆ†å‘åŠ¨ç”»ã€‚è‹¥ä»»åŠ¡æœ‰VIPé¢å¤–å¥–åŠ±ï¼Œåœ¨å¡ç‰‡ä¸Šç”¨å°çš‡å† +é‡‘è‰²æ•°å­—æ¸…æ™°æ ‡å‡ºã€‚
    *   æœ€è¿‘å¥–åŠ±æ—¥å¿—ï¼Œå›¾æ ‡é€æ¡æ»šåŠ¨å‡ºç°ï¼Œå¸¦æœ‰æ·¡å…¥æ·¡å‡ºä¸ç²’å­ç‚¹ç¼€ã€‚
    *   åº•éƒ¨å¯¼èˆªæ ä¸ºè‡ªå®šä¹‰ä¸­å›½é£å›¾æ ‡ï¼Œé€‰ä¸­æœ‰ç¥¥äº‘æµåŠ¨ä¸é«˜äº®ç‰¹æ•ˆï¼Œæ•´ä½“é‡‡ç”¨åŠé€æ˜ç‰çŸ³è´¨æ„Ÿã€‚
-   **æµ®åŠ¨VIPå¼•å¯¼æŒ‰é’®/Banner**ï¼š
    *   è‹¥ç”¨æˆ·éVIPï¼Œåœ¨ä¸»é¡µçš„åˆé€‚ä½ç½®ï¼ˆå¦‚ç†ŠçŒ«æ—è¾¹/ä»»åŠ¡åŒºä¸Šæ–¹ï¼‰å¯è®¾ç½®ä¸€ä¸ªä¸æ‰“æ‰°ä½†å¯è§çš„â€œæˆä¸ºå®ˆæŠ¤è€…â€å…¥å£ï¼Œå›¾æ ‡ä¸ºåä¸½çš‡å† æˆ–ç‰ä½©ï¼Œå¯å¸¦æœ‰å¾®å¼±çš„å‘¼å¸å…‰æ•ˆã€‚ç‚¹å‡»è¿›å…¥VIPä¸­å¿ƒæˆ–è®¢é˜…é€‰æ‹©é¡µã€‚

### 4.2 ä»»åŠ¡é¡µï¼ˆä¿®è¡Œä¹‹è·¯ï¼‰
ä»»åŠ¡é¡µçªå‡ºâ€œå¤å·â€ä¸â€œåä¸½åŠ¨æ•ˆâ€ä¸»é¢˜ï¼Œæå‡äº¤äº’ä»ªå¼æ„Ÿï¼š

-   **é¡¶éƒ¨åŒºåŸŸ**ï¼š
    *   æ—¥æœŸå±•ç¤ºé‡‡ç”¨ä¹¦æ³•å­—ä½“ä¸ç¥¥äº‘è£…é¥°ï¼ŒèƒŒæ™¯ä¸ºæ·¡é›…å®£çº¸çº¹ç†ã€‚
    *   æ¯æ—¥è¿›åº¦æ¡ä¸ºå·è½´å±•å¼€åŠ¨ç”»ï¼Œå¡«å……æ—¶æœ‰æ°´å¢¨æ™•æŸ“ä¸é‡‘å…‰ç²’å­ã€‚
    *   ç­›é€‰/æ’åºä¸‹æ‹‰èœå•ä¸ºç‰ä½©/ç«¹ç®€é€ å‹ï¼Œå±•å¼€æœ‰å¼¹æ€§åŠ¨ç”»ã€‚
-   **ä»»åŠ¡åˆ—è¡¨**ï¼š
    *   æ»šåŠ¨åˆ—è¡¨ï¼Œæ¯ä¸ªä»»åŠ¡å¡ç‰‡ä¸ºç«‹ä½“æµ®é›•å·è½´ï¼Œè¾¹æ¡†æœ‰é‡‘è‰²æè¾¹ä¸äº‘çº¹ã€‚
    *   ä»»åŠ¡ç±»å‹å›¾æ ‡ä¸ºæ°´å¢¨é£ï¼Œä»»åŠ¡åç”¨å®‹ä½“/ä¹¦æ³•å­—ä½“ï¼Œé‡è¦ä»»åŠ¡æœ‰ç‰¹æ®Šé«˜äº®ã€‚
    *   å¥–åŠ±é¢„è§ˆå›¾æ ‡æœ‰å¼¹è·³ä¸é«˜å…‰åŠ¨ç”»ã€‚æ¸…æ™°åŒºåˆ†åŸºç¡€å¥–åŠ±å’ŒVIPé¢å¤–å¥–åŠ±ï¼Œåè€…ç”¨é‡‘è‰²æ•°å­—+å°çš‡å† æ ‡è¯†ã€‚è‹¥éVIPï¼Œé¢å¤–å¥–åŠ±éƒ¨åˆ†ç½®ç°å¹¶æœ‰â€œå®ˆæŠ¤è€…ä¸“äº«â€æç¤ºã€‚
    *   åŠæ—¶æ€§ä»»åŠ¡æœ‰â°/âœ¨ç‰¹æ•ˆï¼Œå®Œæˆæ—¶æœ‰ç²’å­çˆ†å‘ä¸å·è½´å°ç« åŠ¨ç”»ã€‚
    *   æ—¶é—´çª—å£å€’è®¡æ—¶ä¸ºåŠ¨æ€æ²™æ¼/æ°´æ»´ï¼ŒæŒ‘æˆ˜/è‡ªå®šä¹‰ç›®æ ‡æœ‰ä¸“å±æ ‡è¯†ï¼ˆå¦‚ç«ç„°/ç†ŠçŒ«å¤´åƒï¼‰ã€‚
    *   VIPç”¨æˆ·å®Œæˆä»»åŠ¡æ—¶ï¼Œå¥–åŠ±é£å‘ç”¨æˆ·çš„åŠ¨ç”»å¯ä»¥æ›´ä¸°å¯Œã€ç²’å­æ•ˆæœæ›´åä¸½ã€‚
-   **æ–°å¢ä»»åŠ¡æŒ‰é’®**ï¼š
    *   æ‚¬æµ®é‡‘è‰²åœ†å½¢æŒ‰é’®ï¼Œä¸­å¿ƒä¸ºåŠ å·ï¼ŒæŒ‰é’®æœ‰è„‰å†²å…‰åœˆä¸ç²’å­ç¯ç»•ã€‚

### 4.3 æŒ‘æˆ˜é¡µï¼ˆæ±Ÿæ¹–å†ç»ƒï¼‰
æŒ‘æˆ˜é¡µå¼ºåŒ–â€œåœ°å›¾æ¢é™©â€ä¸â€œæˆå°±æ„Ÿâ€è§†è§‰ï¼š

-   **é¡¶éƒ¨åŒºåŸŸ**ï¼š
    *   æŒ‘æˆ˜åˆ†ç±»Tabä¸ºå¤ä»£ä»¤ç‰Œ/ç«¹ç®€é€ å‹ï¼Œåˆ‡æ¢æœ‰ç¿»è½¬/å·è½´å±•å¼€åŠ¨ç”»ã€‚
    *   é¡¶éƒ¨è£…é¥°éšæŒ‘æˆ˜ä¸»é¢˜å˜æ¢ï¼ˆå¦‚å±±æ°´ã€ç«ç„°ã€ç¥¥äº‘ï¼‰ã€‚
-   **æŒ‘æˆ˜å¡ç‰‡**ï¼š
    *   å¡ç‰‡ä¸ºç«‹ä½“æµ®é›•ï¼ŒèƒŒæ™¯ä¸ºåœ°å›¾/å±±æ°´ç”»å·ï¼Œä¸»æ ‡é¢˜ç”¨é‡‘è‰²æè¾¹å­—ä½“ã€‚
    *   VIPä¸“å±æŒ‘æˆ˜å¡ç‰‡èƒŒæ™¯é‡‡ç”¨æ›´é«˜çº§çš„åŠ¨æ€å±±æ°´ç”»å·æˆ–æ˜Ÿç©ºå›¾ï¼Œè¾¹æ¡†ä¸ºé¾™çº¹/å‡¤çº¹ç­‰é«˜çº§å›¾è…¾ï¼Œæ ‡é¢˜ä½¿ç”¨ç‰¹æ®Šä¹¦æ³•å­—ä½“ã€‚
    *   å…³é”®å¥–åŠ±æœ‰å®ç®±/ç‰ç’§é«˜äº®å±•ç¤ºï¼Œå¥–åŠ±å›¾æ ‡æœ‰å…‰æ™•ä¸ç²’å­ç‰¹æ•ˆã€‚è‹¥æŒ‘æˆ˜å®ŒæˆåVIPæœ‰é¢å¤–å¥–åŠ±ï¼Œåœ¨å¥–åŠ±é¢„è§ˆä¸­æ¸…æ™°æ ‡å‡ºã€‚
    *   è¿›åº¦æ¡ä¸ºç«¹èŠ‚/å·è½´ï¼Œå¡«å……æœ‰æ°´å¢¨æµåŠ¨åŠ¨ç”»ã€‚
    *   æ—¶é—´é™åˆ¶ä¸ºåŠ¨æ€å€’è®¡æ—¶ï¼Œæœªå®Œæˆæ—¶æœ‰è½»å¾®é—ªçƒã€‚
    *   å­ä»»åŠ¡å¯å±•å¼€ï¼Œå®Œæˆæœ‰å°ç« /ç¥¥äº‘åŠ¨ç”»ã€‚
    *   æ¥å—/é¢†å–æŒ‰é’®ä¸ºç‰ä½©é€ å‹ï¼Œç‚¹å‡»æœ‰å¼¹è·³ä¸ç²’å­çˆ†å‘ã€‚

### 4.4 æˆé•¿ä¹‹é“ï¼ˆæ—…ç¨‹é¡µï¼‰
æˆé•¿ä¹‹é“çªå‡ºâ€œè¿›åŒ–ä»ªå¼æ„Ÿâ€ä¸â€œä¸œæ–¹ç¾å­¦â€ï¼š

-   **æˆé•¿è·¯å¾„å¯è§†åŒ–**ï¼š
    *   é‡‡ç”¨å±±æ°´ç”»å·å¼æ—¶é—´è½´æˆ–æ ‘çŠ¶ç»“æ„ï¼ŒèŠ‚ç‚¹é—´ç”¨ç¥¥äº‘/ç«¹èŠ‚è¿æ¥ã€‚
    *   æ¯ä¸ªèŠ‚ç‚¹ä¸ºç†ŠçŒ«ä¸åŒæˆé•¿é˜¶æ®µå°åƒï¼Œå®ŒæˆèŠ‚ç‚¹æœ‰é‡‘å…‰é«˜äº®ä¸ç²’å­åº†ç¥ã€‚
    *   VIPç”¨æˆ·åœ¨æˆé•¿è·¯å¾„ä¸Šå¯è§£é”é¢å¤–çš„å¥–åŠ±èŠ‚ç‚¹ï¼Œè§£é”ä¸“å±çºªå¿µè£…é¥°å“æˆ–ç†ŠçŒ«äº’åŠ¨åŠ¨ä½œã€‚è¿™äº›VIPèŠ‚ç‚¹ç”¨æ›´åä¸½çš„å›¾æ ‡ï¼ˆå¦‚é•¶é‡‘ç‰ç’§ï¼‰è¡¨ç¤ºã€‚
    *   å½“å‰èŠ‚ç‚¹è„‰å†²åŠ¨ç”»ï¼Œæœªè§£é”èŠ‚ç‚¹åŠé€æ˜å¹¶æœ‰ç¥ç§˜å…‰æ•ˆã€‚
    *   å¥–åŠ±é¢„è§ˆä¸ºç‰ç®€/å®ç®±å±•å¼€ï¼Œå¥–åŠ±å›¾æ ‡æœ‰é«˜å…‰ä¸å¼¹è·³ã€‚
-   **Milestone Log**:
    *   Scrollable timeline with rich visual treatment.
    *   Achievement cards with decorative frames and gold accents for significant milestones.
    *   Date stamps with elegant calligraphy-style typography.
    *   Reward recap with animated icons and particle effects.

### 4.5 å•†åº—é¡µï¼ˆçå®é˜ï¼‰
å•†åº—é¡µè¥é€ â€œå¥¢åè´­ç‰©â€ä¸â€œæ”¶è—å±•ç¤ºâ€æ°›å›´ï¼š

-   **é¡¶éƒ¨åŒºåŸŸ**ï¼š
    *   æœç´¢æ ä¸ºç‰ç®€/ç¥¥äº‘é€ å‹ï¼Œè¾“å…¥æ—¶æœ‰å…‰æ•ˆæµåŠ¨ã€‚
    *   åˆ†ç±»ç­›é€‰ä¸ºç«‹ä½“ç‰ä½©/å·è½´ï¼Œé€‰ä¸­æœ‰é«˜äº®ä¸ç²’å­ç¯ç»•ã€‚
    *   ç‰¹è‰²å•†å“è½®æ’­ä¸ºå®ç®±/ç‰ç’§å±•ç¤ºï¼Œåˆ‡æ¢æœ‰ç¿»è½¬åŠ¨ç”»ã€‚
    *   æ˜¾è‘—çš„â€œVIPä¸­å¿ƒ/æˆä¸ºå®ˆæŠ¤è€…â€å…¥å£ï¼Œå¯è®¾è®¡ä¸ºåä¸½çš„å·è½´æˆ–ç‰ŒåŒ¾ï¼Œå¸¦æœ‰åŠ¨æ€å…‰æ•ˆã€‚
    *   é™æ—¶è®¢é˜…ä¼˜æƒ Banneré‡‡ç”¨åŠ¨æ€å€’è®¡æ—¶å™¨å’Œå¸å¼•äººçš„è§†è§‰è®¾è®¡ï¼ˆç•Œé¢D1ï¼‰ã€‚
-   **å•†å“ç½‘æ ¼**ï¼š
    *   å•†å“å¡ç‰‡ä¸ºæµ®é›•é‡‘è¾¹ï¼Œæ’ç”»é«˜ç²¾åº¦å¹¶å¸¦æœ‰å¾®åŠ¨ç”»ã€‚
    *   VIPä¸“å±å•†å“å¸¦æœ‰é†’ç›®çš„â€œVIPä¸“äº«â€é‡‘è‰²æ ‡ç­¾æˆ–çš‡å† è§’æ ‡ï¼Œå•†å“å¡ç‰‡èƒŒæ™¯æ›´åä¸½ã€‚å•†åº—å†…è®¾ç«‹â€œå®ˆæŠ¤è€…ç§˜å®â€ç­‰ä¸“åŒºã€‚
    *   ä»·æ ¼ç”¨é‡‘è‰²å­—ä½“ä¸ç«‹ä½“è´§å¸å›¾æ ‡ï¼ŒVIPå•†å“æœ‰ä¸“å±å…‰æ•ˆä¸æ ‡è¯†ã€‚è‹¥VIPè´­ä¹°æœ‰æŠ˜æ‰£ï¼Œæ¸…æ™°æ ‡å‡ºåŸä»·ã€æŠ˜æ‰£ä»·å’ŒèŠ‚çœé‡‘é¢ã€‚
-   **å•†å“è¯¦æƒ…**ï¼š
    *   å¤§å›¾é¢„è§ˆæ”¯æŒ3Dæ—‹è½¬ï¼Œæè¿°åŒºç”¨å®‹ä½“/ä¹¦æ³•å­—ä½“ã€‚
    *   ç†ŠçŒ«å®šåˆ¶ç±»å•†å“æœ‰å‰åå¯¹æ¯”åŠ¨ç”»ã€‚
    *   è´­ä¹°æŒ‰é’®ä¸ºç‰ç’§/ç¥¥äº‘é€ å‹ï¼Œç‚¹å‡»æœ‰ç²’å­çˆ†å‘ã€‚
    *   ç›¸å…³å•†å“æ¨ªå‘æ»šåŠ¨ï¼Œå¡ç‰‡æœ‰å¼¹è·³ä¸é«˜å…‰ã€‚
-   **è®¢é˜…é€‰æ‹©æ¨¡å—**ï¼šç›´æ¥åœ¨å•†åº—é¦–é¡µæˆ–æ¬¡çº§é¡µé¢åµŒå…¥ç•Œé¢E1ï¼ˆè®¢é˜…é€‰æ‹©é¡µé¢ï¼‰çš„å¡ç‰‡å¼è®¾è®¡ï¼Œæ–¹ä¾¿ç”¨æˆ·éšæ—¶æŸ¥çœ‹å’Œé€‰æ‹©ã€‚

### 4.6 ç†ŠçŒ«äº’åŠ¨é¡µï¼ˆå¿ƒçµç›¸é€šï¼‰
å¼ºåŒ–â€œäº²å¯†äº’åŠ¨â€ä¸â€œåŠ¨æ€ç¯å¢ƒâ€ä½“éªŒï¼š

-   **ç¯å¢ƒè®¾è®¡**ï¼š
    *   èƒŒæ™¯ä¸ºé«˜ç²¾åº¦ä¸­å›½å›­æ—ï¼Œéšæ—¶é—´å˜åŒ–å…‰å½±ï¼ŒåŠ å…¥åŠ¨æ€æ°´é¢ã€ç«¹å¶ã€ç¥¥äº‘ç­‰ç²’å­ã€‚
    *   ç¯å¢ƒå…ƒç´ å¯äº¤äº’ï¼ˆå¦‚ç‚¹å‡»æ°´æ± æœ‰æ¶Ÿæ¼ªï¼Œç«¹å¶å¯é£˜è½ï¼‰ã€‚
-   **ç†ŠçŒ«å¯è§†åŒ–**ï¼š
    *   ç†ŠçŒ«å¤§å¹…åŠ¨æ€æ’ç”»ï¼Œæƒ…ç»ªé€šè¿‡è¡¨æƒ…ã€åŠ¨ä½œã€ç‰¹æ•ˆå±•ç°ï¼ˆå¦‚å¼€å¿ƒæ—¶æœ‰é‡‘å…‰ã€æ’’å¨‡æ—¶æœ‰çˆ±å¿ƒç²’å­ï¼‰ã€‚
    *   å®šåˆ¶è£…é¥°é«˜ç²¾åº¦æ¸²æŸ“ï¼Œç¨€æœ‰ç‰©å“æœ‰ç‰¹æ®Šå…‰æ•ˆã€‚
-   **äº’åŠ¨æ§ä»¶**ï¼š
    *   æŒ‰é’®ä¸ºç‰ä½©/ç¥¥äº‘é€ å‹ï¼Œç‚¹å‡»æœ‰å¼¹è·³ä¸ç²’å­åŠ¨ç”»ã€‚
    *   å–‚é£Ÿã€ç©è€ã€è®­ç»ƒå‡æœ‰ä¸“å±åŠ¨ç”»ä¸å¥–åŠ±åé¦ˆã€‚
    *   ç†ŠçŒ«å¯è§£é”ä¸€äº›åªæœ‰VIPæ‰èƒ½è§¦å‘çš„ç‰¹æ®Šäº’åŠ¨åŠ¨ç”»æˆ–å¯¹è¯ï¼ˆå¦‚ç†ŠçŒ«è¡¨æ¼”ä¸€æ®µç‰¹æ®Šçš„æ‰è‰ºã€åˆ†äº«ä¸€æ®µâ€œæ™ºæ…§ç®´è¨€â€ï¼‰ã€‚
    *   åæ€æç¤ºä¸ºæ¸©æŸ”å¼¹çª—ï¼ŒèƒŒæ™¯è™šåŒ–å¹¶æœ‰ç¥¥äº‘ç¯ç»•ã€‚

### 4.7 å¹¸è¿æŠ½å¥–é¡µï¼ˆç¦ç¼˜æŠ½ç­¾ï¼‰
çªå‡ºâ€œä»ªå¼æ„Ÿâ€ä¸â€œæƒŠå–œæ„Ÿâ€è§†è§‰ï¼š

-   **é¡¶éƒ¨åŒºåŸŸ**ï¼š
    *   å¹¸è¿ç‚¹ä½™é¢ä¸ºç«‹ä½“ç‰ç’§è®¡æ•°å™¨ï¼Œå‘¨å›´å¸¸é©»é—ªçƒç²’å­ã€‚
-   **æŠ½å¥–æœºåˆ¶**ï¼š
    *   æŠ½å¥–åŠ¨ç”»ä¸ºåä¸½å®ç®±/è½¬ç›˜/ç«¹ç®€å±•å¼€ï¼Œç²’å­ä¸éŸ³æ•ˆè¥é€ æœŸå¾…æ°›å›´ã€‚
    *   æŠ½å¥–æŒ‰é’®ä¸ºé‡‘è‰²ç¥¥äº‘é€ å‹ï¼Œç‚¹å‡»æœ‰é«˜å…‰ä¸ç²’å­çˆ†å‘ã€‚
    *   ç»“æœæ­æ™“æœ‰å·è½´å±•å¼€ã€å®ç®±å¼€å¯ç­‰åº†ç¥åŠ¨ç”»ã€‚
    *   æ¸…æ™°æ˜¾ç¤ºVIPç”¨æˆ·å‰©ä½™çš„æ¯æ—¥å…è´¹æŠ½å¥–æ¬¡æ•°ã€‚æŒ‰é’®æ—å¯æœ‰â€œå®ˆæŠ¤è€…æ¯æ—¥å…è´¹Xæ¬¡â€æç¤ºã€‚
-   **å¥–æ± å±•ç¤º**ï¼š
    *   å¥–å“ä»¥ç”»å»Šå½¢å¼å±•ç¤ºï¼Œç¨€æœ‰åº¦ç”¨é‡‘å…‰/ç¥¥äº‘ç‰¹æ•ˆåŒºåˆ†ã€‚
    *   è‹¥VIPåœ¨å¥–æ± ä¸­æœ‰ä¸“å±ç‰©å“æˆ–æ›´é«˜çš„ç¨€æœ‰ç‰©å“è·å–æ¦‚ç‡ï¼Œåº”åœ¨å¥–æ± è¯´æ˜ä¸­æˆ–é€šè¿‡è§†è§‰æš—ç¤ºï¼ˆå¦‚VIPæŠ½å¥–æ—¶è½¬ç›˜ä¸Šæœ‰æ›´å¤šé‡‘è‰²æ ¼å­ï¼‰ã€‚
    *   æ¦‚ç‡ç”¨ç²¾ç¾æ•°æ®å¯è§†åŒ–ï¼Œè¿‘æœŸä¸­å¥–æœ‰æ—¶é—´è½´åŠ¨ç”»ã€‚å¯åœ¨æ­¤é¡µé¢åº•éƒ¨æ»šåŠ¨æ˜¾ç¤ºâ€œç©å®¶XXXåˆšåˆšé€šè¿‡ç¦ç¼˜æŠ½ç­¾è·å¾—äº†[ç¨€æœ‰ç‰©å“]ï¼â€ï¼ˆè‹¥ä¸ºVIPï¼Œå¯åŠ ä¸Šå®ˆæŠ¤è€…æ ‡è¯†ï¼‰ã€‚

### 4.8 åæ€æ¨¡å—ï¼ˆé™å¿ƒèŒ¶å®¤ï¼‰
è¥é€ â€œé™è°§æ²»æ„ˆâ€ä¸â€œæ¸©æŸ”æ”¯æŒâ€æ°›å›´ï¼š

-   **è§†è§‰è®¾è®¡**ï¼š
    *   èƒŒæ™¯ä¸ºæ·¡é›…èŒ¶å®¤/å±±æ°´ï¼Œç¥¥äº‘ã€èŒ¶çƒŸç­‰æŸ”å’ŒåŠ¨ç”»ï¼Œæ•´ä½“è‰²è°ƒæ¸©æš–æŸ”å’Œã€‚
    *   UIå…ƒç´ æç®€ï¼Œå‡å°‘å¹²æ‰°ï¼Œè¾“å…¥åŒºä¸ºå®£çº¸/ç«¹ç®€é€ å‹ã€‚
-   **äº¤äº’è®¾è®¡**ï¼š
    *   ç†ŠçŒ«å¤´åƒæœ‰åŒç†å¿ƒè¡¨æƒ…ï¼Œæ–‡å­—å¯¹è¯é‡‡ç”¨é€å­—æ·¡å…¥åŠ¨ç”»ã€‚
    *   è¾“å…¥æ–¹å¼ä¸ºå®šåˆ¶æŒ‰é’®/æ¸©æŸ”æ–‡æœ¬æ¡†ï¼Œåé¦ˆæœ‰æ°´å¢¨æ‰©æ•£åŠ¨ç”»ã€‚
    *   è‹¥ç†ŠçŒ«æ¨èçš„è°ƒé€‚æ–¹æ¡ˆä¸­æœ‰é«˜çº§å†¥æƒ³è¯¾ç¨‹æˆ–æ·±åº¦å¿ƒç†æ”¯æŒå·¥å…·ï¼Œè€Œç”¨æˆ·éVIPï¼Œåˆ™ä¼šæç¤ºâ€œæ­¤ä¸ºå®ˆæŠ¤è€…ä¸“å±æ”¯æŒï¼Œå‡çº§åå¯ä½“éªŒå®Œæ•´ç‰ˆï¼Œè·å¾—ç†ŠçŒ«æ›´æ·±å±‚çš„é™ªä¼´ã€‚â€
    *   é˜¶æ®µåˆ‡æ¢ä¸ºå·è½´å±•å¼€/ç¥¥äº‘æµåŠ¨ï¼Œæ•´ä½“è¿‡æ¸¡å¹³æ»‘ã€‚

### 4.9 VIPä¸­å¿ƒé¡µï¼ˆç´«å®¸æ®¿/éº’éºŸé˜ï¼‰
é›†ä¸­å±•ç¤ºæ‰€æœ‰VIPæƒç›Šï¼Œæä¾›æ¸…æ™°çš„ä»·å€¼å¯¹æ¯”ï¼Œå¹¶ä½œä¸ºè®¢é˜…å’Œç®¡ç†å…¥å£ï¼š

-   **è®¾è®¡é£æ ¼ï¼š** æå°½åä¸½ï¼Œé‡‡ç”¨å®«æ®¿ã€ä»™å¢ƒç­‰é«˜çº§æ„è±¡ã€‚èƒŒæ™¯å¯ä»¥æ˜¯åŠ¨æ€çš„æ˜Ÿç©ºã€ç¥¥äº‘ç¼­ç»•çš„å±±å·…æˆ–åä¸½çš„å®«æ®¿å†…æ™¯ã€‚
-   **å†…å®¹æ¨¡å—ï¼š**
    *   **èº«ä»½è±¡å¾ï¼š** é¡¶éƒ¨å±•ç¤ºç”¨æˆ·å½“å‰çš„VIPç­‰çº§ï¼ˆè‹¥å·²è®¢é˜…ï¼‰æˆ–â€œåŠ å…¥å®ˆæŠ¤è€…è¡Œåˆ—â€çš„é†’ç›®å…¥å£ã€‚å±•ç¤ºVIPä¸“å±å¤´åƒæ¡†ã€ç§°å·çš„é¢„è§ˆã€‚
    *   **æ ¸å¿ƒç‰¹æƒå±•ç¤ºåŒºï¼š** ä»¥å›¾æ–‡å¹¶èŒ‚çš„å¡ç‰‡æˆ–æ»šåŠ¨åˆ—è¡¨å½¢å¼ï¼Œæ¸…æ™°å±•ç¤ºå„é¡¹VIPç‰¹æƒï¼Œå¹¶ä¸å…è´¹ç‰ˆè¿›è¡Œè§†è§‰åŒ–å¯¹æ¯”ã€‚ä¾‹å¦‚ï¼šâ€œèµ„æºè·å–UPï¼â€ å¡ç‰‡ï¼Œå·¦è¾¹æ˜¯æ™®é€šç†ŠçŒ«ï¼Œå³è¾¹æ˜¯æˆ´ç€çš‡å† çš„VIPç†ŠçŒ«ï¼Œæ—è¾¹åˆ†åˆ«æ˜¾ç¤ºè·å–çš„ç«¹å­æ•°é‡ï¼ˆ1 vs 2ï¼‰ï¼ŒVIPéƒ¨åˆ†ç”¨é‡‘è‰²å’Œç²’å­ç‰¹æ•ˆã€‚ â€œæˆé•¿åŠ é€Ÿï¼â€å¡ç‰‡ï¼Œç”¨åŠ¨æ€è¿›åº¦æ¡å¯¹æ¯”å…è´¹ä¸VIPçš„æˆé•¿é€Ÿåº¦ã€‚ â€œä¸“å±å†…å®¹è§£é”ï¼â€å¡ç‰‡ï¼Œå±•ç¤ºVIPä¸“å±çš®è‚¤ã€ä»»åŠ¡ã€è¯¾ç¨‹çš„ç²¾ç¾é¢„è§ˆå›¾ã€‚
    *   **è®¢é˜…é€‰é¡¹æ¨¡å—ï¼š** (ç•Œé¢E1è®¾è®¡) æ¸…æ™°å±•ç¤ºæœˆå¡ã€å­£å¡ã€å¹´å¡é€‰é¡¹ï¼Œçªå‡ºâ€œæ¨èâ€å’Œâ€œæœ€ä½³ä»·å€¼â€ï¼Œæ ‡æ˜ä»·æ ¼å’Œå¹³å‡æ¯æœˆèŠ±è´¹ã€‚
    *   **å®ˆæŠ¤è€…ä¸“å±ç¦åˆ©åŒºï¼š** å±•ç¤ºå½“æœˆ/å½“å­£VIPå¯é¢†å–çš„ä¸“å±ç¤¼åŒ…ã€å‚ä¸çš„ä¸“å±æ´»åŠ¨ç­‰ã€‚
    *   **ä»·å€¼å›é¡¾/æ¨èç†ç”±ï¼š** (å¯é€‰) ç»“åˆç”¨æˆ·æ•°æ®ï¼ˆè‹¥å·²è¯•ç”¨æˆ–æ›¾è®¢é˜…ï¼‰ï¼Œå±•ç¤ºâ€œæ‚¨å·²èŠ‚çœ/é¢å¤–è·å¾—...â€ï¼Œæˆ–å¼•ç”¨å…¶ä»–â€œå®ˆæŠ¤è€…â€çš„å¥½è¯„ã€‚
    *   **FAQ/å¸®åŠ©ï¼š** è§£ç­”å…³äºVIPè®¢é˜…çš„å¸¸è§é—®é¢˜ã€‚

## 5. Core Gameplay Elements (å¼ºè°ƒVIPçš„è§†è§‰å’Œä½“éªŒå‡çº§)

### 5.1 Panda Companion Visualization
The Panda companion is the emotional heart of the app and features:

-   **Growth Stages**:
    -   Infant: Small, extra fluffy with large eyes and playful movements.
    -   Youth: More active, curious expressions, developing unique personality.
    -   Adult: Graceful, wise appearance with confident posture.
    -   Perfect Form: Majestic presence with subtle glow effects and special animations.
-   **Emotional States**:
    -   Happy: Bright eyes, smiling expression, energetic movements, often accompanied by playful particle effects.
    -   Neutral: Calm demeanor, regular breathing animation, soft ambient sounds.
    -   Concerned: Gentle head tilt, softer movements, attentive gaze, perhaps a subtle sigh animation.
-   **Customization Visualization**:
    -   Seamless integration of accessories and clothing with high-fidelity rendering.
    -   Environment decorations that the Panda interacts with dynamically (e.g., sleeps on a VIP bed, plays with a VIP toy).
    -   **VIPä¸“å±çš®è‚¤/é¥°å“**ï¼šå…·æœ‰æ›´å¤æ‚çš„ç»†èŠ‚ã€ç‹¬ç‰¹çš„å…‰æ•ˆï¼ˆå¦‚æµå…‰ã€ç²’å­ç¯ç»•ï¼‰æˆ–åŠ¨æ€æ•ˆæœï¼ˆå¦‚å°¾å·´æ‘†åŠ¨æ—¶æœ‰æ˜Ÿå°˜æ•£è½ï¼‰ã€‚
    -   **VIPä¸“å±ç¯å¢ƒè£…é¥°**ï¼šæ›´åä¸½ã€æ›´å…·ä¸»é¢˜æ€§çš„å®¶å›­è£…é¥°ï¼Œç†ŠçŒ«å¯ä»¥ä¸ä¹‹è¿›è¡Œç‰¹æ®Šäº’åŠ¨ã€‚

### 5.2 Resource System Visualization
Resources are presented with premium visual treatment:

-   **Resource Icons**:
    -   Bamboo: Detailed, realistic bamboo stalks with subtle shine and gentle sway animation.
    -   Water: Crystal-clear droplets with light refraction effects and shimmering highlights.
    -   Coins: Ornate gold coins with embossed panda design, metallic sheen, and slight spinning effect.
    -   Diamonds: Multi-faceted gems with light reflection, sparkle animation, and a subtle glow.
-   **Resource Animations**:
    -   Collection: Satisfying gather animation where icons fly towards the HUD with particle trails and a distinct collection sound.
    -   Spending: Elegant transfer animation from inventory to use, with resources visually depleting or transforming.
    -   Low resources: Subtle visual indicator (e.g., resource icon slightly dimmed) without being punitive.
    -   Resource milestone: Special celebration animation when a large amount is collected or spent.
    -   **VIPé¢å¤–è·å–**ï¼šå½“VIPç”¨æˆ·è·å¾—é¢å¤–èµ„æºæ—¶ï¼Œè¿™äº›é¢å¤–çš„èµ„æºå›¾æ ‡ä¼šä»¥æ›´é†’ç›®çš„é‡‘è‰²å…‰èŠ’é£å‘åº“å­˜ï¼Œå¹¶ä¼´æœ‰æ¸…è„†çš„ç‰¹æ®ŠéŸ³æ•ˆã€‚

### 5.3 Timely Reward System Visualization
The Timely Reward System features premium visual elements:

-   **Timeliness Bar**:
    -   Elegant scroll or bamboo-themed progress indicator with intricate patterns.
    -   Rich fill animation with flowing ink/golden light particle effects.
    *   VIPç”¨æˆ·çš„è¿›åº¦æ¡å¡«å……åŠ¨ç”»å¯ä»¥æ›´å¿«ï¼Œæˆ–è€…æ¯æ¬¡å¡«å……çš„â€œå…‰èŠ’â€æ›´äº®ã€èŒƒå›´æ›´å¤§ã€‚
    -   Reward preview with subtle highlight animation, showcasing the valuable item. å¦‚æœTimeliness Barçš„æœ€ç»ˆå¥–åŠ±å¯¹VIPæœ‰é¢å¤–åŠ æˆæˆ–ä¸“å±å†…å®¹ï¼Œåº”åœ¨é¢„è§ˆä¸­æ¸…æ™°æ ‡å‡ºã€‚
    -   Completion celebration with luxurious visual effects like unfolding scrolls, blooming flowers, or auspicious cloud formations.
-   **Luck Points**:
    -   Premium counter designed as a glowing orb or a lucky charm, with sparkle animation.
    -   Earning visualization with floating point animation, points having a distinct golden shimmer or lucky symbol.
    -   Accumulation milestone effects with special visual treatment, e.g., the counter glowing brighter.
-   **On-Time Completion**:
    -   Satisfying visual feedback for timely task completion, like a golden checkmark appearing or a seal stamp animation.
    -   Special animation for "Early Bird" bonus, perhaps a sunrise motif or a chirping bird sound.
    -   Elegant visual connection between task completion and rewards, with particles flowing from the task to the Timeliness Bar and Luck Point counter.

### 5.4 Challenge System Visualization
Challenges are presented with immersive visual elements:

-   **Challenge Categories**:
    -   Visual theming for different challenge types (e.g., misty mountains for long-term challenges, festive lanterns for event challenges).
    -   Custom illustrations for challenge backgrounds, reflecting Oriental aesthetics.
    -   Animated transitions between categories, like a scroll unfurling or a map panning.
-   **Progress Tracking**:
    -   Rich progress bar design with milestone markers stylized as jade pieces or calligraphy strokes.
    -   Sub-task completion visualization with elegant checkmarks or an ink stamp appearing.
    -   Time remaining indicator with premium countdown design, perhaps a traditional Chinese hourglass or a burning incense stick.
-   **Reward Presentation**:
    *   Treasure chest or ornate gift box animation for claiming rewards, opening with a flourish and light effects.
    *   Particle effects (like golden dust or flower petals) and celebratory sound design.
    *   Reward showcase with detailed item presentation, items appearing with a shimmer or glow.
    *   **VIPé¢å¤–å¥–åŠ±ï¼š** é¢†å–æŒ‘æˆ˜å¥–åŠ±æ—¶ï¼Œè‹¥VIPæœ‰é¢å¤–å¥–åŠ±ï¼Œä¼šåˆ†é˜¶æ®µå±•ç¤ºï¼šå…ˆå±•ç¤ºåŸºç¡€å¥–åŠ±ï¼Œç„¶ååä¸½åŠ¨ç”»æ•ˆæœåï¼Œå†å±•ç¤ºVIPä¸“å±çš„é¢å¤–å¥–åŠ±éƒ¨åˆ†ï¼Œå¼ºåŒ–è·å¾—æ„Ÿã€‚

## 6. Monetization Design (åŸºäºChecklist 2.0çš„ä¼˜åŒ–)

### 6.1 VIP Subscription UI/UX
The VIP subscription is presented with a premium, value-focused approach:

-   **VIP Badge Design**:
    *   Elegant, non-intrusive badge with subtle animation (e.g., a gently glowing bamboo leaf crown or a jade pendant with a "å®ˆ" character).
    *   Tiered designs for different subscription levels (e.g., Bronze, Silver, Gold Panda Guardian) with increasingly ornate details.
    *   Special visual effects for VIP users' avatars, like a flowing aura or unique particle trail in social contexts.
    *   åœ¨ç”¨æˆ·å¤´åƒã€æ’è¡Œæ¦œã€èŠå¤©ï¼ˆè‹¥æœ‰ï¼‰ç­‰å¤„ï¼ŒVIPå¾½ç« ï¼ˆå¦‚åŠ¨æ€ç«¹å¶çš‡å† ï¼‰éœ€é†’ç›®ä¸”è®¾è®¡ç²¾è‰¯ï¼Œæ˜¯èº«ä»½çš„ç›´æ¥å½°æ˜¾ã€‚
-   **VIP Benefits Visualization (in VIP Center Page - ç´«å®¸æ®¿/éº’éºŸé˜)**:
    *   Clear, visually rich comparison between free and VIP using side-by-side infographics or animated carousels.
    *   Animated demonstrations of enhanced features (e.g., faster Panda growth, increased resource gain with golden particle effects).
    *   Before/after visualizations of rewards and progression (e.g., a split screen showing a free user's reward vs. a VIP's enhanced reward for the same task).
    *   æ ¸å¿ƒæ˜¯å¯¹æ¯”å’Œå¯è§†åŒ–ã€‚ ä½¿ç”¨å¹¶æ’å¸ƒå±€ã€åŠ¨ç”»æ¼”ç¤ºã€æ•°æ®å¯¹æ¯”ï¼ˆå¦‚â€œèŠ‚çœXXæ—¶é—´â€ã€â€œèµ„æºè·å–+XX%â€ï¼‰æ¥æ¸…æ™°å±•ç¤ºä»·å€¼ã€‚
-   **Subscription Flow (via VIP Center or contextual prompts)**:
    *   Elegant, distraction-free purchase screen with a luxurious background (e.g., silk brocade, starry night sky).
    *   Tiered options (Monthly, Seasonal, Annual) presented as ornate jade tablets or scrolls, with visual hierarchy based on value. å­£å¡æ ‡è®°â€œæ¨èâ€ï¼Œå¹´å¡æ ‡è®°â€œæœ€ä½³ä»·å€¼â€å¹¶çªå‡ºå…¶æè‡´æ€§ä»·æ¯”å’Œé¢å¤–ä¸“å±å¤§ç¤¼åŒ…ã€‚
    *   Secure payment visualization with premium styling, perhaps a golden seal animation upon confirmation.
    *   Thank you/confirmation screen with a celebratory animation featuring the Panda and auspicious symbols.
    *   â€œæ— é£é™©â€è¯•ç”¨å¼•å¯¼ï¼ˆç•Œé¢B1ï¼‰ï¼šåœ¨åˆé€‚æ—¶æœºï¼ˆå¦‚æ–°æ‰‹æœŸç»“æŸï¼‰æä¾›3-7å¤©æ ¸å¿ƒVIPåŠŸèƒ½å…è´¹è¯•ç”¨ï¼Œè¯•ç”¨ç»“æŸå‰é€šè¿‡ä»·å€¼å›é¡¾å¼¹çª—ï¼ˆç•Œé¢F2ï¼‰å¼ºåŒ–è½¬åŒ–ã€‚
    *   äººæ€§åŒ–æŒ½ç•™ï¼ˆç•Œé¢F3ï¼‰ï¼šåœ¨ç”¨æˆ·å°è¯•é€€è®¢æ—¶ï¼Œæä¾›é™çº§ã€æŠ˜æ‰£ã€ä¼‘çœ ä¿ç•™ç­‰é€‰é¡¹ï¼Œé¿å…å¼ºç¡¬ã€‚

### 6.2 Shop Design (çå®é˜)
The Shop provides a luxurious shopping experience:

-   **Item Categories**:
    *   Visual theming for different item types (e.g., Panda skins in a "Wardrobe Pavilion", decorations in a "Garden Emporium").
    *   Elegant category icons with selection effects (e.g., icons glowing or subtly animating).
    *   Featured items carousel with premium presentation using dynamic lighting and particle effects.
    *   å•†åº—å†…è®¾ç«‹â€œå®ˆæŠ¤è€…ç§˜å®â€ç­‰ä¸“åŒºï¼Œé™ˆåˆ—VIPæ‰èƒ½è´­ä¹°çš„é¡¶çº§å¤–è§‚æˆ–é“å…·ï¼Œä½¿ç”¨æ›´åä¸½çš„å¡ç‰‡å’ŒèƒŒæ™¯ã€‚
-   **Item Presentation**:
    *   High-quality item illustrations with subtle animations (e.g., clothing gently swaying, decorations emitting a soft glow).
    *   3D preview capability for certain items, allowing users to rotate and inspect details.
    *   Try-before-buy visualization for Panda customizations, showing the item on the user's current Panda.
    *   Limited-time items with special visual treatment, like a golden border or a countdown timer display.
-   **Purchase Experience**:
    *   Smooth, satisfying purchase animation, like items flying into an ornate treasure chest.
    *   Elegant confirmation screen with item showcase and a thank you message in calligraphy.
    *   Gift wrapping animation for new acquisitions, perhaps tied with a silk ribbon.
    *   Inventory update visualization with items appearing in a beautifully designed inventory screen.
-   **Limited-Time Offers (èå…¥ç•Œé¢D1)**:
    *   åŠ¨æ€åŒ–é™æ—¶ä¼˜æƒ ï¼šé’ˆå¯¹æ–°ç”¨æˆ·æˆ–ç‰¹å®šèŠ‚æ—¥ï¼Œæ¨å‡ºé«˜æ€§ä»·æ¯”çš„â€œæ–°æ‰‹ç‰¹æƒ è®¢é˜…åŒ…â€æˆ–â€œèŠ‚æ—¥é™å®šè®¢é˜…ç¤¼é‡â€ï¼Œé…åˆé†’ç›®çš„å€’è®¡æ—¶å™¨ã€‚

### 6.3 Conversion Optimization (èå…¥Checklist 2.0çš„åœºæ™¯åŒ–ç­–ç•¥)
Conversion points are designed to be compelling yet non-intrusive:

-   **Feature Discovery / â€œè§£é”â€å‹æ¿€åŠ± (èå…¥ç•Œé¢A3)**:
    *   Elegant "VIP Feature" indicators (e.g., a small golden lock icon or a subtle shimmer) on locked content or features.
    *   Subtle glow or highlight effects to draw attention to VIP-exclusive options.
    *   Preview capabilities for some VIP content (e.g., watching a snippet of a VIP meditation course) with "Upgrade to Access Full Content" messaging.
    *   å½“ç”¨æˆ·å°è¯•è®¿é—®VIPåŠŸèƒ½æ—¶ï¼Œå¼¹å‡ºå¼•å¯¼å¼¹çª—ï¼Œæ¸…æ™°è¯´æ˜æ­¤åŠŸèƒ½çš„VIPä¼˜åŠ¿ï¼Œå¹¶æä¾›â€œäº†è§£å®ˆæŠ¤è€…ç‰¹æƒâ€çš„ç›´æ¥å…¥å£ã€‚
-   **Value Demonstration / å…³é”®æ—¶åˆ»ä¸æƒ…æ„Ÿè¿æ¥ (èå…¥ç•Œé¢A2, C1, C2)**:
    *   Visual comparisons showing enhanced rewards (e.g., a split screen showing free vs. VIP loot drops).
    *   Progress acceleration visualizations (e.g., an animated bar graph showing faster Panda growth for VIPs).
    *   Exclusive item showcases with premium presentation and particle effects.
    *   é«˜å…‰æ—¶åˆ»åŠ©æ¨ï¼šæˆå°±è¾¾æˆã€ç¨€æœ‰æ‰è½åï¼Œæç¤ºâ€œè®¢é˜…åæ­¤ç±»å¥–åŠ±ç¿»å€/æ°¸ä¹…æå‡â€ã€‚
    *   ç—›ç‚¹è§£å†³æ–¹æ¡ˆï¼šé‡åˆ°ç“¶é¢ˆæ—¶ï¼Œæä¾›è®¢é˜…ä½œä¸ºâ€œä¼˜é›…â€çš„è§£å†³æ–¹æ¡ˆï¼ˆå¦‚â€œå®ˆæŠ¤è€…ä¸“äº«å†è¯•ä¸€æ¬¡æœºä¼šâ€ï¼‰ã€‚
    *   å³æ—¶æ”¶ç›Šåé¦ˆï¼šä»»åŠ¡å®Œæˆã€å‡çº§æ—¶ï¼Œæ˜ç¡®å±•ç¤ºè®¢é˜…å¸¦æ¥çš„â€œé¢å¤–â€æ”¶ç›Šã€‚
-   **Contextual Prompts (èå…¥ç•Œé¢B2)**:
    *   Thoughtfully timed upgrade suggestions, appearing when users might most appreciate VIP benefits (e.g., after running out of energy, or when facing a difficult challenge).
    *   Elegant modal design for upgrade prompts, using soft animations and calming visuals.
    *   Clear value proposition with visual support, focusing on how VIP enhances the user's journey.
    *   åœ¨ç”¨æˆ·é¢ä¸´èµ„æºçŸ­ç¼ºæˆ–è€—æ—¶æ“ä½œæ—¶ï¼Œé€‚æ—¶æç¤ºè®¢é˜…å¦‚ä½•é«˜æ•ˆè§£å†³ã€‚
-   **ç¤¾äº¤å¯¹æ¯”ä¸å‘å¾€ (èå…¥ç•Œé¢C3, G2, H1, H2, H3)**:
    *   æ’è¡Œæ¦œã€å¥½å‹åˆ—è¡¨æ¸…æ™°å±•ç¤ºVIPæ ‡è¯†åŠå…¶å¸¦æ¥çš„å¯è§ä¼˜åŠ¿ï¼ˆä¸“å±å¤–è§‚ã€æ›´é«˜æ’ååŠ æˆï¼‰ï¼Œæ¿€å‘å‘å¾€ã€‚
    *   è®¢é˜…ç”¨æˆ·ç»„é˜Ÿæ—¶èƒ½ä¸ºå…¨é˜Ÿå¸¦æ¥å¾®å°å¢ç›Šã€‚

## 7. Technical Implementation Guidelines

### 7.1 Integration with Existing Codebase
The implementation will build upon the existing React/TypeScript architecture:

-   Leverage the current component structure while enhancing visual elements with more detailed styling and animations, potentially using libraries like Framer Motion for sophisticated effects.
-   Maintain the existing data flow patterns (e.g., Redux, Context API) while adding new state slices for game-specific data like Panda stats, inventory, and Timely Reward progress.
-   Extend the current state management approach to include new game elements, ensuring efficient updates for dynamic UIs.

### 7.2 Internationalization Approach
Building on the existing i18n infrastructure (e.g., i18next):

-   Extend the current language system to include game-specific terminology, ensuring all narrative text, UI labels, and Panda dialogues are translatable.
-   Ensure all new UI elements, including dynamically generated text for rewards and VIP benefits, support multiple languages and varying text lengths.
-   Implement culturally appropriate visual elements for different regions, such as specific festival themes or color symbolism, where applicable and manageable.

### 7.3 Component Structure
The component architecture will follow a modular approach, potentially Atomic Design:

-   **Atomic Design Methodology**:
    -   Atoms: Basic UI elements (buttons with ornate borders, inputs with subtle textures, icons with water-ink style).
    -   Molecules: Compound components (task cards withå·è½´styling, reward displays with particle effects, Panda status indicators).
    -   Organisms: Feature sections (Task List with scrollableå·è½´, Panda Interaction Area with dynamic background, Shop item grid).
    -   Templates: Page layouts with placeholder content, defining the structure for Home, Task, Shop pages.
    -   Pages: Complete screens with real content, populated via state and props.
-   **Game-Specific Components**:
    -   PandaAvatar: Handles rendering and animating the Panda across growth stages, emotions, and with equipped customizations.
    *   ResourceDisplay: Manages resource visualization withè¯éº—é‡‘å±¬è³ªæ„Ÿ and particle effects for updates.
    *   RewardAnimation: Controls reward presentation effects (e.g.,å¯¶ç®±é–‹å•Ÿ, é‡‘å¹£é£›èˆ).
    *   ChallengeTracker: Visualizes challenge progress with dynamically updatingåœ°åœ–/å±±æ°´ç•«å·.
    *   TimelinessBarComponent: Renders theè¯éº—å·è»¸/ç«¹ç°¡style progress bar withæ°´å¢¨æšˆæŸ“fill.
    *   LuckyDrawMachine: Handles theç¦ç·£æŠ½ç­¾animation and reward reveal sequence.

### 7.4 State Management
The state management approach (e.g., Redux Toolkit, Zustand) will handle game-specific requirements:

-   User progress (levels, XP, completed tasks/challenges), achievements, and milestones stored in persistent state, synced with backend.
-   Real-time interactions (e.g., Panda mood changes, immediate reward feedback) managed with local component state or efficient global state updates to prevent unnecessary re-renders.
-   Animation states (e.g., for transitions, reward reveals, Panda expressions) controlled with dedicated hooks or state variables.
-   Game mechanics (timers for tasks/events, random events for Lucky Draw, Panda's needs decay) managed with specialized services or thunks/sagas, interacting with the backend for validation and persistence.

## 8. Appendices

### 8.1 Asset Requirements
-   High-resolution Panda illustrations in various poses, emotional states, and growth stages, suitable for dynamic animation.
-   Premium UI element designs (buttons with cloud/ruyi patterns, cards with silk/brocade textures, icons in water-ink style with gold accents).
-   Environmental elements and backgrounds (dynamic bamboo forests, serene tea rooms, majestic mountain landscapes, ornate palace interiors for VIP Center).
-   Resource and reward visualizations (detailed bamboo, crystal water, ornate coins, multifaceted diamonds, treasure chests, scrolls).
-   Animation sequences for key interactions (Panda movements, resource collection, reward celebrations, UI transitions with ink-wash effects).
-   Unique assets for VIP skins, decorations, and exclusive event rewards, designed to be visibly superior.

### 8.2 Animation Specifications
-   Micro-interactions for UI elements (button presses with particle bursts, switches with jade-like clicks, sliders with smooth ink trails).
-   Character animations for the Panda (idle states with subtle breathing/blinking, expressive happy/concerned/playful animations, specific animations for interacting with VIP items).
-   Reward and achievement celebrations (e.g., scroll unfurling with golden text, treasure chest opening with a shower of coins and gems, Panda performing a celebratory dance).
-   Transition effects between screens and states (e.g., ink wash wipes, page turns like an ancient book, shimmering portals for entering special areas like the VIP Center).
-   Timely Reward System animations: Bar filling with flowing golden ink, Luck Points appearing with a sparkle, Lucky Draw machine animations (spinning wheel, bamboo fortune sticks falling).

### 8.3 Accessibility Considerations
-   Color contrast compliance for all UI elements, ensuring text is readable against ornate backgrounds. Provide high-contrast mode if necessary.
-   Alternative text for decorative elements and complex visuals, especially for images conveying important information.
-   Keyboard navigation support for key interactive elements.
-   Screen reader compatibility, with proper labeling for buttons, icons, and dynamic content.
-   Motion reduction options for animations, allowing users to disable or simplify complex visual effects if they cause discomfort.
-   Clear and legible typography choices, even for stylized fonts, ensuring readability for all users.

---

This updated Design Brief aims to provide a comprehensive and actionable guide for creating PandaHabit with a distinctive "åä¸½æ¸¸æˆé£æ ¼" while strategically embedding effective subscription growth principles. The emphasis is on creating an experience that is not only visually stunning but also deeply engaging and valuable to the user, making the premium offering a natural and desirable upgrade.
</file>

<file path="multilingual-implementation-guide.md">
# PandaHabit å¤šè¯­è¨€å®ç°æŒ‡å—

æœ¬æ–‡æ¡£æä¾›äº†åœ¨ PandaHabit åº”ç”¨ä¸­å®ç°å’Œç»´æŠ¤å¤šè¯­è¨€æ”¯æŒçš„è¯¦ç»†æŒ‡å—ï¼ŒåŒ…æ‹¬ç»„ä»¶çº§åˆ«çš„å¤šè¯­è¨€æ”¯æŒã€æ ‡ç­¾ç®¡ç†å’Œæœ€ä½³å®è·µã€‚

## å¤šè¯­è¨€æ¶æ„æ¦‚è¿°

PandaHabit ä½¿ç”¨ä»¥ä¸‹æ¶æ„æ¥æ”¯æŒå¤šè¯­è¨€ï¼š

1. **LanguageProvider**ï¼šå…¨å±€è¯­è¨€ä¸Šä¸‹æ–‡æä¾›è€…ï¼Œç®¡ç†å½“å‰é€‰æ‹©çš„è¯­è¨€
2. **useLocalizedView**ï¼šè‡ªå®šä¹‰é’©å­ï¼Œç”¨äºè·å–ç‰¹å®šé¡µé¢æˆ–è§†å›¾çš„æœ¬åœ°åŒ–å†…å®¹
3. **localizedContentService**ï¼šæœåŠ¡å±‚ï¼Œè´Ÿè´£ä»æ•°æ®åº“è·å–æœ¬åœ°åŒ–æ ‡ç­¾
4. **æ ‡ç­¾æ•°æ®åº“**ï¼šä½¿ç”¨ Dexie.js å­˜å‚¨æ‰€æœ‰è¯­è¨€çš„æ ‡ç­¾

## ç»„ä»¶çº§åˆ«å¤šè¯­è¨€æ”¯æŒå®ç°

### 1. ç»„ä»¶æ¥å£å®šä¹‰

æ‰€æœ‰éœ€è¦æ˜¾ç¤ºæ–‡æœ¬çš„ç»„ä»¶éƒ½åº”è¯¥æ¥å— `labels` å±æ€§ï¼š

```typescript
interface ComponentProps {
  // å…¶ä»–å±æ€§
  labels?: {
    // ç»„ä»¶éœ€è¦çš„æ‰€æœ‰æ–‡æœ¬æ ‡ç­¾
    title?: string;
    description?: string;
    buttonText?: string;
    // å…¶ä»–æ ‡ç­¾...
  };
}
```

### 2. ç»„ä»¶å®ç°

ç»„ä»¶åº”è¯¥ä½¿ç”¨ä¼ å…¥çš„æ ‡ç­¾ï¼Œå¹¶æä¾›è‹±æ–‡é»˜è®¤å€¼ä½œä¸ºå›é€€ï¼š

```typescript
const MyComponent: React.FC<ComponentProps> = ({ labels, ...props }) => {
  return (
    <div>
      <h2>{labels?.title || "Default Title"}</h2>
      <p>{labels?.description || "Default description text."}</p>
      <button>{labels?.buttonText || "Click Me"}</button>
    </div>
  );
};
```

### 3. åµŒå¥—ç»„ä»¶

å¯¹äºåŒ…å«å­ç»„ä»¶çš„ç»„ä»¶ï¼Œåº”è¯¥å°†ç›¸å…³æ ‡ç­¾ä¼ é€’ç»™å­ç»„ä»¶ï¼š

```typescript
const ParentComponent: React.FC<ParentProps> = ({ labels, ...props }) => {
  return (
    <div>
      <h1>{labels?.title || "Parent Title"}</h1>
      <ChildComponent 
        labels={labels?.childComponent}
        {...childProps} 
      />
    </div>
  );
};
```

## é¡µé¢çº§åˆ«å¤šè¯­è¨€æ”¯æŒå®ç°

### 1. ä½¿ç”¨ useLocalizedView é’©å­

æ‰€æœ‰é¡µé¢ç»„ä»¶éƒ½åº”è¯¥ä½¿ç”¨ `useLocalizedView` é’©å­è·å–æœ¬åœ°åŒ–å†…å®¹ï¼š

```typescript
const MyPage: React.FC = () => {
  const {
    labels: pageLabels,
    data,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<MyPageDataType, MyPageLabelsBundle>(
    'myPageViewContent',
    fetchMyPageView
  );

  // ä½¿ç”¨ pageLabels æ¸²æŸ“é¡µé¢å†…å®¹
  // ...
};
```

### 2. ä¼ é€’æ ‡ç­¾ç»™å­ç»„ä»¶

é¡µé¢ç»„ä»¶åº”è¯¥å°†ç›¸å…³æ ‡ç­¾ä¼ é€’ç»™å­ç»„ä»¶ï¼š

```typescript
<MyComponent 
  labels={pageLabels?.myComponent}
  // å…¶ä»–å±æ€§
/>
```

## æ ‡ç­¾ç®¡ç†

### 1. æ ‡ç­¾ç»„ç»‡

æ ‡ç­¾åº”è¯¥æŒ‰ç…§ä»¥ä¸‹å±‚æ¬¡ç»“æ„ç»„ç»‡ï¼š

```
[é¡µé¢/è§†å›¾].[ç»„ä»¶].[æ ‡ç­¾]
```

ä¾‹å¦‚ï¼š

- `homeView.welcomeSection.title`
- `challengesView.challengeCard.statusActive`
- `storeView.itemCard.buyButton`

### 2. æ ‡ç­¾åŒ…ç±»å‹å®šä¹‰

ä¸ºæ¯ä¸ªé¡µé¢æˆ–è§†å›¾å®šä¹‰æ ‡ç­¾åŒ…ç±»å‹ï¼š

```typescript
export interface ChallengesPageViewLabelsBundle {
  pageTitle: string;
  loadingMessage?: string;
  errorTitle?: string;
  retryButtonText?: string;
  filters?: {
    statusLabel?: string;
    typeLabel?: string;
    // å…¶ä»–è¿‡æ»¤å™¨æ ‡ç­¾
  };
  challengeCard?: {
    statusActive?: string;
    statusCompleted?: string;
    // å…¶ä»–å¡ç‰‡æ ‡ç­¾
  };
  // å…¶ä»–ç»„ä»¶æ ‡ç­¾
}
```

### 3. æ·»åŠ æ–°æ ‡ç­¾

å½“æ·»åŠ æ–°æ ‡ç­¾æ—¶ï¼Œéœ€è¦ï¼š

1. æ›´æ–°ç›¸å…³çš„æ ‡ç­¾åŒ…ç±»å‹å®šä¹‰
2. åœ¨æ•°æ®åº“ä¸­æ·»åŠ æ‰€æœ‰æ”¯æŒè¯­è¨€çš„æ ‡ç­¾
3. æ›´æ–°ç»„ä»¶ä»¥ä½¿ç”¨æ–°æ ‡ç­¾

## æœ€ä½³å®è·µ

### 1. ç»„ä»¶è®¾è®¡

- æ‰€æœ‰æ˜¾ç¤ºæ–‡æœ¬çš„ç»„ä»¶éƒ½åº”è¯¥æ”¯æŒå¤šè¯­è¨€
- ç»„ä»¶åº”è¯¥æ¥å— `labels` å±æ€§ï¼Œå¹¶ä¸ºæ‰€æœ‰æ–‡æœ¬æä¾›è‹±æ–‡é»˜è®¤å€¼
- é¿å…åœ¨ç»„ä»¶ä¸­ç¡¬ç¼–ç ä»»ä½•è¯­è¨€çš„æ–‡æœ¬

### 2. é”™è¯¯å¤„ç†

- é”™è¯¯æ¶ˆæ¯åº”è¯¥ä½¿ç”¨å¤šè¯­è¨€æ ‡ç­¾
- æä¾›æœ‰æ„ä¹‰çš„é»˜è®¤è‹±æ–‡é”™è¯¯æ¶ˆæ¯ä½œä¸ºå›é€€

### 3. åŠ¨æ€å†…å®¹

- å¯¹äºåŠ¨æ€ç”Ÿæˆçš„å†…å®¹ï¼Œè€ƒè™‘ä½¿ç”¨æ¨¡æ¿å­—ç¬¦ä¸²å’Œå ä½ç¬¦
- ç¡®ä¿æ—¥æœŸã€æ•°å­—å’Œè´§å¸æ ¼å¼åŒ–è€ƒè™‘è¯­è¨€ç‰¹å®šçš„æ ¼å¼

### 4. æµ‹è¯•

- ä¸ºæ¯ä¸ªç»„ä»¶ç¼–å†™æµ‹è¯•ï¼Œç¡®ä¿å®ƒä»¬åœ¨ä¸åŒè¯­è¨€è®¾ç½®ä¸‹æ­£ç¡®æ¸²æŸ“
- æµ‹è¯•è¯­è¨€åˆ‡æ¢åŠŸèƒ½ï¼Œç¡®ä¿æ‰€æœ‰ç»„ä»¶æ­£ç¡®æ›´æ–°

## ç¤ºä¾‹å®ç°

### ç»„ä»¶ç¤ºä¾‹ï¼šChallengeCard

```typescript
interface ChallengeCardProps {
  challenge: ChallengeRecord;
  onClick?: (challenge: ChallengeRecord) => void;
  onComplete?: (challengeId: number) => void;
  labels?: {
    statusActive?: string;
    statusCompleted?: string;
    statusExpired?: string;
    statusUpcoming?: string;
    startLabel?: string;
    endLabel?: string;
    completedOnLabel?: string;
    completeButtonText?: string;
    inProgressText?: string;
  };
}

const ChallengeCard: React.FC<ChallengeCardProps> = ({ 
  challenge, 
  onClick, 
  onComplete,
  labels 
}) => {
  // è·å–æŒ‘æˆ˜çŠ¶æ€å¯¹åº”çš„æ–‡æœ¬
  const getStatusText = () => {
    switch (challenge.status) {
      case ChallengeStatus.ACTIVE:
        return labels?.statusActive || 'Active';
      case ChallengeStatus.COMPLETED:
        return labels?.statusCompleted || 'Completed';
      case ChallengeStatus.EXPIRED:
        return labels?.statusExpired || 'Expired';
      case ChallengeStatus.UPCOMING:
        return labels?.statusUpcoming || 'Upcoming';
      default:
        return '';
    }
  };

  // ç»„ä»¶å…¶ä½™éƒ¨åˆ†...
};
```

### é¡µé¢ç¤ºä¾‹ï¼šChallengesPage

```typescript
const ChallengesPage: React.FC = () => {
  const {
    labels: pageLabels,
    data,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<ChallengesPageDataPayload, ChallengesPageViewLabelsBundle>(
    'challengesPageViewContent',
    fetchChallengesPageView
  );

  // æ¸²æŸ“æŒ‘æˆ˜å¡ç‰‡
  const renderChallenges = () => {
    return challenges.map(challenge => (
      <ChallengeCard
        key={challenge.id}
        challenge={challenge}
        onClick={handleChallengeClick}
        onComplete={handleCompleteChallenge}
        labels={pageLabels?.challengeCard}
      />
    ));
  };

  // é¡µé¢å…¶ä½™éƒ¨åˆ†...
};
```

## ç»“è®º

é€šè¿‡éµå¾ªæœ¬æŒ‡å—ä¸­çš„åŸåˆ™å’Œæœ€ä½³å®è·µï¼ŒPandaHabit åº”ç”¨å¯ä»¥æä¾›ä¸€è‡´çš„å¤šè¯­è¨€ä½“éªŒï¼Œå¹¶ä¸ºæœªæ¥æ·»åŠ æ›´å¤šè¯­è¨€æ”¯æŒå¥ å®šåŸºç¡€ã€‚æ­£ç¡®å®ç°å¤šè¯­è¨€æ”¯æŒä¸ä»…æé«˜äº†åº”ç”¨çš„å¯è®¿é—®æ€§ï¼Œè¿˜å¢å¼ºäº†ç”¨æˆ·ä½“éªŒã€‚
</file>

<file path="multilingual-support-fixes.md">
# PandaHabit å¤šè¯­è¨€æ”¯æŒä¿®å¤æ–‡æ¡£

## é—®é¢˜æ¦‚è¿°

åœ¨å¯¹ PandaHabit åº”ç”¨è¿›è¡Œå¤šè¯­è¨€æ”¯æŒæ£€æŸ¥æ—¶ï¼Œå‘ç°è®¸å¤šç»„ä»¶ä¸­å­˜åœ¨ç¡¬ç¼–ç çš„ä¸­æ–‡æ–‡æœ¬ï¼Œå¯¼è‡´å³ä½¿ç”¨æˆ·é€‰æ‹©äº†è‹±è¯­ä½œä¸ºç•Œé¢è¯­è¨€ï¼Œéƒ¨åˆ†ç•Œé¢å…ƒç´ ä»ç„¶æ˜¾ç¤ºä¸­æ–‡ã€‚è¿™ç§ä¸ä¸€è‡´æ€§å½±å“äº†ç”¨æˆ·ä½“éªŒï¼Œéœ€è¦ç³»ç»Ÿæ€§åœ°ä¿®å¤ã€‚

## é—®é¢˜åˆ†ç±»

### 1. ç»„ä»¶çº§åˆ«çš„æœ¬åœ°åŒ–ç¼ºå¤±

- è®¸å¤šç»„ä»¶æ²¡æœ‰æ¥æ”¶æˆ–æ­£ç¡®ä½¿ç”¨å¤šè¯­è¨€æ ‡ç­¾
- ç»„ä»¶å†…éƒ¨çš„æ–‡æœ¬ï¼ˆæŒ‰é’®ã€æ ‡ç­¾ã€æè¿°ç­‰ï¼‰ç›´æ¥ç¡¬ç¼–ç ä¸ºä¸­æ–‡
- é”™è¯¯æ¶ˆæ¯å’ŒçŠ¶æ€æ–‡æœ¬é€šå¸¸æ˜¯ç¡¬ç¼–ç çš„ä¸­æ–‡

### 2. æ ‡ç­¾ä½œç”¨åŸŸä¸å®Œæ•´

- æ•°æ®åº“ä¸­å¯èƒ½ç¼ºå°‘æŸäº›ç»„ä»¶çš„è‹±æ–‡æ ‡ç­¾
- æ ‡ç­¾çš„ä½œç”¨åŸŸï¼ˆscopeKeyï¼‰è®¾ç½®ä¸æ­£ç¡®ï¼Œå¯¼è‡´ç»„ä»¶æ— æ³•è·å–æ­£ç¡®çš„æ ‡ç­¾

### 3. ç»„ä»¶æœªä½¿ç”¨æœ¬åœ°åŒ–é’©å­

- ä¸€äº›ç»„ä»¶æ²¡æœ‰ä½¿ç”¨ `useLocalizedView` é’©å­
- çˆ¶ç»„ä»¶è·å–äº†æœ¬åœ°åŒ–æ ‡ç­¾ï¼Œä½†æ²¡æœ‰æ­£ç¡®åœ°å°†è¿™äº›æ ‡ç­¾ä¼ é€’ç»™å­ç»„ä»¶

## é—®é¢˜ç»„ä»¶æ¸…å•

### åæ€å’Œæƒ…ç»ªç›¸å…³ç»„ä»¶

1. **MoodTracker.tsx**
   - è™½ç„¶å·²æ·»åŠ  labels å‚æ•°ï¼Œä½†ä»æœ‰éƒ¨åˆ†ä¸­æ–‡æ–‡æœ¬æœªä½¿ç”¨æ ‡ç­¾
   - ä¾‹å¦‚ï¼š"å¼ºåº¦:"ã€"æš‚æ— æƒ…ç»ªè®°å½•"ç­‰

2. **EnhancedReflectionModule.tsx**
   - åŒ…å«å¤§é‡ç¡¬ç¼–ç ä¸­æ–‡æ–‡æœ¬
   - ä¾‹å¦‚ï¼š"æˆ‘æ³¨æ„åˆ°ä½ çš„æƒ…ç»ªæœ‰äº›æ³¢åŠ¨ã€‚æƒ³èŠèŠå—ï¼Ÿ"ã€"ä»»åŠ¡æœªèƒ½æŒ‰æ—¶å®Œæˆã€‚è¿™æ²¡å…³ç³»ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€èµ·åæ€ä¸€ä¸‹ã€‚"
   - ç”Ÿæˆå»ºè®®è¡ŒåŠ¨çš„å‡½æ•°ä¸­æœ‰ç¡¬ç¼–ç ä¸­æ–‡æ ‡ç­¾å¦‚"ç„¦è™‘"ã€"å‹åŠ›"ã€"ç–²æƒ«"ç­‰

3. **ReflectionModule.tsx**
   - åŒ…å«ç¡¬ç¼–ç ä¸­æ–‡æ–‡æœ¬
   - ä¾‹å¦‚ï¼š"åˆ†äº«ä½ çš„æƒ³æ³•ï¼ˆå¯ä»¥æ˜¯ä»»ä½•æ„Ÿå—ã€å›°éš¾æˆ–æˆå°±ï¼‰"ã€"ç»§ç»­"ã€"è°¢è°¢ä½ çš„åˆ†äº«"ç­‰

### æ¸¸æˆå’ŒæŒ‘æˆ˜ç›¸å…³ç»„ä»¶

1. **ChallengeCard.tsx**
   - çŠ¶æ€æ–‡æœ¬ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"è¿›è¡Œä¸­"ã€"å·²å®Œæˆ"ã€"å·²è¿‡æœŸ"ã€"å³å°†å¼€å§‹"
   - æ—¥æœŸæ ‡ç­¾ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"å¼€å§‹:"ã€"ç»“æŸ:"ã€"å®Œæˆäº:"
   - æŒ‰é’®æ–‡æœ¬ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"å®ŒæˆæŒ‘æˆ˜"ã€"è¿›è¡Œä¸­..."

2. **ChallengeDiscoveryCard.tsx**
   - é”™è¯¯ä¿¡æ¯å’Œæç¤ºä¿¡æ¯ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"æ— æ³•åŠ è½½æŒ‘æˆ˜æ•°æ®"ã€"åŠ è½½æŒ‘æˆ˜å¤±è´¥ï¼Œè¯·é‡è¯•"ç­‰
   - æ—¥æœŸæ ‡ç­¾ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"å¼€å§‹æ—¥æœŸ:"ã€"ç»“æŸæ—¥æœŸ:"
   - æŒ‰é’®æ–‡æœ¬ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"ç¨åå†è¯´"ã€"æ¥å—æŒ‘æˆ˜"

3. **StoreItemCard.tsx**
   - é”™è¯¯ä¿¡æ¯ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"éœ€è¦VIPä¼šå‘˜æ‰èƒ½è´­ä¹°"ã€"é‡‘å¸ä¸è¶³"ã€"ç‰çŸ³ä¸è¶³"
   - VIPæ ‡ç­¾ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"VIPä¸“å±"
   - ä¿ƒé”€æ ‡ç­¾ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"ä¿ƒé”€"
   - æŒ‰é’®æ–‡æœ¬ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"è´­ä¹°"

### ä»»åŠ¡ç›¸å…³ç»„ä»¶

1. **TaskManager.tsx**
   - é»˜è®¤æ ‡ç­¾ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"ä»»åŠ¡ç®¡ç†"ã€"åˆ›å»ºæ–°ä»»åŠ¡"ã€"å…¨éƒ¨"ã€"å¾…åŠ"ã€"è¿›è¡Œä¸­"ã€"å·²å®Œæˆ"ã€"æš‚æ— ä»»åŠ¡"

2. **SubtaskList.tsx**
   - é”™è¯¯ä¿¡æ¯ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"åŠ è½½å­ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•"ã€"æ·»åŠ å­ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•"ç­‰
   - æŒ‰é’®å’Œè¾“å…¥æ¡†å ä½ç¬¦ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"æ·»åŠ æ–°å­ä»»åŠ¡..."ã€"æ·»åŠ "
   - åˆ é™¤æŒ‰é’®çš„aria-labelç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"åˆ é™¤å­ä»»åŠ¡"

3. **TasksPage.tsx**
   - åŠ è½½æ¶ˆæ¯ç¡¬ç¼–ç ä¸ºä¸­æ–‡ï¼š"åŠ è½½ä»»åŠ¡é¡µé¢å†…å®¹..."

## è§£å†³æ–¹æ¡ˆ

### 1. ç»„ä»¶çº§åˆ«ä¿®å¤

ä¸ºæ¯ä¸ªç»„ä»¶æ·»åŠ æ ‡å‡†åŒ–çš„å¤šè¯­è¨€æ”¯æŒï¼š

1. **æ·»åŠ  labels å‚æ•°**ï¼š
   ```typescript
   interface ComponentProps {
     // å…¶ä»–å±æ€§
     labels?: {
       // ç»„ä»¶éœ€è¦çš„æ‰€æœ‰æ–‡æœ¬æ ‡ç­¾
     };
   }
   ```

2. **æ›¿æ¢ç¡¬ç¼–ç æ–‡æœ¬**ï¼š
   ```typescript
   // æ›¿æ¢å‰
   <Button onClick={handleSubmit}>è´­ä¹°</Button>
   
   // æ›¿æ¢å
   <Button onClick={handleSubmit}>{labels?.buyButton || "Buy"}</Button>
   ```

3. **ç¡®ä¿è‹±æ–‡é»˜è®¤å€¼**ï¼šæ‰€æœ‰æ ‡ç­¾éƒ½åº”æä¾›è‹±æ–‡é»˜è®¤å€¼ä½œä¸ºå›é€€

### 2. ç±»å‹å®šä¹‰æ›´æ–°

ä¸ºæ¯ä¸ªé¡µé¢è§†å›¾çš„æ ‡ç­¾åŒ…æ·»åŠ æ‰€æœ‰éœ€è¦çš„æ ‡ç­¾ï¼š

```typescript
// ä¾‹å¦‚ï¼Œä¸ºæŒ‘æˆ˜é¡µé¢æ·»åŠ æ ‡ç­¾
export interface ChallengesPageViewLabelsBundle {
  pageTitle: string;
  loadingMessage?: string;
  errorTitle?: string;
  retryButtonText?: string;
  filters?: {
    statusLabel?: string;
    typeLabel?: string;
    difficultyLabel?: string;
    allLabel?: string;
    activeLabel?: string;
    completedLabel?: string;
    upcomingLabel?: string;
    // å…¶ä»–è¿‡æ»¤å™¨æ ‡ç­¾
  };
  challengeCard?: {
    statusActive?: string;
    statusCompleted?: string;
    statusExpired?: string;
    statusUpcoming?: string;
    startLabel?: string;
    endLabel?: string;
    completedOnLabel?: string;
    completeButtonText?: string;
    inProgressText?: string;
  };
  // å…¶ä»–æ ‡ç­¾
}
```

### 3. æ•°æ®åº“æ›´æ–°

åœ¨ `db.ts` ä¸­æ·»åŠ æ‰€æœ‰æ–°æ ‡ç­¾çš„è‹±æ–‡å’Œä¸­æ–‡ç¿»è¯‘ï¼š

```typescript
// è‹±æ–‡æ ‡ç­¾
{ id: generateId(), languageCode: 'en', scopeKey: 'challengesView.challengeCard.statusActive', value: 'Active' },
{ id: generateId(), languageCode: 'en', scopeKey: 'challengesView.challengeCard.statusCompleted', value: 'Completed' },
// ...

// ä¸­æ–‡æ ‡ç­¾
{ id: generateId(), languageCode: 'zh', scopeKey: 'challengesView.challengeCard.statusActive', value: 'è¿›è¡Œä¸­' },
{ id: generateId(), languageCode: 'zh', scopeKey: 'challengesView.challengeCard.statusCompleted', value: 'å·²å®Œæˆ' },
// ...
```

### 4. é¡µé¢ç»„ä»¶æ›´æ–°

ç¡®ä¿é¡µé¢ç»„ä»¶æ­£ç¡®ä¼ é€’æ ‡ç­¾ç»™å­ç»„ä»¶ï¼š

```typescript
// ä¾‹å¦‚ï¼Œåœ¨ ChallengesPage ä¸­
<ChallengeCard 
  challenge={challenge}
  onClick={handleChallengeClick}
  onComplete={handleCompleteChallenge}
  labels={pageLabels?.challengeCard}
/>
```

## ä¿®å¤ä¼˜å…ˆçº§

æ ¹æ®ç”¨æˆ·ç•Œé¢çš„é‡è¦æ€§ï¼Œå»ºè®®æŒ‰ä»¥ä¸‹é¡ºåºä¼˜å…ˆå¤„ç†ï¼š

1. **æ ¸å¿ƒæ¸¸æˆç»„ä»¶**ï¼š
   - ChallengeCard.tsx
   - StoreItemCard.tsx
   - TaskCard.tsx

2. **ç”¨æˆ·äº¤äº’é¢‘ç¹çš„ç»„ä»¶**ï¼š
   - SubtaskList.tsx
   - MoodTracker.tsx
   - TaskManager.tsx

3. **å…¶ä»–æ”¯æŒç»„ä»¶**ï¼š
   - EnhancedReflectionModule.tsx
   - ChallengeDiscoveryCard.tsx
   - VipSubscriptionCard.tsx

## ä¿®å¤ç¤ºä¾‹

ä»¥ ChallengeCard.tsx ä¸ºä¾‹ï¼Œä¿®å¤æ–¹å¼å¦‚ä¸‹ï¼š

### ä¿®å¤å‰ï¼š

```typescript
// è·å–æŒ‘æˆ˜çŠ¶æ€å¯¹åº”çš„æ–‡æœ¬
const getStatusText = () => {
  switch (challenge.status) {
    case ChallengeStatus.ACTIVE:
      return 'è¿›è¡Œä¸­';
    case ChallengeStatus.COMPLETED:
      return 'å·²å®Œæˆ';
    case ChallengeStatus.EXPIRED:
      return 'å·²è¿‡æœŸ';
    case ChallengeStatus.UPCOMING:
      return 'å³å°†å¼€å§‹';
    default:
      return '';
  }
};

// JSX ä¸­
<span>å¼€å§‹: {formatTime(challenge.startDate, false)}</span>
{challenge.endDate && (
  <span>ç»“æŸ: {formatTime(challenge.endDate, false)}</span>
)}

// æŒ‰é’®æ–‡æœ¬
{challenge.progress >= 100 ? 'å®ŒæˆæŒ‘æˆ˜' : 'è¿›è¡Œä¸­...'}
```

### ä¿®å¤åï¼š

```typescript
// æ·»åŠ  labels å‚æ•°åˆ°æ¥å£
interface ChallengeCardProps {
  challenge: ChallengeRecord;
  onClick?: (challenge: ChallengeRecord) => void;
  onComplete?: (challengeId: number) => void;
  labels?: {
    statusActive?: string;
    statusCompleted?: string;
    statusExpired?: string;
    statusUpcoming?: string;
    startLabel?: string;
    endLabel?: string;
    completedOnLabel?: string;
    completeButtonText?: string;
    inProgressText?: string;
  };
}

// è·å–æŒ‘æˆ˜çŠ¶æ€å¯¹åº”çš„æ–‡æœ¬
const getStatusText = () => {
  switch (challenge.status) {
    case ChallengeStatus.ACTIVE:
      return labels?.statusActive || 'Active';
    case ChallengeStatus.COMPLETED:
      return labels?.statusCompleted || 'Completed';
    case ChallengeStatus.EXPIRED:
      return labels?.statusExpired || 'Expired';
    case ChallengeStatus.UPCOMING:
      return labels?.statusUpcoming || 'Upcoming';
    default:
      return '';
  }
};

// JSX ä¸­
<span>{labels?.startLabel || 'Start'}: {formatTime(challenge.startDate, false)}</span>
{challenge.endDate && (
  <span>{labels?.endLabel || 'End'}: {formatTime(challenge.endDate, false)}</span>
)}

// æŒ‰é’®æ–‡æœ¬
{challenge.progress >= 100 ? (labels?.completeButtonText || 'Complete Challenge') : (labels?.inProgressText || 'In Progress...')}
```

## æµ‹è¯•è®¡åˆ’

1. **ç»„ä»¶çº§æµ‹è¯•**ï¼š
   - ä¸ºæ¯ä¸ªä¿®å¤çš„ç»„ä»¶ç¼–å†™å•å…ƒæµ‹è¯•ï¼Œç¡®ä¿å®ƒä»¬æ­£ç¡®ä½¿ç”¨æ ‡ç­¾
   - æµ‹è¯•ä¸åŒè¯­è¨€è®¾ç½®ä¸‹çš„ç»„ä»¶æ¸²æŸ“

2. **é›†æˆæµ‹è¯•**ï¼š
   - æµ‹è¯•é¡µé¢ç»„ä»¶æ˜¯å¦æ­£ç¡®ä¼ é€’æ ‡ç­¾ç»™å­ç»„ä»¶
   - æµ‹è¯•è¯­è¨€åˆ‡æ¢åŠŸèƒ½æ˜¯å¦æ­£ç¡®æ›´æ–°æ‰€æœ‰ç»„ä»¶çš„æ–‡æœ¬

3. **ç”¨æˆ·ç•Œé¢æµ‹è¯•**ï¼š
   - åœ¨ä¸åŒè¯­è¨€è®¾ç½®ä¸‹æ‰‹åŠ¨æµ‹è¯•åº”ç”¨
   - ç¡®ä¿æ‰€æœ‰æ–‡æœ¬éƒ½æ­£ç¡®æ˜¾ç¤ºä¸ºé€‰å®šçš„è¯­è¨€

## ç»“è®º

é€šè¿‡ç³»ç»Ÿæ€§åœ°ä¿®å¤å¤šè¯­è¨€æ”¯æŒé—®é¢˜ï¼ŒPandaHabit åº”ç”¨å°†èƒ½å¤Ÿä¸ºç”¨æˆ·æä¾›ä¸€è‡´çš„å¤šè¯­è¨€ä½“éªŒã€‚è¿™äº›ä¿®å¤ä¸ä»…æé«˜äº†åº”ç”¨çš„è´¨é‡ï¼Œè¿˜ä¸ºæœªæ¥æ·»åŠ æ›´å¤šè¯­è¨€æ”¯æŒå¥ å®šäº†åŸºç¡€ã€‚
</file>

<file path="screens.md">
å¥½çš„ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸åºå¤§çš„ä»»åŠ¡ï¼Œå› ä¸ºâ€œåŒ…å«æ‰€æœ‰é¡µé¢çš„å®Œæ•´ç•Œé¢è®¾è®¡â€å®é™…ä¸Šç›¸å½“äºä¸€ä¸ªå®Œæ•´çš„UI/UXè®¾è®¡äº¤ä»˜ç‰©ã€‚ç”±äºæ–‡æœ¬æ ¼å¼çš„é™åˆ¶ï¼Œæˆ‘æ— æ³•åƒFigmaé‚£æ ·æä¾›å¯äº¤äº’çš„åŸå‹æˆ–ç²¾ç¡®çš„åƒç´ çº§å¸ƒå±€ï¼Œä½†æˆ‘å¯ä»¥å°½åŠ›ç”¨**æ›´è¯¦ç»†çš„æ–‡æœ¬æè¿°å’Œç»“æ„åŒ–å¸ƒå±€**æ¥æç»˜PandaHabitçš„å…³é”®é¡µé¢ï¼Œå¹¶ä¸²è”èµ·ä¹‹å‰è®¨è®ºçš„æ‰€æœ‰åŠŸèƒ½å’Œä»˜è´¹å¼•å¯¼ç­–ç•¥ã€‚

**æ ¸å¿ƒåŸåˆ™ï¼š** ç•Œé¢è®¾è®¡å°†éµå¾ªâ€œç®€æ´ã€æ²»æ„ˆã€å¼•å¯¼æ€§å¼ºã€ç†ŠçŒ«å…ƒç´ çªå‡ºâ€çš„åŸåˆ™ã€‚é¢œè‰²ä»¥æŸ”å’Œçš„è‡ªç„¶è‰²ç³»ä¸ºä¸»ï¼ˆå¦‚ç«¹ç»¿è‰²ã€å¤©ç©ºè“ã€å¤§åœ°æ£•ï¼‰ï¼Œç‚¹ç¼€å°‘é‡æ˜äº®çš„å¼ºè°ƒè‰²ã€‚

---

**PandaHabit App - å®Œæ•´ç•Œé¢è®¾è®¡æè¿° (Conceptual)**

---

**å…¨å±€å…ƒç´  (Global Elements):**

*   **çŠ¶æ€æ  (Status Bar):** æ ‡å‡†çš„ç§»åŠ¨è®¾å¤‡çŠ¶æ€æ  (æ—¶é—´, Wi-Fi, ç”µé‡)ã€‚
*   **å¯¼èˆªæ  (Navigation Bar - è‹¥æœ‰é¡¶éƒ¨å¯¼èˆª):** é€šå¸¸åŒ…å«é¡µé¢æ ‡é¢˜ï¼Œè¿”å›æŒ‰é’® (è‹¥éä¸€çº§é¡µé¢)ã€‚
*   **åº•éƒ¨æ ‡ç­¾å¯¼èˆªæ  (Bottom Tab Bar - ä¸»è¦å¯¼èˆª):** å›ºå®šåœ¨å±å¹•åº•éƒ¨ï¼ŒåŒ…å«4-5ä¸ªæ ¸å¿ƒæ¨¡å—å…¥å£ã€‚
*   **ç†ŠçŒ«å½¢è±¡ (Panda Avatar):** åœ¨å¤šä¸ªç•Œé¢ä»¥ä¸åŒå½¢å¼å‡ºç°ï¼Œä½œä¸ºæƒ…æ„Ÿè¿æ¥å’Œå¼•å¯¼çš„æ ¸å¿ƒã€‚
*   **ç»Ÿä¸€çš„æŒ‰é’®é£æ ¼ï¼š** åœ†è§’ï¼Œæ¸…æ™°çš„æ–‡å­—æ ‡ç­¾ï¼Œæœ‰æ˜ç¡®çš„ç‚¹å‡»åé¦ˆã€‚
*   **ç»Ÿä¸€çš„å¡ç‰‡é£æ ¼ï¼š** åœ†è§’ï¼Œæœ‰è½»å¾®é˜´å½±ï¼Œå†…å®¹ç»„ç»‡æ¸…æ™°ã€‚
*   **ä¸€è‡´çš„å›¾æ ‡é£æ ¼ï¼š** ç®€æ´ã€è¡¨æ„æ˜ç¡®ï¼Œä¸æ•´ä½“é£æ ¼ç»Ÿä¸€ã€‚
*   **å­—ä½“ï¼š** é€‰æ‹©æ˜“è¯»ã€å‹å¥½çš„æ— è¡¬çº¿å­—ä½“ã€‚

---

**ä¸»è¦é¡µé¢è®¾è®¡æè¿°:**

**I. å¯åŠ¨ä¸è´¦æˆ· (Launch & Account)**

**1. é—ªå±é¡µ (Splash Screen)**
    *   **å¸ƒå±€ï¼š** å…¨å±ã€‚
    *   **å…ƒç´ ï¼š**
        *   PandaHabit Logo (åŠ¨æ€çš„ï¼Œå¦‚ç†ŠçŒ«çœ¨çœ¼æˆ–ç«¹å¶é£˜è½)ã€‚
        *   åº•éƒ¨æ˜¾ç¤ºç‰ˆæœ¬å·å’ŒåŠ è½½åŠ¨ç”» (å¯é€‰)ã€‚
    *   **äº¤äº’ï¼š** è‡ªåŠ¨è·³è½¬åˆ°ç™»å½•/æ³¨å†Œé¡µæˆ–ä¸»é¡µ (å¦‚æœå·²ç™»å½•)ã€‚

**2. æ¬¢è¿/å¼•å¯¼é¡µ (Welcome/Onboarding Screens - é¦–æ¬¡å¯åŠ¨)**
    *   **å¸ƒå±€ï¼š** é€šå¸¸3-5å±è½®æ’­ã€‚
    *   **å…ƒç´  (æ¯å±ä¸åŒä¸»é¢˜)ï¼š**
        *   **å±1 (æ¦‚å¿µå¼•å…¥):** å¤§å¹…æ²»æ„ˆç³»ç†ŠçŒ«æ’ç”»ã€‚â€œé‡è§ä½ çš„å¥åº·ç”Ÿæ´»ä¼´ä¾£ï¼ŒPandaHabitï¼â€ ç®€çŸ­ä»‹ç»Appæ ¸å¿ƒä»·å€¼ã€‚
        *   **å±2 (ä¹ æƒ¯å…»æˆ):** å›¾ç¤ºåŒ–çš„ä¹ æƒ¯å…»æˆè¿‡ç¨‹ã€‚â€œå’Œç†ŠçŒ«ä¸€èµ·ï¼Œè½»æ¾å…»æˆå¥½ä¹ æƒ¯ã€‚â€
        *   **å±3 (æƒ…æ„Ÿæ”¯æŒ):** ç†ŠçŒ«ä¸ç”¨æˆ·äº’åŠ¨çš„æ¸©é¦¨åœºæ™¯ã€‚â€œç†ŠçŒ«æ—¶åˆ»å…³å¿ƒä½ ï¼Œç»™äºˆæ¸©æš–æ”¯æŒã€‚â€
        *   **å±4 (ä¸ªæ€§åŒ–):** å±•ç¤ºå¯çˆ±çš„ç†ŠçŒ«çš®è‚¤å’Œå®¶å›­è£…é¥°ã€‚â€œæ‰“é€ ä½ ç‹¬ä¸€æ— äºŒçš„ç†ŠçŒ«ä¼™ä¼´ã€‚â€ ( subtly hinting at customization through engagement/VIP)
        *   **å±5 (å‡†å¤‡å¼€å§‹/æƒé™è¯·æ±‚):** â€œå‡†å¤‡å¥½å¼€å§‹ä½ çš„PandaHabitä¹‹æ—…äº†å—ï¼Ÿâ€ è¯·æ±‚å¿…è¦çš„æƒé™ (å¦‚é€šçŸ¥)ã€‚
    *   **äº¤äº’ï¼š** å·¦å³æ»‘åŠ¨åˆ‡æ¢ï¼Œåº•éƒ¨æœ‰æŒ‡ç¤ºç‚¹å’Œâ€œè·³è¿‡â€/â€œä¸‹ä¸€æ­¥â€/â€œå¼€å§‹â€æŒ‰é’®ã€‚

**3. ç™»å½•/æ³¨å†Œé¡µ (Login/Register Page)**
    *   **å¸ƒå±€ï¼š** å±…ä¸­å¯¹é½ã€‚
    *   **å…ƒç´ ï¼š**
        *   PandaHabit Logoã€‚
        *   è¾“å…¥æ¡†ï¼šé‚®ç®±/æ‰‹æœºå·ã€å¯†ç ã€‚
        *   æŒ‰é’®ï¼šâ€œç™»å½•â€ã€â€œæ³¨å†Œâ€ã€‚
        *   ç¬¬ä¸‰æ–¹ç™»å½•é€‰é¡¹ (å¦‚Apple, Google, Facebook)ã€‚
        *   é“¾æ¥ï¼šâ€œå¿˜è®°å¯†ç ï¼Ÿâ€ã€â€œç”¨æˆ·åè®®â€ã€â€œéšç§æ”¿ç­–â€ã€‚
    *   **äº¤äº’ï¼š** æ ‡å‡†è¡¨å•è¾“å…¥å’Œæäº¤ã€‚

**4. ç†ŠçŒ«åˆå§‹è®¾ç½®é¡µ (Initial Panda Setup - é¦–æ¬¡æ³¨å†Œå)**
    *   **å¸ƒå±€ï¼š** å¼•å¯¼å¼æ­¥éª¤ã€‚
    *   **å…ƒç´ ï¼š**
        *   **æ­¥éª¤1 (å‘½å):** â€œç»™ä½ çš„ç†ŠçŒ«ä¼™ä¼´å–ä¸ªå¯çˆ±çš„åå­—å§ï¼â€ è¾“å…¥æ¡†ã€‚
        *   **æ­¥éª¤2 (åŸºç¡€å¤–è§‚é€‰æ‹© - å¯é€‰):** æä¾›å‡ ç§å…è´¹çš„åŸºç¡€ç†ŠçŒ«é¢œè‰²/å°é…é¥°ä¾›é€‰æ‹©ã€‚â€œé€‰æ‹©ç†ŠçŒ«çš„åˆå§‹æ¨¡æ ·ã€‚â€
        *   **æ­¥éª¤3 (ç¬¬ä¸€ä¸ªä¹ æƒ¯å¼•å¯¼):** â€œè®©æˆ‘ä»¬ä»ä¸€ä¸ªå°ä¹ æƒ¯å¼€å§‹ï¼Œæ¯”å¦‚â€˜æ¯å¤©å–ä¸€æ¯æ°´â€™ã€‚ç†ŠçŒ«ä¼šé™ªä½ ä¸€èµ·ï¼â€ é¢„è®¾å‡ ä¸ªç®€å•ä¹ æƒ¯é€‰é¡¹ï¼Œæˆ–å…è®¸è¾“å…¥ã€‚
    *   **äº¤äº’ï¼š** ç‚¹å‡»â€œä¸‹ä¸€æ­¥â€å®Œæˆè®¾ç½®ã€‚

---

**II. æ ¸å¿ƒä½“éªŒä¸äº’åŠ¨ (Core Experience & Interaction)**

**5. ä¸»é¡µ/å®¶å›­ (Home Page / Panda's Home)**
    *   **å¸ƒå±€ï¼š**
        *   **é¡¶éƒ¨çŠ¶æ€æ ï¼š**
            *   å·¦ï¼šç”¨æˆ·å¤´åƒ (ç‚¹å‡»è¿›å…¥ä¸ªäººèµ„æ–™)ã€æ˜µç§°ã€**[VIPæ ‡è¯†]** (è‹¥æœ‰)ã€‚
            *   ä¸­ï¼š**[ç†ŠçŒ«å½“å‰å¿ƒæƒ…çŠ¶æ€]** (å¦‚å¼€å¿ƒã€å¹³é™ã€æœ‰ç‚¹é¥¿)ã€‚
            *   å³ï¼š**[é‡‘å¸]** æ•°é‡ã€**[é’»çŸ³]** æ•°é‡ (è‹¥æœ‰)ã€**[å¹¸è¿ç‚¹æ•°]** æ•°é‡ (â­)ã€‚
        *   **ä¸»è§†è§‰åŒº (å æ®å¤§éƒ¨åˆ†å±å¹•)ï¼š**
            *   **[åŠ¨æ€ç†ŠçŒ«]** åœ¨å…¶â€œå®¶å›­â€åœºæ™¯ä¸­æ´»åŠ¨ (å¦‚ç©è€ã€ä¼‘æ¯ã€æœŸå¾…äº’åŠ¨)ã€‚ç†ŠçŒ«å¤–è§‚æ ¹æ®ç”¨æˆ·è‡ªå®šä¹‰å’Œæˆé•¿é˜¶æ®µå˜åŒ–ã€‚
            *   **[å‡†æ—¶è¿›åº¦æ¡ (Timeliness Bar)]** æ¸…æ™°å¯è§ï¼Œæ˜¾ç¤ºå½“å‰è¿›åº¦å’Œæœ€ç»ˆå¤§å¥–å›¾æ ‡ã€‚
        *   **å¿«æ·äº’åŠ¨æŒ‰é’® (å›´ç»•ç†ŠçŒ«æˆ–åœ¨å›ºå®šåŒºåŸŸ)ï¼š**
            *   **â€œå–‚é£Ÿâ€** (ç«¹å­/æ°´/è‚‰å›¾æ ‡ï¼Œæ ¹æ®ç†ŠçŒ«éœ€æ±‚é«˜äº®)ã€‚
            *   **â€œäº’åŠ¨/ç©è€â€** (å¦‚å°çƒå›¾æ ‡ï¼Œç‚¹å‡»è§¦å‘ä¸ç†ŠçŒ«çš„ç®€å•äº’åŠ¨åŠ¨ç”»æˆ–å°æ¸¸æˆ)ã€‚
            *   **â€œå¿ƒæƒ…æ‰“å¡â€** (è¡¨æƒ…å›¾æ ‡ï¼Œæ¯æ—¥ä¸€æ¬¡)ã€‚
        *   **æ ¸å¿ƒä»»åŠ¡å¼•å¯¼åŒº (åº•éƒ¨æˆ–ä¾§è¾¹æ )ï¼š**
            *   æ˜¾ç¤º1-2ä¸ªå½“å‰æœ€é‡è¦çš„**[ä¸»çº¿ä»»åŠ¡]** æˆ– **[å³å°†åˆ°æœŸçš„æŒ‘æˆ˜å­ä»»åŠ¡]**ï¼ŒåŒ…å«ä»»åŠ¡æè¿°ã€è¿›åº¦ã€å¥–åŠ±é¢„è§ˆã€**[å‡†æ—¶å¥–åŠ±æ ‡è¯†â°]**ã€‚ç‚¹å‡»å¯è·³è½¬åˆ°ä»»åŠ¡è¯¦æƒ…æˆ–ä»»åŠ¡åˆ—è¡¨ã€‚
        *   **åº•éƒ¨æ ‡ç­¾å¯¼èˆªæ  (Fixed Bottom Tab Bar)ï¼š**
            *   **â€œå®¶å›­â€** (å½“å‰é¡µï¼Œé«˜äº®)ã€‚
            *   **â€œä»»åŠ¡â€** (è·³è½¬åˆ°ä»»åŠ¡åˆ—è¡¨é¡µ)ã€‚
            *   **â€œæˆé•¿/æ—…ç¨‹â€** (è·³è½¬åˆ°ç†ŠçŒ«æˆé•¿/é‡Œç¨‹ç¢‘é¡µ)ã€‚
            *   **â€œæŠ½å¥–/å¥–åŠ±â€** (è·³è½¬åˆ°å¹¸è¿æŠ½å¥–/å¥–åŠ±ä¸­å¿ƒé¡µ)ã€‚
            *   **â€œå•†åº—â€** (è·³è½¬åˆ°å•†åº—é¡µ)ã€‚
    *   **äº¤äº’ï¼š**
        *   ç‚¹å‡»ç†ŠçŒ«è§¦å‘ç®€å•åŠ¨ç”»/é—®å€™ã€‚
        *   ç‚¹å‡»äº’åŠ¨æŒ‰é’®æ‰§è¡Œç›¸åº”æ“ä½œã€‚
        *   ç‚¹å‡»ä»»åŠ¡å¼•å¯¼åŒºè·³è½¬ã€‚
        *   å¯å·¦å³æ»‘åŠ¨åˆ‡æ¢å®¶å›­åœºæ™¯ (è‹¥æœ‰å¤šä¸ªåœºæ™¯)ã€‚
        *   **[VIPç‰¹æƒå…¥å£]**: å¯èƒ½åœ¨ç”¨æˆ·å¤´åƒæ—æˆ–è®¾ç½®èœå•ä¸­ï¼Œæœ‰é†’ç›®â€œVIPâ€æ ‡è¯†ã€‚

**6. ä»»åŠ¡åˆ—è¡¨é¡µ (Task List Page)**
    *   **å¸ƒå±€ï¼š**
        *   **é¡¶éƒ¨ï¼š**
            *   æ—¥æœŸæ˜¾ç¤ºã€‚
            *   â€œä»Šæ—¥ä»»åŠ¡å®Œæˆè¿›åº¦â€ (å¦‚ â€œ3/5 å·²å®Œæˆâ€)ã€‚
            *   ç­›é€‰æŒ‰é’® (æŒ‰ç±»å‹ï¼šæ—¥å¸¸/ä¸»çº¿/æ”¯çº¿/æŒ‘æˆ˜ï¼›æŒ‰çŠ¶æ€ï¼šæœªå®Œæˆ/å·²å®Œæˆ)ã€‚
            *   **[â€œ+ æ·»åŠ ä»»åŠ¡â€æŒ‰é’® (VIPç”¨æˆ·å¯åˆ›å»ºæ›´å¤šè‡ªå®šä¹‰ä»»åŠ¡)]**
        *   **ä»»åŠ¡åˆ—è¡¨åŒº (å¯æ»šåŠ¨)ï¼š**
            *   æ¯ä¸ªä»»åŠ¡ä»¥**[å¡ç‰‡å½¢å¼]**å±•ç¤ºï¼š
                *   ä»»åŠ¡åç§° (å¦‚â€œå–æ°´3æ¬¡â€ã€â€œå®Œæˆ5åˆ†é’Ÿå†¥æƒ³â€)ã€‚
                *   ä»»åŠ¡å›¾æ ‡ (å¦‚æ°´æ»´ã€è²èŠ±)ã€‚
                *   **[ä»»åŠ¡æ¥æºæ ‡è¯†]** (å¦‚ä¸»çº¿ã€æ”¯çº¿ã€æŒ‘æˆ˜ğŸ”¥ã€è‡ªå®šä¹‰ğŸ‘¤)ã€‚
                *   å¥–åŠ±é¢„è§ˆ (å¦‚â€œ+10ç«¹å­ï¼Œ+5æ°´ï¼Œ+5å¹¸è¿ç‚¹æ•°â€)ã€‚
                *   **[å‡†æ—¶å¥–åŠ±æ ‡è¯†â°]** åŠ**[å®Œæˆæ—¶é—´çª—å£æç¤º]** (å¦‚â€œä»Šæ—¥23:59å‰â€)ã€‚
                *   è¿›åº¦æ¡ (è‹¥ä»»åŠ¡å¯åˆ†æ­¥å®Œæˆï¼Œå¦‚å–æ°´1/3æ¬¡)ã€‚
                *   **[å®Œæˆå¤é€‰æ¡†/æŒ‰é’®]**ã€‚
            *   å·²å®Œæˆä»»åŠ¡ç½®ç°æˆ–æ‰“å‹¾ï¼Œå¯æŠ˜å æˆ–ç§»è‡³åˆ—è¡¨åº•éƒ¨ã€‚
    *   **äº¤äº’ï¼š**
        *   ç‚¹å‡»å¤é€‰æ¡†/æŒ‰é’®æ ‡è®°ä»»åŠ¡å®Œæˆ -> è§¦å‘å¥–åŠ±åŠ¨ç”»å’ŒéŸ³æ•ˆï¼Œ**[å‡†æ—¶è¿›åº¦æ¡å’Œå¹¸è¿ç‚¹æ•°æ›´æ–°åŠ¨ç”»]**ã€‚
        *   ç‚¹å‡»ä»»åŠ¡å¡ç‰‡æœ¬èº« -> å¼¹å‡º**[ä»»åŠ¡è¯¦æƒ…å¼¹çª—]**ã€‚

**7. ä»»åŠ¡è¯¦æƒ…å¼¹çª— (Task Details Modal)**
    *   **å¸ƒå±€ï¼š** æ¨¡æ€å¼¹çª—ã€‚
    *   **å…ƒç´ ï¼š**
        *   ä»»åŠ¡åç§°ã€‚
        *   è¯¦ç»†æè¿°å’Œå®Œæˆæ ‡å‡†ã€‚
        *   æ‰€å±æŒ‘æˆ˜/ç›®æ ‡ (è‹¥æœ‰ï¼Œå¯ç‚¹å‡»è·³è½¬)ã€‚
        *   è¯¦ç»†å¥–åŠ±åˆ—è¡¨ (åŸºç¡€å¥–åŠ± + VIPé¢å¤–å¥–åŠ±é¢„è§ˆ)ã€‚
        *   å‡†æ—¶å¥–åŠ±è¯´æ˜ã€‚
        *   ç›¸å…³å¼•å¯¼ (å¦‚â€œè¿›è¡Œå†¥æƒ³â€æŒ‰é’®ç›´æ¥è·³è½¬åˆ°å†¥æƒ³åŠŸèƒ½)ã€‚
        *   ç¼–è¾‘/åˆ é™¤æŒ‰é’® (é’ˆå¯¹è‡ªå®šä¹‰ä»»åŠ¡)ã€‚
    *   **äº¤äº’ï¼š** å…³é—­å¼¹çª—ï¼Œæˆ–é€šè¿‡å¼•å¯¼æŒ‰é’®è·³è½¬ã€‚

**8. ç†ŠçŒ«æˆé•¿/æ—…ç¨‹é¡µ (Panda Growth/Journey Page)**
    *   **å¸ƒå±€ï¼š**
        *   **é¡¶éƒ¨æ ‡ç­¾é¡µï¼š** â€œæˆé•¿ä¹‹è·¯â€ã€â€œé‡Œç¨‹ç¢‘â€ã€â€œæˆå°±â€ã€‚
        *   **â€œæˆé•¿ä¹‹è·¯â€æ ‡ç­¾ä¸‹ï¼š**
            *   **[ç†ŠçŒ«å½“å‰ç­‰çº§å’Œç»éªŒæ¡]**ã€‚
            *   **[è¿›åŒ–æ ‘/æˆé•¿è·¯å¾„å›¾]**ï¼šæ¸…æ™°å±•ç¤ºç†ŠçŒ«çš„å„ä¸ªæˆé•¿é˜¶æ®µ (å¹¼å¹´->å°‘å¹´->æˆå¹´->å®Œç¾å½¢æ€)ï¼Œä»¥åŠæ¯ä¸ªé˜¶æ®µè§£é”çš„æ ¸å¿ƒèƒ½åŠ›/å¤–è§‚/è£…å¤‡ã€‚å·²è§£é”çš„é«˜äº®ï¼Œæœªè§£é”çš„ç½®ç°å¹¶æ˜¾ç¤ºè§£é”æ¡ä»¶ï¼ˆå¦‚ç­‰çº§ã€æ¶ˆè€—èµ„æºï¼‰ã€‚
            *   **[æŠ€èƒ½/èƒ½åŠ›åˆ—è¡¨]**ï¼šå±•ç¤ºç†ŠçŒ«å·²æŒæ¡å’Œå¯å­¦ä¹ çš„è¾…åŠ©æŠ€èƒ½ (å¦‚â€œç›®æ ‡æ‹†è§£åŠ©æ‰‹â€ã€â€œé«˜çº§å†¥æƒ³å¼•å¯¼è€…â€)ã€‚
        *   **â€œé‡Œç¨‹ç¢‘â€æ ‡ç­¾ä¸‹ï¼š**
            *   æŒ‰**[ç”¨æˆ·ç”Ÿå‘½å‘¨æœŸï¼ˆæ–°æ‰‹/æˆé•¿/æˆç†Ÿï¼‰]**æˆ–æ—¶é—´è½´å±•ç¤ºå·²è¾¾æˆå’Œå¾…è¾¾æˆçš„é‡Œç¨‹ç¢‘ã€‚
            *   æ¯ä¸ªé‡Œç¨‹ç¢‘æ˜¾ç¤ºåç§°ã€æè¿°ã€è¾¾æˆæ¡ä»¶ã€å¥–åŠ±é¢„è§ˆã€**[â€œé¢†å–å¥–åŠ±â€æŒ‰é’®ï¼ˆè‹¥å·²è¾¾æˆæœªé¢†å–ï¼‰]**ã€‚
        *   **â€œæˆå°±â€æ ‡ç­¾ä¸‹ï¼š**
            *   åˆ†ç±»å±•ç¤ºå„ç±»æˆå°± (å® ç‰©æˆé•¿ã€èµ„æºæ”¶é›†ã€ä»»åŠ¡å®Œæˆã€ç¤¾äº¤ç­‰)ã€‚
            *   æ¯ä¸ªæˆå°±æ˜¾ç¤ºåç§°ã€æè¿°ã€è¾¾æˆæ¡ä»¶ã€è¿›åº¦ã€å¥–åŠ±ã€**[â€œé¢†å–å¥–åŠ±â€æŒ‰é’®]**ã€‚
    *   **äº¤äº’ï¼š**
        *   ç‚¹å‡»æœªè§£é”çš„æˆé•¿èŠ‚ç‚¹/æŠ€èƒ½ -> æ˜¾ç¤ºè¯¦ç»†è§£é”æ¡ä»¶å’Œæ•ˆæœã€‚
        *   ç‚¹å‡»å·²è¾¾æˆçš„é‡Œç¨‹ç¢‘/æˆå°± -> é¢†å–å¥–åŠ±ï¼Œè§¦å‘åº†ç¥åŠ¨ç”»ã€‚

**9. å¹¸è¿æŠ½å¥–/å¥–åŠ±ä¸­å¿ƒé¡µ (Lucky Draw/Rewards Center Page)**
    *   **å¸ƒå±€ï¼š**
        *   **é¡¶éƒ¨æ ‡ç­¾é¡µï¼š** â€œå¹¸è¿æŠ½å¥–â€ã€â€œå¥–åŠ±å†å²/èƒŒåŒ…â€ã€‚
        *   **â€œå¹¸è¿æŠ½å¥–â€æ ‡ç­¾ä¸‹ï¼š**
            *   **[é†’ç›®çš„æŠ½å¥–ä¸»è§†è§‰]** (å¦‚æ—‹è½¬çš„ç«¹ç­’ã€é—ªè€€çš„å®ç®±)ã€‚
            *   **[å½“å‰å¹¸è¿ç‚¹æ•°ä½™é¢ â­]**ã€‚
            *   **[â€œæŠ½1æ¬¡â€æŒ‰é’® (æ¶ˆè€—XXXå¹¸è¿ç‚¹æ•°)]**ã€‚
            *   **[â€œæŠ½10æ¬¡â€æŒ‰é’® (é€šå¸¸æœ‰ä¼˜æƒ ï¼Œæ¶ˆè€—YYYå¹¸è¿ç‚¹æ•°)]**ã€‚
            *   **[å¥–æ± é¢„è§ˆåŒº]**ï¼šæ»šåŠ¨å±•ç¤ºæˆ–ä»¥å›¾æ ‡å½¢å¼å±•ç¤ºå¥–æ± ä¸­çš„éƒ¨åˆ†ç¨€æœ‰å¥–åŠ±ï¼Œå¸å¼•ç”¨æˆ·ã€‚å¯ç‚¹å‡»æŸ¥çœ‹å®Œæ•´å¥–æ± åŠæ¦‚ç‡ (å¯é€‰)ã€‚
            *   **[VIPæ¯æ—¥å…è´¹æŠ½å¥–æ¬¡æ•°æç¤º/å…¥å£]** (è‹¥æœ‰)ã€‚
        *   **â€œå¥–åŠ±å†å²/èƒŒåŒ…â€æ ‡ç­¾ä¸‹ï¼š**
            *   åˆ—è¡¨å½¢å¼å±•ç¤ºç”¨æˆ·è¿‘æœŸè·å¾—çš„å„ç±»å¥–åŠ± (ä»»åŠ¡ã€æŠ½å¥–ã€æˆå°±ã€é‡Œç¨‹ç¢‘ç­‰)ã€‚
            *   å¯æŒ‰ç±»å‹ç­›é€‰ (å¦‚çš®è‚¤ã€é“å…·ã€èµ„æº)ã€‚
    *   **äº¤äº’ï¼š**
        *   ç‚¹å‡»æŠ½å¥–æŒ‰é’® -> è§¦å‘æŠ½å¥–åŠ¨ç”» -> å±•ç¤ºè·å¾—å¥–åŠ±å¼¹çª—ã€‚
        *   æµè§ˆå¥–åŠ±å†å²ï¼Œç‚¹å‡»ç‰¹å®šå¥–åŠ±å¯æŸ¥çœ‹è¯¦æƒ… (å¦‚çš®è‚¤é¢„è§ˆ)ã€‚

**10. å•†åº—é¡µ (Shop Page)**
    *   **å¸ƒå±€ï¼š**
        *   **é¡¶éƒ¨ï¼š**
            *   **[æœç´¢æ¡†]**ã€‚
            *   **[å¯æ¨ªå‘æ»‘åŠ¨çš„åˆ†ç±»æ ‡ç­¾]** (å¦‚â€œç†ŠçŒ«å¤–è§‚â€ã€â€œå®¶å›­è£…é¥°â€ã€â€œå®ç”¨é“å…·â€ã€â€œVIPç‰¹æƒ â€ã€â€œèµ„æºè¡¥å……â€)ã€‚
        *   **å•†å“å±•ç¤ºåŒº (ç½‘æ ¼æˆ–åˆ—è¡¨)ï¼š**
            *   æ¯ä¸ªå•†å“ä»¥**[å¡ç‰‡å½¢å¼]**å±•ç¤ºï¼šå•†å“å›¾ç‰‡ã€åç§°ã€ä»·æ ¼ (é‡‘å¸/é’»çŸ³/çœŸå®è´§å¸)ã€**[â€œè´­ä¹°â€æŒ‰é’®]**ã€‚
            *   **[VIPä¸“å±å•†å“]** å¸¦æœ‰ç‰¹æ®Šè§’æ ‡ã€‚
            *   **[é™æ—¶æŠ˜æ‰£å•†å“]** å¸¦æœ‰å€’è®¡æ—¶å’ŒæŠ˜æ‰£æ ‡è¯†ã€‚
        *   **é†’ç›®çš„VIPè®¢é˜…å…¥å£/å¹¿å‘ŠBannerï¼š** (è§ä¸‹ä¸€èŠ‚ä»˜è´¹å¼•å¯¼ç•Œé¢)
    *   **äº¤äº’ï¼š**
        *   ç‚¹å‡»åˆ†ç±»æ ‡ç­¾ç­›é€‰å•†å“ã€‚
        *   ç‚¹å‡»å•†å“å¡ç‰‡ -> è¿›å…¥**[å•†å“è¯¦æƒ…é¡µ]**ã€‚
        *   ç‚¹å‡»è´­ä¹°æŒ‰é’® -> è§¦å‘è´­ä¹°æµç¨‹ (ç¡®è®¤å¼¹çª— -> æ”¯ä»˜æ¥å£)ã€‚

**11. å•†å“è¯¦æƒ…é¡µ (Item Details Page)**
    *   **å¸ƒå±€ï¼š**
        *   **[å¤§å¹…å•†å“å›¾ç‰‡/3Dé¢„è§ˆ (å¦‚ç†ŠçŒ«çš®è‚¤å¯æ—‹è½¬æŸ¥çœ‹)]**ã€‚
        *   å•†å“åç§°ã€è¯¦ç»†æè¿°ã€å±æ€§/æ•ˆæœè¯´æ˜ã€‚
        *   ä»·æ ¼ã€‚
        *   **[â€œè¯•ç©¿/é¢„è§ˆâ€æŒ‰é’® (é’ˆå¯¹å¤–è§‚ç±»å•†å“)]** -> åœ¨ç†ŠçŒ«æ¨¡å‹ä¸Šå±•ç¤ºæ•ˆæœã€‚
        *   **[â€œè´­ä¹°â€æŒ‰é’®]**ã€‚
    *   **äº¤äº’ï¼š** è´­ä¹°ï¼Œè¯•ç©¿ï¼Œè¿”å›å•†åº—ã€‚

**12. ç†ŠçŒ«äº’åŠ¨/è¯¦æƒ…é¡µ (Pet Interaction/Details Page - å¯ä»å®¶å›­ç‚¹å‡»ç†ŠçŒ«è¿›å…¥æˆ–ç‹¬ç«‹å…¥å£)**
    *   **å¸ƒå±€ï¼š**
        *   **é¡¶éƒ¨ï¼š** ç†ŠçŒ«åç§°ã€ç­‰çº§ã€å¿ƒæƒ…ã€ä½“åŠ›/å¥åº·å€¼æ¡ã€‚
        *   **ä¸»è§†è§‰ï¼š** æ›´å¤§çš„å¯äº’åŠ¨ç†ŠçŒ«æ¨¡å‹ã€‚
        *   **äº’åŠ¨æŒ‰é’®åŒºï¼š** â€œå–‚é£Ÿâ€ã€â€œæ¸…æ´â€ã€â€œç©è€â€ã€â€œè®­ç»ƒâ€ã€â€œå­¦ä¹ æŠ€èƒ½â€ã€‚
        *   **è£…å¤‡/å¤–è§‚åˆ‡æ¢åŒºï¼š** å±•ç¤ºå·²æ‹¥æœ‰çš„çš®è‚¤å’Œé¥°å“ï¼Œå¯è¿›è¡Œæ›´æ¢ã€‚
        *   **æŠ€èƒ½æ ‘/èƒ½åŠ›è¯¦æƒ…ï¼š** æŸ¥çœ‹å·²æŒæ¡å’Œå¯å­¦ä¹ çš„æŠ€èƒ½åŠå…¶æ•ˆæœã€‚
    *   **äº¤äº’ï¼š**
        *   ç‚¹å‡»äº’åŠ¨æŒ‰é’®è§¦å‘ç›¸åº”åŠ¨ç”»å’Œæ•ˆæœ (å¦‚å–‚é£Ÿæ¶ˆè€—èµ„æºï¼Œç†ŠçŒ«å¿ƒæƒ…å˜å¥½)ã€‚
        *   æ›´æ¢ç†ŠçŒ«å¤–è§‚ã€‚
        *   å‡çº§æŠ€èƒ½ (è‹¥æœ‰æ­¤æœºåˆ¶)ã€‚

**13. å¿ƒæƒ…æ‰“å¡/åæ€æ¨¡å— (Mood Check-in/Reflection Module - é€šå¸¸ä¸ºå¼¹çª—æˆ–å¼•å¯¼æµç¨‹)**
    *   **å¿ƒæƒ…æ‰“å¡ (æ¯æ—¥ä¸€æ¬¡ï¼Œå®¶å›­è§¦å‘)ï¼š**
        *   **ç•Œé¢ï¼š** ç®€æ´çš„è¡¨æƒ…é€‰æ‹© (å¦‚5ä¸ªä»éš¾è¿‡åˆ°å¼€å¿ƒçš„ç†ŠçŒ«è¡¨æƒ…) æˆ–æ»‘å—ã€‚
        *   **äº¤äº’ï¼š** ç”¨æˆ·é€‰æ‹©åï¼Œç†ŠçŒ«ç»™å‡ºå¯¹åº”åé¦ˆ (å¦‚ç”¨æˆ·é€‰å¼€å¿ƒï¼Œç†ŠçŒ«ä¹Ÿå¼€å¿ƒï¼›ç”¨æˆ·é€‰éš¾è¿‡ï¼Œç†ŠçŒ«è¡¨ç¤ºå…³å¿ƒå¹¶å¯èƒ½**[å¼•å¯¼è‡³åæ€æ¨¡å—]**)ã€‚
    *   **åæ€æ¨¡å— (å½“ç”¨æˆ·æŒ£æ‰æˆ–é€‰æ‹©æ·±å…¥åæ€æ—¶è§¦å‘)ï¼š**
        *   **ç•Œé¢ï¼š** å¯¹è¯å¼ç•Œé¢ï¼Œç†ŠçŒ«å¤´åƒå’Œå¯¹è¯æ°”æ³¡ã€‚å¹³é™çš„èƒŒæ™¯ã€‚
        *   **å…ƒç´ ï¼š**
            *   ç†ŠçŒ«æå‡ºçš„å¼•å¯¼æ€§é—®é¢˜ (æ–‡æœ¬)ã€‚
            *   ç”¨æˆ·å›å¤é€‰é¡¹ (æŒ‰é’®å¼é€‰æ‹©) æˆ–ç®€çŸ­æ–‡æœ¬è¾“å…¥æ¡†ã€‚
            *   ç†ŠçŒ«çš„å…±æƒ…å›åº”å’Œç§¯æå»ºè®® (æ–‡æœ¬)ã€‚
        *   **äº¤äº’ï¼š** ç‚¹å‡»é€‰é¡¹æˆ–è¾“å…¥æ–‡å­—ï¼Œé€æ­¥æ¨è¿›å¯¹è¯ã€‚

**14. ä¸ªäººèµ„æ–™/è®¾ç½®é¡µ (Profile/Settings Page)**
    *   **å¸ƒå±€ï¼š** åˆ—è¡¨å¼ã€‚
    *   **å…ƒç´ ï¼š**
        *   ç”¨æˆ·å¤´åƒã€æ˜µç§°ã€IDã€**[VIPçŠ¶æ€åŠåˆ°æœŸæ—¥]**ã€‚
        *   æ•°æ®ç»Ÿè®¡ (ç´¯è®¡å®Œæˆä»»åŠ¡æ•°ã€ç†ŠçŒ«æœ€é«˜ç­‰çº§ã€æˆå°±ç‚¹æ•°ç­‰)ã€‚
        *   è´¦æˆ·ç®¡ç† (ä¿®æ”¹å¯†ç ã€ç»‘å®šé‚®ç®±/æ‰‹æœº)ã€‚
        *   é€šçŸ¥è®¾ç½®ã€‚
        *   éŸ³æ•ˆ/éŸ³ä¹å¼€å…³ã€‚
        *   å¸®åŠ©ä¸åé¦ˆ/FAQã€‚
        *   è”ç³»å®¢æœã€‚
        *   éšç§æ”¿ç­–ã€ç”¨æˆ·åè®®ã€‚
        *   â€œç™»å‡ºâ€æŒ‰é’®ã€‚
        *   **[â€œç®¡ç†VIPè®¢é˜…â€å…¥å£]** (è·³è½¬è‡³VIPæ€»è§ˆæˆ–App Storeè®¢é˜…ç®¡ç†)ã€‚
    *   **äº¤äº’ï¼š** ç‚¹å‡»å„æ¡ç›®è¿›å…¥ç›¸åº”è®¾ç½®æˆ–ä¿¡æ¯å±•ç¤ºã€‚

---

**III. VIPä»˜è´¹å¼•å¯¼ä¸ç®¡ç†ç•Œé¢ (VIP Onboarding & Management)**

**15. VIPç‰¹æƒæ€»è§ˆé¡µ (VIP Benefits Overview Page - ç•Œé¢A1å˜ç§/æ‰©å±•)**
    *   **è§¦å‘ç‚¹ï¼š** ç‚¹å‡»â€œVIPâ€å…¥å£ã€å•†åº—å†…VIPå¹¿å‘Šã€ç‰¹å®šåŠŸèƒ½å¼•å¯¼ã€‚
    *   **å¸ƒå±€ï¼š** ç²¾ç¾è®¾è®¡çš„å…¨å±é¡µé¢ã€‚
        *   **é¡¶éƒ¨ï¼š** â€œæˆä¸ºç†ŠçŒ«å®ˆæŠ¤è€…ï¼Œå°Šäº«éå‡¡ä½“éªŒï¼â€ æˆ–ç±»ä¼¼å¸å¼•æ€§æ ‡é¢˜ï¼Œé…åˆVIPä¸“å±è§†è§‰å…ƒç´ ã€‚
        *   **æ ¸å¿ƒä»·å€¼å±•ç¤ºåŒº (å¡ç‰‡å¼/è½®æ’­å¼)ï¼š**
            *   **å¡ç‰‡1 (åŠ é€Ÿæˆé•¿):** å›¾æ–‡å¹¶èŒ‚å±•ç¤ºç»éªŒåŠ æˆã€èµ„æºè·å–åŠ æˆã€ç†ŠçŒ«æˆé•¿é€Ÿåº¦å¯¹æ¯”ã€‚
            *   **å¡ç‰‡2 (ä¸“å±ç‰¹æƒ):** å±•ç¤ºå¯è§£é”çš„ä¸“å±ç†ŠçŒ«å¤–è§‚ã€å®¶å›­è£…é¥°ã€é«˜çº§è¯¾ç¨‹ã€è‡ªå®šä¹‰ç›®æ ‡åŠŸèƒ½ã€‚
            *   **å¡ç‰‡3 (ä¸°åšç¦åˆ©):** å±•ç¤ºæ¯æ—¥é¢å¤–å¹¸è¿æŠ½å¥–æ¬¡æ•°ã€VIPä¸“å±ç­¾åˆ°å¥–åŠ±ã€æœˆåº¦/å­£åº¦å¤§ç¤¼åŒ…ã€‚
            *   **å¡ç‰‡4 (èº«ä»½è±¡å¾):** å±•ç¤ºä¸“å±å¤´åƒæ¡†ã€ç§°å·ã€èŠå¤©æ°”æ³¡ã€‚
        *   **[ç”¨æˆ·è¯„ä»·/æ¨èè¯­ (å¯é€‰ï¼Œç¤¾äº¤è¯æ˜)]**ã€‚
        *   **è¡ŒåŠ¨æŒ‰é’®åŒº (åº•éƒ¨å›ºå®š)ï¼š** â€œæŸ¥çœ‹è®¢é˜…è®¡åˆ’â€ (å¼•å¯¼è‡³è®¢é˜…é€‰æ‹©é¡µ)ã€‚
    *   **äº¤äº’ï¼š** å·¦å³æ»‘åŠ¨æŸ¥çœ‹ä¸åŒä»·å€¼ç‚¹å¡ç‰‡ï¼Œç‚¹å‡»æŒ‰é’®è¿›å…¥ä¸‹ä¸€æ­¥ã€‚

**16. è®¢é˜…é€‰æ‹©é¡µ (Subscription Options Page - ç•Œé¢E1)**
    *   **å¸ƒå±€ï¼š** (å¦‚å‰è¿°) è‡³å°‘2-3æ¡£è®¢é˜…è®¡åˆ’ (æœˆ/å­£/å¹´) å¡ç‰‡å¼å¹¶åˆ—ã€‚
        *   æ¯æ¡£æ¸…æ™°åˆ—å‡ºä»·æ ¼ã€å¹³å‡æ¯æœˆèŠ±è´¹ã€æ ¸å¿ƒæƒç›Šå·®å¼‚ã€‚
        *   **[â€œæ¨èâ€/â€œæœ€å—æ¬¢è¿â€/â€œæœ€ä½³ä»·å€¼â€è§’æ ‡]** çªå‡ºå¼•å¯¼ã€‚
        *   é»˜è®¤é€‰ä¸­æ¨èæ¡£ä½ã€‚
        *   æ¸…æ™°çš„â€œç¡®è®¤è®¢é˜…å¹¶æ”¯ä»˜â€æŒ‰é’®ã€‚
        *   å°å­—é“¾æ¥ï¼šâ€œæ¢å¤è´­ä¹°â€ã€â€œè®¢é˜…æ¡æ¬¾â€ã€‚
    *   **äº¤äº’ï¼š** é€‰æ‹©ä¸åŒæ¡£ä½ï¼ŒæŸ¥çœ‹æƒç›Šå˜åŒ–ï¼Œç‚¹å‡»ç¡®è®¤æ”¯ä»˜ -> è°ƒç”¨å¹³å°æ”¯ä»˜æ¥å£ã€‚

**17. VIPé™æ—¶ä½“éªŒå¼•å¯¼å¼¹çª— (VIP Limited-Time Trial Offer - ç•Œé¢B1)**
    *   **å¸ƒå±€ï¼š** (å¦‚å‰è¿°) ç®€æ´æ˜äº†çš„å¼¹çª—ã€‚
        *   æ ‡é¢˜ã€æ ¸å¿ƒè¯•ç”¨ç‰¹æƒåˆ—è¡¨ã€å€’è®¡æ—¶ï¼ˆè‹¥é€‚ç”¨ï¼‰ã€â€œç«‹å³å…è´¹è¯•ç”¨â€æŒ‰é’®ã€‚
    *   **äº¤äº’ï¼š** ç‚¹å‡»è¯•ç”¨åï¼Œç›¸å…³VIPåŠŸèƒ½ä¸´æ—¶è§£é”ï¼Œä¸»ç•Œé¢æ˜¾ç¤ºä¸´æ—¶VIPæ ‡è¯†å’Œè¯•ç”¨åˆ°æœŸå€’è®¡æ—¶ã€‚

**18. è¯•ç”¨æœŸä»·å€¼å›é¡¾å¼¹çª— (Trial Value Summary - ç•Œé¢F2)**
    *   **å¸ƒå±€ï¼š** (å¦‚å‰è¿°) è¯•ç”¨åˆ°æœŸå‰å¼¹å‡ºã€‚
        *   æ•°æ®åŒ–å±•ç¤ºè¯•ç”¨æœŸé—´è·å¾—çš„é¢å¤–ä»·å€¼ã€‚
        *   â€œç«‹å³è®¢é˜…ä¿ç•™ç‰¹æƒâ€æŒ‰é’®ã€‚
    *   **äº¤äº’ï¼š** å¼•å¯¼ç”¨æˆ·ä»˜è´¹è½¬åŒ–ã€‚

**19. VIPè®¢é˜…åˆ°æœŸæé†’å¼¹çª— (VIP Expiry Reminder - ç•Œé¢B3)**
    *   **å¸ƒå±€ï¼š** (å¦‚å‰è¿°) åˆ°æœŸå‰å‡ å¤©å¼¹å‡ºã€‚
        *   è§†è§‰åŒ–å€’è®¡æ—¶ã€ä»·å€¼å›é¡¾ã€ç»­è®¢å¥½å¤„ã€ç»­è®¢æŒ‰é’®ã€‚
        *   éƒ¨åˆ†VIPç‰¹æƒå›¾æ ‡å¼€å§‹å˜ç°ã€‚
    *   **äº¤äº’ï¼š** å¼•å¯¼ç”¨æˆ·ç»­è®¢ã€‚

**20. è®¢é˜…æŒ½ç•™é¡µé¢/æµç¨‹ (Subscription Cancellation Retention Flow - ç•Œé¢F3)**
    *   **è§¦å‘ç‚¹ï¼š** ç”¨æˆ·å°è¯•åœ¨åº”ç”¨å†…ç®¡ç†è®¢é˜…å¹¶è¡¨è¾¾å–æ¶ˆæ„æ„¿æ—¶ (è‹¥å¹³å°å…è®¸æ­¤æµç¨‹)ã€‚
    *   **å¸ƒå±€ (å¤šæ­¥å¼¹çª—/é¡µé¢æµ)ï¼š**
        *   **æ­¥éª¤1 (ç¡®è®¤):** â€œçœŸçš„è¦ç¦»å¼€å—ï¼Ÿç†ŠçŒ«ä¼šæƒ³ä½ çš„ã€‚â€ [ç¡®è®¤å–æ¶ˆ] / [å†æƒ³æƒ³]ã€‚
        *   **æ­¥éª¤2 (ä¼˜æƒ /é™çº§):** â€œæˆ‘ä»¬ä¸ºæ‚¨å‡†å¤‡äº†ç‰¹åˆ«æŒ½ç•™ä¼˜æƒ ï¼š[7æŠ˜ç»­è®¢] æˆ– [ä¿ç•™æ ¸å¿ƒç‰¹æƒçš„åŸºç¡€ç‰ˆå®ˆæŠ¤è€…]ã€‚â€ [æ¥å—ä¼˜æƒ ] / [æŸ¥çœ‹åŸºç¡€ç‰ˆ] / [ä»ç„¶å–æ¶ˆ]ã€‚
        *   **æ­¥éª¤3 (ä¼‘çœ /åé¦ˆ):** â€œæ‚¨å¯ä»¥é€‰æ‹©[æš‚åœè®¢é˜…1ä¸ªæœˆï¼Œæƒç›Šä¿ç•™]ã€‚æˆ–å‘Šè¯‰æˆ‘ä»¬ç¦»å¼€çš„åŸå› ï¼Œå¸®åŠ©æˆ‘ä»¬æ”¹è¿›ã€‚â€ [æš‚åœè®¢é˜…] / [å¡«å†™é—®å·] / [ç›´æ¥å–æ¶ˆ]ã€‚
    *   **äº¤äº’ï¼š** æ ¹æ®ç”¨æˆ·é€‰æ‹©æ¨è¿›æµç¨‹ï¼Œå§‹ç»ˆæä¾›æ¸…æ™°çš„é€€å‡ºè·¯å¾„ã€‚

---

**IV. å…¶ä»–è¾…åŠ©é¡µé¢ (Other Supporting Pages)**

**21. é€šçŸ¥ä¸­å¿ƒ/æ¶ˆæ¯é¡µ (Notification Center/Messages Page)**
    *   **å¸ƒå±€ï¼š** åˆ—è¡¨å¼ã€‚
    *   **å…ƒç´ ï¼š**
        *   ç³»ç»Ÿé€šçŸ¥ (ç‰ˆæœ¬æ›´æ–°ã€æ´»åŠ¨é¢„å‘Šã€ç»´æŠ¤å…¬å‘Š)ã€‚
        *   ä»»åŠ¡/æŒ‘æˆ˜å®Œæˆæé†’ (è‹¥ç”¨æˆ·é”™è¿‡å³æ—¶å¼¹çª—)ã€‚
        *   ç†ŠçŒ«çš„ç‰¹æ®Šé—®å€™/å…³å¿ƒ (å¦‚â€œä»Šå¤©å¤©æ°”ä¸é”™ï¼Œè®°å¾—å‡ºé—¨èµ°èµ°å“¦ï¼â€)ã€‚
        *   å¥½å‹äº’åŠ¨æ¶ˆæ¯ (è‹¥æœ‰)ã€‚
    *   **äº¤äº’ï¼š** ç‚¹å‡»æ¶ˆæ¯æŸ¥çœ‹è¯¦æƒ…ï¼Œå¯æ ‡è®°å·²è¯»/åˆ é™¤ã€‚

**22. å¸®åŠ©ä¸åé¦ˆ/FAQé¡µ (Help & Feedback/FAQ Page)**
    *   **å¸ƒå±€ï¼š** å¯æœç´¢çš„FAQåˆ—è¡¨ï¼Œé—®é¢˜åˆ†ç±»ã€‚
    *   **å…ƒç´ ï¼š**
        *   å¸¸è§é—®é¢˜è§£ç­” (å¦‚ä½•å®Œæˆä»»åŠ¡ã€ç†ŠçŒ«å¦‚ä½•æˆé•¿ã€VIPæƒç›Šè¯´æ˜ç­‰)ã€‚
        *   â€œè”ç³»å®¢æœâ€å…¥å£ (è¡¨å•/é‚®ä»¶é“¾æ¥)ã€‚
        *   â€œæäº¤åé¦ˆ/å»ºè®®â€å…¥å£ã€‚
    *   **äº¤äº’ï¼š** æœç´¢å…³é”®è¯ï¼Œå±•å¼€/æŠ˜å é—®é¢˜ç­”æ¡ˆã€‚

---

**æ€»ç»“ä¸å¼ºè°ƒï¼š**

*   **æƒ…æ„ŸåŒ–è®¾è®¡ï¼š** ç†ŠçŒ«çš„è¡¨æƒ…ã€åŠ¨ä½œã€å¯¹è¯åº”è´¯ç©¿å§‹ç»ˆï¼Œä¼ é€’æ¸©æš–å’Œæ”¯æŒã€‚
*   **æ¸…æ™°çš„è§†è§‰å¼•å¯¼ï¼š** é€šè¿‡é¢œè‰²ã€å¤§å°ã€åŠ¨ç”»ç­‰æ‰‹æ®µçªå‡ºé‡ç‚¹ä¿¡æ¯å’Œå¯æ“ä½œå…ƒç´ ã€‚
*   **æµç•…çš„äº¤äº’ï¼š** å‡å°‘ä¸å¿…è¦çš„ç‚¹å‡»ï¼Œæä¾›å³æ—¶åé¦ˆã€‚
*   **ä»·å€¼é©±åŠ¨çš„ä»˜è´¹å¼•å¯¼ï¼š** æ‰€æœ‰ä»˜è´¹æç¤ºéƒ½åº”ä¸ç”¨æˆ·å½“ä¸‹åœºæ™¯çš„éœ€æ±‚æˆ–æ¸´æœ›ç›¸å…³è”ï¼Œæ¸…æ™°å±•ç¤ºVIPå¸¦æ¥çš„å®é™…å¥½å¤„ã€‚
*   **A/Bæµ‹è¯•ï¼š** ä¸Šè¿°ç•Œé¢ä¸­çš„æ–‡æ¡ˆã€æŒ‰é’®ã€å¸ƒå±€ã€è§¦å‘æ—¶æœºç­‰éƒ½åº”ä½œä¸ºA/Bæµ‹è¯•çš„å€™é€‰ï¼ŒæŒç»­ä¼˜åŒ–ã€‚

è¿™ä»½æè¿°å°½å¯èƒ½è¯¦ç»†åœ°å‹¾å‹’äº†PandaHabitçš„ç•Œé¢å®‡å®™ã€‚åœ¨å®é™…è®¾è®¡è¿‡ç¨‹ä¸­ï¼Œæ¯ä¸ªé¡µé¢è¿˜éœ€è¦ç»†åŒ–åˆ°å…·ä½“çš„ç»„ä»¶ã€é—´è·ã€å­—ä½“å¤§å°ã€é¢œè‰²ä»£ç ç­‰ï¼Œå¹¶åˆ¶ä½œå¯äº¤äº’åŸå‹è¿›è¡Œç”¨æˆ·æµ‹è¯•ã€‚
</file>

<file path="src/hooks/useComponentLabels.ts">
// src/hooks/useComponentLabels.ts
import { useLocalizedView } from './useLocalizedView';
import { fetchComponentsLabels } from '@/services/localizedContentService';
import type { ComponentsLabelsBundle } from '@/types';

/**
 * Hook to access localized labels for common UI components
 *
 * @returns An object containing component labels and loading/error states
 */
export function useComponentLabels() {
  const {
    labels: componentLabels,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<null, ComponentsLabelsBundle>(
    'componentsLabels',
    fetchComponentsLabels
  );

  // Default fallback labels for critical components
  const fallbackLabels: Partial<ComponentsLabelsBundle> = {
    button: {
      loading: 'Loading...',
      retry: 'Retry',
      confirm: 'Confirm',
      cancel: 'Cancel',
      save: 'Save',
      close: 'Close',
      submit: 'Submit',
      edit: 'Edit',
      delete: 'Delete',
      back: 'Back',
      next: 'Next'
    },
    loading: {
      generic: 'Loading...',
      data: 'Loading data...',
      content: 'Loading content...',
      saving: 'Saving...',
      processing: 'Processing...'
    },
    error: {
      generic: 'An error occurred',
      title: 'Error',
      retry: 'Try Again',
      details: 'Details: {message}',
      networkError: 'Network error',
      serverError: 'Server error',
      unknownError: 'Unknown error'
    },
    emptyState: {
      generic: 'No data available',
      noData: 'No data',
      noResults: 'No results found',
      noItems: 'No items'
    },
    modal: {
      close: 'Close',
      confirm: 'Confirm',
      cancel: 'Cancel'
    },
    taskReminder: {
      title: 'Panda Messenger',
      subtitle: 'Task Reminder',
      defaultMessage: 'You have a task to handle.',
      reminderTimeLabel: 'Reminder time:',
      dismissButton: 'Dismiss',
      laterButton: 'Later',
      viewTaskButton: 'View Task',
      unknownTask: 'Unknown Task'
    }
  } as ComponentsLabelsBundle;

  // Merge fetched labels with fallback labels, prioritizing fetched labels
  const mergedLabels = componentLabels
    ? {
        button: { ...fallbackLabels.button, ...componentLabels.button },
        loading: { ...fallbackLabels.loading, ...componentLabels.loading },
        error: { ...fallbackLabels.error, ...componentLabels.error },
        emptyState: { ...fallbackLabels.emptyState, ...componentLabels.emptyState },
        modal: { ...fallbackLabels.modal, ...componentLabels.modal },
        taskReminder: { ...fallbackLabels.taskReminder, ...componentLabels.taskReminder }
      }
    : fallbackLabels;

  return {
    labels: mergedLabels,
    isPending,
    isError,
    error,
    refetch
  };
}
</file>

<file path="src/scripts/addTimelyRewardCardLabels.js">
// src/scripts/addTimelyRewardCardLabels.js
// æ­¤è„šæœ¬ç”¨äºå‘æ•°æ®åº“æ·»åŠ TimelyRewardCardç»„ä»¶çš„æ ‡ç­¾

// å¯¼å…¥æ•°æ®åº“
const { db } = require('../db');

// å®šä¹‰è¦æ·»åŠ çš„æ ‡ç­¾
const timelyRewardCardLabels = [
  // ç±»å‹æ ‡ç­¾
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeLabel', languageCode: 'zh', translatedText: 'ç±»å‹' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeDaily', languageCode: 'en', translatedText: 'Daily Reward' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeDaily', languageCode: 'zh', translatedText: 'æ¯æ—¥å¥–åŠ±' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeMorning', languageCode: 'en', translatedText: 'Early Bird Reward' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeMorning', languageCode: 'zh', translatedText: 'æ—©èµ·é¸Ÿå¥–åŠ±' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeStreak', languageCode: 'en', translatedText: 'Streak Reward' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeStreak', languageCode: 'zh', translatedText: 'è¿ç»­å®Œæˆå¥–åŠ±' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeSpecial', languageCode: 'en', translatedText: 'Special Reward' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeSpecial', languageCode: 'zh', translatedText: 'ç‰¹æ®Šå¥–åŠ±' },
  
  // çŠ¶æ€æ ‡ç­¾
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusLabel', languageCode: 'en', translatedText: 'Status' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusLabel', languageCode: 'zh', translatedText: 'çŠ¶æ€' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusActive', languageCode: 'en', translatedText: 'Active' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusActive', languageCode: 'zh', translatedText: 'è¿›è¡Œä¸­' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusCompleted', languageCode: 'en', translatedText: 'Completed' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusCompleted', languageCode: 'zh', translatedText: 'å·²å®Œæˆ' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusExpired', languageCode: 'en', translatedText: 'Expired' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusExpired', languageCode: 'zh', translatedText: 'å·²è¿‡æœŸ' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusUpcoming', languageCode: 'en', translatedText: 'Upcoming' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusUpcoming', languageCode: 'zh', translatedText: 'å³å°†å¼€å§‹' },
  
  // å…¶ä»–æ ‡ç­¾
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'remainingTimeLabel', languageCode: 'en', translatedText: 'Remaining time' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'remainingTimeLabel', languageCode: 'zh', translatedText: 'å‰©ä½™æ—¶é—´' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'timeEnded', languageCode: 'en', translatedText: 'Ended' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'timeEnded', languageCode: 'zh', translatedText: 'å·²ç»“æŸ' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'hourUnit', languageCode: 'en', translatedText: 'h' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'hourUnit', languageCode: 'zh', translatedText: 'å°æ—¶' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'minuteUnit', languageCode: 'en', translatedText: 'm' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'minuteUnit', languageCode: 'zh', translatedText: 'åˆ†é’Ÿ' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'luckyPointsLabel', languageCode: 'en', translatedText: 'Lucky Points' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'luckyPointsLabel', languageCode: 'zh', translatedText: 'å¹¸è¿ç‚¹' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'claimRewardButton', languageCode: 'en', translatedText: 'Claim Reward' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'claimRewardButton', languageCode: 'zh', translatedText: 'é¢†å–å¥–åŠ±' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'inProgressButton', languageCode: 'en', translatedText: 'In Progress...' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'inProgressButton', languageCode: 'zh', translatedText: 'è¿›è¡Œä¸­...' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedOnLabel', languageCode: 'en', translatedText: 'Completed on' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedOnLabel', languageCode: 'zh', translatedText: 'å®Œæˆäº' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'progressLabel', languageCode: 'en', translatedText: 'Progress' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'progressLabel', languageCode: 'zh', translatedText: 'è¿›åº¦' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'startTimeLabel', languageCode: 'en', translatedText: 'Start Time' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'startTimeLabel', languageCode: 'zh', translatedText: 'å¼€å§‹æ—¶é—´' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'endTimeLabel', languageCode: 'en', translatedText: 'End Time' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'endTimeLabel', languageCode: 'zh', translatedText: 'ç»“æŸæ—¶é—´' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedTimeLabel', languageCode: 'en', translatedText: 'Completed Time' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedTimeLabel', languageCode: 'zh', translatedText: 'å®Œæˆæ—¶é—´' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'continueEffortButton', languageCode: 'en', translatedText: 'Keep Going' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'continueEffortButton', languageCode: 'zh', translatedText: 'ç»§ç»­åŠªåŠ›' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'noRewardsMessage', languageCode: 'en', translatedText: 'No timely rewards available' },
  { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'noRewardsMessage', languageCode: 'zh', translatedText: 'æš‚æ— åŠæ—¶å¥–åŠ±' },
];

// æ·»åŠ æ ‡ç­¾åˆ°æ•°æ®åº“
async function addTimelyRewardCardLabels() {
  try {
    console.log('Adding TimelyRewardCard labels to database...');
    
    // æ£€æŸ¥æ ‡ç­¾æ˜¯å¦å·²å­˜åœ¨
    for (const label of timelyRewardCardLabels) {
      const existingLabel = await db.uiLabels
        .where({
          scopeKey: label.scopeKey,
          labelKey: label.labelKey,
          languageCode: label.languageCode
        })
        .first();
      
      if (!existingLabel) {
        await db.uiLabels.add(label);
        console.log(`Added label: ${label.scopeKey}.${label.labelKey} (${label.languageCode})`);
      } else {
        console.log(`Label already exists: ${label.scopeKey}.${label.labelKey} (${label.languageCode})`);
      }
    }
    
    console.log('TimelyRewardCard labels added successfully.');
  } catch (error) {
    console.error('Error adding TimelyRewardCard labels:', error);
  }
}

// æ‰§è¡Œæ·»åŠ æ ‡ç­¾æ“ä½œ
addTimelyRewardCardLabels();
</file>

<file path="src/services/abilityService.ts">
// src/services/abilityService.ts
import { db } from '@/db';
import { 
  AbilityType, 
  PandaAbilityRecord, 
  initializePandaAbilities, 
  getAllPandaAbilities 
} from './pandaAbilityService';

/**
 * Unlock a specific ability by key
 * @param abilityKey The key of the ability to unlock (e.g., 'focus_boost')
 * @param abilityType The type of the ability (passive, active, ultimate)
 */
export async function unlockAbility(abilityKey: string, abilityType: AbilityType): Promise<PandaAbilityRecord | null> {
  try {
    // Ensure abilities are initialized
    await initializePandaAbilities();
    
    // Get all abilities
    const abilities = await getAllPandaAbilities();
    
    // Find the ability by key and type
    // Note: In a real implementation, we would have a more robust way to find abilities by key
    // For now, we'll use a simple name-based approach
    const abilityToUnlock = abilities.find(ability => {
      const nameLower = ability.name.toLowerCase();
      const keyParts = abilityKey.split('_');
      
      // Check if all parts of the key are in the name
      return keyParts.every(part => nameLower.includes(part)) && ability.type === abilityType;
    });
    
    if (!abilityToUnlock) {
      console.warn(`No ability found with key ${abilityKey} and type ${abilityType}`);
      return null;
    }
    
    // Unlock the ability
    const now = new Date();
    const updatedAbility = {
      ...abilityToUnlock,
      isUnlocked: true,
      unlockDate: now
    };
    
    await db.table('abilities').update(abilityToUnlock.id!, updatedAbility);
    return updatedAbility;
  } catch (error) {
    console.error(`Error unlocking ability ${abilityKey}:`, error);
    return null;
  }
}

/**
 * Get all unlocked abilities
 */
export async function getUnlockedAbilities(): Promise<PandaAbilityRecord[]> {
  try {
    // Ensure abilities are initialized
    await initializePandaAbilities();
    
    // Get all abilities and filter for unlocked ones
    const abilities = await getAllPandaAbilities();
    return abilities.filter(ability => ability.isUnlocked);
  } catch (error) {
    console.error('Error getting unlocked abilities:', error);
    return [];
  }
}

/**
 * Get abilities by type
 * @param type The type of abilities to get
 */
export async function getAbilitiesByType(type: AbilityType): Promise<PandaAbilityRecord[]> {
  try {
    // Ensure abilities are initialized
    await initializePandaAbilities();
    
    // Get all abilities and filter by type
    const abilities = await getAllPandaAbilities();
    return abilities.filter(ability => ability.type === type);
  } catch (error) {
    console.error(`Error getting abilities of type ${type}:`, error);
    return [];
  }
}

/**
 * Get ability by ID
 * @param id The ID of the ability to get
 */
export async function getAbilityById(id: number): Promise<PandaAbilityRecord | undefined> {
  try {
    return await db.table('abilities').get(id);
  } catch (error) {
    console.error(`Error getting ability with ID ${id}:`, error);
    return undefined;
  }
}
</file>

<file path="src/services/gameInitService.ts">
// src/services/gameInitService.ts
import { db } from '@/db';
import { generateTestChallengeData } from './challengeService';
import { initializeTimelyRewards, addLuckyPoints } from './timelyRewardService';
import { recordMood, MoodType } from './reflectionService';
import { createTask, TaskStatus, TaskPriority, TaskCategory, TaskType } from './taskService';
import { updatePandaState, PandaState } from './pandaStateService';
import { generateRewards, RewardRarity, RewardType } from './rewardService';
import { unlockAbility } from './abilityService';
import { AbilityType } from './pandaAbilityService';

/**
 * Initialize game data
 * Creates sample data for all game systems
 */
export async function initializeGameData(): Promise<void> {
  try {
    console.log('Starting game data initialization...');

    // Initialize challenges
    await generateTestChallengeData();

    // Initialize timely rewards
    await initializeTimelyRewards();

    // Add some lucky points
    await addLuckyPoints(50, 'Game initialization');

    // Record initial mood
    await recordMood({
      userId: 'current-user',
      mood: 'content',
      intensity: 3,
      note: 'Starting my productivity journey'
    });

    // Create some initial tasks
    await createInitialTasks();

    // Initialize panda state
    await updatePandaState({
      mood: 'content',
      energy: 80 as any, // Type assertion to handle number vs enum
      level: 1,
      experience: 0,
      name: 'Bamboo',
      outfit: 'default',
      accessories: []
    });

    // Generate some initial rewards
    await generateInitialRewards();

    // Unlock initial abilities
    await unlockInitialAbilities();

    console.log('Game data initialization completed successfully');
  } catch (error) {
    console.error('Error initializing game data:', error);
  }
}

/**
 * Create initial tasks
 */
async function createInitialTasks(): Promise<void> {
  const now = new Date();
  const tomorrow = new Date(now);
  tomorrow.setDate(tomorrow.getDate() + 1);

  const nextWeek = new Date(now);
  nextWeek.setDate(nextWeek.getDate() + 7);

  // Get category IDs
  const categories = await db.table('taskCategories').toArray();
  const getCategoryId = (name: string) => {
    const category = categories.find(c => c.name.toLowerCase() === name.toLowerCase());
    return category ? category.id : 1; // Default to first category if not found
  };

  const tasks = [
    {
      title: 'Set up daily routine',
      description: 'Create a structured daily routine to improve productivity',
      status: TaskStatus.TODO,
      priority: TaskPriority.HIGH,
      categoryId: getCategoryId('Personal'),
      type: TaskType.DAILY,
      dueDate: tomorrow,
      estimatedMinutes: 30,
      tags: ['planning', 'productivity']
    },
    {
      title: 'Complete project proposal',
      description: 'Finish the draft proposal for the new project',
      status: TaskStatus.TODO,
      priority: TaskPriority.MEDIUM,
      categoryId: getCategoryId('Work'),
      type: TaskType.MAIN,
      dueDate: nextWeek,
      estimatedMinutes: 120,
      tags: ['work', 'project']
    },
    {
      title: 'Morning meditation',
      description: 'Practice mindfulness meditation for 10 minutes',
      status: TaskStatus.COMPLETED,
      priority: TaskPriority.MEDIUM,
      categoryId: getCategoryId('Health'),
      type: TaskType.DAILY,
      completedAt: new Date(now.getTime() - 2 * 60 * 60 * 1000), // 2 hours ago
      estimatedMinutes: 10,
      tags: ['health', 'mindfulness']
    },
    {
      title: 'Weekly grocery shopping',
      description: 'Buy groceries for the week',
      status: TaskStatus.TODO,
      priority: TaskPriority.LOW,
      categoryId: getCategoryId('Errands'),
      type: TaskType.SIDE,
      dueDate: tomorrow,
      estimatedMinutes: 60,
      tags: ['shopping', 'food']
    }
  ];

  for (const task of tasks) {
    await createTask(task);
  }
}

/**
 * Generate initial rewards
 */
async function generateInitialRewards(): Promise<void> {
  // Generate some common rewards
  await generateRewards(2, RewardRarity.COMMON, RewardType.ITEM);

  // Generate an uncommon reward
  await generateRewards(1, RewardRarity.UNCOMMON, RewardType.CURRENCY);
}

/**
 * Unlock initial abilities
 */
async function unlockInitialAbilities(): Promise<void> {
  // Unlock basic abilities
  await unlockAbility('focus_boost', AbilityType.PASSIVE);
  await unlockAbility('quick_start', AbilityType.ACTIVE);
}
</file>

<file path="src/utils/localization.ts">
// src/utils/localization.ts
import { db } from '@/db';

/**
 * Get a localized label from the database
 * @param scopeKey The scope key of the label (e.g., 'abilities')
 * @param labelKey The label key (e.g., 'bambooHeart.name')
 * @param languageCode The language code (e.g., 'en', 'zh')
 * @returns The localized text or null if not found
 */
export async function getLocalizedLabel(
  scopeKey: string,
  labelKey: string,
  languageCode: string
): Promise<string | null> {
  try {
    // Check if the database is initialized
    if (!db.tables.some(table => table.name === 'uiLabels')) {
      console.warn('uiLabels table does not exist yet');
      return null;
    }

    // Query the database for the label
    const label = await db.table('uiLabels')
      .where('[scopeKey+labelKey+languageCode]')
      .equals([scopeKey, labelKey, languageCode])
      .first();

    return label ? label.translatedText : null;
  } catch (error) {
    console.error(`Error getting localized label for ${scopeKey}.${labelKey} in ${languageCode}:`, error);
    return null;
  }
}

/**
 * Get all localized labels for a specific scope and language
 * @param scopeKey The scope key of the labels (e.g., 'abilities')
 * @param languageCode The language code (e.g., 'en', 'zh')
 * @returns An object with label keys as properties and translated text as values
 */
export async function getLocalizedLabels(
  scopeKey: string,
  languageCode: string
): Promise<Record<string, string>> {
  try {
    // Check if the database is initialized
    if (!db.tables.some(table => table.name === 'uiLabels')) {
      console.warn('uiLabels table does not exist yet');
      return {};
    }

    // Query the database for all labels in the scope and language
    const labels = await db.table('uiLabels')
      .where('[scopeKey+languageCode]')
      .equals([scopeKey, languageCode])
      .toArray();

    // Convert to an object with label keys as properties
    const result: Record<string, string> = {};
    for (const label of labels) {
      result[label.labelKey] = label.translatedText;
    }

    return result;
  } catch (error) {
    console.error(`Error getting localized labels for ${scopeKey} in ${languageCode}:`, error);
    return {};
  }
}

/**
 * Get the current language code from localStorage
 * @returns The current language code (defaults to 'en')
 */
export function getCurrentLanguageCode(): string {
  return localStorage.getItem('language') || 'en';
}

/**
 * Set the current language code in localStorage
 * @param languageCode The language code to set
 */
export function setCurrentLanguageCode(languageCode: string): void {
  localStorage.setItem('language', languageCode);
}

/**
 * Format a date according to the current locale
 * @param date The date to format
 * @param options The Intl.DateTimeFormatOptions to use
 * @returns The formatted date string
 */
export function formatLocalizedDate(
  date: Date,
  options: Intl.DateTimeFormatOptions = { 
    year: 'numeric', 
    month: 'short', 
    day: 'numeric' 
  }
): string {
  const languageCode = getCurrentLanguageCode();
  return new Intl.DateTimeFormat(languageCode, options).format(date);
}

/**
 * Format a number according to the current locale
 * @param number The number to format
 * @param options The Intl.NumberFormatOptions to use
 * @returns The formatted number string
 */
export function formatLocalizedNumber(
  number: number,
  options: Intl.NumberFormatOptions = { 
    style: 'decimal'
  }
): string {
  const languageCode = getCurrentLanguageCode();
  return new Intl.NumberFormat(languageCode, options).format(number);
}
</file>

<file path="task.md">
# è®¾è®¡ä¸å®ç°å·®å¼‚è®°å½•

## 1. ç›®å½•ç»“æ„ä¸ç»„ä»¶åˆ†å¸ƒ
- è®¾è®¡æ–‡æ¡£å»ºè®®é‡‡ç”¨åŸå­è®¾è®¡æ³•ï¼ˆAtomsã€Moleculesã€Organismsï¼‰ï¼Œå®é™… `src/components` ä¸‹å·²åˆ†ä¸º commonã€animationã€decorationã€gameã€layoutã€pandaã€reflectionã€storeã€taskã€tasks ç­‰å­ç›®å½•ï¼ŒåŸºæœ¬è¦†ç›–è®¾è®¡è¦æ±‚ï¼Œä½†éƒ¨åˆ†å‘½åä¸åˆ†å±‚ç•¥æœ‰ä¸åŒã€‚
- æ²¡æœ‰å•ç‹¬çš„ `game` ç›®å½•ï¼Œæ¸¸æˆåŒ–ç›¸å…³å†…å®¹åˆ†å¸ƒåœ¨ `components/game`ã€`panda`ã€`store` ç­‰ï¼Œéœ€ç»Ÿä¸€æ–‡æ¡£ä¸å®ç°çš„æœ¯è¯­ã€‚

## 2. ä¸»è¦é¡µé¢å®ç°æƒ…å†µ
- è®¾è®¡æ–‡æ¡£è¦æ±‚çš„ä¸»è¦é¡µé¢ï¼ˆä¸»é¡µã€ä»»åŠ¡ã€æŒ‘æˆ˜ã€æˆé•¿/æ—…ç¨‹ã€å•†åº—ã€åæ€/èŒ¶å®¤ç­‰ï¼‰åœ¨ `src/pages` ä¸‹å‡æœ‰å¯¹åº”å®ç°ï¼ˆå¦‚ HomePageã€TasksPageã€ChallengesPageã€StorePageã€TeaRoomPage ç­‰ï¼‰ï¼ŒåŸºæœ¬è¦†ç›–ã€‚
- é¡µé¢å‘½åä¸è®¾è®¡æ–‡æ¡£ç•¥æœ‰å·®å¼‚ï¼Œå¦‚â€œæˆé•¿ä¹‹é“â€åœ¨ä»£ç ä¸­ä¸º JourneyPage æˆ–æœªæ˜ç¡®å‘½åã€‚

## 3. è§†è§‰é£æ ¼ä¸åŠ¨ç”»
- è®¾è®¡æ–‡æ¡£å¼ºè°ƒåä¸½ä¸­å›½é£ã€é‡‘è‰²ç‚¹ç¼€ã€æ¸å˜ã€ç²’å­åŠ¨ç”»ç­‰ï¼Œ`components/animation` ä¸‹æœ‰ä¸°å¯ŒåŠ¨ç”»ç»„ä»¶ï¼ˆå¦‚ GoldenGlowã€InkSplashã€RewardAnimationã€TaskCompletionAnimationï¼‰ï¼Œä½†éœ€è¿›ä¸€æ­¥æ ¸æŸ¥æ˜¯å¦æ‰€æœ‰é¡µé¢å’Œäº¤äº’å‡å·²åº”ç”¨ã€‚
- `components/decoration` æä¾›äº†ä¸­å›½é£è£…é¥°ç»„ä»¶ï¼ˆå¦‚ ChineseDecorationã€LanternDecorationï¼‰ï¼Œä½†å®é™…é¡µé¢è£…é¥°åº”ç”¨æƒ…å†µéœ€è¿›ä¸€æ­¥æ ¸æŸ¥ã€‚

## 4. UIåŸå­ç»„ä»¶
- è®¾è®¡æ–‡æ¡£è¦æ±‚æŒ‰é’®ã€è¾“å…¥æ¡†ã€è¿›åº¦æ¡ç­‰éœ€æœ‰ä¸­å›½é£è£…é¥°ã€é‡‘è‰²ç‚¹ç¼€ã€åŠ¨ç”»åé¦ˆï¼Œ`components/common` ä¸‹æœ‰ Buttonã€ProgressBarã€Modal ç­‰åŸºç¡€ç»„ä»¶ï¼Œä½†æœªè§è¾“å…¥æ¡†ï¼ˆInputï¼‰ç»„ä»¶ï¼Œéœ€è¡¥å……ã€‚
- æŒ‰é’®ã€è¿›åº¦æ¡ç­‰æ˜¯å¦å®Œå…¨ç¬¦åˆè®¾è®¡ç¨¿çš„è§†è§‰ç»†èŠ‚ï¼ˆå¦‚è½¯åœ†è§’ã€é‡‘è‰²æè¾¹ã€ç²’å­ç‰¹æ•ˆï¼‰éœ€è¿›ä¸€æ­¥å¯¹æ¯”ã€‚

## 5. æ¸¸æˆåŒ–ä¸è™šæ‹Ÿå® ç‰©
- è®¾è®¡æ–‡æ¡£å¯¹ç†ŠçŒ«æˆé•¿ã€æƒ…æ„ŸçŠ¶æ€ã€èµ„æºç³»ç»Ÿã€å¥–åŠ±ç³»ç»Ÿç­‰æœ‰è¯¦ç»†æè¿°ï¼Œ`components/game` ä¸‹æœ‰ PandaAvatarã€ResourceDisplayã€TimelyRewardCardã€LuckyDraw ç­‰ç»„ä»¶ï¼ŒåŸºæœ¬è¦†ç›–ã€‚
- ç†ŠçŒ«æˆé•¿é˜¶æ®µã€æƒ…æ„ŸçŠ¶æ€ã€å®šåˆ¶åŒ–ç­‰ç»†èŠ‚å®ç°æƒ…å†µéœ€è¿›ä¸€æ­¥æ ¸æŸ¥ï¼ˆå¦‚ PandaCustomizationPanelã€PandaEnvironmentPanel æ˜¯å¦å®Œæ•´å®ç°æ‰€æœ‰è®¾è®¡è¦æ±‚ï¼‰ã€‚

## 6. åæ€ä¸æ”¯æŒæ¨¡å—
- è®¾è®¡æ–‡æ¡£æœ‰â€œåæ€æ¨¡å—ï¼ˆé™å¿ƒèŒ¶å®¤ï¼‰â€ï¼Œ`pages/TeaRoomPage.tsx` åŠ `components/reflection` ä¸‹æœ‰ç›¸å…³å®ç°ï¼ˆEnhancedReflectionModuleã€MoodTracker ç­‰ï¼‰ï¼Œéœ€è¿›ä¸€æ­¥æ ¸æŸ¥äº¤äº’ä¸åŠ¨ç”»ç»†èŠ‚æ˜¯å¦è¾¾æ ‡ã€‚

## 7. å…¶ä»–å·®å¼‚ä¸å»ºè®®
- è®¾è®¡æ–‡æ¡£å¯¹å­—ä½“ã€è‰²å½©ã€åŠ¨ç”»ã€è£…é¥°ç­‰æœ‰è¯¦ç»†è¦æ±‚ï¼Œéœ€ç»“åˆå®é™… UI è¿›ä¸€æ­¥å¯¹æ¯”ï¼ˆå¦‚å­—ä½“æ˜¯å¦å·²å…¨å±€åº”ç”¨ï¼Œè‰²å½©æ–¹æ¡ˆæ˜¯å¦ä¸€è‡´ï¼‰ã€‚
- å»ºè®®åç»­æ¢³ç†æ¯ä¸ªé¡µé¢å’Œæ ¸å¿ƒç»„ä»¶çš„ UI ç»†èŠ‚ä¸äº¤äº’ï¼Œé€é¡¹å¯¹ç…§è®¾è®¡æ–‡æ¡£è¡¥é½å·®å¼‚ã€‚

---

> æœ¬æ–‡ä»¶ä¸ºåˆæ­¥å·®å¼‚æ¢³ç†ï¼Œå»ºè®®åç»­ç»“åˆå…·ä½“ UI æˆªå›¾å’Œä»£ç ç»†èŠ‚è¿›ä¸€æ­¥å®Œå–„ã€‚
</file>

<file path=".gitignore">
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage
/.nyc_output

# next.js
/.next/
/out/
/dist/

# production
/build

# misc
.DS_Store
*.pem
# .env
# .env.local
.env.development.local
.env.test.local
.env.production.local
# .env.mock

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
# .env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# IDE
.idea/
.vscode/
*.swp
*.swo

# Capacitor
/android/
/ios/
/capacitor/

# Database
/data/
*.db
*.sqlite
*.sqlite3

# Logs
/logs/
*.log

# Cache
.cache/
.temp/

# Build
/dist/
/build/
/out/

# Test
/coverage/
/.nyc_output/

# Misc
.DS_Store
Thumbs.db
*.bak
*.tmp
*.temp
</file>

<file path="app-design-brief.md">
# PandaHabit App Design Brief: åä¸½æ¸¸æˆé£æ ¼

## 1. Introduction

### 1.1 Overview
PandaHabitæ˜¯ä¸€æ¬¾ç§»åŠ¨åº”ç”¨ï¼Œé€šè¿‡å¼•äººå…¥èƒœä¸”æ”¯æŒæ€§çš„è™šæ‹Ÿå® ç‰©ä½“éªŒï¼Œå¸®åŠ©ç”¨æˆ·å»ºç«‹ç§¯æçš„ä¹ æƒ¯ï¼Œæ”¹å–„è‡ªæˆ‘æŠ¤ç†ï¼Œæå‡å¿ƒç†å¥åº·ã€‚ç”¨æˆ·é€šè¿‡å®Œæˆç°å®ç”Ÿæ´»ä¸­çš„ä»»åŠ¡å’Œä¹ æƒ¯æ¥åŸ¹å…»è™šæ‹Ÿç†ŠçŒ«ï¼Œåˆ›é€ ä¸€ç§å…±ç”Ÿå…³ç³»ï¼Œç…§é¡¾è‡ªå·±ç›´æ¥æœ‰ç›Šäºå® ç‰©ï¼Œè€Œå® ç‰©åˆ™æä¾›é™ªä¼´ã€åŠ¨åŠ›å’Œæ¸©å’Œçš„æŒ‡å¯¼ã€‚

### 1.2 åä¸½æ¸¸æˆé£æ ¼è®¾è®¡ç†å¿µï¼ˆèåˆä»·å€¼é©±åŠ¨ï¼‰
PandaHabitçš„è®¾è®¡ç†å¿µå›´ç»•åˆ›é€ ä¸€ç§**åä¸½å¥¢åä¸”ä»·å€¼é©±åŠ¨çš„æ¸¸æˆä½“éªŒ**ï¼Œç»™äººä»¥é«˜çº§æ„Ÿã€æ²‰æµ¸æ„Ÿå’Œæƒ…æ„Ÿæ»¡è¶³æ„Ÿã€‚åº”ç”¨æ—¨åœ¨é€šè¿‡åˆ©ç”¨ç²¾ç¾ç»šä¸½çš„è§†è§‰æ•ˆæœã€ç²¾å¿ƒè®¾è®¡çš„äº¤äº’å’Œä»¤äººæƒŠå¹çš„åŠ¨ç”»æ•ˆæœï¼Œå°†è‡ªæˆ‘æŠ¤ç†ä»ä¸€é¡¹çäº‹è½¬å˜ä¸ºä¸€æ®µæ„‰æ‚¦çš„æ—…ç¨‹ã€‚æˆ‘ä»¬é‡‡ç”¨äº†ä¸œæ–¹ç¾å­¦ä¸ç°ä»£æ¸¸æˆè®¾è®¡ç›¸ç»“åˆçš„æ–¹å¼ï¼Œæ‰“é€ å‡ºä¸€ä¸ªæ—¢åä¸½å£®è§‚åˆæ¸©é¦¨èˆ’é€‚çš„æ•°å­—ç©ºé—´ã€‚æ‰€æœ‰åä¸½çš„è§†è§‰å’Œäº¤äº’ï¼Œéƒ½æœåŠ¡äºæ¸…æ™°åœ°ä¼ é€’PandaHabitä¸ºç”¨æˆ·å¸¦æ¥çš„æ ¸å¿ƒä»·å€¼ï¼Œç‰¹åˆ«æ˜¯VIPè®¢é˜…æ‰€èƒ½æä¾›çš„å“è¶Šæ”¯æŒä¸ä½“éªŒå‡çº§ã€‚

### 1.3 ç›®æ ‡ç”¨æˆ·
- å¯»æ±‚ä¹ æƒ¯å…»æˆå’Œè‡ªæˆ‘æŠ¤ç†å·¥å…·çš„ä¸ªäºº
- å–œæ¬¢æ¸¸æˆåŒ–å’Œè™šæ‹Ÿå® ç‰©ä½“éªŒçš„ç”¨æˆ·
- æ¸´æœ›è·å¾—æ”¯æŒæ€§ã€æ¸©å’Œæ–¹å¼è¿›è¡Œä¸ªäººå‘å±•çš„äººç¾¤
- å¹´é¾„èŒƒå›´ï¼š18-45å²ï¼Œé‡ç‚¹å…³æ³¨å¹´è½»ä¸“ä¸šäººå£«å’Œå­¦ç”Ÿ
- æ¬£èµé«˜å“è´¨æ•°å­—ä½“éªŒå¹¶æ„¿æ„æŠ•èµ„ä¼˜è´¨åº”ç”¨çš„ç”¨æˆ·
- å¯¹ä¸œæ–¹ç¾å­¦å’Œåä¸½è§†è§‰é£æ ¼æœ‰åå¥½çš„ç©å®¶

## 2. åä¸½æ¸¸æˆé£æ ¼åˆ†æ

### 2.1 åä¸½æ¸¸æˆé£æ ¼å®šä¹‰

å¯¹äºPandaHabitï¼Œ"åä¸½æ¸¸æˆé£æ ¼"çš„å®šä¹‰åŒ…æ‹¬ï¼š
- **ç»šä¸½åç¾çš„è§†è§‰æ•ˆæœ**ï¼ŒåŒ…å«ç²¾ç»†çš„æ’ç”»å’ŒåŠ¨ç”»ï¼Œçµæ„Ÿæ¥æºäºä¸œæ–¹ç¾å­¦å’Œä¼ ç»Ÿä¸­å›½è‰ºæœ¯ã€‚VIPä¸“å±å†…å®¹ï¼ˆå¦‚çš®è‚¤ã€åœºæ™¯ï¼‰å°†é‡‡ç”¨æ›´é«˜çº§åˆ«çš„ç»†èŠ‚å’Œå…‰æ•ˆï¼Œä»¥å½°æ˜¾å…¶ç‹¬ç‰¹æ€§ã€‚
- **é‡‘ç¢§è¾‰ç…Œçš„è‰²å½©æ­é…**ï¼Œèåˆæ·±æ²‰çš„å®çŸ³è‰²è°ƒã€é‡‘è‰²ç‚¹ç¼€ã€ç²¾è‡´çš„æ¸å˜å’Œä¼ ç»Ÿä¸­å›½è‰²å½©ã€‚é‡‘è‰²å’Œç‰¹å®šå®çŸ³è‰²ï¼ˆå¦‚ç´«æª€ç´«ï¼‰å°†ä¼˜å…ˆç”¨äºVIPç›¸å…³å…ƒç´ ï¼Œè¥é€ å°Šè´µæ„Ÿã€‚
- **ç²¾é›•ç»†ç¢çš„UIå…ƒç´ **ï¼Œæ³¨é‡é˜´å½±ã€é«˜å…‰å’Œçº¹ç†ç»†èŠ‚ï¼Œé‡‡ç”¨ä¼ ç»Ÿä¸­å›½è£…é¥°å…ƒç´ ï¼ˆå¦‚äº‘çº¹ã€å¦‚æ„çº¹ï¼‰ã€‚VIPç›¸å…³æŒ‰é’®ã€å¡ç‰‡å°†æ‹¥æœ‰æ›´å¤æ‚çš„çº¹é¥°å’Œæ›´æ˜¾è‘—çš„åŠ¨æ€æ•ˆæœã€‚
- **æµç•…åä¸½çš„åŠ¨ç”»æ•ˆæœ**ï¼Œæä¾›è§†è§‰åé¦ˆå’Œæ„‰æ‚¦æ„Ÿï¼ŒåŠ¨ç”»é£æ ¼èåˆç°ä»£æ¸¸æˆä¸ä¼ ç»Ÿæ°´å¢¨ç”»åŠ¨æ€ç¾æ„Ÿã€‚VIPç‰¹æƒå¸¦æ¥çš„åŠ é€Ÿã€é¢å¤–å¥–åŠ±ç­‰å°†é€šè¿‡æ›´ç‚«ä¸½ã€æ›´å…·å†²å‡»åŠ›çš„åŠ¨ç”»æ¥ä½“ç°ã€‚
- **æ²‰æµ¸å¼éŸ³æ•ˆè®¾è®¡**ï¼Œç»“åˆå¹³é™çš„è‡ªç„¶å£°éŸ³ã€ä¼ ç»Ÿä¸­å›½ä¹å™¨å’Œæ¸©æŸ”çš„éŸ³ä¹å…ƒç´ ã€‚VIPä¸“å±åœºæ™¯æˆ–äº’åŠ¨å°†é…å¤‡ç‹¬ç‰¹çš„èƒŒæ™¯éŸ³ä¹æˆ–éŸ³æ•ˆã€‚
- **ç²¾å¿ƒè®¾è®¡çš„å­—ä½“æ’ç‰ˆ**ï¼Œå¹³è¡¡å¯è¯»æ€§ä¸ç¾å­¦å¸å¼•åŠ›ï¼Œä¸­æ–‡ä½¿ç”¨ä¼˜é›…çš„ä¹¦æ³•é£æ ¼å­—ä½“ã€‚VIPèº«ä»½æ ‡è¯†ã€ç‰¹æƒæè¿°å°†ä½¿ç”¨æ›´å…·è‰ºæœ¯æ„Ÿçš„å­—ä½“æˆ–ç‰¹æ®Šæ’ç‰ˆã€‚

### 2.2 è§†è§‰å‚è€ƒä¸çµæ„Ÿæ¥æº
- **é«˜å“è´¨ç§»åŠ¨æ¸¸æˆ**ï¼šã€ŠåŸç¥ã€‹(æ•´ä½“UIé£æ ¼ä¸åŠ¨æ•ˆ)ã€ã€Šå¤©æ¶¯æ˜æœˆåˆ€ã€‹(ä¸­å›½é£å…ƒç´ )ã€ã€Šé˜´é˜³å¸ˆã€‹(åä¸½ç‰¹æ•ˆ)
- **ä¸­å›½ä¼ ç»Ÿè‰ºæœ¯**ï¼šæ°´å¢¨ç”»ã€ç«¹å­å›¾æ¡ˆã€å±±æ°´ç”»ã€ä¼ ç»Ÿçº¹é¥°ã€å‰ªçº¸è‰ºæœ¯ã€äº¬å‰§è„¸è°±å…ƒç´ 
- **å¥¢ä¾ˆå“ç‰Œåº”ç”¨**ï¼šä¸Šæµ·æ»©ã€æ•…å®«æ–‡åˆ›ã€Louis Vuittonä¸­å›½ç‰ˆ
- **è‡ªç„¶å¯å‘è®¾è®¡**ï¼šå›½å®¶åœ°ç†ã€é«˜ç«¯åº¦å‡æ‘ç½‘ç«™ã€ä¸­å›½å›­æ—è®¾è®¡
- **å¤å…¸æ¸¸æˆç¾å­¦**ï¼šã€Šè½©è¾•å‰‘ã€‹ç³»åˆ—ã€ã€Šä»™å‰‘å¥‡ä¾ ä¼ ã€‹ç³»åˆ—çš„è§†è§‰é£æ ¼
- **ç°ä»£ä¸­å›½é£è®¾è®¡**ï¼šå½“ä»£ä¸­å›½æ’ç”»å¸ˆä½œå“ã€æ–°ä¸­å¼è®¾è®¡å…ƒç´ 

### 2.3 åä¸½è‰²å½©æ–¹æ¡ˆï¼ˆçªå‡ºVIPå°Šè´µæ„Ÿï¼‰
- **ä¸»è¦è‰²å½©**:
  - çš‡å®¶ç¿¡ç¿ ç»¿ (#1A5F4A)ï¼šä»£è¡¨æˆé•¿ã€å®é™ä¸è‡ªç„¶ï¼Œçµæ„Ÿæ¥è‡ªä¼ ç»Ÿä¸­å›½ç‰å™¨
  - å¯Œè´µç«¹ç»¿ (#88B04B)ï¼šè±¡å¾ç†ŠçŒ«çš„é£Ÿç‰©å’Œæ´»åŠ›ï¼Œä¼ é€’ç”Ÿæœºä¸å¸Œæœ›
  - ç‘é›ªç™½ (#F7F9F9)ï¼šæä¾›è§†è§‰å‘¼å¸ç©ºé—´å’Œæ¸…æ™°åº¦ï¼Œè±¡å¾çº¯å‡€ä¸å’Œè°
  - æœ±ç ‚çº¢ (#D73E35)ï¼šä¼ ç»Ÿä¸­å›½çº¢ï¼Œè±¡å¾å–œåº†ã€æ´»åŠ›ä¸å¥½è¿
- **ç‚¹ç¼€è‰²å½©**:
  - **åè´µé‡‘ (#D4AF37):** å¤§é‡ç”¨äºVIPèº«ä»½æ ‡è¯†ã€ç‰¹æƒå¥–åŠ±ã€ä»˜è´¹æŒ‰é’®ã€é‡è¦æˆå°±ç­‰ï¼Œè±¡å¾å°Šè´µä¸ä»·å€¼ã€‚
  - é’èŠ±è“ (#1A6DB0)ï¼šä»£è¡¨æ°´åˆ†å’ŒæµåŠ¨ï¼Œçµæ„Ÿæ¥è‡ªé’èŠ±ç“·
  - ç‰¡ä¸¹ç²‰ (#F8C8DC)ï¼šå¢æ·»æ¸©æš–å’Œæƒ…æ„Ÿè¿æ¥ï¼Œçµæ„Ÿæ¥è‡ªä¸­å›½ä¼ ç»ŸèŠ±å‰
  - **ç´«æª€ç´« (#5D3954):** å¯ç”¨äºVIPä¸“å±ç•Œé¢çš„èƒŒæ™¯æˆ–é«˜çº§è®¢é˜…æ¡£ä½çš„è§†è§‰å¼ºè°ƒï¼Œå¢æ·»ç¥ç§˜ä¸é«˜è´µã€‚
- **åŠŸèƒ½è‰²å½©**:
  - å¦‚æ„ç»¿ (#2E8B57)ï¼šè¡¨ç¤ºå®Œæˆå’Œç§¯ææˆæœï¼Œçµæ„Ÿæ¥è‡ªå¦‚æ„ç‰å™¨ã€‚VIPç”¨æˆ·å®Œæˆä»»åŠ¡æˆ–è·å¾—å¥–åŠ±æ—¶ï¼Œæ­¤ç»¿è‰²å¯å¸¦æœ‰é‡‘è‰²ç²’å­æ•ˆæœã€‚
  - ç¥ç€é»„ (#FFA500)ï¼šå¼•èµ·æ³¨æ„ä½†ä¸åˆºçœ¼ï¼Œçµæ„Ÿæ¥è‡ªå¤ä»£ç¥ç€é¥°å“
  - å¢¨ç° (#8A8D91)ï¼šç”¨äºæ¬¡è¦æ–‡æœ¬å’Œéæ´»åŠ¨å…ƒç´ ï¼Œçµæ„Ÿæ¥è‡ªæ°´å¢¨ç”»

### 2.4 å­—ä½“è®¾è®¡ï¼ˆåŒºåˆ†æ™®é€šä¸VIPä¿¡æ¯ï¼‰
- **ä¸»æ ‡é¢˜å­—ä½“**:
  - ä¸­æ–‡ï¼š"æ–¹æ­£æ¸…åˆ»æœ¬æ‚¦å®‹"ï¼Œä¼ é€’å…¸é›…ä¸æ°¸æ’æ„Ÿã€‚
  - è‹±æ–‡ï¼š"Playfair Display"ï¼Œä¸ä¸­æ–‡å­—ä½“é£æ ¼ç›¸åè°ƒã€‚
  - ç”¨äºé¡µé¢æ ‡é¢˜ã€æˆå°±åç§°å’Œé‡è¦æ ‡ç­¾ï¼Œé…ä»¥é‡‘è‰²æè¾¹å¢å¼ºåä¸½æ„Ÿã€‚
- **æ­£æ–‡å­—ä½“**:
  - ä¸­æ–‡ï¼š"æ€æºå®‹ä½“"ï¼Œé«˜å¯è¯»æ€§ï¼Œå¸¦æœ‰å‹å¥½ã€å¹³æ˜“è¿‘äººçš„æ„Ÿè§‰ã€‚
  - è‹±æ–‡ï¼š"Nunito Sans"ï¼Œä¸ä¸­æ–‡å­—ä½“æ­é…å’Œè°ã€‚
  - ç”¨äºä»»åŠ¡æè¿°ã€è¯´æ˜å’Œä¸€èˆ¬å†…å®¹ï¼Œä¿æŒæ¸…æ™°æ˜“è¯»ã€‚
- **è£…é¥°å­—ä½“ / VIPä¸“å±å­—ä½“**:
  - ä¸­æ–‡ï¼š"åºé—¨æ­£é“è¡Œä¹¦" æˆ– æ›´å…·è¯†åˆ«åº¦çš„ä»˜è´¹ä¹¦æ³•å­—ä½“ï¼ˆå¦‚â€œæ±‰ä»ªå°šå·æ‰‹ä¹¦â€ï¼‰ã€‚
  - è‹±æ–‡ï¼š"Caveat" æˆ– æ›´ä¼˜é›…çš„è¡¬çº¿æ‰‹å†™ä½“ã€‚
  - ç”¨äºVIPç‰¹æƒæè¿°ã€ä¸“å±æ´»åŠ¨æ ‡é¢˜ã€ç†ŠçŒ«çš„ç‰¹æ®ŠVIPé—®å€™ç­‰ï¼Œå¢å¼ºç‹¬ç‰¹æ€§å’Œæƒ…æ„Ÿè¿æ¥ã€‚

### 2.5 UIç»„ä»¶è®¾è®¡æŒ‡å—ï¼ˆå¼ºåŒ–VIPå…ƒç´ çš„è§†è§‰å±‚çº§ï¼‰
- **æŒ‰é’®**ï¼š
  * æ™®é€šæŒ‰é’®ï¼šä¼ ç»Ÿä¸­å›½é£æ ¼å…ƒç´ è£…é¥°çš„è½¯åœ†è§’çŸ©å½¢ï¼Œé…ä»¥ç²¾è‡´æ¸å˜ã€‚
  * VIP/ä»˜è´¹å¼•å¯¼æŒ‰é’®ï¼šé‡‡ç”¨æ›´åä¸½çš„äº‘çº¹ã€å¦‚æ„çº¹æˆ–é¾™çº¹è£…é¥°ï¼Œé¢œè‰²ä»¥åè´µé‡‘ã€æœ±ç ‚çº¢ä¸ºä¸»ï¼Œé…ä»¥åŠ¨æ€å…‰æ•ˆã€æ›´æ˜¾è‘—çš„ç²’å­æ•ˆæœï¼Œç‚¹å‡»åŠ¨ç”»æ›´å…·å†²å‡»åŠ›ã€‚
- **å¡ç‰‡**ï¼š
  * æ™®é€šå¡ç‰‡ï¼šå±‚å è®¾è®¡ï¼Œç²¾è‡´é˜´å½±å’Œçº¹ç†èƒŒæ™¯ï¼Œä¼ ç»Ÿçº¹é¥°è¾¹æ¡†ã€‚
  * VIPç‰¹æƒå±•ç¤ºå¡ç‰‡/è®¢é˜…é€‰é¡¹å¡ç‰‡ï¼šè¾¹æ¡†é‡‡ç”¨æ›´å¤æ‚çš„é‡‘è‰²æˆ–çº¢è‰²æè¾¹ï¼ŒèƒŒæ™¯å¯ä½¿ç”¨ä¸ç»¸æˆ–é”¦ç¼ç­‰é«˜çº§çº¹ç†ï¼Œé‡è¦ä¿¡æ¯åŒºåŸŸå¯æœ‰å¾®å…‰æµ®åŠ¨æ•ˆæœã€‚
- **å›¾æ ‡**ï¼š
  * æ™®é€šå›¾æ ‡ï¼šæ°´å¢¨ç”»é£æ ¼ï¼Œç¬”è§¦ä¸€è‡´ï¼Œåœ†æ¶¦è¾¹è§’ã€‚
  * VIPä¸“å±åŠŸèƒ½å›¾æ ‡ï¼šåœ¨æ°´å¢¨é£æ ¼åŸºç¡€ä¸Šå¢åŠ é‡‘è‰²ç‚¹ç¼€æˆ–å¾®å°åŠ¨æ€å…‰æ•ˆï¼Œä½¿å…¶åœ¨è§†è§‰ä¸Šæ›´çªå‡ºã€‚
- **è¿›åº¦æŒ‡ç¤ºå™¨**ï¼š
  * æ™®é€šè¿›åº¦æ¡ï¼šä¼˜é›…ç¯å½¢æˆ–çº¿æ€§ï¼Œæ°´å¢¨æ™•æŸ“å¡«å……ã€‚
  * åŠæ—¶æ€§è¿›åº¦æ¡/VIPåŠ é€Ÿè¿›åº¦æ¡ï¼šé‡‡ç”¨æ›´åä¸½çš„å·è½´æˆ–é¾™å½¢ç«¹ç®€å½¢å¼ï¼Œå¡«å……åŠ¨ç”»å¯åŠ å…¥é‡‘è‰²ç²’å­æµå…‰æ•ˆæœï¼Œå®Œæˆæ—¶æœ‰æ›´ç››å¤§çš„åº†ç¥åŠ¨ç”»ã€‚
- **è¾“å…¥æ¡†**ï¼šç®€çº¦è®¾è®¡ï¼Œå¸¦æœ‰å¾®å¦™è¾¹æ¡†å’Œç„¦ç‚¹çŠ¶æ€ï¼Œè¾¹æ¡†é‡‡ç”¨ä¼ ç»Ÿçº¹é¥°ï¼Œæ¿€æ´»æ—¶æœ‰æ°´å¢¨æ‰©æ•£æ•ˆæœã€‚
- **å¼¹çª—**ï¼š
  * æ™®é€šå¼¹çª—ï¼šå±…ä¸­è®¾è®¡ï¼Œè£…é¥°æ€§æ¡†æ¶é‡‡ç”¨ä¼ ç»Ÿçª—æ£‚æ ·å¼ï¼ŒåŠé€æ˜èƒŒæ™¯æ¨¡ä»¿å®£çº¸è´¨æ„Ÿã€‚
  * VIPå¼•å¯¼/ä¼˜æƒ å¼¹çª—ï¼šæ¡†æ¶å¯é‡‡ç”¨æ›´åä¸½çš„é›•èŠ±æˆ–é•¶é‡‘è®¾è®¡ï¼ŒèƒŒæ™¯å¯åŠ å…¥åŠ¨æ€ç¥¥äº‘æˆ–ç‰¡ä¸¹ç››å¼€ç­‰å…ƒç´ ï¼ŒæŒ‰é’®è®¾è®¡å‚ç…§VIPæŒ‰é’®ã€‚

## 3. ä¿¡æ¯æ¶æ„

### 3.1 å¯¼èˆªç»“æ„
åŸºäºPRDï¼ŒPandaHabitå°†ä½¿ç”¨åº•éƒ¨æ ‡ç­¾å¯¼èˆªï¼Œå…·æœ‰ä»¥ä¸‹ä¸»è¦éƒ¨åˆ†ï¼Œæ¯ä¸ªå¯¼èˆªå›¾æ ‡éƒ½é‡‡ç”¨åä¸½çš„ä¸­å›½é£è®¾è®¡ï¼š

1. **ä¸»é¡µï¼ˆç«¹æ—å®¶å›­ï¼‰**ï¼šä¸»ä»ªè¡¨ç›˜ï¼Œå±•ç¤ºç†ŠçŒ«ã€åŠæ—¶å¥–åŠ±è¿›åº¦æ¡å’Œå¿«é€Ÿæ“ä½œï¼ŒèƒŒæ™¯ä¸ºåŠ¨æ€ç«¹æ—åœºæ™¯
2. **ä»»åŠ¡ï¼ˆä¿®è¡Œä¹‹è·¯ï¼‰**ï¼šæ—¥å¸¸ä»»åŠ¡åˆ—è¡¨å’Œç®¡ç†ï¼Œè®¾è®¡ä¸ºå¤ä»£å·è½´æ ·å¼
3. **æŒ‘æˆ˜ï¼ˆæ±Ÿæ¹–å†ç»ƒï¼‰**ï¼šé•¿æœŸç›®æ ‡å’Œç‰¹åˆ«æ´»åŠ¨ï¼Œè®¾è®¡ä¸ºåœ°å›¾æ¢é™©é£æ ¼
4. **æ—…ç¨‹ï¼ˆæˆé•¿ä¹‹é“ï¼‰**ï¼šç†ŠçŒ«æˆé•¿è·¯å¾„å’Œé‡Œç¨‹ç¢‘ï¼Œè®¾è®¡ä¸ºä¼ ç»Ÿå±±æ°´ç”»å·
5. **å•†åº—ï¼ˆçå®é˜ï¼‰**ï¼šè£…é¥°ç‰©å“ã€èµ„æºå’ŒVIPè®¢é˜…ï¼Œè®¾è®¡ä¸ºå¤ä»£å•†é“ºé£æ ¼

æ¬¡è¦å¯¼èˆªåŒ…æ‹¬ï¼š
- **ç†ŠçŒ«äº’åŠ¨ï¼ˆå¿ƒçµç›¸é€šï¼‰**ï¼šé€šè¿‡ç‚¹å‡»ä¸»é¡µä¸Šçš„ç†ŠçŒ«è®¿é—®ï¼Œè®¾è®¡ä¸ºç²¾ç¾çš„äº’åŠ¨åœºæ™¯
- **å¹¸è¿æŠ½å¥–ï¼ˆç¦ç¼˜æŠ½ç­¾ï¼‰**ï¼šé€šè¿‡é¡¶éƒ¨å¯¼èˆªä¸­çš„ä¸“ç”¨å›¾æ ‡è®¿é—®ï¼Œè®¾è®¡ä¸ºä¼ ç»ŸæŠ½ç­¾ä¸å®ç®±ç›¸ç»“åˆçš„å½¢å¼
- **è®¾ç½®ï¼ˆç‰ç®€è®¾å®šï¼‰**ï¼šé€šè¿‡å³ä¸Šè§’çš„é½¿è½®å›¾æ ‡è®¿é—®ï¼Œå›¾æ ‡è®¾è®¡ä¸ºå¤ä»£ç‰ç®€
- **åæ€æ¨¡å—ï¼ˆé™å¿ƒèŒ¶å®¤ï¼‰**ï¼šæ ¹æ®ç”¨æˆ·è¡Œä¸ºæƒ…å¢ƒè§¦å‘ï¼Œè®¾è®¡ä¸ºå®é™çš„ä¼ ç»ŸèŒ¶å®¤ç¯å¢ƒ

### 3.2 ç”¨æˆ·æµç¨‹å›¾
å…³é”®ç”¨æˆ·æµç¨‹åŒ…æ‹¬ï¼Œæ¯ä¸ªæµç¨‹éƒ½é…æœ‰åä¸½çš„è¿‡æ¸¡åŠ¨ç”»å’Œè§†è§‰å¼•å¯¼ï¼š

1. **æ–°ç”¨æˆ·å¼•å¯¼ï¼ˆåˆå…¥ä»™å¢ƒï¼‰**ï¼š
   - åº”ç”¨ä»‹ç»ï¼ˆå¤å·å±•å¼€åŠ¨ç”»ï¼‰â†’ ç†ŠçŒ«å®šåˆ¶ï¼ˆæ°´å¢¨æ¸²æŸ“æ•ˆæœï¼‰â†’ é¦–ä¸ªä»»åŠ¡è®¾ç½®ï¼ˆå·è½´ä¹¦å†™åŠ¨ç”»ï¼‰â†’ ä»»åŠ¡å®Œæˆï¼ˆé‡‘å…‰ç‰¹æ•ˆï¼‰â†’ å¥–åŠ±ï¼ˆå®ç®±å¼€å¯åŠ¨ç”»ï¼‰â†’ ä¸»é¡µï¼ˆç«¹æ—å±•å¼€æ•ˆæœï¼‰

2. **æ—¥å¸¸ä¹ æƒ¯æ‰“å¡ï¼ˆæ¯æ—¥ä¿®è¡Œï¼‰**ï¼š
   - é€šçŸ¥ï¼ˆç†ŠçŒ«ä¿¡ä½¿åŠ¨ç”»ï¼‰â†’ ä»»åŠ¡é¡µé¢ï¼ˆå·è½´å±•å¼€ï¼‰â†’ ä»»åŠ¡å®Œæˆï¼ˆå¢¨è¿¹æ¸²æŸ“åŠ¨ç”»ï¼‰â†’ åŠæ—¶å¥–åŠ±ï¼ˆé‡‘å¸é£èˆæ•ˆæœï¼‰â†’ ç†ŠçŒ«äº’åŠ¨ï¼ˆç†ŠçŒ«æ¬¢å–œåŠ¨ç”»ï¼‰

3. **æŒ‘æˆ˜å‚ä¸ï¼ˆæ±Ÿæ¹–æ¢ç´¢ï¼‰**ï¼š
   - æŒ‘æˆ˜é¡µé¢ï¼ˆåœ°å›¾å±•å¼€åŠ¨ç”»ï¼‰â†’ æŒ‘æˆ˜é€‰æ‹©ï¼ˆåœ°ç‚¹ç‚¹äº®æ•ˆæœï¼‰â†’ æ—¥å¸¸å­ä»»åŠ¡ï¼ˆå°å·è½´å±•å¼€ï¼‰â†’ è¿›åº¦è·Ÿè¸ªï¼ˆåœ°å›¾è·¯å¾„ç‚¹äº®ï¼‰â†’ å®Œæˆå¥–åŠ±ï¼ˆå®ç®±åä¸½å¼€å¯ï¼‰

4. **åæ€è¿‡ç¨‹ï¼ˆèŒ¶é“é™å¿ƒï¼‰**ï¼š
   - è§¦å‘äº‹ä»¶ï¼ˆèŒ¶æ¯å›¾æ ‡å‡ºç°ï¼‰â†’ æ¸©å’Œæç¤ºï¼ˆç†ŠçŒ«é‚€è¯·åŠ¨ç”»ï¼‰â†’ åæ€é—®é¢˜ï¼ˆæ°´å¢¨æ‰©æ•£æ•ˆæœï¼‰â†’ æ”¯æŒæ€§åé¦ˆï¼ˆç†ŠçŒ«å®‰æ…°åŠ¨ç”»ï¼‰â†’ è¡ŒåŠ¨å»ºè®®ï¼ˆç«¹ç®€å±•å¼€æ•ˆæœï¼‰

5. **VIPè½¬åŒ–ï¼ˆé£å‡ä¹‹è·¯ï¼‰**ï¼š
   - åŠŸèƒ½äº’åŠ¨ï¼ˆé‡‘è‰²å…‰èŠ’æç¤ºï¼‰â†’ VIPæç¤ºï¼ˆåä¸½å·è½´å±•å¼€ï¼‰â†’ ç¦åˆ©å±•ç¤ºï¼ˆé‡‘å…‰ç‰¹æ•ˆå±•ç¤ºï¼‰â†’ è®¢é˜…é€‰æ‹©ï¼ˆç‰ç’§é€‰æ‹©ç•Œé¢ï¼‰â†’ è´­ä¹°ç¡®è®¤ï¼ˆç¥¥äº‘ç¯ç»•åŠ¨ç”»ï¼‰

### 3.3 å±å¹•å±‚æ¬¡ç»“æ„
å±å¹•å±‚æ¬¡ç»“æ„éµå¾ªä»ä¸€èˆ¬åˆ°ç‰¹å®šçš„é€»è¾‘è¿›å±•ï¼Œæ¯ä¸€å±‚éƒ½æœ‰ç‹¬ç‰¹çš„è§†è§‰é£æ ¼ï¼š

- **ç¬¬ä¸€å±‚**ï¼šä¸»æ ‡ç­¾å±å¹•ï¼ˆç«¹æ—å®¶å›­ã€ä¿®è¡Œä¹‹è·¯ã€æ±Ÿæ¹–å†ç»ƒã€æˆé•¿ä¹‹é“ã€çå®é˜ï¼‰ï¼Œè®¾è®¡ä¸ºå®Œæ•´çš„åœºæ™¯ç”»é¢
- **ç¬¬äºŒå±‚**ï¼šç‰¹å®šåŠŸèƒ½å±å¹•ï¼ˆå¿ƒçµç›¸é€šã€ç¦ç¼˜æŠ½ç­¾ã€ç‰ç®€è®¾å®šï¼‰ï¼Œè®¾è®¡ä¸ºä¸»åœºæ™¯çš„ç‰¹å†™æˆ–å˜ä½“
- **ç¬¬ä¸‰å±‚**ï¼šè¯¦æƒ…å±å¹•ï¼ˆä»»åŠ¡è¯¦æƒ…ã€æŒ‘æˆ˜è¯¦æƒ…ã€ç‰©å“è¯¦æƒ…ï¼‰ï¼Œè®¾è®¡ä¸ºç²¾ç¾çš„å·è½´æˆ–ç‰ç®€å±•å¼€
- **ç¬¬å››å±‚**ï¼šæµç¨‹å±å¹•ï¼ˆé™å¿ƒèŒ¶å®¤ã€VIPè´­ä¹°ã€ä»»åŠ¡åˆ›å»ºï¼‰ï¼Œè®¾è®¡ä¸ºç‰¹æ®Šäº’åŠ¨åœºæ™¯

## 4. Detailed UI/UX Design

### 4.1 ä¸»é¡µï¼ˆç«¹æ—å®¶å›­ï¼‰
ä¸»é¡µæ˜¯æƒ…æ„Ÿä¸­å¿ƒå’Œä¸»è¦ä»ªè¡¨ç›˜ï¼Œéœ€å¼ºåŒ–â€œåä¸½æ¸¸æˆé£æ ¼â€ä¸äº’åŠ¨ä½“éªŒï¼š

- **é¡¶éƒ¨åŒºåŸŸ**ï¼š
  - ç”¨æˆ·å¤´åƒ/èµ„æ–™ï¼ˆå·¦ä¸Šï¼‰ï¼ŒVIPç”¨æˆ·æœ‰ä¸“å±å¾½ç« ä¸åŠ¨ç”»å…‰æ•ˆ
  - è´§å¸æ˜¾ç¤ºï¼ˆé‡‘å¸ã€é’»çŸ³ã€å¹¸è¿ç‚¹ï¼‰ï¼Œé‡‡ç”¨ç«‹ä½“é‡‘å±è´¨æ„Ÿä¸ç²’å­ç‰¹æ•ˆ
  - è®¾ç½®é½¿è½®ï¼ˆå³ä¸Šï¼‰ï¼Œä»¥ç‰ç®€æˆ–ç¥¥äº‘ä¸ºé€ å‹ï¼Œå¸¦å…¥åœºåŠ¨ç”»
  - å¹¸è¿æŠ½å¥–å…¥å£ï¼Œå¸¸é©»é—ªçƒç²’å­ä¸åŠ¨æ€é«˜äº®

- **ä¸­å¤®åŒºåŸŸ**ï¼š
  - å¤§å¹…ç²¾ç¾ç†ŠçŒ«æ’ç”»ï¼Œåˆ†é˜¶æ®µæˆé•¿ï¼ŒçŠ¶æ€ä¸äº’åŠ¨å‡æœ‰ä¸°å¯ŒåŠ¨ç”»ï¼ˆå¦‚çœ¨çœ¼ã€ä¼¸æ‡’è…°ã€æ’’å¨‡ï¼‰
  - ç¯å¢ƒä¸ºåŠ¨æ€ç«¹æ—ï¼Œéšæ—¶é—´å˜åŒ–å…‰å½±ï¼ŒåŠ å…¥è´è¶ã€ç«¹å¶é£˜è½ç­‰ç²’å­åŠ¨æ•ˆ
  - åŠæ—¶æ€§è¿›åº¦æ¡è®¾è®¡ä¸ºåä¸½å·è½´æˆ–ç«¹ç®€ï¼Œå¡«å……åŠ¨ç”»æœ‰æ°´å¢¨æ™•æŸ“ä¸é‡‘å…‰ç²’å­
  - å¥–åŠ±é¢„è§ˆé‡‡ç”¨å®ç®±/å·è½´å±•å¼€åŠ¨ç”»ï¼Œå¥–åŠ±å›¾æ ‡æœ‰é«˜å…‰ä¸å¼¹è·³ç‰¹æ•ˆ

- **åº•éƒ¨åŒºåŸŸ**ï¼š
  - æ´»è·ƒä»»åŠ¡å¿«æ·å…¥å£ï¼Œå¡ç‰‡é‡‡ç”¨æµ®é›•ã€é‡‘è¾¹ã€äº‘çº¹ç­‰è£…é¥°ï¼Œå®Œæˆæ—¶æœ‰ç²’å­çˆ†å‘åŠ¨ç”»
  - æœ€è¿‘å¥–åŠ±æ—¥å¿—ï¼Œå›¾æ ‡é€æ¡æ»šåŠ¨å‡ºç°ï¼Œå¸¦æœ‰æ·¡å…¥æ·¡å‡ºä¸ç²’å­ç‚¹ç¼€
  - åº•éƒ¨å¯¼èˆªæ ä¸ºè‡ªå®šä¹‰ä¸­å›½é£å›¾æ ‡ï¼Œé€‰ä¸­æœ‰ç¥¥äº‘æµåŠ¨ä¸é«˜äº®ç‰¹æ•ˆï¼Œæ•´ä½“é‡‡ç”¨åŠé€æ˜ç‰çŸ³è´¨æ„Ÿ

### 4.2 ä»»åŠ¡é¡µï¼ˆä¿®è¡Œä¹‹è·¯ï¼‰
ä»»åŠ¡é¡µéœ€çªå‡ºâ€œå¤å·â€ä¸â€œåä¸½åŠ¨æ•ˆâ€ä¸»é¢˜ï¼Œæå‡äº¤äº’ä»ªå¼æ„Ÿï¼š

- **é¡¶éƒ¨åŒºåŸŸ**ï¼š
  - æ—¥æœŸå±•ç¤ºé‡‡ç”¨ä¹¦æ³•å­—ä½“ä¸ç¥¥äº‘è£…é¥°ï¼ŒèƒŒæ™¯ä¸ºæ·¡é›…å®£çº¸çº¹ç†
  - æ¯æ—¥è¿›åº¦æ¡ä¸ºå·è½´å±•å¼€åŠ¨ç”»ï¼Œå¡«å……æ—¶æœ‰æ°´å¢¨æ™•æŸ“ä¸é‡‘å…‰ç²’å­
  - ç­›é€‰/æ’åºä¸‹æ‹‰èœå•ä¸ºç‰ä½©/ç«¹ç®€é€ å‹ï¼Œå±•å¼€æœ‰å¼¹æ€§åŠ¨ç”»

- **ä»»åŠ¡åˆ—è¡¨**ï¼š
  - æ»šåŠ¨åˆ—è¡¨ï¼Œæ¯ä¸ªä»»åŠ¡å¡ç‰‡ä¸ºç«‹ä½“æµ®é›•å·è½´ï¼Œè¾¹æ¡†æœ‰é‡‘è‰²æè¾¹ä¸äº‘çº¹
  - ä»»åŠ¡ç±»å‹å›¾æ ‡ä¸ºæ°´å¢¨é£ï¼Œä»»åŠ¡åç”¨å®‹ä½“/ä¹¦æ³•å­—ä½“ï¼Œé‡è¦ä»»åŠ¡æœ‰ç‰¹æ®Šé«˜äº®
  - å¥–åŠ±é¢„è§ˆå›¾æ ‡æœ‰å¼¹è·³ä¸é«˜å…‰åŠ¨ç”»
  - åŠæ—¶æ€§ä»»åŠ¡æœ‰â°/âœ¨ç‰¹æ•ˆï¼Œå®Œæˆæ—¶æœ‰ç²’å­çˆ†å‘ä¸å·è½´å°ç« åŠ¨ç”»
  - æ—¶é—´çª—å£å€’è®¡æ—¶ä¸ºåŠ¨æ€æ²™æ¼/æ°´æ»´ï¼ŒæŒ‘æˆ˜/è‡ªå®šä¹‰ç›®æ ‡æœ‰ä¸“å±æ ‡è¯†ï¼ˆå¦‚ç«ç„°/ç†ŠçŒ«å¤´åƒï¼‰

- **æ–°å¢ä»»åŠ¡æŒ‰é’®**ï¼š
  - æ‚¬æµ®é‡‘è‰²åœ†å½¢æŒ‰é’®ï¼Œä¸­å¿ƒä¸ºåŠ å·ï¼ŒæŒ‰é’®æœ‰è„‰å†²å…‰åœˆä¸ç²’å­ç¯ç»•

### 4.3 æŒ‘æˆ˜é¡µï¼ˆæ±Ÿæ¹–å†ç»ƒï¼‰
æŒ‘æˆ˜é¡µéœ€å¼ºåŒ–â€œåœ°å›¾æ¢é™©â€ä¸â€œæˆå°±æ„Ÿâ€è§†è§‰ï¼š

- **é¡¶éƒ¨åŒºåŸŸ**ï¼š
  - æŒ‘æˆ˜åˆ†ç±»Tabä¸ºå¤ä»£ä»¤ç‰Œ/ç«¹ç®€é€ å‹ï¼Œåˆ‡æ¢æœ‰ç¿»è½¬/å·è½´å±•å¼€åŠ¨ç”»
  - é¡¶éƒ¨è£…é¥°éšæŒ‘æˆ˜ä¸»é¢˜å˜æ¢ï¼ˆå¦‚å±±æ°´ã€ç«ç„°ã€ç¥¥äº‘ï¼‰

- **æŒ‘æˆ˜å¡ç‰‡**ï¼š
  - å¡ç‰‡ä¸ºç«‹ä½“æµ®é›•ï¼ŒèƒŒæ™¯ä¸ºåœ°å›¾/å±±æ°´ç”»å·ï¼Œä¸»æ ‡é¢˜ç”¨é‡‘è‰²æè¾¹å­—ä½“
  - å…³é”®å¥–åŠ±æœ‰å®ç®±/ç‰ç’§é«˜äº®å±•ç¤ºï¼Œå¥–åŠ±å›¾æ ‡æœ‰å…‰æ™•ä¸ç²’å­ç‰¹æ•ˆ
  - è¿›åº¦æ¡ä¸ºç«¹èŠ‚/å·è½´ï¼Œå¡«å……æœ‰æ°´å¢¨æµåŠ¨åŠ¨ç”»
  - æ—¶é—´é™åˆ¶ä¸ºåŠ¨æ€å€’è®¡æ—¶ï¼Œæœªå®Œæˆæ—¶æœ‰è½»å¾®é—ªçƒ
  - å­ä»»åŠ¡å¯å±•å¼€ï¼Œå®Œæˆæœ‰å°ç« /ç¥¥äº‘åŠ¨ç”»
  - æ¥å—/é¢†å–æŒ‰é’®ä¸ºç‰ä½©é€ å‹ï¼Œç‚¹å‡»æœ‰å¼¹è·³ä¸ç²’å­çˆ†å‘

### 4.4 æˆé•¿ä¹‹é“ï¼ˆæ—…ç¨‹é¡µï¼‰
æˆé•¿ä¹‹é“éœ€çªå‡ºâ€œè¿›åŒ–ä»ªå¼æ„Ÿâ€ä¸â€œä¸œæ–¹ç¾å­¦â€ï¼š

- **æˆé•¿è·¯å¾„å¯è§†åŒ–**ï¼š
  - é‡‡ç”¨å±±æ°´ç”»å·å¼æ—¶é—´è½´æˆ–æ ‘çŠ¶ç»“æ„ï¼ŒèŠ‚ç‚¹é—´ç”¨ç¥¥äº‘/ç«¹èŠ‚è¿æ¥
  - æ¯ä¸ªèŠ‚ç‚¹ä¸ºç†ŠçŒ«ä¸åŒæˆé•¿é˜¶æ®µå°åƒï¼Œå®ŒæˆèŠ‚ç‚¹æœ‰é‡‘å…‰é«˜äº®ä¸ç²’å­åº†ç¥
  - å½“å‰èŠ‚ç‚¹è„‰å†²åŠ¨ç”»ï¼Œæœªè§£é”èŠ‚ç‚¹åŠé€æ˜å¹¶æœ‰ç¥ç§˜å…‰æ•ˆ
  - å¥–åŠ±é¢„è§ˆä¸ºç‰ç®€/å®ç®±å±•å¼€ï¼Œå¥–åŠ±å›¾æ ‡æœ‰é«˜å…‰ä¸å¼¹è·³

- **Milestone Log**:
  - Scrollable timeline with rich visual treatment
  - Achievement cards with decorative frames
  - Date stamps with elegant typography
  - Reward recap with animated icons

### 4.5 å•†åº—é¡µï¼ˆçå®é˜ï¼‰
å•†åº—é¡µéœ€è¥é€ â€œå¥¢åè´­ç‰©â€ä¸â€œæ”¶è—å±•ç¤ºâ€æ°›å›´ï¼š

- **é¡¶éƒ¨åŒºåŸŸ**ï¼š
  - æœç´¢æ ä¸ºç‰ç®€/ç¥¥äº‘é€ å‹ï¼Œè¾“å…¥æ—¶æœ‰å…‰æ•ˆæµåŠ¨
  - åˆ†ç±»ç­›é€‰ä¸ºç«‹ä½“ç‰ä½©/å·è½´ï¼Œé€‰ä¸­æœ‰é«˜äº®ä¸ç²’å­ç¯ç»•
  - ç‰¹è‰²å•†å“è½®æ’­ä¸ºå®ç®±/ç‰ç’§å±•ç¤ºï¼Œåˆ‡æ¢æœ‰ç¿»è½¬åŠ¨ç”»

- **å•†å“ç½‘æ ¼**ï¼š
  - å•†å“å¡ç‰‡ä¸ºæµ®é›•é‡‘è¾¹ï¼Œæ’ç”»é«˜ç²¾åº¦å¹¶å¸¦æœ‰å¾®åŠ¨ç”»
  - ä»·æ ¼ç”¨é‡‘è‰²å­—ä½“ä¸ç«‹ä½“è´§å¸å›¾æ ‡ï¼ŒVIPå•†å“æœ‰ä¸“å±å…‰æ•ˆä¸æ ‡è¯†

- **å•†å“è¯¦æƒ…**ï¼š
  - å¤§å›¾é¢„è§ˆæ”¯æŒ3Dæ—‹è½¬ï¼Œæè¿°åŒºç”¨å®‹ä½“/ä¹¦æ³•å­—ä½“
  - ç†ŠçŒ«å®šåˆ¶ç±»å•†å“æœ‰å‰åå¯¹æ¯”åŠ¨ç”»
  - è´­ä¹°æŒ‰é’®ä¸ºç‰ç’§/ç¥¥äº‘é€ å‹ï¼Œç‚¹å‡»æœ‰ç²’å­çˆ†å‘
  - ç›¸å…³å•†å“æ¨ªå‘æ»šåŠ¨ï¼Œå¡ç‰‡æœ‰å¼¹è·³ä¸é«˜å…‰

### 4.6 ç†ŠçŒ«äº’åŠ¨é¡µï¼ˆå¿ƒçµç›¸é€šï¼‰
å¼ºåŒ–â€œäº²å¯†äº’åŠ¨â€ä¸â€œåŠ¨æ€ç¯å¢ƒâ€ä½“éªŒï¼š

- **ç¯å¢ƒè®¾è®¡**ï¼š
  - èƒŒæ™¯ä¸ºé«˜ç²¾åº¦ä¸­å›½å›­æ—ï¼Œéšæ—¶é—´å˜åŒ–å…‰å½±ï¼ŒåŠ å…¥åŠ¨æ€æ°´é¢ã€ç«¹å¶ã€ç¥¥äº‘ç­‰ç²’å­
  - ç¯å¢ƒå…ƒç´ å¯äº¤äº’ï¼ˆå¦‚ç‚¹å‡»æ°´æ± æœ‰æ¶Ÿæ¼ªï¼Œç«¹å¶å¯é£˜è½ï¼‰

- **ç†ŠçŒ«å¯è§†åŒ–**ï¼š
  - ç†ŠçŒ«å¤§å¹…åŠ¨æ€æ’ç”»ï¼Œæƒ…ç»ªé€šè¿‡è¡¨æƒ…ã€åŠ¨ä½œã€ç‰¹æ•ˆå±•ç°ï¼ˆå¦‚å¼€å¿ƒæ—¶æœ‰é‡‘å…‰ã€æ’’å¨‡æ—¶æœ‰çˆ±å¿ƒç²’å­ï¼‰
  - å®šåˆ¶è£…é¥°é«˜ç²¾åº¦æ¸²æŸ“ï¼Œç¨€æœ‰ç‰©å“æœ‰ç‰¹æ®Šå…‰æ•ˆ

- **äº’åŠ¨æ§ä»¶**ï¼š
  - æŒ‰é’®ä¸ºç‰ä½©/ç¥¥äº‘é€ å‹ï¼Œç‚¹å‡»æœ‰å¼¹è·³ä¸ç²’å­åŠ¨ç”»
  - å–‚é£Ÿã€ç©è€ã€è®­ç»ƒå‡æœ‰ä¸“å±åŠ¨ç”»ä¸å¥–åŠ±åé¦ˆ
  - åæ€æç¤ºä¸ºæ¸©æŸ”å¼¹çª—ï¼ŒèƒŒæ™¯è™šåŒ–å¹¶æœ‰ç¥¥äº‘ç¯ç»•

### 4.7 å¹¸è¿æŠ½å¥–é¡µï¼ˆç¦ç¼˜æŠ½ç­¾ï¼‰
çªå‡ºâ€œä»ªå¼æ„Ÿâ€ä¸â€œæƒŠå–œæ„Ÿâ€è§†è§‰ï¼š

- **é¡¶éƒ¨åŒºåŸŸ**ï¼š
  - å¹¸è¿ç‚¹ä½™é¢ä¸ºç«‹ä½“ç‰ç’§è®¡æ•°å™¨ï¼Œå‘¨å›´å¸¸é©»é—ªçƒç²’å­

- **æŠ½å¥–æœºåˆ¶**ï¼š
  - æŠ½å¥–åŠ¨ç”»ä¸ºåä¸½å®ç®±/è½¬ç›˜/ç«¹ç®€å±•å¼€ï¼Œç²’å­ä¸éŸ³æ•ˆè¥é€ æœŸå¾…æ°›å›´
  - æŠ½å¥–æŒ‰é’®ä¸ºé‡‘è‰²ç¥¥äº‘é€ å‹ï¼Œç‚¹å‡»æœ‰é«˜å…‰ä¸ç²’å­çˆ†å‘
  - ç»“æœæ­æ™“æœ‰å·è½´å±•å¼€ã€å®ç®±å¼€å¯ç­‰åº†ç¥åŠ¨ç”»

- **å¥–æ± å±•ç¤º**ï¼š
  - å¥–å“ä»¥ç”»å»Šå½¢å¼å±•ç¤ºï¼Œç¨€æœ‰åº¦ç”¨é‡‘å…‰/ç¥¥äº‘ç‰¹æ•ˆåŒºåˆ†
  - æ¦‚ç‡ç”¨ç²¾ç¾æ•°æ®å¯è§†åŒ–ï¼Œè¿‘æœŸä¸­å¥–æœ‰æ—¶é—´è½´åŠ¨ç”»

### 4.8 åæ€æ¨¡å—ï¼ˆé™å¿ƒèŒ¶å®¤ï¼‰
è¥é€ â€œé™è°§æ²»æ„ˆâ€ä¸â€œæ¸©æŸ”æ”¯æŒâ€æ°›å›´ï¼š

- **è§†è§‰è®¾è®¡**ï¼š
  - èƒŒæ™¯ä¸ºæ·¡é›…èŒ¶å®¤/å±±æ°´ï¼Œç¥¥äº‘ã€èŒ¶çƒŸç­‰æŸ”å’ŒåŠ¨ç”»ï¼Œæ•´ä½“è‰²è°ƒæ¸©æš–æŸ”å’Œ
  - UIå…ƒç´ æç®€ï¼Œå‡å°‘å¹²æ‰°ï¼Œè¾“å…¥åŒºä¸ºå®£çº¸/ç«¹ç®€é€ å‹

- **äº¤äº’è®¾è®¡**ï¼š
  - ç†ŠçŒ«å¤´åƒæœ‰åŒç†å¿ƒè¡¨æƒ…ï¼Œæ–‡å­—å¯¹è¯é‡‡ç”¨é€å­—æ·¡å…¥åŠ¨ç”»
  - è¾“å…¥æ–¹å¼ä¸ºå®šåˆ¶æŒ‰é’®/æ¸©æŸ”æ–‡æœ¬æ¡†ï¼Œåé¦ˆæœ‰æ°´å¢¨æ‰©æ•£åŠ¨ç”»
  - é˜¶æ®µåˆ‡æ¢ä¸ºå·è½´å±•å¼€/ç¥¥äº‘æµåŠ¨ï¼Œæ•´ä½“è¿‡æ¸¡å¹³æ»‘

## 5. Core Gameplay Elements

### 5.1 Panda Companion Visualization
The Panda companion is the emotional heart of the app and features:

- **Growth Stages**:
  - Infant: Small, extra fluffy with large eyes and playful movements
  - Youth: More active, curious expressions, developing unique personality
  - Adult: Graceful, wise appearance with confident posture
  - Perfect Form: Majestic presence with subtle glow effects and special animations

- **Emotional States**:
  - Happy: Bright eyes, smiling expression, energetic movements
  - Neutral: Calm demeanor, regular breathing animation
  - Concerned: Gentle head tilt, softer movements, attentive gaze

- **Customization Visualization**:
  - Seamless integration of accessories and clothing
  - Environment decorations that the Panda interacts with
  - Special effects for rare or VIP items

### 5.2 Resource System Visualization
Resources are presented with premium visual treatment:

- **Resource Icons**:
  - Bamboo: Detailed, realistic bamboo stalks with subtle shine
  - Water: Crystal-clear droplets with light refraction effects
  - Coins: Ornate gold coins with embossed panda design
  - Diamonds: Multi-faceted gems with light reflection and sparkle

- **Resource Animations**:
  - Collection: Satisfying gather animation with particle effects
  - Spending: Elegant transfer animation from inventory to use
  - Low resources: Subtle visual indicator without being punitive
  - Resource milestone: Special celebration animation

### 5.3 Timely Reward System Visualization
The Timely Reward System features premium visual elements:

- **Timeliness Bar**:
  - Elegant scroll or bamboo-themed progress indicator
  - Rich fill animation with particle effects
  - Reward preview with subtle highlight animation
  - Completion celebration with luxurious visual effects

- **Luck Points**:
  - Premium counter with sparkle animation
  - Earning visualization with floating point animation
  - Accumulation milestone effects with special visual treatment

- **On-Time Completion**:
  - Satisfying visual feedback for timely task completion
  - Special animation for "Early Bird" bonus
  - Elegant visual connection between task completion and rewards

### 5.4 Challenge System Visualization
Challenges are presented with immersive visual elements:

- **Challenge Categories**:
  - Visual theming for different challenge types
  - Custom illustrations for challenge backgrounds
  - Animated transitions between categories

- **Progress Tracking**:
  - Rich progress bar design with milestone markers
  - Sub-task completion visualization with elegant checkmarks
  - Time remaining indicator with premium countdown design

- **Reward Presentation**:
  - Treasure chest or gift box animation for claiming rewards
  - Particle effects and sound design for celebration
  - Reward showcase with detailed item presentation

## 6. Monetization Design

### 6.1 VIPè®¢é˜… UI/UX è®¾è®¡ä¸ä»˜è´¹å¼•å¯¼ç­–ç•¥

PandaHabit çš„VIPè®¢é˜…ä½“ç³»é‡‡ç”¨åˆ†å±‚ã€ä»·å€¼é©±åŠ¨ã€æ¸¸æˆåŒ–ä½“éªŒä¸ç”¨æˆ·å¿ƒç†æ¿€åŠ±ç›¸ç»“åˆçš„è®¾è®¡ï¼Œå…¨é¢èåˆChecklist 2.0ä¸æœ€æ–°å¢é•¿ç­–ç•¥ï¼Œå…·ä½“åŒ…æ‹¬ï¼š

#### 6.1.1 VIPç‰¹æƒå¯è§†åŒ–ä¸å·®å¼‚åŒ–
- ä¸»é¡µã€ä¸ªäººèµ„æ–™ã€æ’è¡Œæ¦œç­‰å¤„ï¼ŒVIPç”¨æˆ·æ‹¥æœ‰ä¸“å±å¾½ç« ã€åŠ¨æ€å…‰æ•ˆã€æ˜µç§°ç‰¹æ®Šæ ‡è¯†ã€‚
- VIPæƒç›Šæ€»è§ˆé¡µï¼šé‡‡ç”¨å¯¹æ¯”å¡ç‰‡æ¸…æ™°å±•ç¤ºå…è´¹ä¸VIPçš„æ ¸å¿ƒå·®å¼‚ï¼ˆå¦‚å¥–åŠ±å€å¢ã€æˆé•¿åŠ é€Ÿã€ä¸“å±å¤–è§‚/ä»»åŠ¡/è¯¾ç¨‹ç­‰ï¼‰ï¼Œé…åˆé«˜äº®åŠ¨ç”»ä¸è§†è§‰å¼ºåŒ–ã€‚
- ä»»åŠ¡ã€æˆé•¿ã€æŠ½å¥–ç­‰å…³é”®èŠ‚ç‚¹ï¼ŒVIPé¢å¤–å¥–åŠ±ä»¥é‡‘è‰²é«˜äº®ã€çš‡å† æ ‡è®°ã€ç²’å­ç‰¹æ•ˆç­‰æ–¹å¼å³æ—¶åé¦ˆï¼Œæœªè®¢é˜…ç”¨æˆ·å¯è§ç°è‰²é¢„è§ˆå¹¶å¼•å¯¼å‡çº§ã€‚

#### 6.1.2 æ™ºèƒ½åŒ–ä»˜è´¹åœºæ™¯ä¸å¼¹çª—å¼•å¯¼
- å…³é”®æ—¶åˆ»ï¼ˆå¦‚ç†ŠçŒ«è¿›åŒ–ã€æŒ‘æˆ˜è¾¾æˆã€ç¨€æœ‰å¥–åŠ±è·å¾—ï¼‰å¼¹çª—åº†ç¥å¹¶é¡ºåŠ¿æ¨èVIPæƒç›Šï¼ŒæŒ‰é’®æ–‡æ¡ˆä¸è§†è§‰å¼ºåŒ–â€œç«‹å³å‡çº§äº«æ›´å¤šæƒŠå–œâ€ã€‚
- ç”¨æˆ·é‡åˆ°ç“¶é¢ˆã€èµ„æºçŸ­ç¼ºã€åŠŸèƒ½å—é™æ—¶ï¼Œå¼¹å‡ºæ¸©å’Œæç¤ºæ¡/æ°”æ³¡ï¼Œè¯´æ˜VIPå¯å¸¦æ¥çš„ä¾¿åˆ©ä¸åŠ é€Ÿã€‚
- è®¿é—®VIPä¸“å±å†…å®¹æ—¶ï¼Œå¼¹çª—ç®€æ˜ä»‹ç»è¯¥åŠŸèƒ½ä¼˜åŠ¿ï¼Œå¹¶æä¾›â€œäº†è§£å®ˆæŠ¤è€…ç‰¹æƒâ€å…¥å£ã€‚

#### 6.1.3 çµæ´»è®¢é˜…ä½“ç³»ä¸è¯•ç”¨/æŒ½ç•™æœºåˆ¶
- è®¢é˜…é€‰æ‹©é¡µé‡‡ç”¨å¡ç‰‡å¼å¹¶åˆ—å¸ƒå±€ï¼Œçªå‡ºâ€œæ¨èâ€ä¸â€œæœ€ä½³ä»·å€¼â€æ¡£ä½ï¼Œæ¸…æ™°åˆ—å‡ºä»·æ ¼ã€æƒç›Šã€å¹³å‡æœˆè´¹ã€‚
- æ–°ç”¨æˆ·/æ´»åŠ¨æœŸé—´å¼¹çª—å¼•å¯¼å…è´¹è¯•ç”¨VIPï¼Œè¯•ç”¨æœŸé—´ç•Œé¢ä¸´æ—¶æ˜¾ç¤ºVIPæ ‡è¯†ï¼Œç›¸å…³åŠŸèƒ½è§£é”ã€‚
- è¯•ç”¨åˆ°æœŸå‰å¼¹çª—æ•°æ®åŒ–å›é¡¾è¯•ç”¨æœŸé—´è·å¾—çš„é¢å¤–ä»·å€¼ï¼Œå¼ºåŒ–è½¬åŒ–æ„æ„¿ã€‚
- ç”¨æˆ·å°è¯•å–æ¶ˆè®¢é˜…æ—¶ï¼Œåˆ†é˜¶æ®µå¼¹çª—æŒ½ç•™ï¼šå…ˆæƒ…æ„ŸæŒ½ç•™ï¼ˆç†ŠçŒ«è¡¨æƒ…ï¼‰ã€å†æä¾›ä¼˜æƒ /é™çº§/ä¼‘çœ é€‰é¡¹ï¼Œæœ€åå¼•å¯¼å¡«å†™åé¦ˆï¼Œå§‹ç»ˆä¿è¯é€€å‡ºè·¯å¾„æ¸…æ™°ã€‚

#### 6.1.4 ç¤¾äº¤è®¤åŒä¸è£èª‰æ¿€åŠ±
- å•†åº—ã€ä¸»åŸã€æ’è¡Œæ¦œç­‰å¤„ä½é¢‘æ»šåŠ¨æ˜¾ç¤ºâ€œç©å®¶XXXåˆšåˆšæˆä¸ºVIPâ€ï¼Œå¢å¼ºç¤¾äº¤å½±å“ã€‚
- å›¢é˜ŸæŒ‘æˆ˜ä¸­ï¼Œé˜Ÿä¼æœ‰VIPæˆå‘˜æ—¶å…¨é˜Ÿè·å¾—å°å¹…å¢ç›Šã€‚
- è®¢é˜…ä¸“å±æˆå°±ã€ç§°å·ç³»ç»Ÿï¼ŒVIPç”¨æˆ·å¯è£…å¤‡å¸¦æœ‰ç‰¹æ®Šè§†è§‰æ•ˆæœçš„è£èª‰ç§°å·ã€‚

#### 6.1.5 è½¬åŒ–ä¸A/Bæµ‹è¯•ä¼˜åŒ–
- æ‰€æœ‰ä»˜è´¹æç¤ºä¸å¼¹çª—å‡ä¸ç”¨æˆ·å½“å‰åœºæ™¯éœ€æ±‚ç´§å¯†å…³è”ï¼Œçªå‡ºVIPå¸¦æ¥çš„å®é™…å¥½å¤„ã€‚
- ä»˜è´¹å¼•å¯¼æ–‡æ¡ˆã€æŒ‰é’®ã€å¸ƒå±€ã€è§¦å‘æ—¶æœºç­‰å‡çº³å…¥A/Bæµ‹è¯•ï¼ŒæŒç»­æ•°æ®é©±åŠ¨ä¼˜åŒ–ã€‚
- ä¿è¯æ ¸å¿ƒå…è´¹ä½“éªŒå®Œæ•´ï¼ŒVIPæ›´å¤šä¸ºåŠ é€Ÿä¸å¢å€¼ï¼Œé¿å…â€œä»˜è´¹å¢™â€é˜»å¡ã€‚

#### 6.1.6 å‰ç»æ€§æ¢ç´¢ä¸åˆ›æ–°
- é¢„ç•™NFTå¾½ç« ã€UGCæ¿€åŠ±ã€ç°å®è”åŠ¨ç­‰åˆ›æ–°ä»˜è´¹æ¨¡å¼æ¥å£ã€‚

### 6.2 å•†åº—ä¸VIPå•†å“ä½“éªŒ
- å•†åº—é¦–é¡µBannerã€åˆ†ç±»æ ‡ç­¾ã€å•†å“å¡ç‰‡å‡çªå‡ºVIPä¸“å±å†…å®¹ï¼ŒVIPå•†å“æœ‰ç‰¹æ®Šå…‰æ•ˆä¸è§’æ ‡ã€‚
- è´­ä¹°æµç¨‹é…åˆç²’å­çˆ†å‘ã€ç‰ç’§/ç¥¥äº‘åŠ¨ç”»ï¼ŒVIPå•†å“è´­ä¹°éœ€éªŒè¯VIPèº«ä»½ã€‚
- VIPä¸“å±ç¤¼åŒ…ã€é™æ—¶ä¼˜æƒ ã€é¦–è´­ç¤¼åŒ…ç­‰å‡æœ‰åŠ¨æ€å€’è®¡æ—¶ä¸è§†è§‰å¼ºåŒ–ã€‚

### 6.3 å…³é”®ç•Œé¢ä¸æµç¨‹è¡¥å……
- ä¸»é¡µã€ä»»åŠ¡é¡µã€æˆé•¿é¡µç­‰å¤„ï¼ŒVIPç›¸å…³å…¥å£ã€å¥–åŠ±ã€åŠŸèƒ½å‡æœ‰é«˜äº®ã€åŠ¨ç”»ã€ä¸“å±æ ‡è¯†ã€‚
- è®¢é˜…åˆ°æœŸå‰ï¼Œéƒ¨åˆ†VIPç‰¹æƒå›¾æ ‡é€æ¸å˜ç°æˆ–åŠ é”ï¼Œé…åˆå€’è®¡æ—¶å¼¹çª—æé†’ç»­è®¢ã€‚
- è¯•ç”¨ã€è½¬åŒ–ã€æŒ½ç•™ã€ç¤¾äº¤æ¿€åŠ±ç­‰æ‰€æœ‰æµç¨‹å‡æœ‰è¯¦ç»†å¼¹çª—ã€æŒ‰é’®ã€åŠ¨ç”»ä¸æ–‡æ¡ˆè®¾è®¡ï¼Œç¡®ä¿ä½“éªŒæµç•…ä¸”å…·å¸å¼•åŠ›ã€‚

### 6.4 æ•°æ®é©±åŠ¨ä¸å…¬å¹³æ€§ä¿éšœ
- å…¨è·¯å¾„è½¬åŒ–è¿½è¸ªã€ç”¨æˆ·åˆ†å±‚ã€è¡Œä¸ºåˆ†æã€é€€è®¢åŸå› æ”¶é›†ç­‰æ•°æ®åŸ‹ç‚¹ï¼ŒæŒç»­ä¼˜åŒ–ä»˜è´¹å¼•å¯¼ã€‚
- æ˜ç¡®çº¢çº¿ï¼šæ ¸å¿ƒç©æ³•å¯¹æ‰€æœ‰ç”¨æˆ·å¼€æ”¾ï¼ŒVIPä»…åŠ é€Ÿ/å¢å€¼ï¼ŒPVPå¹³è¡¡ã€å®šä»·é€æ˜ã€‚

## 7. Technical Implementation Guidelines

### 7.1 Integration with Existing Codebase
The implementation will build upon the existing React/TypeScript architecture:

- Leverage the current component structure while enhancing visual elements
- Maintain the existing data flow patterns while adding new features
- Extend the current state management approach to include new game elements

### 7.2 Internationalization Approach
Building on the existing i18n infrastructure:

- Extend the current language system to include game-specific terminology
- Ensure all new UI elements support multiple languages
- Implement culturally appropriate visual elements for different regions

### 7.3 Component Structure
The component architecture will follow a modular approach:

- **Atomic Design Methodology**:
  - Atoms: Basic UI elements (buttons, inputs, icons)
  - Molecules: Compound components (task cards, reward displays)
  - Organisms: Feature sections (task list, panda interaction area)
  - Templates: Page layouts with placeholder content
  - Pages: Complete screens with real content

- **Game-Specific Components**:
  - PandaAvatar: Handles rendering and animating the Panda
  - ResourceDisplay: Manages resource visualization
  - RewardAnimation: Controls reward presentation effects
  - ChallengeTracker: Visualizes challenge progress

### 7.4 State Management
The state management approach will handle game-specific requirements:

- User progress and achievements stored in persistent state
- Real-time interactions managed with local state
- Animation states controlled with dedicated hooks
- Game mechanics (timers, random events) managed with specialized services

## 8. Appendices

### 8.1 Asset Requirements
- High-resolution Panda illustrations in various poses and growth stages
- Premium UI element designs (buttons, cards, icons)
- Environmental elements and backgrounds
- Resource and reward visualizations
- Animation sequences for key interactions

### 8.2 Animation Specifications
- Micro-interactions for UI elements (button presses, switches, sliders)
- Character animations for the Panda (idle, happy, concerned, interactions)
- Reward and achievement celebrations
- Transition effects between screens and states

### 8.3 Accessibility Considerations
- Color contrast compliance for all UI elements
- Alternative text for decorative elements
- Keyboard navigation support
- Screen reader compatibility
- Motion reduction options for animations
</file>

<file path="checklist.md">
å¥½çš„ï¼Œè¿™ä»½æ¸¸æˆåŒ–Appè®¢é˜…ä»˜è´¹å¼•å¯¼Checklistéå¸¸è¯¦å°½ï¼Œå·²ç»æ¶µç›–äº†å¾ˆå¤šå…³é”®ç‚¹ã€‚ç»“åˆYouTubeä¸Šä¸€äº›äº§å“è®¾è®¡ã€æ¸¸æˆåŒ–å’Œç”¨æˆ·å¢é•¿â€œå¤§ç¥â€ä»¬å¸¸åˆ†äº«çš„ç†å¿µï¼Œæˆ‘ä»¬å¯ä»¥ä»ä»¥ä¸‹å‡ ä¸ªæ–¹é¢è¿›è¡Œæ¢³ç†å’Œä¼˜åŒ–ï¼Œä½¿å…¶æ›´èšç„¦ã€æ›´å…·æˆ˜ç•¥æ€§ï¼Œå¹¶å¼ºè°ƒä¸€äº›ä»–ä»¬å¯èƒ½ä¼šåå¤å¼ºè°ƒçš„åŸåˆ™ï¼š

**æ ¸å¿ƒä¼˜åŒ–æ€è·¯ï¼š**

1.  **å¼ºåŒ–â€œç”¨æˆ·ä¸­å¿ƒâ€å’Œâ€œä»·å€¼é©±åŠ¨â€**ï¼šå¤§ç¥ä»¬é€šå¸¸å¼ºè°ƒï¼Œæœ€å¥½çš„ä»˜è´¹å¼•å¯¼æ˜¯è®©ç”¨æˆ·â€œå¿ƒç”˜æƒ…æ„¿â€åœ°ä»˜è´¹ï¼Œå› ä¸ºä»–ä»¬æ¸…æ™°æ„ŸçŸ¥åˆ°äº†ä»·å€¼ï¼Œè€Œä¸æ˜¯è¢«â€œå¥—è·¯â€ã€‚
2.  **ç®€åŒ–å†³ç­–ï¼Œçªå‡ºé”šç‚¹**ï¼šé¿å…è¿‡å¤šé€‰æ‹©ï¼Œåˆ©ç”¨å¿ƒç†å­¦é”šç‚¹å¼•å¯¼ç”¨æˆ·é€‰æ‹©æœ€ä¼˜æ–¹æ¡ˆã€‚
3.  **æµ‹è¯•ä¸è¿­ä»£çš„å¼ºè°ƒ**ï¼šå°†A/Bæµ‹è¯•å’Œæ•°æ®é©±åŠ¨çš„ç†å¿µæ›´æ·±åœ°èå…¥ã€‚
4.  **é•¿æœŸä¸»ä¹‰ä¸ç”¨æˆ·ä¿¡ä»»**ï¼šé¿å…çŸ­æœŸæ¦¨å–ï¼Œå»ºç«‹é•¿æœŸä¿¡ä»»å…³ç³»ã€‚
5.  **æ›´ç²¾ç‚¼çš„åˆ†ç±»å’Œå‘½å**ï¼šè®©Checklistæ›´æ˜“ç†è§£å’Œä¼ æ’­ã€‚

**ä¼˜åŒ–åçš„è®¢é˜…ä»˜è´¹å¼•å¯¼Checklistå»ºè®®ï¼š**

---

**ã€æ¸¸æˆåŒ–Appè®¢é˜…å¢é•¿é»„é‡‘æ³•åˆ™ï¼šChecklist 2.0ã€‘**

**ğŸ¯ æ ¸å¿ƒç›®æ ‡ï¼šåœ¨æå‡è®¢é˜…è½¬åŒ–çš„åŒæ—¶ï¼Œæœ€å¤§åŒ–ç”¨æˆ·ç”Ÿå‘½å‘¨æœŸä»·å€¼ (LTV) å¹¶ç»´æŠ¤å¥åº·çš„æ¸¸æˆç”Ÿæ€ã€‚**

---

### **ä¸€ã€æ¸…æ™°çš„ä»·å€¼ä¸»å¼  (Clear Value Proposition)**
*â€œè®©ç©å®¶ä¸€çœ¼çœ‹æ‡‚â€˜æˆ‘ä¸ºä»€ä¹ˆéœ€è¦è¿™ä¸ªï¼Ÿâ€™å¹¶æ„Ÿåˆ°ç‰©è¶…æ‰€å€¼ã€‚â€*

âœ… **æ ¸å¿ƒç‰¹æƒå¯è§†åŒ–ä¸å·®å¼‚åŒ–**
-   [ ] **èº«ä»½å½°æ˜¾ï¼š** è®¢é˜…èº«ä»½çš„ä¸“å±è§†è§‰æ ‡è¯†ï¼ˆå¦‚ç‰¹æ®Šå¤´åƒæ¡†ã€åŠ¨æ€ç§°å·ã€èŠå¤©æ°”æ³¡ã€è§’è‰²å…‰ç¯ï¼‰ã€‚
-   [ ] **åŠŸèƒ½/æ•ˆç‡å¯¹æ¯”ï¼š** æ¸…æ™°å±•ç¤ºè®¢é˜…ç‰ˆåœ¨æ ¸å¿ƒä½“éªŒä¸Šçš„æ˜¾è‘—ä¼˜åŠ¿ï¼ˆä¾‹å¦‚ï¼šå…è´¹ç‰ˆå»ºé€ è€—æ—¶1å°æ—¶ vs è®¢é˜…ç‰ˆ15åˆ†é’Ÿï¼Œå¹¶é…æœ‰åŠ é€ŸåŠ¨ç”»ï¼›å…è´¹æ¯æ—¥å¥–åŠ±x1 vs è®¢é˜…x3ï¼‰ã€‚
-   [ ] **å³æ—¶æ”¶ç›Šåé¦ˆï¼š** åœ¨å…³é”®èŠ‚ç‚¹ï¼ˆå¦‚æˆ˜æ–—èƒœåˆ©ã€ä»»åŠ¡å®Œæˆã€å‡çº§ï¼‰æ˜ç¡®å±•ç¤ºè®¢é˜…å¸¦æ¥çš„â€œé¢å¤–â€å³æ—¶æ”¶ç›Šï¼ˆå¦‚é¢å¤–ç»éªŒæ¡ã€ä¸“å±æ‰è½ç‰©å›¾æ ‡+æ•°é‡ï¼Œé…åˆéŸ³æ•ˆå’Œç²’å­æ•ˆæœï¼‰ã€‚
-   [ ] **â€œè§£é”â€å‹æ¿€åŠ±ï¼š** å·§å¦™å±•ç¤ºè®¢é˜…å¯è§£é”çš„å†…å®¹æˆ–åŠ é€Ÿçš„è¿›åº¦ï¼Œä¾‹å¦‚â€œè®¢é˜…å³å¯ç«‹å³ä½“éªŒåç»­ç« èŠ‚/è·å¾—é«˜çº§èµ„æºåŒ…/è§£é”ä¸“å±è§’è‰²æ•…äº‹çº¿â€ã€‚

âœ… **è¥é€ â€œæ‹¥æœ‰æ„Ÿâ€ä¸â€œæŸå¤±è§„é¿â€å¿ƒç†**
-   [ ] **è®¢é˜…ç‰¹æƒâ€œé¢„è§ˆâ€/â€œé™æ—¶ä½“éªŒâ€ï¼š** å…è®¸å…è´¹ç©å®¶çŸ­æš‚ä½“éªŒéƒ¨åˆ†æ ¸å¿ƒè®¢é˜…åŠŸèƒ½ï¼ˆå¦‚å…³é”®æˆ˜æ–—å‰â€œæœ¬æ¬¡æˆ˜æ–—å¯è¯•ç”¨VIPæ€¥é€Ÿæ¨¡å¼â€ï¼‰ï¼Œä½“éªŒåæç¤ºâ€œè®¢é˜…ä¿ç•™æ­¤ç‰¹æƒâ€ã€‚
-   [ ] **èµ„æº/æ—¶é—´èŠ‚çœæç¤ºï¼š** å½“ç©å®¶é¢ä¸´èµ„æºçŸ­ç¼ºæˆ–è€—æ—¶æ“ä½œæ—¶ï¼Œé€‚æ—¶æç¤ºè®¢é˜…å¦‚ä½•é«˜æ•ˆè§£å†³é—®é¢˜ï¼ˆä¾‹å¦‚â€œè®¢é˜…ç«‹äº«æ¯æ—¥å…è´¹ä½“åŠ›è¡¥ç»™/å»ºé€ é˜Ÿåˆ—+1â€ï¼‰ã€‚
-   [ ] **è®¢é˜…åˆ°æœŸæé†’ä¸ä»·å€¼é‡ç”³ï¼š** åˆ°æœŸå‰é€šè¿‡è§†è§‰åŒ–å€’è®¡æ—¶ï¼ˆå¦‚é€æ¸â€œå˜ç°â€çš„ç‰¹æƒå›¾æ ‡ï¼‰ã€æƒé™â€œé€æ­¥å¤±æ•ˆâ€é¢„è§ˆç­‰æ–¹å¼æé†’ï¼Œå¹¶é‡ç”³è®¢é˜…æœŸé—´å·²äº«å—çš„ä»·å€¼æˆ–â€œè‹¥ç»­è®¢å¯ç»§ç»­äº«æœ‰XXç‰¹æƒâ€ã€‚

---

### **äºŒã€æ™ºèƒ½åŒ–çš„ä»˜è´¹åœºæ™¯ (Intelligent Payment Scenarios)**
*â€œåœ¨ç©å®¶æœ€éœ€è¦ã€æœ€æ¸´æœ›æˆ–æƒ…ç»ªæœ€é«˜æ¶¨çš„æ—¶åˆ»ï¼Œè‡ªç„¶åœ°å‘ˆç°æœºä¼šã€‚â€*

âœ… **å…³é”®æ—¶åˆ»ä¸æƒ…æ„Ÿè¿æ¥**
-   [ ] **é«˜å…‰æ—¶åˆ»åŠ©æ¨ï¼š** åœ¨ç©å®¶è·å¾—æˆå°±ã€ç¨€æœ‰æ‰è½ã€é™©èƒœPVPç­‰ç§¯ææƒ…ç»ªé¡¶ç‚¹ï¼Œé€‚æ—¶æ¨èç›¸å…³è®¢é˜…å¢ç›Šï¼ˆå¦‚â€œè®¢é˜…åæ­¤ç±»å¥–åŠ±ç¿»å€/æ°¸ä¹…æå‡çˆ†ç‡/è§£é”ä¸“å±åº†ç¥åŠ¨ä½œâ€ï¼‰ã€‚
-   [ ] **ç—›ç‚¹è§£å†³æ–¹æ¡ˆï¼š** åœ¨ç©å®¶é‡åˆ°æŒ«æŠ˜ã€ç“¶é¢ˆï¼ˆå¦‚PVPè¿ç»­å¤±è´¥ã€é«˜éš¾åº¦å…³å¡å¡å…³ã€é‡è¦ç‰©å“åˆæˆå¤±è´¥ï¼‰æ—¶ï¼Œæä¾›è®¢é˜…ä½œä¸ºâ€œä¼˜é›…â€çš„è§£å†³æ–¹æ¡ˆï¼ˆå¦‚è®¢é˜…ä¸“äº«â€œå†è¯•ä¸€æ¬¡â€æœºä¼šã€â€œå±æ€§ä¸´æ—¶å¢å¼ºâ€é“å…·ã€â€œä¿åº•æˆåŠŸç‡â€ç‰¹æƒï¼‰ã€‚
-   [ ] **ç¤¾äº¤å¯¹æ¯”ä¸å‘å¾€ï¼š** åœ¨æ’è¡Œæ¦œã€å¥½å‹åˆ—è¡¨ã€è§‚æˆ˜ç­‰åœºæ™¯ï¼Œæ¸…æ™°å±•ç¤ºé«˜é˜¶ç©å®¶çš„è®¢é˜…æ ‡è¯†åŠå…¶å¸¦æ¥çš„å¯è§ä¼˜åŠ¿ï¼ˆå¦‚ä¸“å±å¤–è§‚ã€æ›´é«˜æ’ååŠ æˆï¼‰ï¼Œæ¿€å‘å‘å¾€ã€‚

âœ… **é™æ—¶ç¨€ç¼ºä¸é¦–è´­æ¿€åŠ±**
-   [ ] **åŠ¨æ€åŒ–é™æ—¶ä¼˜æƒ ï¼š** å•†åŸæˆ–ç‰¹å®šè§¦å‘ç‚¹å‡ºç°â€œä»…å‰©XXå°æ—¶ï¼šæ–°æ‰‹ç‰¹æƒ è®¢é˜…åŒ…/èŠ‚æ—¥é™å®šè®¢é˜…ç¤¼é‡â€ï¼ˆé…åˆå€’è®¡æ—¶å™¨ï¼‰ã€‚
-   [ ] **é‡Œç¨‹ç¢‘å¼é¦–è´­ç¤¼åŒ…ï¼š** æ–°ç©å®¶åœ¨ç‰¹å®šæ¸¸æˆè¿›åº¦æˆ–æ³¨å†Œæ—¶é•¿å†…ï¼ˆå¦‚å®Œæˆæ–°æ‰‹æ•™ç¨‹å/æ³¨å†Œ3å¤©å†…ï¼‰è§£é”çš„ä¸€æ¬¡æ€§é«˜ä»·å€¼é¦–è´­è®¢é˜…åŒ…ã€‚
-   [ ] **è®¢é˜…ä¸“äº«å†…å®¹/æ´»åŠ¨ï¼š** æä¾›è®¢é˜…ç”¨æˆ·æ‰èƒ½å®Œæ•´ä½“éªŒçš„å‰¯æœ¬ã€æ´»åŠ¨ã€å‰§æƒ…æˆ–åŒºåŸŸï¼ˆå…è®¸å…è´¹ç©å®¶â€œè¯•ç©â€æˆ–â€œé¢„è§ˆâ€ä¸€å°éƒ¨åˆ†ä»¥æ¿€å‘å…´è¶£ï¼‰ã€‚

---

### **ä¸‰ã€çµæ´»çš„è®¢é˜…ä½“ç³» (Flexible Subscription System)**
*â€œæä¾›é€‰æ‹©ï¼Œä½†å·§å¦™å¼•å¯¼ï¼›é‡è§†é¦–è´­ï¼Œæ›´è¦åŸ¹å…»é•¿æœŸå¿ è¯šã€‚â€*

âœ… **å¤šå±‚æ¬¡ä¸å¢å€¼é€‰é¡¹**
-   [ ] **é”šç‚¹å®šä»·ä¸ä»·å€¼æ‰“åŒ…ï¼š** æä¾›è‡³å°‘2-3æ¡£è®¢é˜…é€‰é¡¹ï¼ˆå¦‚åŸºç¡€ç‰ˆ/é«˜çº§ç‰ˆ/å°Šäº«ç‰ˆï¼Œæˆ–æœˆå¡/å­£å¡/å¹´å¡ï¼‰ï¼Œæ¸…æ™°æ ‡æ³¨æ¯æ¡£æ ¸å¿ƒæƒç›Šå·®å¼‚å’Œâ€œæ¯å…ƒä»·å€¼æ¯”â€ï¼Œé»˜è®¤æ¨èæˆ–é«˜äº®â€œæœ€å—æ¬¢è¿â€/â€œæœ€ä½³ä»·å€¼â€é€‰é¡¹ã€‚
-   [ ] **â€œä¸€æ­¥åˆ°ä½â€çš„é•¿æœŸè®¢é˜…æ¿€åŠ±ï¼š** å¼ºè°ƒå¹´å¡ç­‰é•¿æœŸè®¢é˜…çš„æè‡´æ€§ä»·æ¯”å’Œé¢å¤–ä¸“å±å¥–åŠ±ï¼ˆå¦‚â€œå¹´å¡ç”¨æˆ·é¢å¤–èµ é€ç»ç‰ˆçš®è‚¤+æ¯æœˆç‰¹æƒç¤¼åŒ…â€ï¼‰ã€‚
-   [ ] **å åŠ å¼/ä¸»é¢˜å¼å°é¢è®¢é˜…ï¼š** è€ƒè™‘æ¨å‡ºé’ˆå¯¹ç‰¹å®šéœ€æ±‚çš„å°é¢è®¢é˜…åŒ…ï¼ˆå¦‚â€œå»ºé€ åŠ é€Ÿæœˆç¥¨â€ã€â€œPVPç•…è¡Œè¯â€ï¼‰ï¼Œå¯ä¸ä¸»è®¢é˜…å åŠ ã€‚

âœ… **ä½é—¨æ§›è¯•ç”¨ä¸ç²¾ç»†åŒ–æŒ½ç•™**
-   [ ] **â€œæ— é£é™©â€å…è´¹è¯•ç”¨ï¼š** æä¾›é™æ—¶ï¼ˆå¦‚3-7å¤©ï¼‰æ ¸å¿ƒVIPåŠŸèƒ½å…è´¹è¯•ç”¨ï¼Œç»“åˆè¯•ç”¨ä¸“å±ä»»åŠ¡å¼•å¯¼ç”¨æˆ·å……åˆ†ä½“éªŒä»·å€¼ã€‚
-   [   ] **è¯•ç”¨æœŸä»·å€¼å›é¡¾ï¼š** è¯•ç”¨ç»“æŸå‰1-2å¤©ï¼Œé€šè¿‡æ•°æ®åŒ–â€œæˆå°±æŠ¥å‘Šâ€æˆ–â€œä»·å€¼æ€»ç»“â€å¼¹çª—ï¼ˆå¦‚â€œè¯•ç”¨æœŸé—´æ‚¨å·²é¢å¤–è·å¾—XXèµ„æºï¼ŒèŠ‚çœXXæ—¶é—´â€ï¼‰å¼ºåŒ–è®¢é˜…æ¬²æœ›ã€‚
-   [ ] **äººæ€§åŒ–æŒ½ç•™ç­–ç•¥ï¼š** åœ¨ç”¨æˆ·å°è¯•é€€è®¢æ—¶ï¼Œæä¾›é™çº§é€‰é¡¹ï¼ˆä¿ç•™éƒ¨åˆ†æ ¸å¿ƒç‰¹æƒï¼‰ã€ä¸´æ—¶æŠ˜æ‰£ã€ä¼‘çœ ç‰¹æƒä¿ç•™ï¼ˆâ€œæš‚åœè®¢é˜…Xä¸ªæœˆï¼Œæƒç›Šå†»ç»“â€ï¼‰æˆ–é€šè¿‡äº’åŠ¨å°æ¸¸æˆæä¾›æŒ½ç•™ä¼˜æƒ ï¼Œé¿å…å¼ºç¡¬é˜»æ‹¦ã€‚

---

### **å››ã€ç¤¾äº¤è®¤åŒä¸ç«äº‰æ°›å›´ (Social Proof & Competitive Atmosphere)**
*â€œè®©ä»–äººæˆä¸ºä½ æœ€å¥½çš„æ¨é”€å‘˜ï¼Œç”¨ç«äº‰ç‚¹ç‡ƒä»˜è´¹æ¬²æœ›ã€‚â€*

âœ… **å¯è§çš„ç¤¾äº¤å½±å“åŠ›**
-   [ ] **å®æ—¶åŠ¨æ€è®¢é˜…ä¿¡æ¯ï¼š** åœ¨æ”¯ä»˜é¡µé¢æˆ–ä¸»åŸç­‰åŒºåŸŸï¼Œé€‚åº¦æ»šåŠ¨æ˜¾ç¤ºâ€œç©å®¶XXXåˆšåˆšåŠ å…¥äº†VIPè¡Œåˆ—ï¼â€ï¼ˆéœ€æ³¨æ„é¢‘ç‡å’ŒçœŸå®æ€§ï¼‰ã€‚
-   [ ] **å›¢é˜Ÿå¢ç›Šä¸äº’æƒ ï¼š** è®¢é˜…ç”¨æˆ·åœ¨ç»„é˜Ÿæ—¶èƒ½ä¸ºå…¨é˜Ÿå¸¦æ¥å¾®å°ä½†å¯è§çš„å¢ç›Šï¼ˆå¦‚â€œé˜Ÿä¼ä¸­æœ‰VIPæˆå‘˜ï¼Œå…¨é˜Ÿç»éªŒ+X%â€ï¼‰ï¼Œæˆ–é‚€è¯·å¥½å‹è®¢é˜…åŒæ–¹å‡å¯è·ç›Šã€‚
-   [ ] **åˆ†äº«è£‚å˜æ¿€åŠ±ï¼š** é¼“åŠ±ç©å®¶åˆ†äº«å¸¦æœ‰è®¢é˜…æ¨å¹¿ä¿¡æ¯ï¼ˆå¦‚â€œåˆ†äº«æˆ‘çš„ä¸“å±æˆ˜ç»©ï¼Œå¥½å‹ç‚¹å‡»å¯é¢†å–3å¤©VIPè¯•ç”¨â€ï¼‰çš„æˆå°±æˆ–ç²¾å½©æ—¶åˆ»ã€‚

âœ… **è£èª‰ä¸åœ°ä½å½°æ˜¾**
-   [ ] **æ’è¡Œæ¦œå·®å¼‚åŒ–å±•ç¤ºï¼š** Topç©å®¶åŠè®¢é˜…ç©å®¶åœ¨æ’è¡Œæ¦œä¸Šæ‹¥æœ‰é†’ç›®çš„VIPæ ‡è¯†ã€ä¸“å±èƒŒæ™¯æ¿æˆ–åŠ¨æ€æ•ˆæœã€‚
-   [ ] **å¤šç»´åº¦æ’è¡Œæ¦œï¼š** è®¾ç«‹â€œæ€»è´¡çŒ®æ¦œâ€ï¼ˆåŒ…å«ä»˜è´¹è¡Œä¸ºï¼‰ã€â€œè®¢é˜…ä¸“å±è£è€€æ¦œâ€ç­‰ï¼Œè®©ä»˜è´¹è¡Œä¸ºè·å¾—é¢å¤–è®¤å¯ã€‚
-   [ ] **è®¢é˜…ä¸“å±æˆå°±ä¸ç§°å·ï¼š** è®¾è®¡ä¸€ç³»åˆ—ä¸è®¢é˜…ç­‰çº§ã€æ—¶é•¿æˆ–æ¶ˆè´¹ç›¸å…³çš„ç‹¬ç‰¹æˆå°±å’Œç§°å·ï¼ˆå¦‚â€œçš‡å®¶èµåŠ©äººâ€ã€â€œæœˆåº¦å®ˆæŠ¤è€…â€ï¼‰ã€‚

---

### **äº”ã€æ•°æ®é©±åŠ¨ä¸ç”¨æˆ·ä½“éªŒä¿éšœ (Data-Driven & User Experience Assurance)**
*â€œç”¨æ•°æ®æŒ‡å¯¼å†³ç­–ï¼Œç”¨å…¬å¹³èµ¢å¾—äººå¿ƒï¼Œè¿™æ˜¯æŒç»­å¢é•¿çš„åŸºçŸ³ã€‚â€*

âœ… **ç²¾ç»†åŒ–åŸ‹ç‚¹ä¸æ¼æ–—åˆ†æ**
-   [ ] **å…¨è·¯å¾„è½¬åŒ–è¿½è¸ªï¼š** ç›‘æ§ä»å¼•å¯¼å…¥å£æ›å…‰ã€ç‚¹å‡»ï¼Œåˆ°æ”¯ä»˜é¡µé¢æµè§ˆã€å„æ¡£ä½é€‰æ‹©ï¼Œå†åˆ°æ”¯ä»˜æˆåŠŸçš„å®Œæ•´æ¼æ–—æ•°æ®ã€‚
-   [ ] **ç”¨æˆ·åˆ†å±‚ä¸è¡Œä¸ºåˆ†æï¼š** è¯†åˆ«é«˜æ½œåŠ›ä»˜è´¹ç”¨æˆ·ã€å·²æµå¤±è®¢é˜…ç”¨æˆ·ã€è¯•ç”¨æœªè½¬åŒ–ç”¨æˆ·ç­‰ç¾¤ä½“ï¼Œåˆ†æå…¶è¡Œä¸ºç‰¹å¾ä»¥ä¼˜åŒ–ç­–ç•¥ã€‚
-   [ ] **é€€è®¢åŸå› åˆ†æï¼š** åœ¨æŒ½ç•™ç¯èŠ‚åï¼Œå¯¹æœ€ç»ˆé€€è®¢ç”¨æˆ·è¿›è¡Œç®€çŸ­é—®å·ï¼ˆå¯é€‰ï¼‰ï¼Œæ”¶é›†é€€è®¢åŸå› æ•°æ®ã€‚

âœ… **å…¬å¹³æ€§ä¸é•¿æœŸç”Ÿæ€ç»´æŠ¤ (çº¢çº¿ï¼)**
-   [ ] **æ ¸å¿ƒä½“éªŒå®Œæ•´æ€§ï¼š** ç¡®ä¿éè®¢é˜…ç”¨æˆ·ä¹Ÿèƒ½å®Œæ•´ä½“éªŒæ¸¸æˆçš„æ ¸å¿ƒç©æ³•å’Œä¸»çº¿å‰§æƒ…ï¼Œè®¢é˜…æ›´å¤šæ˜¯â€œåŠ é€Ÿâ€æˆ–â€œå¢å€¼â€è€Œéâ€œå¿…éœ€â€ã€‚
-   [ ] **é¿å…â€œä»˜è´¹å¢™â€é˜»å¡ï¼š** å…³é”®çš„æ¸¸æˆè¿›ç¨‹ä¸åº”è¢«ç¡¬æ€§ä»˜è´¹å¢™å®Œå…¨å¡æ­»ã€‚
-   [ ] **PVPå¹³è¡¡æ€§è€ƒé‡ï¼š** ä»˜è´¹å¸¦æ¥çš„PVPä¼˜åŠ¿åº”æ§åˆ¶åœ¨åˆç†èŒƒå›´ï¼Œé¿å…ä¸¥é‡ç ´åç«æŠ€å…¬å¹³æ€§ï¼ˆå¯é€šè¿‡åŒ¹é…æœºåˆ¶ã€æ•°å€¼è°ƒæ•´ç­‰å¹³è¡¡ï¼‰ã€‚
-   [ ] **é€æ˜åŒ–å®šä»·ä¸è¥é”€ï¼š** æœç»è™šå‡å®£ä¼ ã€æ¨¡ç³Šå®šä»·å’Œæ°¸ä¹…æ€§â€œé™æ—¶â€æŠ˜æ‰£ï¼Œä¿æŒè¥é”€æ´»åŠ¨çš„çœŸå®æ€§ä¸è¯šä¿¡ã€‚

---

### **å…­ã€å‰ç»æ€§æ¢ç´¢ (Forward-Looking Exploration) (å¯é€‰ï¼Œå°æ­¥å¿«è·‘)**
*â€œä¿æŒåˆ›æ–°ï¼Œæ¢ç´¢æœªæ¥ä»˜è´¹æ¨¡å¼çš„å¯èƒ½æ€§ã€‚â€*

ğŸ”˜ **Web3/å…ƒå®‡å®™æ•´åˆ**
-   [ ] è®¢é˜…ç”¨æˆ·å¯è·å¾—é™é‡ç‰ˆNFTå¾½ç« /æ•°å­—è—å“ï¼Œæˆ–åœ¨åˆä½œçš„å…ƒå®‡å®™å¹³å°ä¸­äº«æœ‰ç‰¹æ®Šèº«ä»½æ ‡è¯†ï¼ˆè¯„ä¼°å®é™…ç”¨æˆ·ä»·å€¼ä¸å®ç°æˆæœ¬ï¼‰ã€‚
ğŸ”˜ **å†…å®¹å…±åˆ›ä¸æ¿€åŠ±**
-   [ ] è®¢é˜…ç”¨æˆ·äº«æœ‰æ›´é«˜çº§çš„UGCç¼–è¾‘å™¨æƒé™ï¼Œå…¶åˆ›ä½œçš„ä¼˜è´¨å†…å®¹è‹¥è¢«å®˜æ–¹é‡‡çº³æˆ–æ¨å¹¿å¯è·å¾—æ¸¸æˆå†…å¥–åŠ±æˆ–å°é¢åˆ†æ¶¦ã€‚
ğŸ”˜ **ç°å®è”åŠ¨ä¸å“ç‰Œå»¶ä¼¸**
-   [ ] è®¢é˜…ç”¨æˆ·äº«æœ‰æ¸¸æˆå‘¨è¾¹æŠ˜æ‰£ã€çº¿ä¸‹æ´»åŠ¨ä¼˜å…ˆå‚ä¸æƒæˆ–é—¨ç¥¨ä¼˜æƒ ç­‰ã€‚

---

**âš¡ å®æ–½æ ¸å¿ƒåŸåˆ™ä¸ç­–ç•¥ âš¡**

1.  **ç”¨æˆ·æ´å¯Ÿå…ˆè¡Œï¼š** æ·±å…¥ç†è§£ä½ çš„ç›®æ ‡ç”¨æˆ·ï¼Œä»–ä»¬çš„æ ¸å¿ƒéœ€æ±‚ã€ç—›ç‚¹ä»¥åŠå¯¹ä»˜è´¹çš„çœŸå®æ€åº¦ã€‚
2.  **ä»·å€¼å‰ç½®ï¼Œä»˜è´¹åç½®ï¼š** å…ˆè®©ç”¨æˆ·å……åˆ†æ„ŸçŸ¥å’Œä½“éªŒåˆ°è®¢é˜…çš„æ½œåœ¨å¥½å¤„ï¼Œå†å¼•å¯¼ä»˜è´¹ã€‚
3.  **A/Bæµ‹è¯•æ–‡åŒ–ï¼š**
    *   **å…³é”®å˜é‡ï¼š** ä»˜è´¹å¼•å¯¼æ–‡æ¡ˆï¼ˆæƒ…æ„Ÿvsåˆ©ç›Šï¼‰ã€å¼¹çª—æ—¶æœºï¼ˆæˆå°±åvså¤±è´¥åï¼‰ã€ä»·æ ¼é”šç‚¹ã€æƒç›Šç»„åˆã€è§†è§‰è®¾è®¡ç­‰ã€‚
    *   **å°èŒƒå›´æµ‹è¯•ï¼Œæ•°æ®éªŒè¯ï¼Œé€æ­¥æ¨å¹¿ã€‚**
4.  **MVPä¸å¿«é€Ÿè¿­ä»£ï¼š** ä»å½±å“æœ€å¤§çš„å‡ ä¸ªç‚¹å¼€å§‹ï¼ˆå¦‚åœºæ™¯åŒ–è§¦å‘ã€ä»·å€¼å¯è§†åŒ–ï¼‰ï¼Œå¿«é€Ÿä¸Šçº¿éªŒè¯ï¼Œæ ¹æ®æ•°æ®åé¦ˆæŒç»­ä¼˜åŒ–ã€‚
5.  **é•¿æœŸè§†è§’ï¼š** å…³æ³¨LTVè€ŒéçŸ­æœŸARPUï¼Œè­¦æƒ•æ¶¸æ³½è€Œæ¸”ã€‚ç”¨æˆ·ä¿¡ä»»æ˜¯æœ€é«˜å£å’ã€‚
6.  **çº¢çº¿è‡ªæŸ¥ï¼š** å®šæœŸï¼ˆå¦‚æ¯æœˆï¼‰å®¡è§†æ˜¯å¦è§¦ç¢°â€œäº”ã€æ•°æ®é©±åŠ¨ä¸ç”¨æˆ·ä½“éªŒä¿éšœâ€ä¸­çš„å…¬å¹³æ€§æ¡æ¬¾ã€‚

**ğŸ“ˆ æ ¸å¿ƒè¿½è¸ªæŒ‡æ ‡ (ç¤ºä¾‹ç›®æ ‡å€¼) ğŸ“ˆ**
*   **ä»˜è´¹è½¬åŒ–ç‡ (Pay Point Conversion Rate):** å„ä»˜è´¹å¼•å¯¼ç‚¹çš„è½¬åŒ–è¡¨ç°ã€‚
*   **é¦–æ¬¡è®¢é˜…è½¬åŒ–ç‡ (First-Time Subscriber Conversion Rate)**
*   **è¯•ç”¨-è½¬-ä»˜è´¹è½¬åŒ–ç‡ (Trial-to-Paid Conversion Rate)**
*   **ä»˜è´¹æ¸—é€ç‡ (Paying User Penetration Rate)** (ç›®æ ‡ > 8-12% å–å†³äºæ¸¸æˆç±»å‹)
*   **ARPPU (Average Revenue Per Paying User)**
*   **è®¢é˜…ç”¨æˆ· LTV (Lifetime Value)**
*   **è®¢é˜…ç”¨æˆ·ç•™å­˜ç‡ (Subscriber Retention Rate - æ¬¡æœˆã€å­£åº¦)** (ç›®æ ‡æ¬¡æœˆ > 60-70%)
*   **é¦–å……ç”¨æˆ·7æ—¥/30æ—¥å›è´­ç‡ (First Purchase 7/30-Day Repurchase Rate)** (ç›®æ ‡7æ—¥ > 25-35%)

---

**è¿™ä»½ä¼˜åŒ–åçš„Checklistæ›´å¼ºè°ƒæˆ˜ç•¥æ€è€ƒã€ç”¨æˆ·å¿ƒç†å’Œæ•°æ®é©±åŠ¨ï¼Œå¸Œæœ›èƒ½å¸®åŠ©å›¢é˜Ÿæ„å»ºä¸€ä¸ªæ›´å¥åº·ã€æ›´å¯æŒç»­çš„æ¸¸æˆåŒ–Appè®¢é˜…ç”Ÿæ€ã€‚**
</file>

<file path="docs/data-sync-architecture.md">
# ç†ŠçŒ«ä¹ æƒ¯ - æ•°æ®åŒæ­¥ä¸å±€éƒ¨åˆ·æ–°æ¶æ„

## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æè¿°äº†ç†ŠçŒ«ä¹ æƒ¯åº”ç”¨ä¸­çš„æ•°æ®åŒæ­¥å’Œå±€éƒ¨åˆ·æ–°æ¶æ„ï¼ŒåŒ…æ‹¬æ•°æ®æµã€åŒæ­¥æœºåˆ¶å’ŒUIæ›´æ–°ç­–ç•¥ã€‚è¿™ç§æ¶æ„æ—¨åœ¨æä¾›é«˜æ•ˆçš„æ•°æ®ç®¡ç†å’Œå“åº”å¼ç”¨æˆ·ç•Œé¢ï¼ŒåŒæ—¶ä¿æŒè‰¯å¥½çš„ç¦»çº¿åŠŸèƒ½ã€‚

## 2. æ ¸å¿ƒç»„ä»¶

### 2.1 æ•°æ®åŒæ­¥æœåŠ¡ (dataSyncService)

æ•°æ®åŒæ­¥æœåŠ¡è´Ÿè´£ç®¡ç†åº”ç”¨æ•°æ®ä¸åç«¯æœåŠ¡å™¨ä¹‹é—´çš„åŒæ­¥ã€‚å®ƒæä¾›ä»¥ä¸‹åŠŸèƒ½ï¼š

- **åŒæ­¥é˜Ÿåˆ—ç®¡ç†**ï¼šè·Ÿè¸ªéœ€è¦åŒæ­¥çš„æ•°æ®é¡¹
- **è‡ªåŠ¨åŒæ­¥**ï¼šå®šæœŸå°è¯•åŒæ­¥å¾…å¤„ç†é¡¹ç›®
- **æ‰‹åŠ¨åŒæ­¥**ï¼šå…è®¸ç”¨æˆ·æ‰‹åŠ¨è§¦å‘åŒæ­¥
- **é”™è¯¯å¤„ç†å’Œé‡è¯•**ï¼šå¤„ç†åŒæ­¥å¤±è´¥å¹¶å®ç°é‡è¯•æœºåˆ¶
- **ç½‘ç»œçŠ¶æ€ç›‘æ§**ï¼šåœ¨ç½‘ç»œæ¢å¤æ—¶è‡ªåŠ¨åŒæ­¥

å…³é”®å‡½æ•°ï¼š
- `initializeDataSync`: åˆå§‹åŒ–åŒæ­¥æœåŠ¡
- `addSyncItem`: å°†é¡¹ç›®æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
- `syncPendingItems`: åŒæ­¥å¾…å¤„ç†é¡¹ç›®
- `getPendingSyncCount`: è·å–å¾…åŒæ­¥é¡¹ç›®æ•°é‡
- `getCurrentSyncStatus`: è·å–å½“å‰åŒæ­¥çŠ¶æ€

### 2.2 æ•°æ®åˆ·æ–°é’©å­ (useDataRefresh)

`useDataRefresh` æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰ React Hookï¼Œç”¨äºç›‘å¬æ•°æ®å˜åŒ–å¹¶è§¦å‘ç»„ä»¶æ›´æ–°ã€‚å®ƒæä¾›ä»¥ä¸‹åŠŸèƒ½ï¼š

- **è¡¨ç‰¹å®šç›‘å¬**ï¼šç›‘å¬ç‰¹å®šæ•°æ®è¡¨çš„å˜åŒ–
- **å›è°ƒå‡½æ•°**ï¼šåœ¨æ•°æ®å˜åŒ–æ—¶æ‰§è¡Œè‡ªå®šä¹‰é€»è¾‘
- **å±€éƒ¨æ›´æ–°**ï¼šæ”¯æŒç²¾ç¡®æ›´æ–°è€Œéå…¨é¡µé¢åˆ·æ–°

å˜ä½“ï¼š
- `useDataRefresh`: ç›‘å¬å¤šä¸ªè¡¨çš„å˜åŒ–
- `useTableRefresh`: ç›‘å¬å•ä¸ªè¡¨çš„å˜åŒ–
- `triggerDataRefresh`: æ‰‹åŠ¨è§¦å‘æ•°æ®åˆ·æ–°äº‹ä»¶

## 3. æ•°æ®æµç¨‹

### 3.1 æ•°æ®åˆ›å»º/æ›´æ–°æµç¨‹

1. ç”¨æˆ·åœ¨UIä¸­åˆ›å»ºæˆ–æ›´æ–°æ•°æ®ï¼ˆå¦‚ä»»åŠ¡ï¼‰
2. æ•°æ®é¦–å…ˆä¿å­˜åˆ°æœ¬åœ°æ•°æ®åº“ï¼ˆDexie.jsï¼‰
3. æ•°æ®å˜æ›´æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—ï¼ˆé€šè¿‡ `addSyncItem`ï¼‰
4. è§¦å‘ `syncItemAdded` äº‹ä»¶ï¼Œé€šçŸ¥UIæ›´æ–°
5. å¦‚æœåœ¨çº¿ï¼Œç«‹å³å°è¯•åŒæ­¥ï¼›å¦åˆ™ç­‰å¾…ç½‘ç»œæ¢å¤
6. åŒæ­¥æˆåŠŸåï¼Œè§¦å‘ `dataRefresh` äº‹ä»¶ï¼Œé€šçŸ¥ç›¸å…³ç»„ä»¶æ›´æ–°

### 3.2 æ•°æ®åŒæ­¥çŠ¶æ€æµç¨‹

1. åŒæ­¥çŠ¶æ€å˜åŒ–æ—¶ï¼Œè§¦å‘ `syncStatusChanged` äº‹ä»¶
2. SyncStatusIndicator ç»„ä»¶ç›‘å¬äº‹ä»¶å¹¶æ›´æ–°æ˜¾ç¤º
3. åŒæ­¥å®Œæˆåï¼Œè§¦å‘ `dataRefresh` äº‹ä»¶
4. ä½¿ç”¨ `useDataRefresh` æˆ– `useTableRefresh` çš„ç»„ä»¶æ¥æ”¶æ›´æ–°å¹¶åˆ·æ–°UI

## 4. ç»„ä»¶é›†æˆ

ä»¥ä¸‹ç»„ä»¶å·²é›†æˆæ•°æ®åŒæ­¥å’Œå±€éƒ¨åˆ·æ–°æœºåˆ¶ï¼š

### 4.1 ä»»åŠ¡ç®¡ç†ç›¸å…³ç»„ä»¶

- **TaskManager**: ä½¿ç”¨ `useDataRefresh` ç›‘å¬ä»»åŠ¡æ•°æ®å˜åŒ–
- **AnimatedTaskList**: ä½¿ç”¨ `useTableRefresh` ç›‘å¬ä»»åŠ¡è¡¨å˜åŒ–ï¼Œå®ç°ä»»åŠ¡åˆ—è¡¨çš„å±€éƒ¨æ›´æ–°

### 4.2 ç†ŠçŒ«çŠ¶æ€ç›¸å…³ç»„ä»¶

- **PandaStateProvider**: ä½¿ç”¨ `useTableRefresh` ç›‘å¬ç†ŠçŒ«çŠ¶æ€å’Œèƒ½åŠ›å˜åŒ–
- **AbilityList**: ä½¿ç”¨ `useTableRefresh` ç›‘å¬èƒ½åŠ›è¡¨å˜åŒ–

### 4.3 å¥–åŠ±ç›¸å…³ç»„ä»¶

- **RewardModal**: ä½¿ç”¨ `useTableRefresh` ç›‘å¬å¥–åŠ±è¡¨å˜åŒ–

### 4.4 UIåé¦ˆç»„ä»¶

- **SyncStatusIndicator**: æ˜¾ç¤ºåŒæ­¥çŠ¶æ€å’Œå¾…åŒæ­¥é¡¹ç›®æ•°é‡ï¼Œç›‘å¬ `syncItemAdded` å’Œ `syncStatusChanged` äº‹ä»¶

## 5. é”™è¯¯å¤„ç†

æ•°æ®åŒæ­¥æ¶æ„åŒ…å«å¤šå±‚é”™è¯¯å¤„ç†æœºåˆ¶ï¼š

1. **åŒæ­¥é”™è¯¯å¤„ç†**ï¼š
   - è®°å½•å¤±è´¥çš„åŒæ­¥å°è¯•
   - å®ç°æŒ‡æ•°é€€é¿é‡è¯•ç­–ç•¥
   - åœ¨ç½‘ç»œæ¢å¤æ—¶è‡ªåŠ¨é‡è¯•

2. **UIé”™è¯¯å¤„ç†**ï¼š
   - æ˜¾ç¤ºåŒæ­¥é”™è¯¯çŠ¶æ€
   - æä¾›æ‰‹åŠ¨é‡è¯•é€‰é¡¹
   - åœ¨é”™è¯¯çŠ¶æ€ä¸‹ä¿æŒåº”ç”¨å¯ç”¨

3. **æ•°æ®ä¸€è‡´æ€§**ï¼š
   - ä½¿ç”¨ä¹è§‚æ›´æ–°ç­–ç•¥ï¼ˆå…ˆæ›´æ–°UIï¼ŒååŒæ­¥æ•°æ®ï¼‰
   - åœ¨åŒæ­¥å¤±è´¥æ—¶å›æ»šåˆ°æœåŠ¡å™¨çŠ¶æ€

## 6. æœ€ä½³å®è·µ

### 6.1 ç»„ä»¶é›†æˆæŒ‡å—

è¦å°†æ–°ç»„ä»¶é›†æˆåˆ°æ•°æ®åŒæ­¥æ¶æ„ä¸­ï¼š

1. å¯¼å…¥é€‚å½“çš„ Hookï¼š
   ```typescript
   import { useDataRefresh } from '@/hooks/useDataRefresh';
   // æˆ–
   import { useTableRefresh } from '@/hooks/useDataRefresh';
   ```

2. åœ¨ç»„ä»¶ä¸­ä½¿ç”¨ Hookï¼š
   ```typescript
   // ç›‘å¬å¤šä¸ªè¡¨
   useDataRefresh(['table1', 'table2'], (event) => {
     // å¤„ç†æ•°æ®åˆ·æ–°
   });
   
   // æˆ–ç›‘å¬å•ä¸ªè¡¨
   useTableRefresh('tableName', (data) => {
     // å¤„ç†è¡¨æ•°æ®åˆ·æ–°
   });
   ```

3. å®ç°æ•°æ®å˜æ›´æ—¶çš„å±€éƒ¨æ›´æ–°é€»è¾‘

### 6.2 æ•°æ®æ“ä½œæŒ‡å—

åœ¨ä¿®æ”¹æ•°æ®æ—¶ï¼š

1. é¦–å…ˆæ›´æ–°æœ¬åœ°æ•°æ®åº“
2. ä½¿ç”¨ `addSyncItem` å°†å˜æ›´æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
3. ä¾èµ–æ•°æ®åŒæ­¥æœåŠ¡å’Œ `useDataRefresh` æœºåˆ¶è‡ªåŠ¨æ›´æ–°UI

## 7. æ€§èƒ½è€ƒè™‘

- **é€‰æ‹©æ€§æ›´æ–°**ï¼šåªæ›´æ–°å˜æ›´çš„æ•°æ®ï¼Œè€Œä¸æ˜¯æ•´ä¸ªåˆ—è¡¨
- **é˜²æŠ–åŠ¨å’ŒèŠ‚æµ**ï¼šé™åˆ¶çŸ­æ—¶é—´å†…çš„å¤šæ¬¡æ›´æ–°
- **æ‡’åŠ è½½**ï¼šä»…åœ¨éœ€è¦æ—¶åŠ è½½æ•°æ®
- **ç¼“å­˜**ï¼šç¼“å­˜é¢‘ç¹è®¿é—®çš„æ•°æ®ä»¥å‡å°‘æ•°æ®åº“æŸ¥è¯¢

## 8. æœªæ¥æ”¹è¿›

- **å†²çªè§£å†³**ï¼šå®ç°æ›´å¤æ‚çš„å†²çªè§£å†³ç­–ç•¥
- **æ‰¹é‡åŒæ­¥ä¼˜åŒ–**ï¼šæ”¹è¿›æ‰¹é‡åŒæ­¥æ€§èƒ½
- **åŒæ­¥ä¼˜å…ˆçº§**ï¼šå®ç°åŸºäºä¼˜å…ˆçº§çš„åŒæ­¥é˜Ÿåˆ—
- **æ•°æ®å‹ç¼©**ï¼šå‡å°‘åŒæ­¥æ•°æ®çš„å¤§å°
- **å¢é‡åŒæ­¥**ï¼šåªåŒæ­¥å˜æ›´çš„å­—æ®µè€Œéæ•´ä¸ªè®°å½•
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- You can add a link to an icon file here if you have one -->
    <!-- <link rel="icon" type="image/svg+xml" href="/vite.svg" /> -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minimal Dexie I18n Demo V3</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="issue.md">
# React Hooks æ— é™å¾ªç¯è°ƒç”¨é—®é¢˜ä¿®å¤æŠ¥å‘Š

## é—®é¢˜æè¿°

åœ¨ PandaHabit åº”ç”¨ä¸­ï¼Œæˆ‘ä»¬å‘ç°äº†å‡ ä¸ªç»„ä»¶å­˜åœ¨ React Hooks çš„ä½¿ç”¨é—®é¢˜ï¼Œå¯¼è‡´æ— é™å¾ªç¯æ¸²æŸ“å’Œä»¥ä¸‹é”™è¯¯ï¼š

1. **Invalid hook call é”™è¯¯**ï¼š
   ```
   Uncaught Error: Invalid hook call. Hooks can only be called inside of the body of a function component.
   ```

2. **Maximum update depth exceeded è­¦å‘Š**ï¼š
   ```
   Warning: Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.
   ```

## é—®é¢˜åŸå› 

è¿™äº›é—®é¢˜ä¸»è¦ç”±ä»¥ä¸‹å‡ ä¸ªåŸå› å¯¼è‡´ï¼š

1. **è¿å React Hooks è§„åˆ™**ï¼šåœ¨éå‡½æ•°ç»„ä»¶é¡¶å±‚æˆ–è‡ªå®šä¹‰ Hook å†…éƒ¨è°ƒç”¨ Hooks
2. **ä¾èµ–æ•°ç»„ä¸æ­£ç¡®**ï¼šåœ¨ useEffect ä¸­ä½¿ç”¨äº†ä¼šåœ¨æ¯æ¬¡æ¸²æŸ“æ—¶å˜åŒ–çš„ä¾èµ–
3. **å¾ªç¯ä¾èµ–**ï¼šç»„ä»¶ä¹‹é—´å­˜åœ¨å¾ªç¯ä¾èµ–å…³ç³»
4. **ç›´æ¥åœ¨ç»„ä»¶å‡½æ•°ä½“å†…è°ƒç”¨ Hook**ï¼šè€Œä¸æ˜¯åœ¨ useEffect æˆ–å…¶ä»– Hook ä¸­è°ƒç”¨

## ä¿®å¤æ–¹æ¡ˆ

### 1. ä¿®å¤ `registerTableRefreshListener` å‡½æ•°

**é—®é¢˜**ï¼š
`registerTableRefreshListener` å‡½æ•°ä¸æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰ Hookï¼ˆä¸ä»¥ "use" å¼€å¤´ï¼‰ï¼Œä½†å®ƒå†…éƒ¨ä½¿ç”¨äº† `useDataRefreshContext` Hookã€‚

**ä¿®å¤**ï¼š
å°†å…¶æ”¹ä¸ºè‡ªå®šä¹‰ Hook `useRegisterTableRefresh`ï¼Œå¹¶åœ¨å†…éƒ¨ä½¿ç”¨ useEffect å¤„ç†è®¢é˜…å’Œæ¸…ç†ï¼š

```typescript
// ä¿®æ”¹å‰
export function registerTableRefreshListener(
  table: string,
  callback: (data: any) => void
): () => void {
  const { registerRefreshListener } = useDataRefreshContext();
  return registerRefreshListener(table, callback);
}

// ä¿®æ”¹å (ç¬¬ä¸€æ¬¡å°è¯•)
export function useRegisterTableRefresh(
  table: string,
  callback: (data: any) => void
): () => void {
  const { registerRefreshListener } = useDataRefreshContext();

  useEffect(() => {
    // æ³¨å†Œè¡¨ç›‘å¬å™¨
    const unregister = registerRefreshListener(table, callback);

    // æ¸…ç†å‡½æ•°
    return unregister;
  }, [table, callback, registerRefreshListener]);

  return () => {}; // è¿”å›ä¸€ä¸ªç©ºå‡½æ•°ï¼Œå®é™…çš„å–æ¶ˆæ³¨å†Œåœ¨ useEffect çš„æ¸…ç†å‡½æ•°ä¸­å®Œæˆ
}

// æœ€ç»ˆä¿®å¤ (ä½¿ç”¨ useRef é¿å…ä¾èµ–å˜åŒ–)
export function useRegisterTableRefresh(
  table: string,
  callback: (data: any) => void
): () => void {
  const { registerRefreshListener } = useDataRefreshContext();

  // ä½¿ç”¨ ref æ¥å­˜å‚¨æœ€æ–°çš„å›è°ƒå‡½æ•°ï¼Œé¿å…ä¾èµ–å˜åŒ–
  const callbackRef = useRef(callback);

  // æ›´æ–° callbackRef å½“ callback å˜åŒ–æ—¶
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  // ä½¿ç”¨ ref æ¥å­˜å‚¨æœ€æ–°çš„ table å€¼
  const tableRef = useRef(table);

  // æ›´æ–° tableRef å½“ table å˜åŒ–æ—¶
  useEffect(() => {
    tableRef.current = table;
  }, [table]);

  // ä½¿ç”¨ ref æ¥å­˜å‚¨æœ€æ–°çš„ registerRefreshListener å‡½æ•°
  const registerRefreshListenerRef = useRef(registerRefreshListener);

  // æ›´æ–° registerRefreshListenerRef å½“ registerRefreshListener å˜åŒ–æ—¶
  useEffect(() => {
    registerRefreshListenerRef.current = registerRefreshListener;
  }, [registerRefreshListener]);

  // åªåœ¨ç»„ä»¶æŒ‚è½½æ—¶æ³¨å†Œä¸€æ¬¡ç›‘å¬å™¨
  useEffect(() => {
    // åˆ›å»ºä¸€ä¸ªç¨³å®šçš„å›è°ƒå‡½æ•°ï¼Œå®ƒæ€»æ˜¯ä½¿ç”¨æœ€æ–°çš„ callback
    const stableCallback = (data: any) => {
      // ä½¿ç”¨ ref è·å–æœ€æ–°çš„ callback
      callbackRef.current(data);
    };

    // æ³¨å†Œè¡¨ç›‘å¬å™¨
    const unregister = registerRefreshListenerRef.current(tableRef.current, stableCallback);

    // æ¸…ç†å‡½æ•°
    return unregister;
  }, []); // æ²¡æœ‰ä¾èµ–é¡¹ï¼Œä½¿ç”¨ ref è·å–æœ€æ–°çš„å€¼

  return () => {}; // è¿”å›ä¸€ä¸ªç©ºå‡½æ•°ï¼Œå®é™…çš„å–æ¶ˆæ³¨å†Œåœ¨ useEffect çš„æ¸…ç†å‡½æ•°ä¸­å®Œæˆ
}
```

### 2. ä¿®å¤ `ChallengeList` ç»„ä»¶

**é—®é¢˜**ï¼š
ç›´æ¥åœ¨ç»„ä»¶å‡½æ•°ä½“å†…è°ƒç”¨ `registerTableRefreshListener`ï¼Œå¯¼è‡´æ¯æ¬¡æ¸²æŸ“éƒ½ä¼šé‡æ–°æ³¨å†Œç›‘å¬å™¨ã€‚

**ä¿®å¤**ï¼š
1. ä½¿ç”¨ `useCallback` åŒ…è£…å›è°ƒå‡½æ•°
2. ä½¿ç”¨æ–°çš„ `useRegisterTableRefresh` Hook

```typescript
// ä¿®æ”¹å‰
useTableRefresh('challenges', (challengeData) => {
  // å¤„ç†é€»è¾‘...
});

// ä¿®æ”¹å
const handleChallengeDataUpdate = useCallback((challengeData: any) => {
  // å¤„ç†é€»è¾‘...
}, [loadChallenges, filter]);

// ä½¿ç”¨ useRegisterTableRefresh hook ç›‘å¬æŒ‘æˆ˜è¡¨çš„å˜åŒ–
useRegisterTableRefresh('challenges', handleChallengeDataUpdate);
```

### 3. ä¿®å¤ `AnimatedTaskList` ç»„ä»¶

**é—®é¢˜**ï¼š
ä¸ `ChallengeList` ç»„ä»¶ç±»ä¼¼ï¼Œç›´æ¥åœ¨ç»„ä»¶å‡½æ•°ä½“å†…è°ƒç”¨ `useTableRefresh`ã€‚

**ä¿®å¤**ï¼š
1. ä½¿ç”¨ `useCallback` åŒ…è£…å›è°ƒå‡½æ•°
2. ä½¿ç”¨æ–°çš„ `useRegisterTableRefresh` Hook
3. ä½¿ç”¨ `useRef` é¿å…ä¾èµ–å˜åŒ–

```typescript
// ä¿®æ”¹å‰
useTableRefresh('tasks', (taskData) => {
  // å¤„ç†é€»è¾‘...
});

// ä¿®æ”¹å (ç¬¬ä¸€æ¬¡å°è¯•)
const handleTaskDataUpdate = useCallback((taskData: any) => {
  // å¤„ç†é€»è¾‘...
}, [loadTasks, filter]);

// ä½¿ç”¨ useRegisterTableRefresh hook ç›‘å¬ä»»åŠ¡è¡¨çš„å˜åŒ–
useRegisterTableRefresh('tasks', handleTaskDataUpdate);

// æœ€ç»ˆä¿®å¤ (ä½¿ç”¨ useRef)
// å®šä¹‰ä»»åŠ¡æ•°æ®æ›´æ–°å¤„ç†å‡½æ•° - ä½¿ç”¨ useRef æ¥é¿å…ä¾èµ–å˜åŒ–
const filterRef = React.useRef(filter);
const loadTasksRef = React.useRef(loadTasks);

// æ›´æ–° refs å½“ä¾èµ–å˜åŒ–æ—¶
React.useEffect(() => {
  filterRef.current = filter;
  loadTasksRef.current = loadTasks;
}, [filter, loadTasks]);

// ä½¿ç”¨ç¨³å®šçš„å›è°ƒå‡½æ•°ï¼Œä¸ä¾èµ–äº filter æˆ– loadTasks
const handleTaskDataUpdate = useCallback((taskData: any) => {
  // ä½¿ç”¨ ref å€¼è€Œä¸æ˜¯ç›´æ¥ä¾èµ–
  const currentFilter = filterRef.current;
  const currentLoadTasks = loadTasksRef.current;

  // å¦‚æœæœ‰ç‰¹å®šä»»åŠ¡æ•°æ®ï¼Œåˆ™æ›´æ–°è¯¥ä»»åŠ¡
  if (taskData && taskData.id) {
    setTasks(prevTasks => {
      // å¤„ç†é€»è¾‘...
    });
  } else {
    // å¦‚æœæ²¡æœ‰ç‰¹å®šä»»åŠ¡æ•°æ®ï¼Œåˆ™é‡æ–°åŠ è½½æ‰€æœ‰ä»»åŠ¡
    currentLoadTasks();
  }
}, [/* æ²¡æœ‰ä¾èµ–é¡¹ï¼Œä½¿ç”¨ ref æ¥è·å–æœ€æ–°å€¼ */]);

// ä½¿ç”¨ useRegisterTableRefresh hook ç›‘å¬ä»»åŠ¡è¡¨çš„å˜åŒ–
useRegisterTableRefresh('tasks', handleTaskDataUpdate);
```

### 4. ä¿®å¤ `TaskManager` ç»„ä»¶

**é—®é¢˜**ï¼š
ä½¿ç”¨ `useDataRefresh` ç›‘å¬ä»»åŠ¡è¡¨å˜åŒ–ï¼Œä½†æ²¡æœ‰æ­£ç¡®å¤„ç†ä¾èµ–å…³ç³»ï¼Œå¯¼è‡´æ— é™å¾ªç¯ã€‚

**ä¿®å¤**ï¼š
1. ä½¿ç”¨ `useRegisterTableRefresh` ä»£æ›¿ `useDataRefresh`
2. ä½¿ç”¨ `useRef` æ¥é¿å…ä¾èµ–å˜åŒ–

```typescript
// ä¿®æ”¹å‰
const handleDataRefresh = useCallback(() => {
  setRefreshTrigger(prev => prev + 1);
}, []);

// ç›‘å¬ 'tasks' è¡¨çš„æ•°æ®åˆ·æ–°
useDataRefresh(['tasks'], () => handleDataRefresh());

// ä¿®æ”¹å (ç¬¬ä¸€æ¬¡å°è¯•)
const handleDataRefresh = useCallback(() => {
  setRefreshTrigger(prev => prev + 1);
}, [setRefreshTrigger]); // æ˜ç¡®ä¾èµ– setRefreshTrigger

// ä½¿ç”¨ useRegisterTableRefresh ç›‘å¬ 'tasks' è¡¨çš„æ•°æ®åˆ·æ–°
useRegisterTableRefresh('tasks', handleDataRefresh);

// æœ€ç»ˆä¿®å¤ (ä½¿ç”¨ useRef)
// ä½¿ç”¨ useRef æ¥é¿å…ä¾èµ–å˜åŒ–
const setRefreshTriggerRef = React.useRef(setRefreshTrigger);

// æ›´æ–° ref å½“ä¾èµ–å˜åŒ–æ—¶
React.useEffect(() => {
  setRefreshTriggerRef.current = setRefreshTrigger;
}, [setRefreshTrigger]);

// ä½¿ç”¨ç¨³å®šçš„å›è°ƒå‡½æ•°ï¼Œä¸ä¾èµ–äº setRefreshTrigger
const handleDataRefresh = useCallback(() => {
  // åªéœ€è¦è§¦å‘åˆ·æ–°ï¼Œä¸éœ€è¦é‡æ–°è·å–æ‰€æœ‰æ•°æ®
  setRefreshTriggerRef.current(prev => prev + 1);
}, []); // æ²¡æœ‰ä¾èµ–é¡¹ï¼Œä½¿ç”¨ ref æ¥è·å–æœ€æ–°å€¼

// ä½¿ç”¨ useRegisterTableRefresh ç›‘å¬ 'tasks' è¡¨çš„æ•°æ®åˆ·æ–°
useRegisterTableRefresh('tasks', handleDataRefresh);
```

### 5. ä¿®å¤å¾ªç¯ä¾èµ–é—®é¢˜

**é—®é¢˜**ï¼š
`App.tsx` å’Œ `dataSyncService.ts` ä¹‹é—´å­˜åœ¨å¾ªç¯ä¾èµ–ã€‚

**ä¿®å¤**ï¼š
åˆ›å»ºå•ç‹¬çš„ `queryClient.ts` æ–‡ä»¶ï¼Œå°† `queryClient` å®ä¾‹ç§»å‡º `App.tsx`ï¼š

```typescript
// src/services/queryClient.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 2, // 2 minutes
      refetchOnWindowFocus: false,
      retry: 1,
    },
  },
});
```

## å…¨å±€æ£€æŸ¥ç±»ä¼¼é—®é¢˜çš„æ–¹æ³•

ä¸ºäº†å…¨å±€æ£€æŸ¥ç±»ä¼¼çš„é—®é¢˜ï¼Œå¯ä»¥é‡‡å–ä»¥ä¸‹æ­¥éª¤ï¼š

1. **æ£€æŸ¥æ‰€æœ‰ç›´æ¥ä½¿ç”¨ Hook çš„é Hook å‡½æ•°**ï¼š
   - æœç´¢æ‰€æœ‰ä¸ä»¥ "use" å¼€å¤´ä½†å†…éƒ¨è°ƒç”¨äº† React Hooks çš„å‡½æ•°
   - å°†è¿™äº›å‡½æ•°æ”¹ä¸ºè‡ªå®šä¹‰ Hookï¼ˆä»¥ "use" å¼€å¤´ï¼‰æˆ–ç§»é™¤å†…éƒ¨çš„ Hook è°ƒç”¨

2. **æ£€æŸ¥æ‰€æœ‰ç»„ä»¶ä¸­ç›´æ¥åœ¨å‡½æ•°ä½“å†…è°ƒç”¨çš„ Hook**ï¼š
   - æœç´¢æ‰€æœ‰åœ¨ç»„ä»¶å‡½æ•°ä½“å†…ç›´æ¥è°ƒç”¨çš„ Hookï¼ˆä¸åœ¨ useEffect ç­‰å…¶ä»– Hook å†…éƒ¨ï¼‰
   - å°†è¿™äº›è°ƒç”¨ç§»åˆ° useEffect æˆ–å…¶ä»–é€‚å½“çš„ Hook ä¸­

3. **æ£€æŸ¥æ‰€æœ‰ useEffect çš„ä¾èµ–æ•°ç»„**ï¼š
   - ç¡®ä¿æ‰€æœ‰ useEffect éƒ½æœ‰æ­£ç¡®çš„ä¾èµ–æ•°ç»„
   - ä½¿ç”¨ ESLint çš„ exhaustive-deps è§„åˆ™æ£€æŸ¥ä¾èµ–é¡¹æ˜¯å¦å®Œæ•´

4. **æ£€æŸ¥å¾ªç¯ä¾èµ–**ï¼š
   - åˆ†ææ¨¡å—å¯¼å…¥å…³ç³»ï¼Œæ‰¾å‡ºå¯èƒ½çš„å¾ªç¯ä¾èµ–
   - é‡æ„ä»£ç ï¼Œå°†å…±äº«çš„é€»è¾‘æˆ–æ•°æ®ç§»åˆ°å•ç‹¬çš„æ¨¡å—ä¸­

5. **ä½¿ç”¨ React DevTools çš„ Profiler**ï¼š
   - ç›‘æ§ç»„ä»¶çš„é‡æ–°æ¸²æŸ“æ¬¡æ•°
   - è¯†åˆ«æ¸²æŸ“æ¬¡æ•°å¼‚å¸¸å¤šçš„ç»„ä»¶

## é¢„é˜²æªæ–½

1. **éµå¾ª React Hooks è§„åˆ™**ï¼š
   - åªåœ¨ React å‡½æ•°ç»„ä»¶æˆ–è‡ªå®šä¹‰ Hook ä¸­è°ƒç”¨ Hooks
   - ä¸è¦åœ¨æ¡ä»¶è¯­å¥ã€å¾ªç¯æˆ–åµŒå¥—å‡½æ•°ä¸­è°ƒç”¨ Hooks
   - ç¡®ä¿è‡ªå®šä¹‰ Hook åç§°ä»¥ "use" å¼€å¤´

2. **æ­£ç¡®ä½¿ç”¨ useEffect ä¾èµ–æ•°ç»„**ï¼š
   - åŒ…å« effect ä¸­ä½¿ç”¨çš„æ‰€æœ‰å¤–éƒ¨å˜é‡
   - ä½¿ç”¨ useCallback å’Œ useMemo ç¨³å®šåŒ–ä¾èµ–é¡¹

3. **é¿å…å¾ªç¯ä¾èµ–**ï¼š
   - è®¾è®¡æ¸…æ™°çš„æ¨¡å—ç»“æ„
   - å°†å…±äº«é€»è¾‘æŠ½å–åˆ°å•ç‹¬çš„æ¨¡å—

4. **ä½¿ç”¨ ESLint æ’ä»¶**ï¼š
   - å®‰è£… eslint-plugin-react-hooks
   - å¯ç”¨ rules-of-hooks å’Œ exhaustive-deps è§„åˆ™

é€šè¿‡ä»¥ä¸Šæªæ–½ï¼Œå¯ä»¥æœ‰æ•ˆé¢„é˜²å’Œè§£å†³ React Hooks ç›¸å…³çš„æ— é™å¾ªç¯æ¸²æŸ“é—®é¢˜ã€‚

## å¤šè¯­è¨€æ”¯æŒæ›´æ–°

ä¸ºäº†ç¡®ä¿æ‰€æœ‰é¡µé¢éƒ½ä½¿ç”¨ä¸€è‡´çš„å¤šè¯­è¨€æ”¯æŒæ–¹å¼ï¼Œæˆ‘ä»¬è¿›è¡Œäº†ä»¥ä¸‹æ›´æ–°ï¼š

1. **æ›´æ–° ChallengesPage**ï¼š
   - ä½¿ç”¨ `useLocalizedView` è·å–å¤šè¯­è¨€æ ‡ç­¾
   - å°†ç¡¬ç¼–ç çš„æ–‡æœ¬æ›¿æ¢ä¸ºæ ‡ç­¾
   - æ·»åŠ é”™è¯¯å¤„ç†å’ŒåŠ è½½çŠ¶æ€çš„å¤šè¯­è¨€æ”¯æŒ

2. **æ›´æ–° AbilitiesPage**ï¼š
   - æ·»åŠ  `useLocalizedView` è·å–å¤šè¯­è¨€æ ‡ç­¾
   - åˆ›å»ºç›¸åº”çš„ç±»å‹å®šä¹‰
   - å°†ç¡¬ç¼–ç çš„æ–‡æœ¬æ›¿æ¢ä¸ºæ ‡ç­¾
   - æ·»åŠ é”™è¯¯å¤„ç†å’ŒåŠ è½½çŠ¶æ€çš„å¤šè¯­è¨€æ”¯æŒ

3. **æ›´æ–° TasksPage**ï¼š
   - ä¿®å¤æ¡ä»¶åˆ¤æ–­å’Œé”™è¯¯å¤„ç†
   - æ·»åŠ é”™è¯¯å¤„ç†å’ŒåŠ è½½çŠ¶æ€çš„å¤šè¯­è¨€æ”¯æŒ

4. **æ›´æ–°ç±»å‹å®šä¹‰**ï¼š
   - ä¸º `TasksPageViewLabelsBundle` æ·»åŠ ç¼ºå¤±çš„å±æ€§
   - ä¸º `ChallengesPageViewLabelsBundle` æ·»åŠ ç¼ºå¤±çš„å±æ€§
   - åˆ›å»º `AbilitiesPageViewLabelsBundle` ç±»å‹å®šä¹‰

5. **æ·»åŠ æœ¬åœ°åŒ–æœåŠ¡å‡½æ•°**ï¼š
   - æ·»åŠ  `fetchAbilitiesPageView` å‡½æ•°

é€šè¿‡è¿™äº›æ›´æ–°ï¼Œæ‰€æœ‰é¡µé¢ç°åœ¨éƒ½ä½¿ç”¨äº†ä¸€è‡´çš„å¤šè¯­è¨€æ”¯æŒæ–¹å¼ï¼Œå¹¶ä¸”æ­£ç¡®ä½¿ç”¨äº† DataRefreshProvider æ¥ç®¡ç†æ•°æ®åŒæ­¥åçš„å±€éƒ¨åˆ·æ–°ã€‚
</file>

<file path="page-design-document.md">
# PandaHabit é¡µé¢è®¾è®¡æ–‡æ¡£

## 1. æ¦‚è¿°

PandaHabit æ˜¯ä¸€æ¬¾åä¸½æ¸¸æˆé£æ ¼çš„ä¹ æƒ¯å…»æˆåº”ç”¨ï¼Œé‡‡ç”¨ä¸­å›½é£è§†è§‰å…ƒç´ ï¼Œä»¥ç†ŠçŒ«ä¼™ä¼´ä¸ºæ ¸å¿ƒè§’è‰²ã€‚æœ¬æ–‡æ¡£æè¿°äº†åº”ç”¨ç¨‹åºçš„é¡µé¢ç»“æ„ã€è®¾è®¡åŸåˆ™å’Œä¸»è¦ç»„ä»¶ã€‚

æœ¬åº”ç”¨é‡‡ç”¨å¤šè¯­è¨€æ”¯æŒï¼Œæ‰€æœ‰é¡µé¢çš„é™æ€æ–‡æœ¬éƒ½é€šè¿‡ useLocalizedView é’©å­ä»æœ¬åœ°åŒ–æœåŠ¡è·å–ï¼Œæ”¯æŒä¸­æ–‡å’Œè‹±æ–‡ç•Œé¢ã€‚

## 2. è®¾è®¡åŸåˆ™

### 2.1 è§†è§‰é£æ ¼

- **åä¸½æ¸¸æˆé£æ ¼**ï¼šé‡‡ç”¨ç²¾ç¾çš„æ¸¸æˆç•Œé¢è®¾è®¡ï¼ŒåŒ…æ‹¬è£…é¥°æ€§è¾¹æ¡†ã€ç²¾è‡´å›¾æ ‡å’ŒåŠ¨ç”»æ•ˆæœ
- **ä¸­å›½é£å…ƒç´ **ï¼šèå…¥æ°´å¢¨ã€ç«¹å¶ã€é‡‘å…‰ç­‰ä¸­å›½ä¼ ç»Ÿè§†è§‰å…ƒç´ 
- **ç†ŠçŒ«ä¸»é¢˜**ï¼šä»¥ç†ŠçŒ«ä¸ºæ ¸å¿ƒè§’è‰²ï¼Œè´¯ç©¿æ•´ä¸ªåº”ç”¨ç¨‹åº

### 2.2 ç”¨æˆ·ä½“éªŒåŸåˆ™

- **ç›´è§‚æ˜“ç”¨**ï¼šç•Œé¢ç®€æ´æ˜äº†ï¼Œæ“ä½œæµç¨‹ç›´è§‚
- **å³æ—¶åé¦ˆ**ï¼šç”¨æˆ·æ“ä½œåæä¾›å³æ—¶è§†è§‰å’ŒéŸ³æ•ˆåé¦ˆ
- **æ¸è¿›å¼å¼•å¯¼**ï¼šé€æ­¥å¼•å¯¼ç”¨æˆ·äº†è§£åŠŸèƒ½ï¼Œé¿å…ä¿¡æ¯è¿‡è½½
- **å¥–åŠ±æœºåˆ¶**ï¼šå®Œæˆä»»åŠ¡åæä¾›ä¸°å¯Œçš„å¥–åŠ±å’Œæˆå°±ç³»ç»Ÿ

### 2.3 å“åº”å¼è®¾è®¡

- **ç§»åŠ¨ä¼˜å…ˆ**ï¼šä»¥ç§»åŠ¨è®¾å¤‡ä¸ºä¸»è¦ç›®æ ‡å¹³å°
- **è‡ªé€‚åº”å¸ƒå±€**ï¼šé€‚åº”ä¸åŒå±å¹•å°ºå¯¸å’Œæ–¹å‘
- **è§¦æ‘¸å‹å¥½**ï¼šæŒ‰é’®å’Œäº¤äº’å…ƒç´ è®¾è®¡é€‚åˆè§¦æ‘¸æ“ä½œ

## 3. é¡µé¢ç»“æ„

### 3.1 ä¸»é¡µ (HomePage)

**åŠŸèƒ½**ï¼šåº”ç”¨ç¨‹åºçš„å…¥å£ç‚¹ï¼Œå±•ç¤ºç”¨æˆ·æ¦‚è§ˆå’Œç†ŠçŒ«ä¼™ä¼´çŠ¶æ€

**ä¸»è¦ç»„ä»¶**ï¼š
- WelcomeSectionï¼šæ¬¢è¿ç”¨æˆ·ï¼Œæ˜¾ç¤ºå½“å‰æ—¥æœŸå’Œæ—¶é—´
- PandaSectionï¼šå±•ç¤ºç†ŠçŒ«ä¼™ä¼´åŠå…¶çŠ¶æ€
- MoodsSectionï¼šæ˜¾ç¤ºç”¨æˆ·å¿ƒæƒ…è®°å½•å’Œç»Ÿè®¡

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- ç«¹å¶è£…é¥°è¾¹æ¡†
- æ°´å¢¨é£æ ¼èƒŒæ™¯
- ç†ŠçŒ«åŠ¨ç”»æ•ˆæœ

### 3.2 ä»»åŠ¡é¡µé¢ (TasksPage)

**åŠŸèƒ½**ï¼šç®¡ç†ç”¨æˆ·çš„ä»»åŠ¡å’Œä¹ æƒ¯

**ä¸»è¦ç»„ä»¶**ï¼š
- TaskManagerï¼šä»»åŠ¡ç®¡ç†å™¨ï¼ŒåŒ…å«ä»»åŠ¡åˆ—è¡¨å’Œè¿‡æ»¤å™¨
- AnimatedTaskListï¼šåŠ¨ç”»ä»»åŠ¡åˆ—è¡¨ï¼Œæ˜¾ç¤ºä»»åŠ¡å¡ç‰‡
- TaskFormï¼šåˆ›å»ºå’Œç¼–è¾‘ä»»åŠ¡çš„è¡¨å•

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- ä»»åŠ¡å¡ç‰‡é‡‡ç”¨å·è½´è®¾è®¡
- å®Œæˆä»»åŠ¡æ—¶çš„é‡‘å…‰ç‰¹æ•ˆ
- ä»»åŠ¡ä¼˜å…ˆçº§è§†è§‰åŒºåˆ†

### 3.3 èƒ½åŠ›é¡µé¢ (AbilitiesPage)

**åŠŸèƒ½**ï¼šå±•ç¤ºå’Œç®¡ç†ç†ŠçŒ«ä¼™ä¼´çš„èƒ½åŠ›

**ä¸»è¦ç»„ä»¶**ï¼š
- AbilityTreeï¼šèƒ½åŠ›æ ‘ï¼Œå±•ç¤ºèƒ½åŠ›ä¹‹é—´çš„å…³ç³»
- AbilityCardï¼šèƒ½åŠ›å¡ç‰‡ï¼Œæ˜¾ç¤ºèƒ½åŠ›è¯¦æƒ…
- AbilityUnlockModalï¼šè§£é”èƒ½åŠ›çš„æ¨¡æ€æ¡†

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- æ ‘çŠ¶ç»“æ„å±•ç¤ºèƒ½åŠ›å…³ç³»
- å·²è§£é”å’Œæœªè§£é”èƒ½åŠ›çš„è§†è§‰åŒºåˆ†
- è§£é”åŠ¨ç”»æ•ˆæœ

### 3.4 æŒ‘æˆ˜é¡µé¢ (ChallengesPage)

**åŠŸèƒ½**ï¼šå±•ç¤ºå’Œç®¡ç†ç”¨æˆ·æŒ‘æˆ˜

**ä¸»è¦ç»„ä»¶**ï¼š
- ChallengeListï¼šæŒ‘æˆ˜åˆ—è¡¨ï¼Œæ˜¾ç¤ºæŒ‘æˆ˜å¡ç‰‡
- ChallengeFilterï¼šæŒ‘æˆ˜è¿‡æ»¤å™¨ï¼ŒæŒ‰çŠ¶æ€ã€ç±»å‹å’Œéš¾åº¦è¿‡æ»¤
- ChallengeCardï¼šæŒ‘æˆ˜å¡ç‰‡ï¼Œæ˜¾ç¤ºæŒ‘æˆ˜è¯¦æƒ…å’Œè¿›åº¦

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- æŒ‘æˆ˜å¡ç‰‡é‡‡ç”¨åä¸½è¾¹æ¡†è®¾è®¡
- è¿›åº¦æ¡é‡‡ç”¨ä¸­å›½é£å…ƒç´ 
- æŒ‘æˆ˜å®Œæˆæ—¶çš„åº†ç¥åŠ¨ç”»

### 3.5 åŠæ—¶å¥–åŠ±é¡µé¢ (TimelyRewardsPage)

**åŠŸèƒ½**ï¼šå±•ç¤ºå’Œç®¡ç†åŠæ—¶å¥–åŠ±å’Œå¹¸è¿æŠ½å¥–

**ä¸»è¦ç»„ä»¶**ï¼š
- TimelyRewardListï¼šåŠæ—¶å¥–åŠ±åˆ—è¡¨ï¼Œæ˜¾ç¤ºå¥–åŠ±å¡ç‰‡
- TimelyRewardCardï¼šåŠæ—¶å¥–åŠ±å¡ç‰‡ï¼Œæ˜¾ç¤ºå¥–åŠ±è¯¦æƒ…å’Œè¿›åº¦
- LuckyDrawï¼šå¹¸è¿æŠ½å¥–ç»„ä»¶ï¼Œä½¿ç”¨å¹¸è¿ç‚¹è¿›è¡ŒæŠ½å¥–

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- å¥–åŠ±å¡ç‰‡é‡‡ç”¨é‡‘è‰²è¾¹æ¡†è®¾è®¡
- å¹¸è¿æŠ½å¥–é‡‡ç”¨è½¬ç›˜åŠ¨ç”»
- å¥–åŠ±è·å–æ—¶çš„ç‰¹æ•ˆåŠ¨ç”»

### 3.6 è®¾ç½®é¡µé¢ (SettingsPage)

**åŠŸèƒ½**ï¼šç®¡ç†åº”ç”¨ç¨‹åºè®¾ç½®å’Œç”¨æˆ·åå¥½

**ä¸»è¦ç»„ä»¶**ï¼š
- LanguageSelectorï¼šè¯­è¨€é€‰æ‹©å™¨
- ThemeSelectorï¼šä¸»é¢˜é€‰æ‹©å™¨
- NotificationSettingsï¼šé€šçŸ¥è®¾ç½®
- AccountSettingsï¼šè´¦æˆ·è®¾ç½®

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- ç®€æ´çš„è®¾ç½®ç•Œé¢
- åˆ†ç±»ç»„ç»‡è®¾ç½®é¡¹
- å³æ—¶åº”ç”¨è®¾ç½®å˜æ›´

## 4. å…±äº«ç»„ä»¶

### 4.1 å¯¼èˆªç»„ä»¶ (Navigation)

**åŠŸèƒ½**ï¼šåœ¨ä¸åŒé¡µé¢ä¹‹é—´å¯¼èˆª

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- åº•éƒ¨å¯¼èˆªæ ï¼Œé€‚åˆç§»åŠ¨è®¾å¤‡
- å›¾æ ‡å’Œæ–‡å­—ç»“åˆ
- å½“å‰é¡µé¢é«˜äº®æ˜¾ç¤º

### 4.2 æ¨¡æ€æ¡†ç»„ä»¶ (Modal)

**åŠŸèƒ½**ï¼šæ˜¾ç¤ºå¼¹å‡ºå†…å®¹

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- åŠé€æ˜èƒŒæ™¯é®ç½©
- åŠ¨ç”»è¿›å…¥å’Œé€€å‡ºæ•ˆæœ
- æ”¯æŒç‚¹å‡»å¤–éƒ¨åŒºåŸŸå…³é—­

### 4.3 å·è½´å¯¹è¯æ¡† (ScrollDialog)

**åŠŸèƒ½**ï¼šä»¥å·è½´å½¢å¼æ˜¾ç¤ºé‡è¦ä¿¡æ¯

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- å¤ä»£å·è½´è®¾è®¡
- è£…é¥°æ€§è¾¹æ¡†å’Œçº¹ç†
- å±•å¼€å’Œæ”¶èµ·åŠ¨ç”»

### 4.4 å¥–åŠ±æ¨¡æ€æ¡† (RewardModal)

**åŠŸèƒ½**ï¼šå±•ç¤ºè·å¾—çš„å¥–åŠ±

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- åä¸½çš„é‡‘è‰²è¾¹æ¡†
- å¥–åŠ±å±•ç¤ºåŠ¨ç”»
- ç²’å­ç‰¹æ•ˆ

### 4.5 ç†ŠçŒ«å¤´åƒ (PandaAvatar)

**åŠŸèƒ½**ï¼šæ˜¾ç¤ºç†ŠçŒ«ä¼™ä¼´

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- æ ¹æ®çŠ¶æ€å˜åŒ–è¡¨æƒ…å’ŒåŠ¨ä½œ
- äº’åŠ¨åŠ¨ç”»æ•ˆæœ
- è£…é¥°æ€§è¾¹æ¡†

## 5. åŠ¨ç”»ç³»ç»Ÿ

### 5.1 é¡µé¢è¿‡æ¸¡åŠ¨ç”»

- é¡µé¢è¿›å…¥ï¼šæ·¡å…¥å’Œä¸Šç§»
- é¡µé¢é€€å‡ºï¼šæ·¡å‡ºå’Œä¸‹ç§»
- é¡µé¢åˆ‡æ¢ï¼šäº¤å‰æ·¡å…¥æ·¡å‡º

### 5.2 å…ƒç´ åŠ¨ç”»

- æŒ‰é’®ï¼šæ‚¬åœæ”¾å¤§ï¼Œç‚¹å‡»ç¼©å°
- å¡ç‰‡ï¼šæ‚¬åœè½»å¾®ä¸Šæµ®ï¼Œæ·»åŠ é˜´å½±
- åˆ—è¡¨é¡¹ï¼šè¿›å…¥æ—¶åºåˆ—åŠ¨ç”»

### 5.3 ç‰¹æ•ˆåŠ¨ç”»

- å®Œæˆä»»åŠ¡ï¼šé‡‘å…‰ç‰¹æ•ˆ
- è§£é”èƒ½åŠ›ï¼šæ°´å¢¨æ‰©æ•£æ•ˆæœ
- è·å¾—å¥–åŠ±ï¼šç²’å­çˆ†ç‚¸æ•ˆæœ

## 6. å“åº”å¼è®¾è®¡ç­–ç•¥

### 6.1 ç§»åŠ¨è®¾å¤‡ (< 768px)

- å•åˆ—å¸ƒå±€
- åº•éƒ¨å¯¼èˆªæ 
- ç®€åŒ–çš„å¡ç‰‡è®¾è®¡

### 6.2 å¹³æ¿è®¾å¤‡ (768px - 1024px)

- åŒåˆ—å¸ƒå±€
- ä¾§è¾¹å¯¼èˆªæ 
- æ›´è¯¦ç»†çš„å¡ç‰‡è®¾è®¡

### 6.3 æ¡Œé¢è®¾å¤‡ (> 1024px)

- å¤šåˆ—å¸ƒå±€
- é¡¶éƒ¨å¯¼èˆªæ 
- å®Œæ•´çš„å¡ç‰‡è®¾è®¡ï¼ŒåŒ…å«æ›´å¤šä¿¡æ¯

## 7. ä¸»é¢˜ç³»ç»Ÿ

### 7.1 é¢œè‰²ä¸»é¢˜

- **é»˜è®¤ä¸»é¢˜**ï¼šç«¹é’ç»¿ä¸ºä¸»è‰²è°ƒï¼Œé‡‘è‰²ä¸ºå¼ºè°ƒè‰²
- **å¤œé—´ä¸»é¢˜**ï¼šæ·±è“ä¸ºä¸»è‰²è°ƒï¼Œé“¶è‰²ä¸ºå¼ºè°ƒè‰²
- **èŠ‚æ—¥ä¸»é¢˜**ï¼šçº¢è‰²ä¸ºä¸»è‰²è°ƒï¼Œé‡‘è‰²ä¸ºå¼ºè°ƒè‰²

### 7.2 å­—ä½“ç³»ç»Ÿ

- æ ‡é¢˜ï¼šåä¸½çš„ä¸­æ–‡ä¹¦æ³•å­—ä½“
- æ­£æ–‡ï¼šæ¸…æ™°æ˜“è¯»çš„æ— è¡¬çº¿å­—ä½“
- å¼ºè°ƒï¼šè£…é¥°æ€§ä¸­æ–‡å­—ä½“

### 7.3 é—´è·ç³»ç»Ÿ

- é‡‡ç”¨ 8px åŸºç¡€ç½‘æ ¼ç³»ç»Ÿ
- ç§»åŠ¨è®¾å¤‡ä½¿ç”¨æ›´ç´§å‡‘çš„é—´è·
- æ¡Œé¢è®¾å¤‡ä½¿ç”¨æ›´å®½æ¾çš„é—´è·

## 8. å›½é™…åŒ–æ”¯æŒ

### 8.1 å¤šè¯­è¨€å®ç°

- æ”¯æŒä¸­æ–‡å’Œè‹±æ–‡ç•Œé¢
- ä½¿ç”¨ useLocalizedView é’©å­åŠ è½½æœ¬åœ°åŒ–å†…å®¹
- æ ¹æ®è¯­è¨€è°ƒæ•´å¸ƒå±€å’Œå­—ä½“å¤§å°

### 8.2 æœ¬åœ°åŒ–å†…å®¹æœåŠ¡

- ä½¿ç”¨ localizedContentService æä¾›æœ¬åœ°åŒ–å†…å®¹
- æ¯ä¸ªé¡µé¢éƒ½æœ‰å¯¹åº”çš„ fetch å‡½æ•°ï¼Œå¦‚ fetchHomePageViewã€fetchSettingsPageView ç­‰
- æœ¬åœ°åŒ–å†…å®¹åŒ…æ‹¬æ ‡ç­¾ï¼ˆlabelsï¼‰å’Œæ•°æ®ï¼ˆdataï¼‰ä¸¤éƒ¨åˆ†

### 8.3 é¡µé¢æœ¬åœ°åŒ–å®ç°

æ¯ä¸ªé¡µé¢éƒ½éµå¾ªç›¸åŒçš„æœ¬åœ°åŒ–æ¨¡å¼ï¼š

1. å¯¼å…¥ useLocalizedView é’©å­å’Œå¯¹åº”çš„ fetch å‡½æ•°
2. åœ¨ç»„ä»¶ä¸­ä½¿ç”¨ useLocalizedView è·å–æœ¬åœ°åŒ–å†…å®¹
3. å¤„ç†åŠ è½½çŠ¶æ€å’Œé”™è¯¯çŠ¶æ€
4. ä½¿ç”¨è·å–åˆ°çš„æ ‡ç­¾æ¸²æŸ“é¡µé¢å†…å®¹

ç¤ºä¾‹ä»£ç ï¼š

```typescript
const {
  labels: pageLabels,
  isPending,
  isError,
  error,
  refetch
} = useLocalizedView<null, PageViewLabelsBundle>(
  'pageViewContent',
  fetchPageView
);

// å¤„ç†åŠ è½½çŠ¶æ€
if (isPending && !pageLabels) {
  return <LoadingSpinner variant="jade" text="åŠ è½½é¡µé¢å†…å®¹..." />;
}

// å¤„ç†é”™è¯¯çŠ¶æ€
if (isError && !pageLabels) {
  return (
    <div className="page-content">
      <ErrorDisplay error={error} title="é¡µé¢é”™è¯¯" onRetry={refetch} />
    </div>
  );
}

// ä½¿ç”¨æ ‡ç­¾æ¸²æŸ“é¡µé¢å†…å®¹
return (
  <div>
    <h1>{pageLabels?.pageTitle || 'é»˜è®¤æ ‡é¢˜'}</h1>
    {/* å…¶ä»–é¡µé¢å†…å®¹ */}
  </div>
);
```

## 9. æ€»ç»“

PandaHabit çš„é¡µé¢è®¾è®¡èåˆäº†åä¸½æ¸¸æˆé£æ ¼å’Œä¸­å›½ä¼ ç»Ÿè§†è§‰å…ƒç´ ï¼Œä»¥ç†ŠçŒ«ä¼™ä¼´ä¸ºæ ¸å¿ƒè§’è‰²ï¼Œé€šè¿‡ç²¾ç¾çš„ç•Œé¢è®¾è®¡ã€æµç•…çš„åŠ¨ç”»æ•ˆæœå’Œä¸°å¯Œçš„å¥–åŠ±æœºåˆ¶ï¼Œä¸ºç”¨æˆ·æä¾›æ„‰æ‚¦çš„ä¹ æƒ¯å…»æˆä½“éªŒã€‚
</file>

<file path="prd.md">
Okay, here is the comprehensive, standalone Product Requirements Document (PRD) for **PandaHabit**, incorporating all the previously discussed elements, including competitor analysis solutions, the Timely Reward System (Scheme C), User Journeys, API Structure Analysis, and detailed Page Descriptions.

---

**Product Requirements Document: PandaHabit**

**Version:** 1.0
**Date:** May 15, 2025
**Status:** Draft

**1. Introduction**

*   **1.1. Overview:** PandaHabit is a mobile application designed to help users build positive habits, improve self-care routines, and enhance mental well-being through an engaging and supportive virtual pet experience. Users nurture a virtual Panda by completing real-life tasks and habits, creating a symbiotic relationship where taking care of oneself directly benefits the pet, and the pet, in turn, offers companionship, motivation, and gentle guidance.
*   **1.2. Vision:** To be the most supportive and engaging habit-building companion, transforming self-care from a chore into a rewarding journey. We aim to foster genuine, long-term positive change by providing proactive support, gentle accountability, meaningful emotional connection, and sustained engagement, overcoming the known shortcomings of existing apps in the market.
*   **1.3. Goals:**
    *   Increase user consistency in desired habits (e.g., hydration, mindfulness, exercise).
    *   Improve user self-reported mood and well-being.
    *   Achieve high user retention and engagement through a rewarding core loop and meaningful progression.
    *   Provide a genuinely supportive and non-judgmental environment, especially when users face challenges.
    *   Establish PandaHabit as a leader in the gamified self-care app market by directly addressing competitor weaknesses (lack of active support, becoming boring, punitive mechanics, negative reinforcement).
    *   Successfully monetize through a valuable VIP subscription model.
*   **1.4. Target Audience:** Individuals seeking tools for habit formation, self-care, mood tracking, motivation, and stress management. Particularly relevant for those who enjoy gamification, virtual pets, and desire a supportive, gentle approach. Also targets users dissatisfied with existing apps due to lack of active help, waning engagement, or negative experiences.

**2. User Journeys**

*   **2.1. New User Onboarding & First Task:**
    1.  User downloads and opens PandaHabit.
    2.  Welcomed with a brief intro to the concept (Panda companion for habits).
    3.  User customizes their initial Panda appearance (basic options).
    4.  User is guided to set their first simple habit/task (e.g., "Drink a glass of water").
    5.  Panda companion provides encouragement.
    6.  User completes the task in real life.
    7.  User opens the app and marks the task complete on the **Task Page**.
    8.  User receives base resource rewards (e.g., Bamboo, Water).
    9.  **Timely Reward:** User also sees the **Timeliness Bar** fill slightly and receives **Luck Points** (with visual feedback).
    10. User is guided to feed the Panda with the earned resources on the **Home Page** or **Pet Interaction Page**.
    11. Panda reacts positively to being fed.
    12. User is introduced to the main **Home Page** interface.
*   **2.2. Daily Habit Check-in & Timely Reward:**
    1.  User receives a gentle reminder notification (optional, Panda-themed).
    2.  User opens the app, landing on the **Home Page**.
    3.  User navigates to the **Task Page**.
    4.  User reviews their daily tasks (some marked with â° for Timely Rewards).
    5.  User completes several tasks within their time windows.
    6.  User marks tasks complete in the app.
    7.  User receives base resources for each task.
    8.  **Timely Reward:** For each on-time task, the **Timeliness Bar** progresses, and **Luck Points** are awarded with visual feedback.
    9.  User sees their total Luck Points increase on the HUD.
    10. User might navigate to the **Lucky Draw Page** to spend points or check the Timeliness Bar reward progress on the Home Page.
*   **2.3. Engaging with a Challenge:**
    1.  User navigates to the **Challenge Page**.
    2.  User browses active Challenges (Daily, Weekly, Event, Continuous).
    3.  User selects a Challenge (e.g., "7-Day Meditation Streak").
    4.  Challenge details show the overall goal, final reward, and component sub-tasks (e.g., "Meditate 5 mins today").
    5.  User accepts the Challenge.
    6.  The relevant daily sub-task appears in the user's **Task Page**, marked as a Challenge Task (ğŸ”¥).
    7.  User completes the sub-task daily and marks it off in the Task Page, earning daily rewards and Timely Rewards if applicable.
    8.  User checks progress on the **Challenge Page**.
    9.  Upon completing the final sub-task, the Challenge is marked complete, and the user claims the main Challenge reward.
*   **2.4. Using the Reflection Module:**
    1.  User consistently skips a core habit task for several days OR reports a low mood during check-in.
    2.  Panda **gently** offers the option to reflect ("Things seem tough with [Task Name] lately. Want to explore that?").
    3.  User accepts and enters the Reflection Module.
    4.  Panda asks simple, non-judgmental questions ("What felt like the biggest barrier today?").
    5.  User provides input (optional text or multiple choice).
    6.  Panda offers empathetic validation ("It's okay to find things difficult sometimes.") and suggests **small, actionable positive steps** ("Maybe tomorrow we try just 2 minutes of it? Or try [alternative simple task] instead?").
    7.  User feels supported and less discouraged.
*   **2.5. Upgrading to VIP:**
    1.  User interacts with a feature locked behind VIP (e.g., creating a Custom Goal, trying to claim extra reward bonus).
    2.  A prompt appears explaining the benefits of VIP related to that feature and others.
    3.  User navigates to the **Shop Page** or a dedicated VIP section.
    4.  User reviews VIP tiers, benefits (increased rewards, custom goals, exclusive items), and pricing.
    5.  User selects a subscription plan and completes the purchase via the App Store.
    6.  App UI updates immediately to reflect VIP status (e.g., VIP badge, unlocked features).
*   **2.6. Using the Lucky Draw:**
    1.  User accumulates sufficient **Luck Points** by completing tasks on time.
    2.  User navigates to the **Lucky Draw Page** (accessible from Home HUD or Rewards page).
    3.  User sees their current Luck Point balance and the "Draw x1" / "Draw x10" buttons with costs.
    4.  User views the potential prize pool highlights.
    5.  User taps a Draw button.
    6.  An engaging animation plays (e.g., spinning wheel, opening bamboo chest).
    7.  The awarded prize is revealed (e.g., "+50 Coins", "Rare Panda Hat").
    8.  The prize is automatically added to the user's inventory/balance.

**3. Functional Requirements**

*   **3.1. Core Gameplay Loop: "Panda Nurturing Lifestyle System"**
    *   **3.1.1. Panda Companion:**
        *   Visual representation of a Panda that grows and evolves.
        *   Displays emotional states (happy, neutral, concerned) based on user actions and inputs.
        *   Reacts to user interactions (feeding, petting).
        *   Possesses unlockable abilities tied to growth stages (see 3.2.2).
    *   **3.1.2. Resource System:**
        *   Core resources (e.g., Bamboo, Water, Coins) earned primarily through Task completion.
        *   Resources used for feeding the Panda and facilitating Panda Growth/Upgrades.
        *   Premium currency (e.g., Diamonds) potentially used for cosmetics, speeding up timers (if any), or specific VIP features.
    *   **3.1.3. Interconnected Loop:** User completes Tasks -> Earns Resources & Timely Rewards -> Feeds/Grows Panda -> Panda Unlocks Abilities/Provides Support -> User is Motivated to Complete More Tasks.
*   **3.2. Panda Growth & Customization**
    *   **3.2.1. Growth Stages:** Defined stages (e.g., Infant, Youth, Adult, Perfect Form) reached by spending resources and meeting level requirements. Each stage unlocks new visual appearances.
    *   **3.2.2. Capability Unlock (Meaningful Progression):** Panda growth unlocks functional benefits:
        *   New supportive dialogue options and emotional responses.
        *   Enhanced ability to help break down User-Defined Goals (VIP).
        *   Access to advanced guided exercises (meditation, breathing).
        *   Potentially offer small passive bonuses (e.g., slightly increased Luck Point gain).
    *   **3.2.3. Customization:** Users can personalize Panda appearance (skins, hats, accessories) and its environment (decorations) using items earned or purchased.
*   **3.3. Tasks System**
    *   **3.3.1. Task Types:**
        *   **Daily Tasks:** Simple, repeatable tasks for daily engagement and basic resource generation (e.g., Login, Feed Panda, Quick Mood Check). Contribute to Timely Rewards.
        *   **Mainline Tasks:** Core habit-building tasks related to user's goals (e.g., Drink Water, Meditate, Exercise, Journal, Health Record). Contribute to Timely Rewards. Can be broken down into smaller steps.
        *   **Side Tasks:** Varied tasks including Positive Psychology prompts (Affirmation, Gratitude), Guided Practices, Event Tasks, and potentially social tasks. Time-sensitive ones contribute to Timely Rewards.
    *   **3.3.2. Task Management:**
        *   Users can select from predefined task suggestions or create basic custom tasks (advanced custom goals are VIP).
        *   Tasks appear on a daily Task List.
        *   Users mark tasks as complete.
        *   Ability to set task recurrence (daily, specific days, weekly).
    *   **3.3.3. Task Decomposition:** System/Panda offers assistance in breaking down larger Mainline tasks or User-Defined Goals into smaller, manageable daily actions.
    *   **3.3.4. Gentle Reminders:** Optional, customizable, Panda-themed push notifications for specific tasks.
*   **3.4. Challenge System**
    *   **3.4.1. Challenge Definition:** Longer-term objectives composed of multiple steps or requiring sustained effort over time (See Section 4.1 for definition).
    *   **3.4.2. Challenge Types:** Daily Login Streaks, Task Completion Streaks, Resource Collection Goals, Event-Specific Challenges, Cooperative Social Challenges. Categorized by duration (Daily, 7-Day, 30-Day, etc.) and source (System, Event).
    *   **3.4.3. Challenge Lifecycle Tagging:** Challenges tagged for user lifecycle stages (Newbie, Growing, Mature) for appropriate presentation.
    *   **3.4.4. Sub-Task Integration:** Challenge sub-tasks appear in the daily Task List, clearly marked. Completing sub-tasks (on time) contributes to the Timely Reward System. Challenge completion grants a separate, larger reward.
*   **3.5. Progression Systems**
    *   **3.5.1. Achievements:** Awarded for specific, one-off accomplishments across all game areas (Pet Growth, Tasks, Challenges, Resources, Social, Timeliness). Provide small-medium rewards (Coins, basic items). (See Appendix A for detailed list).
    *   **3.5.2. Milestones:** Mark major user journey progression points, often tied to account age or significant achievements. Provide substantial rewards (Large Coins, Rare Cosmetics, Materials). Tailored to user lifecycle stages. (See Appendix B for detailed list).
*   **3.6. Timely Reward System (Scheme C)**
    *   **3.6.1. Eligibility:** Clearly marked Tasks (Daily, Mainline, applicable Side/Challenge sub-tasks) are eligible.
    *   **3.6.2. Time Windows:** Defined windows for "on-time" completion (daily cutoff, specific times, task deadlines). "Early Bird" bonus potential.
    *   **3.6.3. Rewards:**
        *   **Timeliness Bar:** Fills progressively with each on-time completion. Visible on Home HUD. Reaching the end grants a **guaranteed significant reward** (e.g., rare seasonal cosmetic, large resource bundle). Bar resets upon claiming. Reward preview visible.
        *   **Luck Points:** Awarded for each on-time completion. Amount varies by task type/difficulty and VIP status. Displayed on HUD.
    *   **3.6.4. Lucky Draw:** Dedicated feature where users spend Luck Points for a chance to win random rewards from a tiered pool (Common to Legendary). Clear UI for drawing and viewing potential prizes.
*   **3.7. Deep Reflection & Psychological Support**
    *   **3.7.1. Reflection Module ("Take a Break"):** Non-intrusive module offered when user struggles (skipping tasks, low mood). Uses gentle, non-judgmental dialogue (Panda-led) to explore barriers and suggest small, positive, actionable steps. Focuses on self-compassion.
    *   **3.7.2. Proactive Support:** Panda provides context-aware, actionable, positive tips based on mood check-ins or detected patterns (e.g., suggesting hydration if mood is low and water task incomplete).
    *   **3.7.3. Avoidance of Negative Reinforcement:** No punitive mechanics for skipping tasks. Mood tracking focuses on providing support, not reinforcing negative feelings. No potentially inaccurate diagnostic quizzes.
*   **3.8. Social & Community Features**
    *   **3.8.1. Friends System:** Add friends, send encouragement messages, small resource gifts.
    *   **3.8.2. Sharing (Optional):** Share Panda growth, Milestone achievements, rare Lucky Draw wins.
    *   **3.8.3. Cooperative Challenges:** Team-based challenges encouraging collaboration.
    *   **3.8.4. Community Forum/Space:** Moderated area for sharing positive stories, tips, and encouragement.
*   **3.9. Monetization (VIP Subscription & Shop)**
    *   **3.9.1. VIP Subscription:** Tiered subscription offering benefits:
        *   Increased Luck Point earnings.
        *   Faster Timeliness Bar progression.
        *   Free daily/weekly Lucky Draws.
        *   Access to create User-Defined Goals (with Panda assistance).
        *   Higher reward caps/better potential rewards for Custom Goals.
        *   Exclusive cosmetic items (accessible only via VIP or VIP shop).
        *   VIP badge/identifier.
        *   Potential ad removal (if ads exist for free tier).
    *   **3.9.2. Shop:** In-app store selling:
        *   Cosmetic items (Panda skins, accessories, environment decorations) for Coins or potentially Diamonds.
        *   Potentially resource bundles or enhancement materials (use with caution to avoid pay-to-win feel).
        *   VIP-exclusive items.

**4. UI/UX Design (Page Descriptions)**

*   **4.1. Home Page**
    *   **Purpose:** Main dashboard, quick overview, access to core interactions.
    *   **Layout:**
        *   *Top:* User info (profile, name), Currency (Coins, Diamonds, **Luck Points** âœ¨), quick access icons (Pet, Achievements, Events, Tasks, VIP, Settings).
        *   *Center:* Large interactive Panda visual, reflecting current state/growth. **Timeliness Bar** è¿›åº¦æ¡ prominently displayed below or near Panda, showing progress and target reward icon.
        *   *Bottom:* Key active Task display/button area. Recent reward notifications/log.
    *   **Navigation:** Fixed bottom navigation bar (Home, Rewards/Draw, Journey, Shop, Task List).
    *   **Key Interactions:** Tapping Panda (petting), feeding shortcut, claiming task rewards, accessing other sections via icons/nav bar, checking Timeliness Bar.
*   **4.2. Task Page**
    *   **Purpose:** View and manage daily/current tasks.
    *   **Layout:**
        *   *Top:* Date, overall daily progress ("X/Y tasks complete"). Filter/Sort options.
        *   *Main:* Vertical scrollable list of tasks. Each task item shows:
            *   Name/Description.
            *   Associated icon (habit type).
            *   Reward preview (base resources).
            *   **Timeliness Icon (â°/âœ¨)** if eligible.
            *   **Time Window/Deadline** clearly stated.
            *   **Challenge/Custom Goal Indicator (ğŸ”¥/ğŸ‘¤)** if applicable.
            *   Checkbox/button/swipe to complete.
    *   **Key Interactions:** Marking tasks complete (triggers reward/timeliness feedback), filtering list, potentially adding new tasks (VIP).
*   **4.3. Challenge Page**
    *   **Purpose:** Track progress on long-term goals and special events.
    *   **Layout:**
        *   *Top:* Tabs or filters for challenge categories (Active, Continuous, Event, Completed).
        *   *Main:* Card-based view of Challenges. Each card shows Title, Key Reward, Progress Bar, Time Limit, potentially list of sub-tasks.
    *   **Key Interactions:** Viewing challenge details, accepting new challenges, tracking progress, claiming final challenge rewards.
*   **4.4. Journey Page (Panda Growth & Milestones)**
    *   **Purpose:** Visualize Panda's growth path and user's major achievements.
    *   **Layout:**
        *   *Top/Main:* Visual representation of Panda's evolution path (timeline, tree, etc.). Nodes mark key levels and Milestones. Each node shows requirement and reward. Clear indication of completed/current/locked status.
        *   *Bottom/Tab:* Log of achieved Milestones and potentially significant past accomplishments.
    *   **Key Interactions:** Exploring the growth path, seeing future rewards, reviewing past achievements.
*   **4.5. Shop Page**
    *   **Purpose:** Browse and purchase cosmetic items, resources, or VIP subscription.
    *   **Layout:**
        *   *Top:* Search bar, scrollable category filters (Decorations, Skins, Resources, VIP).
        *   *Main:* Grid/list of items with image, name, price. Highlighted section for Sales/Featured/VIP items.
        *   *Item Detail View:* Larger image/preview, description, purchase button.
    *   **Key Interactions:** Browsing categories, searching, viewing item details, making purchases.
*   **4.6. Pet Interaction Page**
    *   **Purpose:** Direct interaction with the Panda, feeding, accessing skills.
    *   **Layout:**
        *   *Top:* Panda status indicators (Mood, Health, Energy).
        *   *Center:* Large interactive Panda view.
        *   *Bottom:* Interaction buttons (Feed, Play, Train, Reflect). Section showing unlocked skills/abilities.
    *   **Key Interactions:** Feeding Panda (uses resources), playing mini-games (if any), triggering reflection, viewing/upgrading skills.
*   **4.7. Lucky Draw Page**
    *   **Purpose:** Spend Luck Points for random rewards.
    *   **Layout:**
        *   *Top:* Current Luck Point balance (â­).
        *   *Center:* Visually engaging draw mechanism (wheel, chest, gacha machine). "Draw x1" and "Draw x10" buttons showing point costs.
        *   *Bottom/Side:* Display of potential prize pool highlights (especially rare items). Link to view probabilities/full pool. History log of recent wins.
    *   **Key Interactions:** Spending points to initiate draws, viewing results, checking prize pool.
*   **4.8. Reflection Module (Modal/Separate Screen)**
    *   **Purpose:** Guided self-reflection when struggling.
    *   **Layout:** Calm, simple interface. Text-based dialogue with Panda avatar. Options for user input (buttons, simple text entry). Clear display of Panda's questions and supportive statements.
    *   **Key Interactions:** Reading prompts, selecting responses or typing brief reflections, receiving actionable suggestions.

**5. API Endpoint Structure Analysis (High-Level)**

*(Assuming a standard RESTful API structure for communication between the mobile app and backend server)*

*   **User:**
    *   `POST /auth/register`
    *   `POST /auth/login`
    *   `GET /user/profile`
    *   `PUT /user/profile`
    *   `GET /user/vip_status`
*   **Panda:**
    *   `GET /panda/status` (Level, evolution, mood, health)
    *   `POST /panda/feed` (Body: {resource_type, amount})
    *   `POST /panda/interact` (Body: {interaction_type})
    *   `GET /panda/customization`
    *   `PUT /panda/customization`
*   **Tasks:**
    *   `GET /tasks?date={YYYY-MM-DD}` (Fetch tasks for a specific day)
    *   `POST /tasks` (Create custom task - basic)
    *   `PUT /tasks/{taskId}` (Update task - e.g., recurrence)
    *   `POST /tasks/{taskId}/complete` (Crucially includes timestamp for timely check)
    *   `DELETE /tasks/{taskId}`
*   **Challenges:**
    *   `GET /challenges?status=active|completed`
    *   `GET /challenges/{challengeId}`
    *   `POST /challenges/{challengeId}/accept`
    *   `POST /challenges/{challengeId}/claim_reward`
*   **User-Defined Goals (VIP):**
    *   `POST /goals` (VIP only - create Goal and sub-tasks)
    *   `GET /goals` (VIP only - list user's custom goals)
    *   `GET /goals/{goalId}`
    *   `PUT /goals/{goalId}`
    *   `DELETE /goals/{goalId}`
*   **Timely Rewards:**
    *   `GET /timely_rewards/status` (Current Luck Points, Timeliness Bar progress & target reward)
    *   `POST /lucky_draw/draw` (Body: {draw_count}) -> Returns awarded items
    *   `GET /lucky_draw/pool` (Info about potential prizes)
    *   `POST /timely_rewards/claim_bar_reward`
*   **Progression:**
    *   `GET /achievements`
    *   `GET /milestones`
*   **Shop & Monetization:**
    *   `GET /shop/items?category={category}`
    *   `POST /shop/purchase/{itemId}`
    *   `POST /vip/subscribe` (Handles App Store receipt validation)
*   **Social:**
    *   `GET /friends`
    *   `POST /friends/add`
    *   `POST /friends/{friendId}/send_encouragement`
    *   `GET /community/feed` (For shared stories)

**6. Non-Functional Requirements**

*   **6.1. Performance:** Smooth animations, fast load times, responsive UI. Backend API responses should be quick (<500ms target).
*   **6.2. Reliability:** Stable app with minimal crashes. Accurate tracking of tasks, resources, and progression. No loss of rewards due to technical issues (addressing Finch complaint). Robust data synchronization.
*   **6.3. Scalability:** Backend infrastructure capable of handling a growing user base.
*   **6.4. Security:** Secure handling of user authentication and personal data (including mood/reflection data if stored). Compliance with privacy regulations (GDPR, CCPA, etc.). Secure payment processing integration.
*   **6.5. Usability:** Intuitive navigation, clear visual hierarchy. Features should be discoverable. Onboarding should effectively teach core mechanics.
*   **6.6. Accessibility:** Adherence to platform accessibility guidelines (e.g., font sizes, color contrast, screen reader support) where feasible.

**7. Future Considerations / Roadmap Ideas**

*   Advanced Panda interactions and mini-games.
*   More sophisticated habit analytics and insights for users.
*   Deeper social features (e.g., forming accountability groups).
*   Integration with wearable devices (e.g., step tracking).
*   Expanded range of guided exercises (mindfulness, fitness).
*   Themed seasonal events with unique mechanics and rewards.

**8. Appendix**

*(Note: This section assumes the detailed tables provided in earlier prompts are available as appendices.)*

*   **Appendix A:** Detailed Task Lists (Daily, Mainline, Side - including 0-7 Day User Behavior Expectation Table)
*   **Appendix B:** Detailed Achievement List & Descriptions (Including Timeliness Achievements)
*   **Appendix C:** Detailed Milestone List & Descriptions (Lifecycle-based, including Timeliness Milestones)
*   **Appendix D:** Detailed Challenge List & Descriptions (Categorized by duration/type)
*   **Appendix E:** Reward Coefficient Tables (Task Type vs. VIP Level, Timely Reward Coefficients)
*   **Appendix F:** Data Models (JSON examples for Goal, Task, Achievement, Milestone, etc.)
*   **Appendix G:** Lucky Draw Pool Itemization (Example list of items and tiers)

---

This PRD provides a comprehensive guide for the development of PandaHabit, focusing on creating a supportive, engaging, and effective self-care and habit-building application that learns from and improves upon existing market offerings.
</file>

<file path="prompt.md">
å¥½çš„ï¼Œè¿™æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„ã€ç®€æ˜æ‰¼è¦ä¸”ä¸å¤±ç»†èŠ‚çš„ Prompt ç‰ˆæœ¬ï¼Œç”¨äºç”Ÿæˆæ¸¸æˆåŒ– App åŸå‹åŠå…¶è®¾è®¡æ–‡æ¡£ã€‚

**(Start of Independent & Concise Gamified App Prototype Prompt)**

**Prompt: æ¸¸æˆåŒ– App åŸå‹ä¸è®¾è®¡æ–‡æ¡£ç”Ÿæˆ (ç”¨æˆ·èšç„¦ä¸åŠŸèƒ½å®ç°)**

**ä»»åŠ¡ï¼š** AI ä½œä¸ºé¦–å¸­ç­–åˆ’ä¸è®¾è®¡å¸ˆï¼Œéœ€æ„æ€å¹¶åˆ›å»ºä¸€ä¸ªåŠŸèƒ½ä¸°å¯Œã€ç”¨æˆ·ä½“éªŒå“è¶Šçš„æ¸¸æˆåŒ– App åŸå‹ (`app.html`) åŠå…¶è¯¦å°½çš„è®¾è®¡æ–‡æ¡£ (`app-design-brief.md`)ã€‚æ ¸å¿ƒç›®æ ‡æ˜¯æœ€å¤§åŒ–ç”¨æˆ·å‚ä¸åº¦ï¼Œé©±åŠ¨è®¢é˜…è½¬åŒ–ï¼Œå¹¶ä½“ç°äº§å“ä»·å€¼ã€‚

**æ ¸å¿ƒäº¤ä»˜ç‰©ï¼š**

1.  **`app** å¯äº¤äº’çš„ App åŸå‹ï¼Œé‡‡ç”¨ç»Ÿä¸€çš„æ¸¸æˆ UI é£æ ¼ï¼ŒåŒ…å«ä¸‹è¿°æ ¸å¿ƒåŠŸèƒ½ã€‚
2.  **`app-design-brief.md`:** è¯¦ç»†çš„è®¾è®¡æ–‡æ¡£ï¼Œé˜è¿°æ‰€æœ‰ç ”ç©¶ã€ç­–ç•¥ã€è®¾è®¡å†³ç­–åŠæŠ€æœ¯å»ºè®®ã€‚

**å…³é”®è¦æ±‚ä¸ AI èŒè´£ï¼š**

*   **AI è‡ªä¸»æ€§ï¼š** å³ä½¿äº§å“éœ€æ±‚ (`prd.md`) ä¸å®Œæ•´ï¼ŒAI ä¹Ÿéœ€ä¸»åŠ¨è¿›è¡Œå¸‚åœºè°ƒç ”ã€ç”¨æˆ·åˆ†æ (èšç„¦æ¸¸æˆç©å®¶)ã€ç«å“åˆ†æ (æ¸¸æˆ App UI/UX)ï¼Œè¡¥å……ä¿¡æ¯å¹¶è‡ªä¸»ä¼˜åŒ–/æ‹“å±•åŠŸèƒ½ã€‚
*   **æ ¸å¿ƒåŠŸèƒ½ (åŸå‹å¿…å¤‡)ï¼š**
    1.  **è¯­è¨€é€‰æ‹©ï¼š** åœ¨è®¾ç½®å†…æä¾›ï¼ŒJSONé©±åŠ¨ï¼Œ`data-i18n` å±æ€§æ”¯æŒã€‚
    2.  **æ’è¡Œæ¦œï¼š** è‹¥ PRD æœªæåŠï¼ŒAI éœ€åˆ¤æ–­æ˜¯å¦æ·»åŠ ä»¥å¢å¼ºæ¸¸æˆæ€§ã€‚
    3.  **è®¢é˜…å¼•å¯¼ä¼˜åŒ–ï¼š** å®ç°æœ‰æ•ˆçš„è®¢é˜… UI/UX ç­–ç•¥ (å¦‚ä¸‹æ–‡è¯¦è¿°)ã€‚
*   **æ¸¸æˆ UI é£æ ¼ï¼š** AI å°†æ ¹æ®ç”¨æˆ·è¾“å…¥æˆ–è‡ªä¸»é€‰æ‹©å¹¶è®ºè¯ä¸€ç§ç‰¹å®šæ¸¸æˆ UI é£æ ¼ (ä¾‹å¦‚ï¼šé­”å¹»ã€ç§‘æŠ€ã€äºŒæ¬¡å…ƒã€ä¼‘é—²ã€å¤å¤ç­‰ï¼Œå…·ä½“é£æ ¼åˆ—è¡¨å¯å‚è€ƒä¹‹å‰çš„è¯¦ç»†ç‰ˆæœ¬)ï¼Œå¹¶ç¡®ä¿å…¶åœ¨ App åŸå‹ä¸­çš„ä¸€è‡´æ€§ä¸æ²‰æµ¸æ„Ÿã€‚
*   **æ¸…æ™°å¯¼èˆªï¼š** åŸºäºç”¨æˆ·æä¾›çš„â€œApp ç»“æ„ä¸å¯¼èˆªâ€æˆ– AI çš„æœ€ä½³å®è·µç ”ç©¶ï¼Œæ„å»ºç›´è§‚æ˜“ç”¨çš„å¯¼èˆªç³»ç»Ÿã€‚

**ç”¨æˆ·éœ€æä¾›ï¼š**

1.  **`prd.md` (äº§å“éœ€æ±‚æ–‡æ¡£)ï¼š** å³ä½¿ä¸å®Œæ•´ã€‚
2.  **æ¸¸æˆ App æ ¸å¿ƒä¿¡æ¯ï¼š** åç§°ã€ä¸»è¦å–ç‚¹ã€ç›®æ ‡ç”¨æˆ·ç‰¹å¾ã€å“ç‰Œè°ƒæ€§ç­‰ã€‚
3.  **App ç»“æ„ä¸å¯¼èˆªè“å›¾ (å¼ºçƒˆå»ºè®®)ï¼š**
    *   **ä¸»è¦å¯¼èˆªé¡µé¢åˆ—è¡¨ï¼š** (ä¾‹å¦‚ï¼šé¦–é¡µã€æ¸¸æˆä¸­å¿ƒã€ä»»åŠ¡ã€ä¸ªäººèµ„æ–™ã€è®¾ç½®ã€å•†åº—)ã€‚
    *   **æ¬¡è¦é¡µé¢åˆ—è¡¨åŠå…¶å…¥å£ï¼š** (ä¾‹å¦‚ï¼šä»æ¸¸æˆä¸­å¿ƒ -> æ¸¸æˆè¯¦æƒ…é¡µï¼›ä»è®¾ç½® -> è¯­è¨€é€‰æ‹©é¡µ)ã€‚
    *   **å…³é”®æµç¨‹é¡µé¢ï¼š** (ä¾‹å¦‚ï¼šæ–°æ‰‹å¼•å¯¼ã€ä»˜è´¹å¢™ã€åˆ†äº«æµç¨‹)ã€‚
    *   *è‹¥ç”¨æˆ·æœªæä¾›ï¼ŒAI å°†åŸºäºç ”ç©¶è¿›è¡Œå‡è®¾å¹¶è¯´æ˜ã€‚*

**AI ç ”ç©¶ä¸è§„åˆ’ (`app-design-brief.md` ä¸­ä½“ç°)ï¼š**

*   **å¸‚åœºä¸ç”¨æˆ·æ´å¯Ÿï¼š** åˆ†æå¸‚åœºè¶‹åŠ¿ã€ç”¨æˆ·éœ€æ±‚ä¸ç—›ç‚¹ã€æ¸¸æˆä¹ æƒ¯ã€UI/å¯¼èˆªåå¥½ã€‚
*   **ç«å“åˆ†æï¼š** å­¦ä¹ æˆåŠŸç«å“çš„ UI/UXã€åŠŸèƒ½ã€å¯¼èˆªæ¶æ„ã€‚
*   **æœ€ä½³å®è·µåº”ç”¨ï¼š** èå…¥ç§»åŠ¨ç«¯ UXã€æ¸¸æˆåŒ–è®¾è®¡ã€å¤šè¯­è¨€æ”¯æŒã€æ’è¡Œæ¦œè®¾è®¡ã€å¯¼èˆªè®¾è®¡åŠè®¢é˜…è½¬åŒ–ç­–ç•¥ã€‚
*   **è®¾è®¡å†³ç­–è®ºè¯ï¼š** è¯¦ç»†è¯´æ˜å„é¡¹è®¾è®¡é€‰æ‹© (é¢œè‰²ã€å¸ƒå±€ã€äº¤äº’ã€åŠŸèƒ½ç­‰) çš„ç†ç”±ï¼Œå¹¶ä¸ç ”ç©¶ç»“æœå’Œæœ€ä½³å®è·µå…³è”ã€‚

**`app.html` åŸå‹æ„å»ºè¦ç‚¹ï¼š**

*   **ç”¨æˆ·ä½“éªŒä¼˜å…ˆï¼š** ç•Œé¢ç›´è§‚ï¼Œæ“ä½œæµç•…ï¼Œæ ¸å¿ƒæµç¨‹æ¸…æ™°ã€‚
*   **å“åº”å¼è®¾è®¡ï¼š** é€‚é…ä¸»æµç§»åŠ¨è®¾å¤‡å±å¹•ã€‚
*   **äº¤äº’åé¦ˆï¼š** åŒ…å«æŒ‰é’®ç‚¹å‡»ã€é¡µé¢åˆ‡æ¢ç­‰åŸºæœ¬äº¤äº’ã€‚
*   **è®¢é˜… UI/UX å®ç°ï¼š**
    *   **åˆ†å±‚æç¤ºï¼š** åœ¨ä¸åŒç”¨æˆ·é˜¶æ®µæä¾›è®¢é˜…å…¥å£ã€‚
    *   **â€œPROâ€ä¸“åŒºï¼š** é›†ä¸­å±•ç¤ºé«˜çº§åŠŸèƒ½ä»·å€¼ã€‚
    *   **è§†è§‰å¼ºåŒ–ï¼š** çªå‡ºè®¢é˜…æŒ‰é’®å’Œæ ¸å¿ƒä»·å€¼ã€‚
    *   **æƒ…å¢ƒè§¦å‘ï¼š** åœ¨ç”¨æˆ·æœ€éœ€è¦é«˜çº§åŠŸèƒ½æ—¶æç¤ºã€‚
    *   **æŒ½ç•™æœºåˆ¶ï¼š** ç”¨æˆ·å°è¯•å–æ¶ˆè®¢é˜…æ—¶æä¾›ä¼˜æƒ æˆ–é‡ç”³ä»·å€¼ã€‚
    *   **ç¤¾äº¤è¯æ˜ï¼š** (å¯é€‰) å±•ç¤ºç”¨æˆ·è¯„ä»·ã€‚
*   **å¯¼èˆªå®ç°ï¼š** æ ¹æ®è§„åˆ’çš„ç»“æ„å’Œå¯¼èˆªæ¨¡å¼ (å¦‚åº•éƒ¨Tabã€æŠ½å±‰å¼ç­‰) å®ç°ï¼Œç¡®ä¿æ‰€æœ‰é¡µé¢å¯è¾¾ä¸”æµç¨‹é¡ºç•…ã€‚

**`app-design-brief.md` æ–‡æ¡£ç»“æ„ï¼š**

1.  **å¼•è¨€ä¸ç ”ç©¶æ€»ç»“ï¼š** PRDåˆ†æã€AIè‡ªä¸»ç ”ç©¶å‘ç° (å¸‚åœºã€ç”¨æˆ·ã€ç«å“)ã€‚
2.  **App æ•´ä½“è®¾è®¡ç­–ç•¥ï¼š** åŠŸèƒ½æ‹“å±•ç†ç”±ã€æ ¸å¿ƒè®¾è®¡åŸåˆ™ã€‚
3.  **è¯¦ç»†è®¾è®¡è§„åˆ’ï¼š**
    *   **ä¿¡æ¯æ¶æ„ä¸å¯¼èˆªè®¾è®¡ï¼š** æ¶æ„å›¾ã€å¯¼èˆªæ¨¡å¼é€‰æ‹©åŠç†ç”±ã€é¡µé¢è·³è½¬æµç¨‹ã€å…³é”®é¡µé¢è®¾è®¡åˆ†æ (å«æˆªå›¾/çº¿æ¡†å›¾)ã€‚
    *   **æ¸¸æˆ UI é£æ ¼é€‰æ‹©ä¸åº”ç”¨ï¼š** ç†ç”±ã€å…·ä½“è§†è§‰å…ƒç´ è§„åˆ’ã€‚
    *   **æ ¸å¿ƒåŠŸèƒ½è®¾è®¡è¯¦è§£ï¼š** è¯­è¨€é€‰æ‹©ã€æ’è¡Œæ¦œ (è‹¥æ·»åŠ )ã€è®¢é˜…å¼•å¯¼ UI/UX (å„ç­–ç•¥ç‚¹å®ç°æ–¹æ¡ˆã€A/Bæµ‹è¯•å»ºè®®)ã€‚
    *   **å…¶ä»–è®¾è®¡è¦ç´ ï¼š** æ–‡æ¡ˆé£æ ¼ã€è§†è§‰ç´ æã€é¢œè‰²æ–¹æ¡ˆã€CTAã€å“åº”å¼ç­–ç•¥ã€‚
4.  **æŠ€æœ¯ä¸åˆè§„æ€§å»ºè®®ï¼š** æ€§èƒ½ä¼˜åŒ–ã€æŠ€æœ¯é€‰å‹å‚è€ƒã€åˆè§„æ€§æç¤ºã€‚

**è¯„ä¼°é‡ç‚¹ï¼š**

*   **ç”¨æˆ·ä½“éªŒä¸å¯¼èˆªï¼š** æ˜¯å¦ç›´è§‚æ˜“ç”¨ï¼Ÿæµç¨‹æ˜¯å¦é¡ºç•…ï¼Ÿ
*   **æ ¸å¿ƒåŠŸèƒ½å®Œæ•´æ€§ï¼š** è¯­è¨€é€‰æ‹©ã€æ’è¡Œæ¦œã€è®¢é˜…å¼•å¯¼æ˜¯å¦æŒ‰è¦æ±‚å®ç°å¹¶æœ‰æ•ˆï¼Ÿ
*   **æ¸¸æˆ UI æ²‰æµ¸æ„Ÿï¼š** UI é£æ ¼æ˜¯å¦ç»Ÿä¸€ä¸”å¸å¼•äººï¼Ÿ
*   **è®¾è®¡æ–‡æ¡£è´¨é‡ï¼š** AI çš„ç ”ç©¶ã€å†³ç­–å’Œè§„åˆ’æ˜¯å¦æ¸…æ™°ã€è¯¦å°½ä¸”åˆç†ï¼Ÿ

**æŒ‡ç¤º AIï¼š** ä¸¥æ ¼éµå¾ªä¸Šè¿°è¦æ±‚ï¼Œç‰¹åˆ«æ˜¯æ ¸å¿ƒåŠŸèƒ½çš„å®ç°ã€æ¸…æ™°å¯¼èˆªçš„æ„å»ºã€æŒ‡å®šæˆ–é€‰å®šæ¸¸æˆ UI é£æ ¼çš„æ·±åº¦èåˆï¼Œä»¥åŠè¯¦å°½è®¾è®¡æ–‡æ¡£çš„äº§å‡ºã€‚

**(End of Independent & Concise Gamified App Prototype Prompt)**
</file>

<file path="public/assets/abilities/bamboo-focus.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Bamboo Focus</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="focusGradient">
            <stop stop-color="#4A90E2" offset="0%"></stop>
            <stop stop-color="#1A5F4A" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Target/Focus symbol -->
        <circle cx="50" cy="50" r="30" stroke="url(#focusGradient)" stroke-width="3" fill="none"></circle>
        <circle cx="50" cy="50" r="20" stroke="url(#focusGradient)" stroke-width="2" fill="none"></circle>
        <circle cx="50" cy="50" r="10" stroke="url(#focusGradient)" stroke-width="1" fill="url(#focusGradient)"></circle>
        
        <!-- Crosshair lines -->
        <path d="M50,10 L50,30" stroke="url(#focusGradient)" stroke-width="2"></path>
        <path d="M50,70 L50,90" stroke="url(#focusGradient)" stroke-width="2"></path>
        <path d="M10,50 L30,50" stroke="url(#focusGradient)" stroke-width="2"></path>
        <path d="M70,50 L90,50" stroke="url(#focusGradient)" stroke-width="2"></path>
        
        <!-- Bamboo elements -->
        <path d="M20,20 L25,25" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M75,75 L80,80" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M20,80 L25,75" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M75,25 L80,20" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#4A90E2" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/bamboo-heart.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Bamboo Heart</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="bambooGradient">
            <stop stop-color="#88B04B" offset="0%"></stop>
            <stop stop-color="#1A5F4A" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Heart shape made of bamboo -->
        <path d="M50,75 C50,75 25,55 25,40 C25,30 35,25 45,30 C48,32 50,35 50,35 C50,35 52,32 55,30 C65,25 75,30 75,40 C75,55 50,75 50,75 Z" fill="url(#bambooGradient)" stroke="#1A5F4A" stroke-width="2"></path>
        
        <!-- Bamboo details -->
        <path d="M40,35 L40,65" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        <path d="M50,35 L50,65" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        <path d="M60,35 L60,65" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        
        <path d="M35,45 L65,45" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        <path d="M30,55 L70,55" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#88B04B" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/bamboo-master.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Bamboo Master</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="masterGradient">
            <stop stop-color="#FFD700" offset="0%"></stop>
            <stop stop-color="#D4AF37" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="4" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Golden bamboo stalks -->
        <path d="M30,20 L30,80" stroke="url(#masterGradient)" stroke-width="4" stroke-linecap="round"></path>
        <path d="M50,20 L50,80" stroke="url(#masterGradient)" stroke-width="4" stroke-linecap="round"></path>
        <path d="M70,20 L70,80" stroke="url(#masterGradient)" stroke-width="4" stroke-linecap="round"></path>
        
        <!-- Bamboo nodes -->
        <path d="M25,30 L35,30" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M25,50 L35,50" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M25,70 L35,70" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M45,40 L55,40" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M45,60 L55,60" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M65,30 L75,30" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M65,50 L75,50" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M65,70 L75,70" stroke="url(#masterGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Bamboo leaves -->
        <path d="M30,25 C25,20 20,25 25,30" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M30,75 C25,80 20,75 25,70" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M50,35 C45,30 40,35 45,40" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M50,65 C45,70 40,65 45,60" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M70,25 C75,20 80,25 75,30" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M70,75 C75,80 80,75 75,70" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Master symbol -->
        <circle cx="50" cy="50" r="35" stroke="url(#masterGradient)" stroke-width="2" stroke-dasharray="3,2"></circle>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#D4AF37" stroke-width="3" stroke-opacity="0.9"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/default-ability.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Default Ability</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="defaultGradient">
            <stop stop-color="#9E9E9E" offset="0%"></stop>
            <stop stop-color="#616161" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Question mark -->
        <circle cx="50" cy="50" r="30" fill="url(#defaultGradient)"></circle>
        <text x="50" y="62" font-family="Arial" font-size="40" fill="#FFFFFF" text-anchor="middle">?</text>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#9E9E9E" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/panda-vitality.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Panda Vitality</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="energyGradient">
            <stop stop-color="#FFD700" offset="0%"></stop>
            <stop stop-color="#FFA500" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Panda face -->
        <circle cx="50" cy="50" r="30" fill="white" stroke="black" stroke-width="2"></circle>
        
        <!-- Panda ears -->
        <circle cx="30" cy="30" r="10" fill="black"></circle>
        <circle cx="70" cy="30" r="10" fill="black"></circle>
        
        <!-- Panda eyes -->
        <ellipse cx="40" cy="45" rx="8" ry="7" fill="black"></ellipse>
        <ellipse cx="60" cy="45" rx="8" ry="7" fill="black"></ellipse>
        
        <!-- Panda nose -->
        <ellipse cx="50" cy="55" rx="5" ry="4" fill="black"></ellipse>
        
        <!-- Energy aura -->
        <circle cx="50" cy="50" r="38" stroke="url(#energyGradient)" stroke-width="3" stroke-dasharray="5,3"></circle>
        
        <!-- Energy rays -->
        <path d="M50,12 L50,20" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M50,80 L50,88" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M12,50 L20,50" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M80,50 L88,50" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M25,25 L31,31" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M69,69 L75,75" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M25,75 L31,69" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M69,31 L75,25" stroke="url(#energyGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#FFA500" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/abilities/panda-wisdom.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Panda Wisdom</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="wisdomGradient">
            <stop stop-color="#9C27B0" offset="0%"></stop>
            <stop stop-color="#673AB7" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="45" fill="#F5F5DC" filter="url(#glow)"></circle>
        
        <!-- Panda face -->
        <circle cx="50" cy="45" r="25" fill="white" stroke="black" stroke-width="2"></circle>
        
        <!-- Panda ears -->
        <circle cx="35" cy="30" r="8" fill="black"></circle>
        <circle cx="65" cy="30" r="8" fill="black"></circle>
        
        <!-- Panda eyes -->
        <ellipse cx="42" cy="42" rx="6" ry="5" fill="black"></ellipse>
        <ellipse cx="58" cy="42" rx="6" ry="5" fill="black"></ellipse>
        
        <!-- Panda nose -->
        <ellipse cx="50" cy="50" rx="4" ry="3" fill="black"></ellipse>
        
        <!-- Wisdom scroll -->
        <path d="M30,65 L70,65 L70,80 C65,75 60,78 55,80 C50,82 45,82 40,80 C35,78 30,75 30,80 L30,65 Z" fill="#F8F0D8" stroke="#9C27B0" stroke-width="2"></path>
        
        <!-- Scroll lines -->
        <path d="M35,70 L65,70" stroke="#9C27B0" stroke-width="1" stroke-opacity="0.5"></path>
        <path d="M35,75 L65,75" stroke="#9C27B0" stroke-width="1" stroke-opacity="0.5"></path>
        
        <!-- Wisdom aura -->
        <path d="M30,20 L35,15 L40,20 L45,15 L50,20 L55,15 L60,20 L65,15 L70,20" stroke="url(#wisdomGradient)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"></path>
        
        <!-- Stars -->
        <path d="M25,35 L27,30 L29,35 L34,35 L30,38 L32,43 L27,40 L22,43 L24,38 L20,35 Z" fill="url(#wisdomGradient)" opacity="0.7"></path>
        <path d="M75,35 L77,30 L79,35 L84,35 L80,38 L82,43 L77,40 L72,43 L74,38 L70,35 Z" fill="url(#wisdomGradient)" opacity="0.7"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="45" stroke="#9C27B0" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/accessories/bamboo-hat.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- ç«¹å¶å¸½ -->
  <defs>
    <radialGradient id="bambooHatGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
      <stop offset="0%" stop-color="#A8C66C" />
      <stop offset="100%" stop-color="#88B04B" />
    </radialGradient>
  </defs>
  
  <!-- å¸½å­ä¸»ä½“ -->
  <ellipse cx="100" cy="40" rx="80" ry="25" fill="url(#bambooHatGradient)" />
  
  <!-- å¸½å­é¡¶éƒ¨ -->
  <path d="M100,15 Q130,30 160,40 Q130,50 100,65 Q70,50 40,40 Q70,30 100,15" fill="#88B04B" />
  
  <!-- å¸½å­è£…é¥° - ç«¹å¶ -->
  <path d="M70,30 Q60,20 50,25 Q55,30 60,35 Q65,33 70,30" fill="#A8C66C" />
  <path d="M130,30 Q140,20 150,25 Q145,30 140,35 Q135,33 130,30" fill="#A8C66C" />
  
  <!-- å¸½å­ç»³å­ -->
  <path d="M40,40 Q70,45 100,40 Q130,45 160,40" stroke="#5D4037" stroke-width="1" fill="none" />
  <path d="M100,40 L100,65" stroke="#5D4037" stroke-width="1" fill="none" />
</svg>
</file>

<file path="public/assets/accessories/default.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- é»˜è®¤è£…é¥°å›¾æ ‡ -->
  <rect x="50" y="50" width="100" height="100" rx="10" ry="10" fill="#f0f0f0" stroke="#cccccc" stroke-width="2" />
  <text x="100" y="110" font-family="Arial" font-size="24" text-anchor="middle" fill="#888888">è£…é¥°</text>
</svg>
</file>

<file path="public/assets/accessories/gold-frame.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- é‡‘æ¡† -->
  <defs>
    <linearGradient id="goldGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" stop-color="#FFD700" />
      <stop offset="50%" stop-color="#D4AF37" />
      <stop offset="100%" stop-color="#FFD700" />
    </linearGradient>
  </defs>
  
  <!-- å¤–åœ†æ¡† -->
  <circle cx="100" cy="100" r="95" stroke="url(#goldGradient)" stroke-width="10" fill="none" />
  
  <!-- è£…é¥°å…ƒç´  - ä¸Š -->
  <path d="M100,5 L100,15 M90,7 L110,7" stroke="url(#goldGradient)" stroke-width="5" />
  
  <!-- è£…é¥°å…ƒç´  - ä¸‹ -->
  <path d="M100,185 L100,195 M90,193 L110,193" stroke="url(#goldGradient)" stroke-width="5" />
  
  <!-- è£…é¥°å…ƒç´  - å·¦ -->
  <path d="M5,100 L15,100 M7,90 L7,110" stroke="url(#goldGradient)" stroke-width="5" />
  
  <!-- è£…é¥°å…ƒç´  - å³ -->
  <path d="M185,100 L195,100 M193,90 L193,110" stroke="url(#goldGradient)" stroke-width="5" />
  
  <!-- è§’è½è£…é¥° - å·¦ä¸Š -->
  <path d="M30,30 Q40,20 50,30" stroke="url(#goldGradient)" stroke-width="5" fill="none" />
  
  <!-- è§’è½è£…é¥° - å³ä¸Š -->
  <path d="M150,30 Q160,20 170,30" stroke="url(#goldGradient)" stroke-width="5" fill="none" />
  
  <!-- è§’è½è£…é¥° - å·¦ä¸‹ -->
  <path d="M30,170 Q40,180 50,170" stroke="url(#goldGradient)" stroke-width="5" fill="none" />
  
  <!-- è§’è½è£…é¥° - å³ä¸‹ -->
  <path d="M150,170 Q160,180 170,170" stroke="url(#goldGradient)" stroke-width="5" fill="none" />
</svg>
</file>

<file path="public/assets/accessories/red-ribbon.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- çº¢ä¸å¸¦ -->
  <defs>
    <linearGradient id="ribbonGradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" stop-color="#D73E35" />
      <stop offset="50%" stop-color="#FF5252" />
      <stop offset="100%" stop-color="#D73E35" />
    </linearGradient>
  </defs>
  
  <!-- ä¸å¸¦ä¸»ä½“ -->
  <path d="M60,90 Q80,85 100,90 Q120,85 140,90 Q120,95 100,100 Q80,95 60,90" fill="url(#ribbonGradient)" />
  
  <!-- ä¸å¸¦å·¦ä¾§ -->
  <path d="M60,90 Q50,100 40,120 Q45,115 50,110 Q55,105 60,90" fill="#D73E35" />
  
  <!-- ä¸å¸¦å³ä¾§ -->
  <path d="M140,90 Q150,100 160,120 Q155,115 150,110 Q145,105 140,90" fill="#D73E35" />
  
  <!-- ä¸å¸¦è£…é¥° -->
  <circle cx="100" cy="95" r="5" fill="#FFD700" />
</svg>
</file>

<file path="public/assets/bamboo-bg-pattern.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- Bamboo pattern background -->
  <defs>
    <pattern id="bamboo-pattern" x="0" y="0" width="50" height="50" patternUnits="userSpaceOnUse">
      <!-- Bamboo stalk -->
      <path d="M25,0 L25,50" stroke="#88B04B" stroke-width="3" opacity="0.1"/>
      <!-- Bamboo joints -->
      <path d="M20,10 L30,10" stroke="#88B04B" stroke-width="2" opacity="0.1"/>
      <path d="M20,25 L30,25" stroke="#88B04B" stroke-width="2" opacity="0.1"/>
      <path d="M20,40 L30,40" stroke="#88B04B" stroke-width="2" opacity="0.1"/>
      <!-- Bamboo leaves -->
      <path d="M25,10 C30,5 35,8 38,12" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,25 C30,20 35,23 38,27" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,40 C30,35 35,38 38,42" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,10 C20,5 15,8 12,12" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,25 C20,20 15,23 12,27" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
      <path d="M25,40 C20,35 15,38 12,42" stroke="#88B04B" stroke-width="1.5" fill="none" opacity="0.1"/>
    </pattern>
  </defs>
  <rect width="100%" height="100%" fill="url(#bamboo-pattern)" />
</svg>
</file>

<file path="public/assets/bamboo-leaves.svg">
<svg width="250" height="250" viewBox="0 0 250 250" xmlns="http://www.w3.org/2000/svg">
  <!-- Bamboo stalk -->
  <path d="M50,250 L50,100" stroke="#88B04B" stroke-width="8" stroke-linecap="round"/>
  <path d="M50,100 L50,50" stroke="#88B04B" stroke-width="6" stroke-linecap="round"/>
  
  <!-- Bamboo joints -->
  <path d="M40,220 L60,220" stroke="#1A5F4A" stroke-width="3"/>
  <path d="M40,180 L60,180" stroke="#1A5F4A" stroke-width="3"/>
  <path d="M40,140 L60,140" stroke="#1A5F4A" stroke-width="3"/>
  <path d="M40,100 L60,100" stroke="#1A5F4A" stroke-width="3"/>
  <path d="M40,60 L60,60" stroke="#1A5F4A" stroke-width="3"/>
  
  <!-- Bamboo leaves -->
  <path d="M50,60 C80,30 120,40 140,20" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,60 C90,50 110,70 130,60" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,100 C70,80 100,90 120,70" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,100 C80,110 100,90 120,100" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,140 C30,120 20,100 10,90" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,140 C30,150 20,130 10,140" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,180 C70,160 90,170 110,150" stroke="#88B04B" stroke-width="3" fill="none"/>
  <path d="M50,180 C70,190 90,170 110,180" stroke="#88B04B" stroke-width="3" fill="none"/>
  
  <!-- Leaf details -->
  <path d="M140,20 C150,15 160,25 140,30" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M130,60 C140,55 150,65 130,70" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M120,70 C130,65 140,75 120,80" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M120,100 C130,95 140,105 120,110" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M10,90 C0,85 -5,95 15,100" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M10,140 C0,135 -5,145 15,150" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M110,150 C120,145 130,155 110,160" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
  <path d="M110,180 C120,175 130,185 110,190" stroke="#1A5F4A" stroke-width="1" fill="#88B04B" opacity="0.8"/>
</svg>
</file>

<file path="public/assets/chinese-cloud.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="200px" height="100px" viewBox="0 0 200 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Chinese Cloud</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="cloudGradient">
            <stop stop-color="#F7F9F9" offset="0%"></stop>
            <stop stop-color="#E0E0E0" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M20,60 C10,60 5,50 10,40 C15,30 30,30 35,40 C40,20 60,10 80,20 C100,30 110,20 130,20 C150,20 170,40 160,60 C180,60 190,80 170,90 C150,100 130,90 120,80 C110,90 90,100 70,90 C50,80 40,90 30,80 C20,70 10,60 20,60 Z" 
              fill="url(#cloudGradient)" 
              stroke="#CCCCCC" 
              stroke-width="1">
        </path>
    </g>
</svg>
</file>

<file path="public/assets/chinese-knot.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="150px" viewBox="0 0 100 150" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Chinese Knot</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="knotGradient">
            <stop stop-color="#D73E35" offset="0%"></stop>
            <stop stop-color="#9E1A1A" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Main knot structure -->
        <path d="M50,10 C60,10 70,20 70,30 C70,40 60,45 50,45 C40,45 30,40 30,30 C30,20 40,10 50,10 Z" 
              fill="url(#knotGradient)" 
              stroke="#7A0000" 
              stroke-width="2">
        </path>
        
        <path d="M50,45 C60,45 70,50 70,60 C70,70 60,75 50,75 C40,75 30,70 30,60 C30,50 40,45 50,45 Z" 
              fill="url(#knotGradient)" 
              stroke="#7A0000" 
              stroke-width="2">
        </path>
        
        <path d="M50,75 C60,75 70,80 70,90 C70,100 60,105 50,105 C40,105 30,100 30,90 C30,80 40,75 50,75 Z" 
              fill="url(#knotGradient)" 
              stroke="#7A0000" 
              stroke-width="2">
        </path>
        
        <!-- Decorative elements -->
        <circle cx="50" cy="30" r="5" fill="#FFD700" stroke="#7A0000" stroke-width="1"></circle>
        <circle cx="50" cy="60" r="5" fill="#FFD700" stroke="#7A0000" stroke-width="1"></circle>
        <circle cx="50" cy="90" r="5" fill="#FFD700" stroke="#7A0000" stroke-width="1"></circle>
        
        <!-- Tassels -->
        <path d="M45,105 L40,140" stroke="#7A0000" stroke-width="2" stroke-linecap="round"></path>
        <path d="M55,105 L60,140" stroke="#7A0000" stroke-width="2" stroke-linecap="round"></path>
        
        <path d="M40,120 L35,130" stroke="#7A0000" stroke-width="1" stroke-linecap="round"></path>
        <path d="M40,130 L35,140" stroke="#7A0000" stroke-width="1" stroke-linecap="round"></path>
        
        <path d="M60,120 L65,130" stroke="#7A0000" stroke-width="1" stroke-linecap="round"></path>
        <path d="M60,130 L65,140" stroke="#7A0000" stroke-width="1" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/chinese-lantern.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="150px" viewBox="0 0 100 150" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Chinese Lantern</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="lanternGradient">
            <stop stop-color="#D73E35" offset="0%"></stop>
            <stop stop-color="#9E1A1A" offset="100%"></stop>
        </linearGradient>
        <filter id="lanternGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Lantern top -->
        <path d="M40,20 L60,20 L55,30 L45,30 Z" 
              fill="#D4AF37" 
              stroke="#7A0000" 
              stroke-width="1">
        </path>
        
        <!-- Lantern body -->
        <path d="M45,30 C25,40 25,90 45,100 L55,100 C75,90 75,40 55,30 Z" 
              fill="url(#lanternGradient)" 
              stroke="#7A0000" 
              stroke-width="2"
              filter="url(#lanternGlow)">
        </path>
        
        <!-- Lantern bottom -->
        <path d="M45,100 L55,100 L60,110 L40,110 Z" 
              fill="#D4AF37" 
              stroke="#7A0000" 
              stroke-width="1">
        </path>
        
        <!-- Decorative lines -->
        <path d="M45,30 L45,100" stroke="#7A0000" stroke-width="1" stroke-dasharray="5,5"></path>
        <path d="M55,30 L55,100" stroke="#7A0000" stroke-width="1" stroke-dasharray="5,5"></path>
        <path d="M35,50 L65,50" stroke="#7A0000" stroke-width="1" stroke-dasharray="5,5"></path>
        <path d="M35,70 L65,70" stroke="#7A0000" stroke-width="1" stroke-dasharray="5,5"></path>
        
        <!-- Chinese character for "ç¦" (Fortune) -->
        <text x="50" y="65" font-family="Ma Shan Zheng, cursive" font-size="24" fill="#FFD700" text-anchor="middle">ç¦</text>
        
        <!-- Tassel -->
        <path d="M50,110 L50,130" stroke="#D4AF37" stroke-width="2" stroke-linecap="round"></path>
        <path d="M45,130 L55,130" stroke="#D4AF37" stroke-width="2" stroke-linecap="round"></path>
        <path d="M45,130 L40,140" stroke="#D4AF37" stroke-width="1" stroke-linecap="round"></path>
        <path d="M50,130 L50,140" stroke="#D4AF37" stroke-width="1" stroke-linecap="round"></path>
        <path d="M55,130 L60,140" stroke="#D4AF37" stroke-width="1" stroke-linecap="round"></path>
        
        <!-- String -->
        <path d="M50,10 L50,20" stroke="#7A0000" stroke-width="1"></path>
    </g>
</svg>
</file>

<file path="public/assets/chinese-pattern.svg">
<svg width="100" height="8" viewBox="0 0 100 8" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <pattern id="chinese-border" x="0" y="0" width="20" height="8" patternUnits="userSpaceOnUse">
      <!-- Traditional Chinese border pattern -->
      <path d="M0,4 L5,4 L5,0 L10,0 L10,4 L15,4 L15,0 L20,0 L20,4" 
            stroke="#D4AF37" stroke-width="1" fill="none"/>
      <path d="M0,8 L5,8 L5,4 L10,4 L10,8 L15,8 L15,4 L20,4 L20,8" 
            stroke="#D4AF37" stroke-width="1" fill="none"/>
      <!-- Decorative elements -->
      <circle cx="5" cy="2" r="0.8" fill="#D73E35"/>
      <circle cx="15" cy="2" r="0.8" fill="#D73E35"/>
      <circle cx="5" cy="6" r="0.8" fill="#D73E35"/>
      <circle cx="15" cy="6" r="0.8" fill="#D73E35"/>
    </pattern>
  </defs>
  <rect width="100" height="8" fill="url(#chinese-border)"/>
</svg>
</file>

<file path="public/assets/environments/bamboo-path.svg">
<svg width="800" height="400" viewBox="0 0 800 400" xmlns="http://www.w3.org/2000/svg">
  <!-- ç«¹æ—å°å¾„èƒŒæ™¯ -->
  <defs>
    <linearGradient id="skyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#87CEEB" />
      <stop offset="100%" stop-color="#E0F7FA" />
    </linearGradient>
    <linearGradient id="groundGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#A8C66C" />
      <stop offset="100%" stop-color="#88B04B" />
    </linearGradient>
    <linearGradient id="pathGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#D7CCC8" />
      <stop offset="100%" stop-color="#BCAAA4" />
    </linearGradient>
    <linearGradient id="bambooGradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" stop-color="#7CB342" />
      <stop offset="100%" stop-color="#558B2F" />
    </linearGradient>
  </defs>
  
  <!-- å¤©ç©º -->
  <rect x="0" y="0" width="800" height="200" fill="url(#skyGradient)" />
  
  <!-- è¿œå¤„çš„å±± -->
  <path d="M0,200 Q200,100 400,180 Q600,100 800,200" fill="#A5D6A7" />
  
  <!-- åœ°é¢ -->
  <rect x="0" y="200" width="800" height="200" fill="url(#groundGradient)" />
  
  <!-- å°å¾„ -->
  <path d="M300,400 Q400,350 500,400" fill="url(#pathGradient)" />
  <path d="M320,400 Q400,360 480,400" fill="#E0E0E0" />
  
  <!-- ç«¹å­ç¾¤ - å·¦ä¾§ -->
  <g transform="translate(100, 150)">
    <!-- ç«¹ç«¿ -->
    <rect x="0" y="0" width="10" height="250" fill="url(#bambooGradient)" />
    <rect x="20" y="-30" width="8" height="280" fill="url(#bambooGradient)" />
    <rect x="40" y="-10" width="12" height="260" fill="url(#bambooGradient)" />
    
    <!-- ç«¹èŠ‚ -->
    <rect x="0" y="50" width="10" height="2" fill="#33691E" />
    <rect x="0" y="100" width="10" height="2" fill="#33691E" />
    <rect x="0" y="150" width="10" height="2" fill="#33691E" />
    <rect x="0" y="200" width="10" height="2" fill="#33691E" />
    
    <rect x="20" y="40" width="8" height="2" fill="#33691E" />
    <rect x="20" y="90" width="8" height="2" fill="#33691E" />
    <rect x="20" y="140" width="8" height="2" fill="#33691E" />
    <rect x="20" y="190" width="8" height="2" fill="#33691E" />
    
    <rect x="40" y="60" width="12" height="2" fill="#33691E" />
    <rect x="40" y="110" width="12" height="2" fill="#33691E" />
    <rect x="40" y="160" width="12" height="2" fill="#33691E" />
    <rect x="40" y="210" width="12" height="2" fill="#33691E" />
    
    <!-- ç«¹å¶ -->
    <path d="M5,0 Q15,-20 25,-10 Q15,0 5,0" fill="#A5D6A7" />
    <path d="M5,10 Q25,0 30,15 Q15,20 5,10" fill="#A5D6A7" />
    <path d="M25,-30 Q40,-40 45,-25 Q35,-20 25,-30" fill="#A5D6A7" />
    <path d="M45,-10 Q60,-25 70,-15 Q55,0 45,-10" fill="#A5D6A7" />
  </g>
  
  <!-- ç«¹å­ç¾¤ - å³ä¾§ -->
  <g transform="translate(600, 170)">
    <!-- ç«¹ç«¿ -->
    <rect x="0" y="0" width="10" height="230" fill="url(#bambooGradient)" />
    <rect x="20" y="-20" width="8" height="250" fill="url(#bambooGradient)" />
    <rect x="40" y="10" width="12" height="220" fill="url(#bambooGradient)" />
    
    <!-- ç«¹èŠ‚ -->
    <rect x="0" y="50" width="10" height="2" fill="#33691E" />
    <rect x="0" y="100" width="10" height="2" fill="#33691E" />
    <rect x="0" y="150" width="10" height="2" fill="#33691E" />
    <rect x="0" y="200" width="10" height="2" fill="#33691E" />
    
    <rect x="20" y="40" width="8" height="2" fill="#33691E" />
    <rect x="20" y="90" width="8" height="2" fill="#33691E" />
    <rect x="20" y="140" width="8" height="2" fill="#33691E" />
    <rect x="20" y="190" width="8" height="2" fill="#33691E" />
    
    <rect x="40" y="60" width="12" height="2" fill="#33691E" />
    <rect x="40" y="110" width="12" height="2" fill="#33691E" />
    <rect x="40" y="160" width="12" height="2" fill="#33691E" />
    <rect x="40" y="210" width="12" height="2" fill="#33691E" />
    
    <!-- ç«¹å¶ -->
    <path d="M5,0 Q15,-20 25,-10 Q15,0 5,0" fill="#A5D6A7" />
    <path d="M5,10 Q25,0 30,15 Q15,20 5,10" fill="#A5D6A7" />
    <path d="M25,-20 Q40,-30 45,-15 Q35,-10 25,-20" fill="#A5D6A7" />
    <path d="M45,10 Q60,-5 70,5 Q55,15 45,10" fill="#A5D6A7" />
  </g>
  
  <!-- ç«¹å­ç¾¤ - ä¸­é—´è¿œå¤„ -->
  <g transform="translate(350, 100) scale(0.7)">
    <!-- ç«¹ç«¿ -->
    <rect x="0" y="0" width="10" height="300" fill="url(#bambooGradient)" />
    <rect x="20" y="-30" width="8" height="330" fill="url(#bambooGradient)" />
    <rect x="40" y="-10" width="12" height="310" fill="url(#bambooGradient)" />
    
    <!-- ç«¹èŠ‚ -->
    <rect x="0" y="50" width="10" height="2" fill="#33691E" />
    <rect x="0" y="100" width="10" height="2" fill="#33691E" />
    <rect x="0" y="150" width="10" height="2" fill="#33691E" />
    <rect x="0" y="200" width="10" height="2" fill="#33691E" />
    <rect x="0" y="250" width="10" height="2" fill="#33691E" />
    
    <rect x="20" y="40" width="8" height="2" fill="#33691E" />
    <rect x="20" y="90" width="8" height="2" fill="#33691E" />
    <rect x="20" y="140" width="8" height="2" fill="#33691E" />
    <rect x="20" y="190" width="8" height="2" fill="#33691E" />
    <rect x="20" y="240" width="8" height="2" fill="#33691E" />
    
    <rect x="40" y="60" width="12" height="2" fill="#33691E" />
    <rect x="40" y="110" width="12" height="2" fill="#33691E" />
    <rect x="40" y="160" width="12" height="2" fill="#33691E" />
    <rect x="40" y="210" width="12" height="2" fill="#33691E" />
    <rect x="40" y="260" width="12" height="2" fill="#33691E" />
    
    <!-- ç«¹å¶ -->
    <path d="M5,0 Q15,-20 25,-10 Q15,0 5,0" fill="#A5D6A7" />
    <path d="M5,10 Q25,0 30,15 Q15,20 5,10" fill="#A5D6A7" />
    <path d="M25,-30 Q40,-40 45,-25 Q35,-20 25,-30" fill="#A5D6A7" />
    <path d="M45,-10 Q60,-25 70,-15 Q55,0 45,-10" fill="#A5D6A7" />
  </g>
  
  <!-- äº‘æœµ -->
  <path d="M100,100 Q120,80 140,90 Q160,70 180,90 Q200,80 220,100 Q200,120 180,110 Q160,130 140,110 Q120,120 100,100" fill="white" opacity="0.8" />
  <path d="M500,70 Q520,50 540,60 Q560,40 580,60 Q600,50 620,70 Q600,90 580,80 Q560,100 540,80 Q520,90 500,70" fill="white" opacity="0.8" />
</svg>
</file>

<file path="public/assets/environments/chinese-garden.svg">
<svg width="800" height="400" viewBox="0 0 800 400" xmlns="http://www.w3.org/2000/svg">
  <!-- ä¸­å¼å›­æ—èƒŒæ™¯ -->
  <defs>
    <linearGradient id="skyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#B3E5FC" />
      <stop offset="100%" stop-color="#E1F5FE" />
    </linearGradient>
    <linearGradient id="waterGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#0288D1" />
      <stop offset="100%" stop-color="#03A9F4" />
    </linearGradient>
    <linearGradient id="roofGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#D32F2F" />
      <stop offset="100%" stop-color="#B71C1C" />
    </linearGradient>
    <linearGradient id="woodGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#795548" />
      <stop offset="100%" stop-color="#5D4037" />
    </linearGradient>
    <linearGradient id="stoneGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#9E9E9E" />
      <stop offset="100%" stop-color="#757575" />
    </linearGradient>
  </defs>
  
  <!-- å¤©ç©º -->
  <rect x="0" y="0" width="800" height="200" fill="url(#skyGradient)" />
  
  <!-- è¿œå±± -->
  <path d="M0,200 Q100,150 200,180 Q300,130 400,170 Q500,120 600,160 Q700,140 800,200" fill="#A5D6A7" opacity="0.7" />
  
  <!-- æ°´é¢ -->
  <rect x="0" y="200" width="800" height="200" fill="url(#waterGradient)" />
  
  <!-- æ°´ä¸­å€’å½± -->
  <rect x="350" y="250" width="100" height="100" fill="#5D4037" opacity="0.5" />
  <path d="M350,250 L450,250 L400,200 Z" fill="#B71C1C" opacity="0.5" />
  
  <!-- çŸ³æ¡¥ -->
  <path d="M100,250 Q400,300 700,250" stroke="url(#stoneGradient)" stroke-width="20" fill="none" />
  <rect x="100" y="240" width="20" height="160" fill="url(#stoneGradient)" />
  <rect x="700" y="240" width="20" height="160" fill="url(#stoneGradient)" />
  <rect x="250" y="245" width="15" height="155" fill="url(#stoneGradient)" />
  <rect x="550" y="245" width="15" height="155" fill="url(#stoneGradient)" />
  
  <!-- äº­å­ -->
  <g transform="translate(350, 150)">
    <!-- äº­å­åº•åº§ -->
    <rect x="0" y="50" width="100" height="10" fill="url(#stoneGradient)" />
    
    <!-- äº­å­æŸ±å­ -->
    <rect x="10" y="10" width="10" height="40" fill="url(#woodGradient)" />
    <rect x="80" y="10" width="10" height="40" fill="url(#woodGradient)" />
    <rect x="10" y="0" width="80" height="10" fill="url(#woodGradient)" />
    
    <!-- äº­å­å±‹é¡¶ -->
    <path d="M0,0 L100,0 L50,-50 Z" fill="url(#roofGradient)" />
    <path d="M10,0 L90,0 L50,-40 Z" fill="#D50000" />
    
    <!-- äº­å­è£…é¥° -->
    <circle cx="50" cy="-25" r="5" fill="#FFD700" />
  </g>
  
  <!-- è·èŠ± -->
  <g transform="translate(200, 300)">
    <circle cx="0" cy="0" r="15" fill="#E91E63" />
    <circle cx="0" cy="0" r="8" fill="#FFC107" />
    <path d="M-20,-5 Q-10,-15 0,-5 Q10,-15 20,-5" fill="#4CAF50" />
  </g>
  
  <g transform="translate(600, 320)">
    <circle cx="0" cy="0" r="12" fill="#E91E63" />
    <circle cx="0" cy="0" r="6" fill="#FFC107" />
    <path d="M-15,-5 Q-8,-12 0,-5 Q8,-12 15,-5" fill="#4CAF50" />
  </g>
  
  <!-- æŸ³æ ‘ -->
  <g transform="translate(150, 200)">
    <rect x="-5" y="0" width="10" height="80" fill="#795548" />
    <path d="M0,0 Q-30,40 -60,100" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q-20,50 -40,120" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q-10,60 -20,130" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q10,60 20,130" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q20,50 40,120" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q30,40 60,100" stroke="#7CB342" stroke-width="2" fill="none" />
  </g>
  
  <g transform="translate(650, 200)">
    <rect x="-5" y="0" width="10" height="80" fill="#795548" />
    <path d="M0,0 Q-30,40 -60,100" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q-20,50 -40,120" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q-10,60 -20,130" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q10,60 20,130" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q20,50 40,120" stroke="#7CB342" stroke-width="2" fill="none" />
    <path d="M0,0 Q30,40 60,100" stroke="#7CB342" stroke-width="2" fill="none" />
  </g>
  
  <!-- äº‘æœµ -->
  <path d="M100,100 Q120,80 140,90 Q160,70 180,90 Q200,80 220,100 Q200,120 180,110 Q160,130 140,110 Q120,120 100,100" fill="white" opacity="0.8" />
  <path d="M500,70 Q520,50 540,60 Q560,40 580,60 Q600,50 620,70 Q600,90 580,80 Q560,100 540,80 Q520,90 500,70" fill="white" opacity="0.8" />
</svg>
</file>

<file path="public/assets/environments/default.svg">
<svg width="800" height="400" viewBox="0 0 800 400" xmlns="http://www.w3.org/2000/svg">
  <!-- é»˜è®¤ç¯å¢ƒèƒŒæ™¯ -->
  <rect x="0" y="0" width="800" height="400" fill="#f0f0f0" />
  <text x="400" y="200" font-family="Arial" font-size="36" text-anchor="middle" fill="#888888">é»˜è®¤ç¯å¢ƒ</text>
</svg>
</file>

<file path="public/assets/ink-splash.svg">
<svg width="300" height="300" viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
  <!-- Ink splash effect -->
  <path d="M150,50 
           C180,30 220,40 240,70 
           C260,100 250,140 230,160 
           C210,180 190,200 170,220 
           C150,240 130,250 110,230 
           C90,210 70,190 60,160 
           C50,130 60,100 80,80 
           C100,60 130,60 150,50 Z" 
        fill="#1A5F4A" opacity="0.8"/>
  <!-- Additional ink splatters -->
  <circle cx="200" cy="100" r="15" fill="#1A5F4A" opacity="0.6"/>
  <circle cx="80" cy="150" r="20" fill="#1A5F4A" opacity="0.5"/>
  <circle cx="180" cy="220" r="12" fill="#1A5F4A" opacity="0.7"/>
  <circle cx="120" cy="80" r="10" fill="#1A5F4A" opacity="0.6"/>
</svg>
</file>

<file path="public/assets/lattice-pattern.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Lattice Pattern</title>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Horizontal lines -->
        <line x1="0" y1="0" x2="100" y2="0" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="0" y1="25" x2="100" y2="25" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="0" y1="50" x2="100" y2="50" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="0" y1="75" x2="100" y2="75" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="0" y1="100" x2="100" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        
        <!-- Vertical lines -->
        <line x1="0" y1="0" x2="0" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="25" y1="0" x2="25" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="50" y1="0" x2="50" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="75" y1="0" x2="75" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        <line x1="100" y1="0" x2="100" y2="100" stroke="#D4AF37" stroke-width="2"></line>
        
        <!-- Decorative elements at intersections -->
        <circle cx="0" cy="0" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="0" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="0" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="0" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="0" r="3" fill="#D4AF37"></circle>
        
        <circle cx="0" cy="25" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="25" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="25" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="25" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="25" r="3" fill="#D4AF37"></circle>
        
        <circle cx="0" cy="50" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="50" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="50" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="50" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="50" r="3" fill="#D4AF37"></circle>
        
        <circle cx="0" cy="75" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="75" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="75" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="75" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="75" r="3" fill="#D4AF37"></circle>
        
        <circle cx="0" cy="100" r="3" fill="#D4AF37"></circle>
        <circle cx="25" cy="100" r="3" fill="#D4AF37"></circle>
        <circle cx="50" cy="100" r="3" fill="#D4AF37"></circle>
        <circle cx="75" cy="100" r="3" fill="#D4AF37"></circle>
        <circle cx="100" cy="100" r="3" fill="#D4AF37"></circle>
        
        <!-- Decorative elements in cells -->
        <path d="M12.5,12.5 L18.75,6.25 L12.5,6.25 L12.5,12.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M37.5,12.5 L43.75,6.25 L37.5,6.25 L37.5,12.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M62.5,12.5 L68.75,6.25 L62.5,6.25 L62.5,12.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M87.5,12.5 L93.75,6.25 L87.5,6.25 L87.5,12.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        
        <path d="M12.5,37.5 L18.75,31.25 L12.5,31.25 L12.5,37.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M37.5,37.5 L43.75,31.25 L37.5,31.25 L37.5,37.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M62.5,37.5 L68.75,31.25 L62.5,31.25 L62.5,37.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M87.5,37.5 L93.75,31.25 L87.5,31.25 L87.5,37.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        
        <path d="M12.5,62.5 L18.75,56.25 L12.5,56.25 L12.5,62.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M37.5,62.5 L43.75,56.25 L37.5,56.25 L37.5,62.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M62.5,62.5 L68.75,56.25 L62.5,56.25 L62.5,62.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M87.5,62.5 L93.75,56.25 L87.5,56.25 L87.5,62.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        
        <path d="M12.5,87.5 L18.75,81.25 L12.5,81.25 L12.5,87.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M37.5,87.5 L43.75,81.25 L37.5,81.25 L37.5,87.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M62.5,87.5 L68.75,81.25 L62.5,81.25 L62.5,87.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
        <path d="M87.5,87.5 L93.75,81.25 L87.5,81.25 L87.5,87.5 Z" fill="#D4AF37" fill-opacity="0.5"></path>
    </g>
</svg>
</file>

<file path="public/assets/lotus-flower.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="150px" height="150px" viewBox="0 0 150 150" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Lotus Flower</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="petalGradient">
            <stop stop-color="#F8C8DC" offset="0%"></stop>
            <stop stop-color="#E57373" offset="100%"></stop>
        </linearGradient>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="centerGradient">
            <stop stop-color="#FFD700" offset="0%"></stop>
            <stop stop-color="#FFA000" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Outer petals -->
        <path d="M75,20 C85,30 95,50 75,70 C55,50 65,30 75,20 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M75,20 C65,30 55,50 75,70 C95,50 85,30 75,20 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M40,40 C50,50 60,70 75,70 C60,50 50,30 40,40 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M110,40 C100,50 90,70 75,70 C90,50 100,30 110,40 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M30,75 C50,65 70,65 75,70 C60,80 40,85 30,75 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M120,75 C100,65 80,65 75,70 C90,80 110,85 120,75 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M40,110 C50,90 70,80 75,70 C60,90 50,110 40,110 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M110,110 C100,90 80,80 75,70 C90,90 100,110 110,110 Z" 
              fill="url(#petalGradient)" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <!-- Inner petals -->
        <path d="M75,40 C80,45 85,55 75,65 C65,55 70,45 75,40 Z" 
              fill="#F8C8DC" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M75,40 C70,45 65,55 75,65 C85,55 80,45 75,40 Z" 
              fill="#F8C8DC" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M55,50 C60,55 65,65 75,65 C65,55 60,45 55,50 Z" 
              fill="#F8C8DC" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <path d="M95,50 C90,55 85,65 75,65 C85,55 90,45 95,50 Z" 
              fill="#F8C8DC" 
              stroke="#E57373" 
              stroke-width="1">
        </path>
        
        <!-- Center -->
        <circle cx="75" cy="65" r="10" fill="url(#centerGradient)" stroke="#FFA000" stroke-width="1"></circle>
        
        <!-- Stem -->
        <path d="M75,70 L75,130" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        
        <!-- Leaves -->
        <path d="M75,100 C60,90 40,100 30,120" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M75,100 C90,90 110,100 120,120" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/mountain-landscape.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="300px" height="150px" viewBox="0 0 300 150" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Mountain Landscape</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="mountainGradient1">
            <stop stop-color="#1A5F4A" offset="0%"></stop>
            <stop stop-color="#0D2F25" offset="100%"></stop>
        </linearGradient>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="mountainGradient2">
            <stop stop-color="#88B04B" offset="0%"></stop>
            <stop stop-color="#1A5F4A" offset="100%"></stop>
        </linearGradient>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="waterGradient">
            <stop stop-color="#1A6DB0" offset="0%"></stop>
            <stop stop-color="#0D3658" offset="100%"></stop>
        </linearGradient>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="0%" id="skyGradient">
            <stop stop-color="#F7F9F9" offset="0%"></stop>
            <stop stop-color="#E0E0E0" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Sky -->
        <rect x="0" y="0" width="300" height="150" fill="url(#skyGradient)"></rect>
        
        <!-- Far mountains -->
        <path d="M0,70 L50,40 L100,60 L150,30 L200,50 L250,35 L300,60 L300,150 L0,150 Z" 
              fill="url(#mountainGradient1)" 
              opacity="0.7">
        </path>
        
        <!-- Near mountains -->
        <path d="M0,90 L30,70 L60,85 L90,60 L120,80 L150,50 L180,75 L210,55 L240,70 L270,60 L300,80 L300,150 L0,150 Z" 
              fill="url(#mountainGradient2)" 
              opacity="0.9">
        </path>
        
        <!-- Water -->
        <path d="M0,120 C30,115 60,125 90,120 C120,115 150,125 180,120 C210,115 240,125 270,120 C300,115 300,150 300,150 L0,150 Z" 
              fill="url(#waterGradient)" 
              opacity="0.6">
        </path>
        
        <!-- Sun -->
        <circle cx="250" cy="30" r="15" fill="#FFD700" opacity="0.8"></circle>
        
        <!-- Clouds -->
        <path d="M50,40 C40,40 35,35 40,30 C45,25 55,25 60,30 C65,20 75,15 85,20 C95,25 100,20 110,20 C120,20 130,30 125,40 C135,40 140,50 130,55 C120,60 110,55 105,50 C100,55 90,60 80,55 C70,50 65,55 60,50 C55,45 50,40 50,40 Z" 
              fill="#FFFFFF" 
              opacity="0.7">
        </path>
        
        <path d="M180,50 C170,50 165,45 170,40 C175,35 185,35 190,40 C195,30 205,25 215,30 C225,35 230,30 240,30 C250,30 260,40 255,50 C265,50 270,60 260,65 C250,70 240,65 235,60 C230,65 220,70 210,65 C200,60 195,65 190,60 C185,55 180,50 180,50 Z" 
              fill="#FFFFFF" 
              opacity="0.5">
        </path>
        
        <!-- Trees -->
        <path d="M60,100 L60,120 L55,120 L65,130 L75,120 L70,120 L70,100 Z" 
              fill="#88B04B">
        </path>
        
        <path d="M240,100 L240,120 L235,120 L245,130 L255,120 L250,120 L250,100 Z" 
              fill="#88B04B">
        </path>
        
        <!-- Bamboo -->
        <path d="M100,90 L100,130" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M110,95 L110,130" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        <path d="M120,100 L120,130" stroke="#88B04B" stroke-width="3" stroke-linecap="round"></path>
        
        <path d="M95,100 L105,100" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M95,110 L105,110" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M95,120 L105,120" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        
        <path d="M105,105 L115,105" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M105,115 L115,115" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M105,125 L115,125" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        
        <path d="M115,110 L125,110" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M115,120 L125,120" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        
        <!-- Birds -->
        <path d="M160,40 C165,35 170,40 175,35" stroke="#333333" stroke-width="1" stroke-linecap="round"></path>
        <path d="M180,30 C185,25 190,30 195,25" stroke="#333333" stroke-width="1" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/panda-focused.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- ç†ŠçŒ«å¤´éƒ¨ - ä¸“æ³¨çŠ¶æ€ -->
  
  <!-- å¤´éƒ¨è½®å»“ -->
  <circle cx="100" cy="100" r="90" fill="white" stroke="black" stroke-width="2"/>
  
  <!-- å·¦è€³æœµ -->
  <ellipse cx="40" cy="40" rx="25" ry="25" fill="black" transform="rotate(-15 40 40)"/>
  
  <!-- å³è€³æœµ -->
  <ellipse cx="160" cy="40" rx="25" ry="25" fill="black" transform="rotate(15 160 40)"/>
  
  <!-- å·¦çœ¼çœ¶ -->
  <ellipse cx="70" cy="85" rx="25" ry="23" fill="black" transform="rotate(-10 70 85)"/>
  
  <!-- å³çœ¼çœ¶ -->
  <ellipse cx="130" cy="85" rx="25" ry="23" fill="black" transform="rotate(10 130 85)"/>
  
  <!-- å·¦çœ¼ - ä¸“æ³¨ -->
  <ellipse cx="70" cy="85" rx="8" ry="10" fill="white" transform="rotate(-10 70 85)"/>
  <circle cx="70" cy="85" r="5" fill="black"/>
  <circle cx="68" cy="83" r="2" fill="white"/>
  
  <!-- å³çœ¼ - ä¸“æ³¨ -->
  <ellipse cx="130" cy="85" rx="8" ry="10" fill="white" transform="rotate(10 130 85)"/>
  <circle cx="130" cy="85" r="5" fill="black"/>
  <circle cx="128" cy="83" r="2" fill="white"/>
  
  <!-- çœ‰æ¯› - ä¸“æ³¨ -->
  <path d="M55,65 L85,70" stroke="black" stroke-width="3" fill="none"/>
  <path d="M145,65 L115,70" stroke="black" stroke-width="3" fill="none"/>
  
  <!-- é¼»å­ -->
  <ellipse cx="100" cy="110" rx="15" ry="10" fill="black"/>
  
  <!-- å˜´å·´ - æŠ¿å˜´ -->
  <path d="M85,125 L115,125" stroke="black" stroke-width="2" fill="none"/>
  
  <!-- è£…é¥° - ç«¹å¶ -->
  <path d="M30,160 C20,150 25,140 35,145" stroke="#88B04B" stroke-width="2" fill="none"/>
  <path d="M30,160 C40,150 45,140 35,135" stroke="#88B04B" stroke-width="2" fill="none"/>
</svg>
</file>

<file path="public/assets/panda-happy.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- ç†ŠçŒ«å¤´éƒ¨ - å¼€å¿ƒçŠ¶æ€ -->
  
  <!-- å¤´éƒ¨è½®å»“ -->
  <circle cx="100" cy="100" r="90" fill="white" stroke="black" stroke-width="2"/>
  
  <!-- å·¦è€³æœµ -->
  <ellipse cx="40" cy="40" rx="25" ry="25" fill="black" transform="rotate(-15 40 40)"/>
  
  <!-- å³è€³æœµ -->
  <ellipse cx="160" cy="40" rx="25" ry="25" fill="black" transform="rotate(15 160 40)"/>
  
  <!-- å·¦çœ¼çœ¶ -->
  <ellipse cx="70" cy="85" rx="25" ry="23" fill="black" transform="rotate(-10 70 85)"/>
  
  <!-- å³çœ¼çœ¶ -->
  <ellipse cx="130" cy="85" rx="25" ry="23" fill="black" transform="rotate(10 130 85)"/>
  
  <!-- å·¦çœ¼ - çœ¯çœ¼ç¬‘ -->
  <path d="M60,85 Q70,75 80,85" stroke="white" stroke-width="3" fill="none"/>
  <circle cx="70" cy="82" r="2" fill="white"/>
  
  <!-- å³çœ¼ - çœ¯çœ¼ç¬‘ -->
  <path d="M120,85 Q130,75 140,85" stroke="white" stroke-width="3" fill="none"/>
  <circle cx="130" cy="82" r="2" fill="white"/>
  
  <!-- é¼»å­ -->
  <ellipse cx="100" cy="110" rx="15" ry="10" fill="black"/>
  
  <!-- å˜´å·´ - ç¬‘å®¹ -->
  <path d="M75,125 Q100,145 125,125" stroke="black" stroke-width="3" fill="none"/>
  
  <!-- è„¸é¢Š - æ›´çº¢ -->
  <circle cx="60" cy="115" r="15" fill="#ff9999" opacity="0.6"/>
  <circle cx="140" cy="115" r="15" fill="#ff9999" opacity="0.6"/>
  
  <!-- è£…é¥° - ç«¹å­ -->
  <path d="M180,160 L190,140" stroke="#88B04B" stroke-width="4" stroke-linecap="round"/>
  <path d="M180,160 L185,150" stroke="#88B04B" stroke-width="2" stroke-linecap="round"/>
  <path d="M185,150 L190,145" stroke="#88B04B" stroke-width="2" stroke-linecap="round"/>
  <ellipse cx="180" cy="160" rx="5" ry="3" fill="#1A5F4A" transform="rotate(-30 180 160)"/>
</svg>
</file>

<file path="public/assets/panda-normal.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- ç†ŠçŒ«å¤´éƒ¨ - åŸºæœ¬çŠ¶æ€ -->
  
  <!-- å¤´éƒ¨è½®å»“ -->
  <circle cx="100" cy="100" r="90" fill="white" stroke="black" stroke-width="2"/>
  
  <!-- å·¦è€³æœµ -->
  <ellipse cx="40" cy="40" rx="25" ry="25" fill="black" transform="rotate(-15 40 40)"/>
  
  <!-- å³è€³æœµ -->
  <ellipse cx="160" cy="40" rx="25" ry="25" fill="black" transform="rotate(15 160 40)"/>
  
  <!-- å·¦çœ¼çœ¶ -->
  <ellipse cx="70" cy="85" rx="25" ry="23" fill="black" transform="rotate(-10 70 85)"/>
  
  <!-- å³çœ¼çœ¶ -->
  <ellipse cx="130" cy="85" rx="25" ry="23" fill="black" transform="rotate(10 130 85)"/>
  
  <!-- å·¦çœ¼ -->
  <ellipse cx="70" cy="85" rx="8" ry="10" fill="white" transform="rotate(-10 70 85)"/>
  <circle cx="70" cy="85" r="4" fill="black"/>
  <circle cx="68" cy="83" r="2" fill="white"/>
  
  <!-- å³çœ¼ -->
  <ellipse cx="130" cy="85" rx="8" ry="10" fill="white" transform="rotate(10 130 85)"/>
  <circle cx="130" cy="85" r="4" fill="black"/>
  <circle cx="128" cy="83" r="2" fill="white"/>
  
  <!-- é¼»å­ -->
  <ellipse cx="100" cy="110" rx="15" ry="10" fill="black"/>
  
  <!-- å˜´å·´ -->
  <path d="M85,120 Q100,130 115,120" stroke="black" stroke-width="2" fill="none"/>
  
  <!-- è„¸é¢Š -->
  <circle cx="60" cy="115" r="10" fill="#ffcccc" opacity="0.5"/>
  <circle cx="140" cy="115" r="10" fill="#ffcccc" opacity="0.5"/>
</svg>
</file>

<file path="public/assets/panda-tired.svg">
<svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- ç†ŠçŒ«å¤´éƒ¨ - ç–²æƒ«çŠ¶æ€ -->
  
  <!-- å¤´éƒ¨è½®å»“ -->
  <circle cx="100" cy="100" r="90" fill="white" stroke="black" stroke-width="2"/>
  
  <!-- å·¦è€³æœµ -->
  <ellipse cx="40" cy="40" rx="25" ry="25" fill="black" transform="rotate(-15 40 40)"/>
  
  <!-- å³è€³æœµ -->
  <ellipse cx="160" cy="40" rx="25" ry="25" fill="black" transform="rotate(15 160 40)"/>
  
  <!-- å·¦çœ¼çœ¶ -->
  <ellipse cx="70" cy="85" rx="25" ry="23" fill="black" transform="rotate(-10 70 85)"/>
  
  <!-- å³çœ¼çœ¶ -->
  <ellipse cx="130" cy="85" rx="25" ry="23" fill="black" transform="rotate(10 130 85)"/>
  
  <!-- å·¦çœ¼ - ç–²æƒ« -->
  <ellipse cx="70" cy="85" rx="8" ry="5" fill="white" transform="rotate(-10 70 85)"/>
  <path d="M62,85 L78,85" stroke="black" stroke-width="1.5" fill="none"/>
  
  <!-- å³çœ¼ - ç–²æƒ« -->
  <ellipse cx="130" cy="85" rx="8" ry="5" fill="white" transform="rotate(10 130 85)"/>
  <path d="M122,85 L138,85" stroke="black" stroke-width="1.5" fill="none"/>
  
  <!-- é»‘çœ¼åœˆ -->
  <path d="M50,95 Q70,105 90,95" stroke="#666" stroke-width="2" fill="none" opacity="0.5"/>
  <path d="M110,95 Q130,105 150,95" stroke="#666" stroke-width="2" fill="none" opacity="0.5"/>
  
  <!-- é¼»å­ -->
  <ellipse cx="100" cy="110" rx="15" ry="10" fill="black"/>
  
  <!-- å˜´å·´ - ç–²æƒ« -->
  <path d="M85,125 Q100,115 115,125" stroke="black" stroke-width="2" fill="none"/>
  
  <!-- æ±—æ»´ -->
  <path d="M40,60 L35,70" stroke="#89CFF0" stroke-width="2" fill="none"/>
  <circle cx="33" cy="73" r="3" fill="#89CFF0"/>
</svg>
</file>

<file path="public/assets/paper-texture.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="200px" height="200px" viewBox="0 0 200 200" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Paper Texture</title>
    <defs>
        <filter id="noise" x="0%" y="0%" width="100%" height="100%">
            <feTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" stitchTiles="stitch" result="noise"/>
            <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.05 0" in="noise" result="coloredNoise"/>
            <feComposite operator="in" in="coloredNoise" in2="SourceGraphic" result="monoNoise"/>
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <rect id="background" fill="#f8f0d8" x="0" y="0" width="200" height="200" filter="url(#noise)"></rect>
        
        <!-- Subtle lines -->
        <line x1="0" y1="20" x2="200" y2="20" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        <line x1="0" y1="60" x2="200" y2="60" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        <line x1="0" y1="100" x2="200" y2="100" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        <line x1="0" y1="140" x2="200" y2="140" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        <line x1="0" y1="180" x2="200" y2="180" stroke="#d0c0a0" stroke-width="0.5" stroke-opacity="0.2"></line>
        
        <!-- Subtle spots -->
        <circle cx="30" cy="30" r="2" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="70" cy="90" r="1.5" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="150" cy="50" r="2" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="120" cy="120" r="1.5" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="40" cy="170" r="2" fill="#d0c0a0" fill-opacity="0.1"></circle>
        <circle cx="180" cy="140" r="1.5" fill="#d0c0a0" fill-opacity="0.1"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/coin.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Coin</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="coinGradient">
            <stop stop-color="#FFD700" offset="0%"></stop>
            <stop stop-color="#D4AF37" offset="100%"></stop>
        </linearGradient>
        <filter id="coinGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Coin base -->
        <circle cx="50" cy="50" r="40" fill="url(#coinGradient)" filter="url(#coinGlow)"></circle>
        
        <!-- Bamboo symbol -->
        <path d="M45,30 C45,30 40,35 40,40 C40,45 45,50 45,50 C45,50 50,45 50,40 C50,35 45,30 45,30 Z" fill="#1A5F4A" fill-opacity="0.8"></path>
        <path d="M55,30 C55,30 50,35 50,40 C50,45 55,50 55,50 C55,50 60,45 60,40 C60,35 55,30 55,30 Z" fill="#1A5F4A" fill-opacity="0.8"></path>
        <path d="M50,40 C50,40 45,45 45,50 C45,55 50,60 50,60 C50,60 55,55 55,50 C55,45 50,40 50,40 Z" fill="#1A5F4A" fill-opacity="0.8"></path>
        
        <!-- Coin edge -->
        <circle cx="50" cy="50" r="40" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7"></circle>
        
        <!-- Coin shine -->
        <path d="M30,40 Q40,30 50,35 Q60,40 70,35" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.8" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/rewards/decoration_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Decoration - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="decorationGradient">
            <stop stop-color="#A0D468" offset="0%"></stop>
            <stop stop-color="#88B04B" offset="100%"></stop>
        </linearGradient>
        <filter id="decorationGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#decorationGlow)"></circle>
        
        <!-- Bamboo hat -->
        <path d="M30,50 C30,35 50,25 70,50" stroke="url(#decorationGradient)" stroke-width="4" stroke-linecap="round"></path>
        <path d="M35,45 L65,45" stroke="url(#decorationGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M40,40 L60,40" stroke="url(#decorationGradient)" stroke-width="2" stroke-linecap="round"></path>
        <path d="M45,35 L55,35" stroke="url(#decorationGradient)" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Decorative strings -->
        <path d="M40,50 L40,65" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        <path d="M60,50 L60,65" stroke="#88B04B" stroke-width="1" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#88B04B" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/experience.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Experience</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="experienceGradient">
            <stop stop-color="#88B04B" offset="0%"></stop>
            <stop stop-color="#1A5F4A" offset="100%"></stop>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <circle cx="50" cy="50" r="45" fill="url(#experienceGradient)" filter="url(#glow)"></circle>
        <path d="M50,20 L55,35 L70,35 L60,45 L65,60 L50,50 L35,60 L40,45 L30,35 L45,35 Z" fill="#FFFFFF" fill-opacity="0.9"></path>
        <circle cx="50" cy="50" r="45" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.5"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/food_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Food - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="bambooGradient">
            <stop stop-color="#A0D468" offset="0%"></stop>
            <stop stop-color="#88B04B" offset="100%"></stop>
        </linearGradient>
        <filter id="foodGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#foodGlow)"></circle>
        
        <!-- Bamboo shoots -->
        <path d="M30,30 L40,70 L50,30 L60,70 L70,30" stroke="url(#bambooGradient)" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"></path>
        
        <!-- Bamboo leaves -->
        <path d="M30,35 C20,30 25,20 35,25" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M50,35 C40,30 45,20 55,25" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        <path d="M70,35 C60,30 65,20 75,25" stroke="#88B04B" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#88B04B" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/food_uncommon.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Food - Uncommon</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="bambooGradient">
            <stop stop-color="#4CAF50" offset="0%"></stop>
            <stop stop-color="#2E7D32" offset="100%"></stop>
        </linearGradient>
        <filter id="foodGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#foodGlow)"></circle>
        
        <!-- Bamboo shoots -->
        <path d="M30,30 L40,70 L50,30 L60,70 L70,30" stroke="url(#bambooGradient)" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"></path>
        
        <!-- Bamboo leaves -->
        <path d="M30,35 C20,30 25,20 35,25" stroke="#2E7D32" stroke-width="2" stroke-linecap="round"></path>
        <path d="M50,35 C40,30 45,20 55,25" stroke="#2E7D32" stroke-width="2" stroke-linecap="round"></path>
        <path d="M70,35 C60,30 65,20 75,25" stroke="#2E7D32" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Sparkles -->
        <circle cx="35" cy="40" r="2" fill="#FFFFFF"></circle>
        <circle cx="55" cy="35" r="2" fill="#FFFFFF"></circle>
        <circle cx="65" cy="45" r="2" fill="#FFFFFF"></circle>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#4CAF50" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/item_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Item - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="itemGradient">
            <stop stop-color="#FFC107" offset="0%"></stop>
            <stop stop-color="#FF9800" offset="100%"></stop>
        </linearGradient>
        <filter id="itemGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#itemGlow)"></circle>
        
        <!-- Item box -->
        <rect x="30" y="30" width="40" height="40" rx="5" fill="#FFFFFF" stroke="#FF9800" stroke-width="2"></rect>
        
        <!-- Box decoration -->
        <rect x="35" y="35" width="30" height="30" rx="3" fill="url(#itemGradient)" fill-opacity="0.3"></rect>
        
        <!-- Question mark -->
        <text x="50" y="60" font-family="Arial" font-size="30" fill="#FF9800" text-anchor="middle">?</text>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#FF9800" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/potion_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Potion - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="potionGradient">
            <stop stop-color="#42A5F5" offset="0%"></stop>
            <stop stop-color="#1976D2" offset="100%"></stop>
        </linearGradient>
        <filter id="potionGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#potionGlow)"></circle>
        
        <!-- Potion bottle -->
        <path d="M45,30 L55,30 L55,40 C60,45 65,55 60,65 C55,70 45,70 40,65 C35,55 40,45 45,40 L45,30 Z" fill="#FFFFFF" stroke="#1976D2" stroke-width="2"></path>
        
        <!-- Potion liquid -->
        <path d="M45,45 C40,50 35,60 40,65 C45,70 55,70 60,65 C65,60 60,50 55,45 L45,45 Z" fill="url(#potionGradient)"></path>
        
        <!-- Bottle cap -->
        <rect x="45" y="27" width="10" height="5" rx="2" fill="#1976D2"></rect>
        
        <!-- Bubbles -->
        <circle cx="45" cy="55" r="2" fill="#FFFFFF" fill-opacity="0.7"></circle>
        <circle cx="55" cy="60" r="1.5" fill="#FFFFFF" fill-opacity="0.7"></circle>
        <circle cx="50" cy="50" r="1" fill="#FFFFFF" fill-opacity="0.7"></circle>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#1976D2" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/scroll_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Scroll - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="scrollGradient">
            <stop stop-color="#D4AF37" offset="0%"></stop>
            <stop stop-color="#FFA000" offset="100%"></stop>
        </linearGradient>
        <filter id="scrollGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#scrollGlow)"></circle>
        
        <!-- Scroll -->
        <rect x="30" y="35" width="40" height="30" rx="2" fill="#F8F0D8"></rect>
        <path d="M30,35 C25,35 25,40 25,45 C25,50 25,55 30,55" stroke="#D4AF37" stroke-width="2" stroke-linecap="round"></path>
        <path d="M70,35 C75,35 75,40 75,45 C75,50 75,55 70,55" stroke="#D4AF37" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Scroll lines -->
        <path d="M35,42 L65,42" stroke="#D4AF37" stroke-width="1" stroke-opacity="0.5"></path>
        <path d="M35,47 L65,47" stroke="#D4AF37" stroke-width="1" stroke-opacity="0.5"></path>
        <path d="M35,52 L65,52" stroke="#D4AF37" stroke-width="1" stroke-opacity="0.5"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#D4AF37" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/toy_common.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Toy - Common</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="toyGradient">
            <stop stop-color="#8CC152" offset="0%"></stop>
            <stop stop-color="#A0D468" offset="100%"></stop>
        </linearGradient>
        <filter id="toyGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#toyGlow)"></circle>
        
        <!-- Bamboo ball -->
        <circle cx="50" cy="50" r="25" fill="url(#toyGradient)"></circle>
        <circle cx="50" cy="50" r="25" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7"></circle>
        
        <!-- Decorative patterns -->
        <path d="M35,40 L65,40" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        <path d="M35,50 L65,50" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        <path d="M35,60 L65,60" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#8CC152" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/rewards/toy_uncommon.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Toy - Uncommon</title>
    <defs>
        <linearGradient x1="0%" y1="0%" x2="100%" y2="100%" id="toyGradient">
            <stop stop-color="#4CAF50" offset="0%"></stop>
            <stop stop-color="#2E7D32" offset="100%"></stop>
        </linearGradient>
        <filter id="toyGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
        </filter>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <!-- Background circle -->
        <circle cx="50" cy="50" r="40" fill="#F5F5DC" filter="url(#toyGlow)"></circle>
        
        <!-- Bamboo ball -->
        <circle cx="50" cy="50" r="25" fill="url(#toyGradient)"></circle>
        <circle cx="50" cy="50" r="25" stroke="#FFFFFF" stroke-width="2" stroke-opacity="0.7"></circle>
        
        <!-- Decorative patterns -->
        <path d="M35,40 L65,40" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        <path d="M35,50 L65,50" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        <path d="M35,60 L65,60" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"></path>
        
        <!-- Sparkles -->
        <circle cx="35" cy="35" r="2" fill="#FFFFFF"></circle>
        <circle cx="65" cy="35" r="2" fill="#FFFFFF"></circle>
        <circle cx="65" cy="65" r="2" fill="#FFFFFF"></circle>
        <circle cx="35" cy="65" r="2" fill="#FFFFFF"></circle>
        
        <!-- Border -->
        <circle cx="50" cy="50" r="40" stroke="#4CAF50" stroke-width="2" stroke-opacity="0.7"></circle>
    </g>
</svg>
</file>

<file path="public/assets/scroll-edge.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="800px" height="30px" viewBox="0 0 800 30" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Scroll Edge</title>
    <defs>
        <linearGradient x1="0%" y1="50%" x2="100%" y2="50%" id="scrollGradient">
            <stop stop-color="#D4AF37" offset="0%"></stop>
            <stop stop-color="#FFA000" offset="50%"></stop>
            <stop stop-color="#D4AF37" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M0,0 L800,0 L800,5 C750,8 700,15 650,20 C600,25 550,28 500,29 C450,30 400,30 350,29 C300,28 250,25 200,20 C150,15 100,8 50,5 L0,5 L0,0 Z" fill="#f8f0d8"></path>
        <path d="M0,5 C50,8 100,15 150,20 C200,25 250,28 300,29 C350,30 400,30 450,29 C500,28 550,25 600,20 C650,15 700,8 750,5 L800,5 L800,30 L0,30 L0,5 Z" fill="#e8d8b8"></path>
        <path d="M0,5 C50,8 100,15 150,20 C200,25 250,28 300,29 C350,30 400,30 450,29 C500,28 550,25 600,20 C650,15 700,8 750,5" stroke="url(#scrollGradient)" stroke-width="1.5" stroke-linecap="round"></path>
    </g>
</svg>
</file>

<file path="public/assets/sounds/README.md">
# éŸ³æ•ˆæ–‡ä»¶ç›®å½•

æ­¤ç›®å½•ç”¨äºå­˜æ”¾æ¸¸æˆä¸­ä½¿ç”¨çš„å„ç§éŸ³æ•ˆæ–‡ä»¶ã€‚

## å¥–åŠ±éŸ³æ•ˆ

ä»¥ä¸‹æ˜¯å¥–åŠ±ç³»ç»Ÿä½¿ç”¨çš„éŸ³æ•ˆæ–‡ä»¶ï¼š

- `reward_common.mp3` - æ™®é€šå¥–åŠ±éŸ³æ•ˆ
- `reward_uncommon.mp3` - ä¸å¸¸è§å¥–åŠ±éŸ³æ•ˆ
- `reward_rare.mp3` - ç¨€æœ‰å¥–åŠ±éŸ³æ•ˆ
- `reward_epic.mp3` - å²è¯—å¥–åŠ±éŸ³æ•ˆ
- `reward_legendary.mp3` - ä¼ è¯´å¥–åŠ±éŸ³æ•ˆ

## ä»»åŠ¡ç›¸å…³éŸ³æ•ˆ

- `task_complete.mp3` - æ™®é€šä»»åŠ¡å®ŒæˆéŸ³æ•ˆ
- `task_complete_high.mp3` - é«˜ä¼˜å…ˆçº§ä»»åŠ¡å®ŒæˆéŸ³æ•ˆ
- `task_complete_main.mp3` - ä¸»çº¿ä»»åŠ¡å®ŒæˆéŸ³æ•ˆ
- `task_failed.mp3` - ä»»åŠ¡å¤±è´¥éŸ³æ•ˆ
- `task_created.mp3` - ä»»åŠ¡åˆ›å»ºéŸ³æ•ˆ

## æŒ‘æˆ˜ç›¸å…³éŸ³æ•ˆ

- `challenge_complete.mp3` - æ™®é€šæŒ‘æˆ˜å®ŒæˆéŸ³æ•ˆ
- `challenge_complete_epic.mp3` - å²è¯—æŒ‘æˆ˜å®ŒæˆéŸ³æ•ˆ
- `challenge_complete_legendary.mp3` - ä¼ è¯´æŒ‘æˆ˜å®ŒæˆéŸ³æ•ˆ
- `challenge_failed.mp3` - æŒ‘æˆ˜å¤±è´¥éŸ³æ•ˆ
- `challenge_unlocked.mp3` - æŒ‘æˆ˜è§£é”éŸ³æ•ˆ

## ç³»ç»ŸéŸ³æ•ˆ

- `level_up.mp3` - ç­‰çº§æå‡éŸ³æ•ˆ
- `ability_unlocked.mp3` - èƒ½åŠ›è§£é”éŸ³æ•ˆ
- `ability_activated.mp3` - èƒ½åŠ›æ¿€æ´»éŸ³æ•ˆ
- `button_click.mp3` - æŒ‰é’®ç‚¹å‡»éŸ³æ•ˆ
- `error.mp3` - é”™è¯¯æç¤ºéŸ³æ•ˆ
- `success.mp3` - æˆåŠŸæç¤ºéŸ³æ•ˆ
- `notification.mp3` - é€šçŸ¥æç¤ºéŸ³æ•ˆ

## éŸ³æ•ˆæ ¼å¼

- æ¨èä½¿ç”¨ MP3 æ ¼å¼ï¼Œæ–‡ä»¶å¤§å°åº”å°½é‡å°ï¼ˆå»ºè®®å°äº 100KBï¼‰
- éŸ³æ•ˆæ—¶é•¿åº”ç®€çŸ­ï¼ˆé€šå¸¸ 1-3 ç§’ï¼‰
- éŸ³é‡åº”é€‚ä¸­ï¼Œé¿å…è¿‡å¤§æˆ–è¿‡å°

## ä½¿ç”¨æ–¹æ³•

åœ¨ä»£ç ä¸­ä½¿ç”¨ `sound.ts` å·¥å…·ç±»æ’­æ”¾éŸ³æ•ˆï¼š

```typescript
import { playSound, SoundType } from '@/utils/sound';

// æ’­æ”¾å¥–åŠ±éŸ³æ•ˆ
playSound(SoundType.REWARD_LEGENDARY);

// æ§åˆ¶éŸ³é‡ï¼ˆ0-1ï¼‰
playSound(SoundType.BUTTON_CLICK, 0.3);
```

## æ³¨æ„äº‹é¡¹

1. æ·»åŠ æ–°éŸ³æ•ˆåï¼Œéœ€è¦åœ¨ `sound.ts` ä¸­æ›´æ–° `SoundType` æšä¸¾å’Œ `soundPaths` æ˜ å°„
2. éŸ³æ•ˆæ–‡ä»¶å‘½ååº”ä¸ `soundPaths` ä¸­çš„è·¯å¾„ä¸€è‡´
3. è€ƒè™‘ä¸ºç”¨æˆ·æä¾›éŸ³æ•ˆå¼€å…³å’ŒéŸ³é‡æ§åˆ¶é€‰é¡¹
</file>

<file path="README.md">
å¥½çš„ï¼Œè¿™æ˜¯ Minimal Demo V3 Final çš„ç‹¬ç«‹å®Œæ•´ä»£ç ã€‚æˆ‘å·²ç»å°†æ‰€æœ‰éƒ¨åˆ†æ•´åˆåœ¨ä¸€èµ·ï¼Œå¹¶ç¡®ä¿äº†å‘½åå’Œç»“æ„çš„ä¸€è‡´æ€§ã€‚

**é¡¹ç›®ç»“æ„ (å›é¡¾):**

```
minimal-dexie-i18n-v3-final/
â”œâ”€â”€ README.md
â”œâ”€â”€ index.html
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ tsconfig.node.json
â”œâ”€â”€ vite.config.ts
â””â”€â”€ src/
    â”œâ”€â”€ App.tsx
    â”œâ”€â”€ main.tsx
    â”œâ”€â”€ index.css
    â”œâ”€â”€ vite-env.d.ts
    â”œâ”€â”€ types/
    â”‚   â””â”€â”€ index.ts
    â”œâ”€â”€ context/
    â”‚   â””â”€â”€ LanguageProvider.tsx
    â”œâ”€â”€ db.ts
    â”œâ”€â”€ services/
    â”‚   â””â”€â”€ index.ts
    â”‚   â””â”€â”€ localizedContentService.ts
    â”œâ”€â”€ hooks/
    â”‚   â””â”€â”€ useInternationalizedQuery.ts
    â”‚   â””â”€â”€ useLocalizedView.ts
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ common/
    â”‚   â”‚   â”œâ”€â”€ Button.tsx
    â”‚   â”‚   â”œâ”€â”€ LoadingSpinner.tsx
    â”‚   â”‚   â””â”€â”€ ErrorDisplay.tsx
    â”‚   â””â”€â”€ layout/
    â”‚       â”œâ”€â”€ AppShell.tsx
    â”‚       â”œâ”€â”€ Header.tsx
    â”‚       â””â”€â”€ Navigation.tsx
    â”œâ”€â”€ features/
    â”‚   â”œâ”€â”€ home/
    â”‚   â”‚   â”œâ”€â”€ WelcomeSection.tsx
    â”‚   â”‚   â””â”€â”€ MoodsSection.tsx
    â”‚   â””â”€â”€ settings/
    â”‚       â””â”€â”€ LanguageSettingsSection.tsx
    â”œâ”€â”€ pages/
    â”‚   â”œâ”€â”€ HomePage.tsx
    â”‚   â””â”€â”€ SettingsPage.tsx
    â””â”€â”€ router.tsx
```

---

**1. `README.md`**

```markdown
# Minimal Dexie I18n Demo (V3 - Finalized Structure)

This project demonstrates a type-safe, API-driven (simulated with Dexie.js) internationalization architecture for React applications, emphasizing clear naming, page-level content fetching, and component-based design for optimal team collaboration.

## Core Architecture & Data Flow:

1.  **Language Management (`LanguageProvider`):**
    *   Manages and persists the global `language` state (`en` | `zh`).
    *   Provides `language` and `setLanguage` via `useLanguage` hook.
    *   Does **not** handle translations directly.

2.  **Dexie.js as Mock Backend (`db.ts`):**
    *   Simulates an API data source using IndexedDB.
    *   The `uiLabels` store holds all translatable text records.
    *   `UILabelRecord` includes `scopeKey`, `labelKey`, `languageCode`, `translatedText`.
    *   **Scope Keys:** Organize labels hierarchically:
        *   `globalLayout`: For app shell (header, footer, nav).
        *   `[viewName]View`: For page-level titles and direct content (e.g., `homeView`, `settingsView`).
        *   `[viewName]View.[sectionName]`: For labels specific to a section within a view.

3.  **Services (`localizedContentService.ts`):**
    *   Functions like `fetchHomePageView`, `fetchSettingsPageView`, `fetchGlobalLayoutView`.
    *   Interact with Dexie to retrieve `labels` and `data` for a given `language` and `scopeKey`.
    *   Return a `Promise<LocalizedContent<TDataPayload, TLabelsBundle>>`.
    *   `buildLabelsObject` helper reconstructs nested label objects from flat Dexie records.

4.  **Custom Hook (`useLocalizedView.ts`):**
    *   Built on `useInternationalizedQuery` (generic React Query wrapper).
    *   Simplifies fetching localized content for a view.
    *   Takes a `viewQueryKey` (e.g., "homeViewContent") and the corresponding `fetchViewFn`.
    *   Automatically manages `language` in the React Query `queryKey`.
    *   Returns typed `{ labels, data, isPending, isError, ... }`.

5.  **Type Definitions (`types/index.ts`):**
    *   Centralized, clearly named types.
    *   `LocalizedContent<TData, TLabels>`: Standard service response.
    *   `[PageName]ViewLabelsBundle`, `[PageName]ViewDataPayload`: For view-specific content.
    *   `[FeatureName][SectionName]Labels`: For section-specific labels.

6.  **Page-Level Data Ownership & Props Delegation:**
    *   **Page/View Components (`src/pages/`):**
        *   Act as containers. Use `useLocalizedView` to fetch all content for their view.
    *   **Data Downflow:** Pages pass relevant slices of `labels` and `data` as props to child "Section" components (`src/features/`) and common components.
    *   **Presentational Children:** Section and common components receive all text and data via props.

7.  **Componentization:**
    *   **Layout (`AppShell`, `Header`, `Navigation`):** `AppShell` fetches `GlobalLayoutLabelsBundle`.
    *   **Features/Sections:** Encapsulate distinct UI parts.
    *   **Common:** Reusable, prop-driven components.

## Running the Demo:

1.  `npm install`
    *   Note: If `vite.config.ts` shows type errors for `path` or `__dirname`, you may need to install Node.js types: `npm install --save-dev @types/node`.
    *   The `package.json` includes necessary type definitions like `@types/react`, but ensure your TypeScript server has recognized them after installation. Sometimes a reload of your editor or TS server might be needed if "Cannot find module" errors persist initially for installed packages.
2.  `npm run dev`
3.  Open in browser (usually `http://localhost:5173`).

**Important Notes for Development:**

*   **`index.html`:** This project uses Vite, which requires an `index.html` file in the project root as the entry point.
*   **Dexie DB Population:** The `src/db.ts` includes a mechanism to populate the IndexedDB with sample data. In development, React's `StrictMode` might cause the population function to be called twice. The provided code has a safeguard to prevent duplicate data errors (`ConstraintError`) in this scenario. If you modify this, be mindful of potential re-entrancy.
*   **Favicon:** You might see a 404 error for `favicon.ico` in the browser console. This is harmless and can be resolved by adding a favicon to your project and linking it in `index.html`.
```

---

**2. `package.json`**

```json
{
  "name": "minimal-dexie-i18n-v3-final",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.32.0",
    "dexie": "^3.2.7",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.23.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@types/react-router-dom": "^5.3.3",
    "@typescript-eslint/eslint-plugin": "^7.2.0",
    "@typescript-eslint/parser": "^7.2.0",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "typescript": "^5.2.2",
    "vite": "^5.2.0"
  }
}
```

---

**3. `vite.config.ts`**

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})
```

---

**4. `tsconfig.json`**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src", "vite.config.ts"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

---

**5. `tsconfig.node.json`**

```json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts"]
}
```

---

**6. `src/vite-env.d.ts`**

```typescript
/// <reference types="vite/client" />
```

---

**7. `src/index.css`**

```css
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
    Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f0f2f5;
  color: #333;
  line-height: 1.6;
}

#root {
  max-width: 960px;
  margin: 20px auto;
  padding: 15px;
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

header {
  padding-bottom: 15px;
  border-bottom: 1px solid #e8e8e8;
  margin-bottom: 20px;
}

h1, h2, h3, h4 {
  color: #2c3e50;
  margin-top: 0;
}
h1 { font-size: 1.8em; }
h2 { font-size: 1.5em; margin-bottom: 0.8em; }
h3 { font-size: 1.3em; margin-bottom: 0.6em; color: #34495e; }
h4 { font-size: 1.1em; margin-bottom: 0.5em; color: #7f8c8d; }


nav {
  margin-bottom: 20px;
  display: flex;
  gap: 10px;
}

nav a {
  padding: 8px 15px;
  text-decoration: none;
  color: #3498db;
  border-radius: 4px;
  transition: background-color 0.2s, color 0.2s;
}

nav a:hover {
  background-color: #ecf0f1;
  color: #2980b9;
}

nav a.active {
  background-color: #3498db;
  color: white;
  font-weight: bold;
}

.page-content, section.page-content { /* Allow section to also use page-content style */
  background-color: #fff;
  padding: 15px;
  border-radius: 5px;
  margin-bottom: 20px;
  /* box-shadow: 0 1px 3px rgba(0,0,0,0.05); */
}
section + section { margin-top: 25px; }


hr {
  border: 0;
  height: 1px;
  background-color: #e8e8e8;
  margin: 25px 0;
}

footer {
  text-align: center;
  margin-top: 30px;
  padding-top: 15px;
  border-top: 1px solid #e8e8e8;
  font-size: 0.9em;
  color: #7f8c8d;
}

ul {
  list-style-type: disc;
  padding-left: 20px;
}
li { margin-bottom: 5px; }


/* Common Components */
.button-common {
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1em;
  font-weight: 500;
  transition: background-color 0.2s, opacity 0.2s;
  margin-right: 10px; /* Default spacing for buttons */
}
.button-common:last-child { margin-right: 0; }

.button-common:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.button-primary {
  background-color: #3498db;
  color: white;
}
.button-primary:hover:not(:disabled) {
  background-color: #2980b9;
}
.button-secondary {
  background-color: #95a5a6;
  color: white;
}
.button-secondary:hover:not(:disabled) {
  background-color: #7f8c8d;
}


select {
  padding: 10px;
  border-radius: 4px;
  border: 1px solid #bdc3c7;
  margin-right: 10px;
  font-size: 1em;
  background-color: white;
}

.loading-spinner-overlay {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  min-height: 100px;
}
.loading-spinner {
  border: 4px solid #ecf0f1; /* Light grey */
  border-top: 4px solid #3498db; /* Blue */
  border-radius: 50%;
  width: 30px;
  height: 30px;
  animation: spin 0.8s linear infinite;
}
.loading-spinner-text { margin-top: 10px; font-style: italic; color: #555; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.error-container {
  border: 1px solid #e74c3c; /* Red */
  padding: 15px;
  border-radius: 5px;
  background-color: #fdedec; /* Light red */
  margin-bottom: 15px;
}
.error-container h3 { color: #c0392b; margin-bottom: 8px;}
.error-text { color: #c0392b; }
.error-code-text { font-size: 0.85em; color: #7f8c8d; margin-top: 5px; }
```

---

**8. `src/types/index.ts`**

```typescript
// src/types/index.ts
export type Language = "en" | "zh";

export interface LanguageContextType {
  language: Language;
  setLanguage: (lang: Language) => void;
}

export interface ApiError extends Error { errorCode?: string; statusCode?: number; }

// Structure for Dexie uiLabels store
export interface UILabelRecord {
  id?: number;
  scopeKey: string; // e.g., "globalLayout", "homeView", "homeView.welcomeSection", "components.button"
  labelKey: string; // e.g., "appTitle", "welcomeMessage", "confirmText"
  languageCode: Language;
  translatedText: string;
}

// --- Generic Localized Content Structure (from services) ---
export interface LocalizedContent<TDataPayload, TLabelsBundle> {
  labels: TLabelsBundle;
  data: TDataPayload | null;
}

// --- Global / Layout Content Types ---
export interface GlobalLayoutLabelsBundle {
  appTitle: string;
  navHome: string;
  navSettings: string;
  footerText: string;
  loadingGeneric: string;
  errorGeneric: string;
}
export type FetchGlobalLayoutViewResult = LocalizedContent<null, GlobalLayoutLabelsBundle>;

// --- Home Page/View Specific Types ---
export interface HomeWelcomeSectionLabels {
  welcomeMessage: string;
}
export interface MoodItem { readonly id: number; readonly name: string; readonly feeling: string; }
export interface HomeMoodsSectionLabels {
  sectionTitle: string;
  noMoodsMessage: string;
  refreshButtonText: string;
}
export interface HomePageViewLabelsBundle {
  pageTitle: string;
  welcomeSection: HomeWelcomeSectionLabels;
  moodsSection: HomeMoodsSectionLabels;
  someActionText: string; // Example of a page-level label for a generic action
}
export interface HomePageViewDataPayload {
  username: string;
  moods: readonly MoodItem[];
}
export type FetchHomePageViewResult = LocalizedContent<HomePageViewDataPayload, HomePageViewLabelsBundle>;

// --- Settings Page/View Specific Types ---
export interface SettingsLanguageSectionLabels {
  sectionTitle: string;
  selectLanguagePrompt: string;
  currentLanguageIs: string;
  langNameEn: string;
  langNameZh: string;
  saveButtonText: string;
  successMessage: string;
}
export interface SettingsPageViewLabelsBundle {
  pageTitle: string;
  languageSection: SettingsLanguageSectionLabels;
}
export type FetchSettingsPageViewResult = LocalizedContent<null, SettingsPageViewLabelsBundle>;
```

---

**9. `src/context/LanguageProvider.tsx`**

```tsx
// src/context/LanguageProvider.tsx
import React, { createContext, useState, useContext, useEffect, ReactNode, useCallback } from "react";
import type { Language, LanguageContextType } from "@/types";

const DEFAULT_LANGUAGE: Language = "en";
const LOCAL_STORAGE_KEY = "app_lang_v3_final";

const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

export const LanguageProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [language, setLanguageState] = useState<Language>(() => {
    try {
      const saved = localStorage.getItem(LOCAL_STORAGE_KEY) as Language | null;
      return (saved === "en" || saved === "zh") ? saved : DEFAULT_LANGUAGE;
    } catch (e) { console.warn("localStorage access error for language", e); return DEFAULT_LANGUAGE; }
  });

  useEffect(() => {
    try {
      localStorage.setItem(LOCAL_STORAGE_KEY, language);
      document.documentElement.lang = language;
    } catch (e) { console.warn("localStorage write error for language", e); }
  }, [language]);

  const setLanguage = useCallback((lang: Language) => setLanguageState(lang), []);
  const value = { language, setLanguage };

  return <LanguageContext.Provider value={value}>{children}</LanguageContext.Provider>;
};

export const useLanguage = (): LanguageContextType => {
  const context = useContext(LanguageContext);
  if (!context) throw new Error("useLanguage must be used within LanguageProvider");
  return context;
};
```

---

**10. `src/db.ts`**

```typescript
// src/db.ts
import Dexie, { Table } from 'dexie';
import type { UILabelRecord } from '@/types';

export class AppDB extends Dexie {
  uiLabels!: Table<UILabelRecord, number>;
  constructor() {
    super('FinalMinimalI18nDB_V3'); // Unique DB name for this version
    this.version(1).stores({
      uiLabels: '++id, scopeKey, labelKey, languageCode, &[scopeKey+labelKey+languageCode]',
    });
  }
}
export const db = new AppDB();

export async function populateDB() {
  const count = await db.uiLabels.count();
  if (count > 0) { /* console.log("DB V3 already populated."); */ return; }
  console.log("Populating Final V3 Dexie DB...");

  const labels: UILabelRecord[] = [
    // GlobalLayout scope
    { scopeKey: 'globalLayout', labelKey: 'appTitle', languageCode: 'en', translatedText: 'App V3 - Consistent' },
    { scopeKey: 'globalLayout', labelKey: 'appTitle', languageCode: 'zh', translatedText: 'åº”ç”¨ V3 - ä¸€è‡´æ€§' },
    { scopeKey: 'globalLayout', labelKey: 'navHome', languageCode: 'en', translatedText: 'Home' },
    { scopeKey: 'globalLayout', labelKey: 'navHome', languageCode: 'zh', translatedText: 'ä¸»é¡µ' },
    { scopeKey: 'globalLayout', labelKey: 'navSettings', languageCode: 'en', translatedText: 'Settings' },
    { scopeKey: 'globalLayout', labelKey: 'navSettings', languageCode: 'zh', translatedText: 'è®¾å®š' },
    { scopeKey: 'globalLayout', labelKey: 'footerText', languageCode: 'en', translatedText: 'Â© 2024 Final Demo App' },
    { scopeKey: 'globalLayout', labelKey: 'footerText', languageCode: 'zh', translatedText: 'Â© 2024 æœ€ç»ˆæ¼”ç¤ºåº”ç”¨' },
    { scopeKey: 'globalLayout', labelKey: 'loadingGeneric', languageCode: 'en', translatedText: 'Loading, one moment...' },
    { scopeKey: 'globalLayout', labelKey: 'loadingGeneric', languageCode: 'zh', translatedText: 'åŠ è½½ä¸­ï¼Œè¯·ç¨å€™...' },
    { scopeKey: 'globalLayout', labelKey: 'errorGeneric', languageCode: 'en', translatedText: 'An unexpected error occurred.' },
    { scopeKey: 'globalLayout', labelKey: 'errorGeneric', languageCode: 'zh', translatedText: 'å‘ç”Ÿäº†ä¸€ä¸ªæ„å¤–é”™è¯¯ã€‚' },

    // homeView scope
    { scopeKey: 'homeView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'My Dashboard' },
    { scopeKey: 'homeView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: 'æˆ‘çš„ä»ªè¡¨æ¿' },
    { scopeKey: 'homeView.welcomeSection', labelKey: 'welcomeMessage', languageCode: 'en', translatedText: 'Greetings, {user}! Have a productive day.' },
    { scopeKey: 'homeView.welcomeSection', labelKey: 'welcomeMessage', languageCode: 'zh', translatedText: 'ä½ å¥½ {user}ï¼Œç¥ä½ æ‹¥æœ‰é«˜æ•ˆçš„ä¸€å¤©ï¼' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Recent Mood Entries' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: 'è¿‘æœŸå¿ƒæƒ…è®°å½•' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'noMoodsMessage', languageCode: 'en', translatedText: 'No moods logged. Why not add one?' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'noMoodsMessage', languageCode: 'zh', translatedText: 'æš‚æ— å¿ƒæƒ…è®°å½•ã€‚è¦ä¸è¦æ·»åŠ ä¸€æ¡ï¼Ÿ' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'refreshButtonText', languageCode: 'en', translatedText: 'Refresh Moods' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'refreshButtonText', languageCode: 'zh', translatedText: 'åˆ·æ–°å¿ƒæƒ…' },
    { scopeKey: 'homeView', labelKey: 'someActionText', languageCode: 'en', translatedText: 'Perform Action' },
    { scopeKey: 'homeView', labelKey: 'someActionText', languageCode: 'zh', translatedText: 'æ‰§è¡Œæ“ä½œ' },

    // settingsView scope
    { scopeKey: 'settingsView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Configuration Panel' },
    { scopeKey: 'settingsView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: 'é…ç½®é¢æ¿' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Display Language' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: 'æ˜¾ç¤ºè¯­è¨€' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'selectLanguagePrompt', languageCode: 'en', translatedText: 'Select your preferred language:' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'selectLanguagePrompt', languageCode: 'zh', translatedText: 'è¯·é€‰æ‹©æ‚¨çš„åå¥½è¯­è¨€ï¼š' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'currentLanguageIs', languageCode: 'en', translatedText: 'Currently using: {lang}' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'currentLanguageIs', languageCode: 'zh', translatedText: 'å½“å‰ä½¿ç”¨ï¼š{lang}' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameEn', languageCode: 'en', translatedText: 'English (US)' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameEn', languageCode: 'zh', translatedText: 'ç¾å¼è‹±è¯­' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameZh', languageCode: 'en', translatedText: 'Chinese (Simplified)' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameZh', languageCode: 'zh', translatedText: 'ç®€ä½“ä¸­æ–‡' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'saveButtonText', languageCode: 'en', translatedText: 'Save Preferences' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'saveButtonText', languageCode: 'zh', translatedText: 'ä¿å­˜åå¥½' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'successMessage', languageCode: 'en', translatedText: 'Preferences have been updated!' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'successMessage', languageCode: 'zh', translatedText: 'åå¥½è®¾ç½®å·²æ›´æ–°ï¼' },
  ];
  await db.uiLabels.bulkAdd(labels);
  console.log("Final V3 DB populated.");
}
```

---

**11. `src/services/index.ts`**

```typescript
// src/services/index.ts
export * from './localizedContentService';
```

---

**12. `src/services/localizedContentService.ts`**

```typescript
// src/services/localizedContentService.ts
import { db } from '@/db';
import type {
  Language, LocalizedContent,
  HomePageViewLabelsBundle, HomePageViewDataPayload, MoodItem,
  SettingsPageViewLabelsBundle,
  GlobalLayoutLabelsBundle,
  UILabelRecord, ApiError,
  FetchHomePageViewResult, FetchSettingsPageViewResult, FetchGlobalLayoutViewResult
} from '@/types';

const SIMULATED_DELAY_MS = 150;

function buildLabelsObject<TLabelsBundle>(records: UILabelRecord[], baseScope: string): TLabelsBundle {
  const labels = {} as any;
  records.forEach(record => {
    let keyPath = record.labelKey;
    if (record.scopeKey.startsWith(baseScope + '.') && record.scopeKey.length > baseScope.length) {
        const sectionPath = record.scopeKey.substring(baseScope.length + 1);
        keyPath = `${sectionPath}.${record.labelKey}`;
    } else if (record.scopeKey !== baseScope) {
        // This label is not directly under baseScope or a direct sub-scope path, might be an issue or intended for a different structure.
        // For this demo, we'll assume labels fetched by getScopedLabels are correctly targeted.
        // console.warn(`Label with key ${record.labelKey} has scope ${record.scopeKey} which is not directly under or part of ${baseScope}`);
    }

    const keys = keyPath.split('.');
    let current = labels;
    keys.forEach((key, index) => {
      if (index === keys.length - 1) {
        current[key] = record.translatedText;
      } else {
        current[key] = current[key] || {};
        current = current[key];
      }
    });
  });
  return labels as TLabelsBundle;
}

async function getScopedLabels<TLabelsBundle>(baseScopeKey: string, lang: Language): Promise<TLabelsBundle> {
  let labelRecords = await db.uiLabels
    .where('languageCode').equals(lang)
    .and(record => record.scopeKey.startsWith(baseScopeKey))
    .toArray();

  if (!labelRecords.length && lang !== 'en') {
    console.warn(`No '${lang}' labels for scope ${baseScopeKey}, falling back to 'en'`);
    labelRecords = await db.uiLabels
      .where('languageCode').equals('en')
      .and(record => record.scopeKey.startsWith(baseScopeKey))
      .toArray();
  }

  if (!labelRecords.length) {
    const errorMessage = `CRITICAL: No labels found for essential scope ${baseScopeKey} (lang: ${lang} or fallback 'en').`;
    console.error(errorMessage);
    // In a real app, you might throw an error or have a more robust fallback
    return {} as TLabelsBundle;
  }
  return buildLabelsObject<TLabelsBundle>(labelRecords, baseScopeKey);
}

export async function fetchGlobalLayoutView(lang: Language): Promise<FetchGlobalLayoutViewResult> {
  console.log(`SVC_DEXIE: Fetching GLOBAL LAYOUT VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<GlobalLayoutLabelsBundle>('globalLayout', lang);
  return { labels, data: null };
}

export async function fetchHomePageView(lang: Language): Promise<FetchHomePageViewResult> {
  console.log(`SVC_DEXIE: Fetching HOME PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS));
  const labels = await getScopedLabels<HomePageViewLabelsBundle>('homeView', lang);

  const moods: MoodItem[] = [
    { id: 1, name: labels.moodsSection?.sectionTitle || (lang === 'zh' ? 'å¿ƒæƒ…' : 'Moods'), feeling: lang === 'zh' ? 'ä¸“æ³¨çš„' : 'Focused' },
    { id: 2, name: lang === 'zh' ? 'é”»ç‚¼ä¼šè®®' : 'Workout Session', feeling: lang === 'zh' ? 'ç²¾åŠ›å……æ²›çš„' : 'Energized' },
  ];
  const data: HomePageViewDataPayload = { username: "DevUser", moods };
  return { labels, data };
}

export async function fetchSettingsPageView(lang: Language): Promise<FetchSettingsPageViewResult> {
  console.log(`SVC_DEXIE: Fetching SETTINGS PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<SettingsPageViewLabelsBundle>('settingsView', lang);
  return { labels, data: null };
}
```

---

**13. `src/hooks/useInternationalizedQuery.ts`**

```typescript
// src/hooks/useInternationalizedQuery.ts
import {
  useQuery,
  type UseQueryOptions,
  type QueryKey,
  type UseQueryResult,
} from '@tanstack/react-query';
import type { ApiError, LocalizedContent } from '@/types';

interface UseInternationalizedQueryResult<TDataPayload, TLabelsBundle, TErrorResponse> {
  data: TDataPayload | undefined | null; // Data can be TDataPayload OR null
  labels: TLabelsBundle | undefined;
  isPending: boolean;
  isLoading: boolean;
  isFetching: boolean;
  isError: boolean;
  error: TErrorResponse | null;
  refetch: UseQueryResult<LocalizedContent<TDataPayload, TLabelsBundle>, TErrorResponse>['refetch'];
  status: UseQueryResult<LocalizedContent<TDataPayload, TLabelsBundle>, TErrorResponse>['status'];
  isSuccess: boolean;
}

export function useInternationalizedQuery<
  TLocalizedContent extends LocalizedContent<TDataPayload, TLabelsBundle>,
  TErrorResponse extends Error = ApiError,
  TDataPayload = TLocalizedContent['data'],
  TLabelsBundle = TLocalizedContent['labels'],
  TQueryKey extends QueryKey = QueryKey
>(
  options: UseQueryOptions<TLocalizedContent, TErrorResponse, TLocalizedContent, TQueryKey>
): UseInternationalizedQueryResult<TDataPayload, TLabelsBundle, TErrorResponse> {
  const {
    data: queryResult,
    isPending,
    isLoading,
    isFetching,
    isError,
    error,
    refetch,
    status,
    isSuccess,
  } = useQuery<TLocalizedContent, TErrorResponse, TLocalizedContent, TQueryKey>(options);

  return {
    data: queryResult?.data, // queryResult can be undefined during initial fetch
    labels: queryResult?.labels,
    isPending,
    isLoading,
    isFetching,
    isError,
    error,
    refetch,
    status,
    isSuccess,
  };
}
```

---

**14. `src/hooks/useLocalizedView.ts`**

```typescript
// src/hooks/useLocalizedView.ts
import { useLanguage } from '@/context/LanguageProvider';
import { useInternationalizedQuery } from './useInternationalizedQuery';
import type { ApiError, Language, LocalizedContent } from '@/types';
import { QueryKey, UseQueryOptions } from '@tanstack/react-query';

export function useLocalizedView<
  TDataPayload,
  TLabelsBundle
>(
  viewQueryKey: QueryKey,
  fetchViewFn: (lang: Language) => Promise<LocalizedContent<TDataPayload, TLabelsBundle>>,
  options?: Omit<UseQueryOptions<LocalizedContent<TDataPayload, TLabelsBundle>, ApiError, LocalizedContent<TDataPayload, TLabelsBundle>, QueryKey>, 'queryKey' | 'queryFn'>
) {
  const { language } = useLanguage();
  const fullQueryKeyWithLang: QueryKey = Array.isArray(viewQueryKey)
    ? [...viewQueryKey, language]
    : [viewQueryKey, language];

  return useInternationalizedQuery<
    LocalizedContent<TDataPayload, TLabelsBundle>,
    ApiError,
    TDataPayload,
    TLabelsBundle
  >({
    queryKey: fullQueryKeyWithLang,
    queryFn: () => fetchViewFn(language),
    enabled: !!language && (options?.enabled === undefined || options.enabled),
    ...options,
  });
}
```

---

**15. `src/components/common/Button.tsx`**

```tsx
// src/components/common/Button.tsx
import React from 'react';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary';
  isLoading?: boolean;
  loadingText?: string;
}

const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'primary',
  isLoading = false,
  loadingText = "Loading...",
  ...props
}) => {
  const baseStyle = "button-common";
  const variantStyle = variant === 'primary' ? "button-primary" : "button-secondary";
  return (
    <button className={`${baseStyle} ${variantStyle}`} disabled={isLoading || props.disabled} {...props}>
      {isLoading ? loadingText : children}
    </button>
  );
};
export default Button;
```

---

**16. `src/components/common/LoadingSpinner.tsx`**

```tsx
// src/components/common/LoadingSpinner.tsx
import React from 'react';
// CSS for this will be in src/index.css

const LoadingSpinner: React.FC<{ text?: string }> = ({ text }) => {
  return (
    <div className="loading-spinner-overlay">
      <div className="loading-spinner"></div>
      {text && <p className="loading-spinner-text">{text}</p>}
    </div>
  );
};
export default LoadingSpinner;
```

---

**17. `src/components/common/ErrorDisplay.tsx`**

```tsx
// src/components/common/ErrorDisplay.tsx
import React from 'react';
import type { ApiError } from '@/types';
import Button from './Button'; // Use our common Button

interface ErrorDisplayProps {
  error: ApiError | Error | null;
  title?: string;
  messageTemplate?: string;
  onRetry?: () => void;
  retryButtonText?: string;
}

const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  title = "Error", // Fallback title
  messageTemplate = "Details: {message}",
  onRetry,
  retryButtonText = "Try Again",
}) => {
  if (!error) return null;

  const errorMessage = error.message || "An unknown error occurred.";
  const finalMessage = messageTemplate.replace('{message}', errorMessage);
  const errorCode = (error as ApiError)?.errorCode;
  const statusCode = (error as ApiError)?.statusCode;

  return (
    <div className="error-container" role="alert">
      <h3>{title}</h3>
      <p className="error-text">{finalMessage}</p>
      {errorCode && <p className="error-code-text">Error Code: {errorCode}</p>}
      {statusCode && <p className="error-code-text">Status Code: {statusCode}</p>}
      {onRetry && (
        <Button onClick={onRetry} variant="secondary" style={{ marginTop: '10px' }}>
          {retryButtonText}
        </Button>
      )}
    </div>
  );
};
export default ErrorDisplay;
```

---

**18. `src/components/layout/Header.tsx`**

```tsx
// src/components/layout/Header.tsx
import React from 'react';
import type { GlobalLayoutLabelsBundle } from '@/types';

interface HeaderProps {
  labels: GlobalLayoutLabelsBundle | undefined;
  isFetching?: boolean;
}

const Header: React.FC<HeaderProps> = ({ labels, isFetching }) => {
  // Provide a minimal fallback if labels are still undefined during initial render pass
  const title = labels?.appTitle || "App Loading...";

  return (
    <header style={{ opacity: isFetching ? 0.7 : 1 }}>
      <h1>
        {title}
        {isFetching && labels && <small style={{ marginLeft: '10px', fontStyle: 'italic', color: '#555' }}>(syncing layout...)</small>}
      </h1>
    </header>
  );
};
export default Header;
```

---

**19. `src/components/layout/Navigation.tsx`**

```tsx
// src/components/layout/Navigation.tsx
import React from 'react';
import { NavLink } from 'react-router-dom';
import type { GlobalLayoutLabelsBundle } from '@/types';

interface NavigationProps {
  labels: GlobalLayoutLabelsBundle | undefined;
}

const Navigation: React.FC<NavigationProps> = ({ labels }) => {
  // Provide fallbacks for label properties
  const navHomeText = labels?.navHome || "Home";
  const navSettingsText = labels?.navSettings || "Settings";

  if (!labels) { // Can show a minimal loading state or just render with fallbacks
    return <nav>Loading navigation...</nav>;
  }

  return (
    <nav>
      <NavLink to="/" className={({isActive}) => isActive ? 'active' : ''}>{navHomeText}</NavLink>
      <NavLink to="/settings" className={({isActive}) => isActive ? 'active' : ''}>{navSettingsText}</NavLink>
    </nav>
  );
};
export default Navigation;
```

---

**20. `src/components/layout/AppShell.tsx`**

```tsx
// src/components/layout/AppShell.tsx
import React, { ReactNode } from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchGlobalLayoutView } from '@/services';
import Header from './Header';
import Navigation from './Navigation';
import LoadingSpinner from '../common/LoadingSpinner';
import ErrorDisplay from '../common/ErrorDisplay';
import type { GlobalLayoutLabelsBundle, ApiError } from '@/types';

interface AppShellProps { children: ReactNode; }

const AppShell: React.FC<AppShellProps> = ({ children }) => {
  const {
    labels: globalLabels, isPending, isError, error, isFetching, refetch
  } = useLocalizedView<null, GlobalLayoutLabelsBundle>(
    'globalLayoutViewContent', // Unique query key for this "view"
    fetchGlobalLayoutView
  );

  if (isPending && !globalLabels) {
    // Use a very generic loading text if global labels themselves are not available
    return <LoadingSpinner text={globalLabels?.loadingGeneric || "Initializing Application..."} />;
  }

  if (isError || !globalLabels) { // Critical error if global labels fail
    return (
      <div style={{ padding: '20px' }}>
        <ErrorDisplay
          error={error} // Error from the hook
          title={globalLabels?.appErrorHeading || "Application Shell Error"}
          messageTemplate={globalLabels?.appErrorGeneralMessage || "Core UI failed. Details: {message}"}
          onRetry={refetch}
          retryButtonText="Retry Loading Shell"
        />
      </div>
    );
  }

  return (
    <div className="app-shell">
      <Header labels={globalLabels} isFetching={isFetching && !!globalLabels}/> {/* Pass fetching only if labels are loaded */}
      <Navigation labels={globalLabels} />
      <hr />
      <main>{children}</main>
      <hr />
      <footer style={{ textAlign: 'center', marginTop: '20px', fontSize: '0.9em', color: '#7f8c8d' }}>
        <p>{globalLabels.footerText || "App Footer"}</p>
      </footer>
    </div>
  );
};
export default AppShell;
```

---

**21. `src/features/home/WelcomeSection.tsx`**

```tsx
// src/features/home/WelcomeSection.tsx
import React from 'react';
import type { HomeWelcomeSectionLabels } from '@/types';

interface WelcomeSectionProps {
  labels: HomeWelcomeSectionLabels | undefined;
  username: string | undefined;
}

const WelcomeSection: React.FC<WelcomeSectionProps> = ({ labels, username }) => {
  if (!labels || username === undefined) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Initializing welcome message...</p>;
  }
  const welcomeText = labels.welcomeMessage.replace('{user}', username);
  return <p>{welcomeText}</p>;
};
export default WelcomeSection;
```

---

**22. `src/features/home/MoodsSection.tsx`**

```tsx
// src/features/home/MoodsSection.tsx
import React from 'react';
import type { HomeMoodsSectionLabels, MoodItem } from '@/types';
import Button from '@/components/common/Button';

interface MoodsSectionProps {
  labels: HomeMoodsSectionLabels | undefined;
  moods: readonly MoodItem[] | undefined; // Made readonly in type
  onRefresh: () => void;
  isFetching?: boolean;
}

const MoodsSection: React.FC<MoodsSectionProps> = ({ labels, moods, onRefresh, isFetching }) => {
  if (!labels) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Loading moods section...</p>;
  }

  return (
    <section className="page-content" style={{marginTop: '20px'}}> {/* Use class for styling */}
      <h4>{labels.sectionTitle}</h4> {/* Use h4 for sections within a page normally */}
      {moods && moods.length > 0 ? (
        <ul>
          {moods.map(mood => (
            <li key={mood.id}>{mood.name}: <strong>{mood.feeling}</strong></li>
          ))}
        </ul>
      ) : (
        <p>{labels.noMoodsMessage}</p>
      )}
      <Button onClick={onRefresh} isLoading={isFetching} loadingText="Refreshing...">
        {labels.refreshButtonText}
      </Button>
    </section>
  );
};
export default MoodsSection;
```

---

**23. `src/features/settings/LanguageSettingsSection.tsx`**

```tsx
// src/features/settings/LanguageSettingsSection.tsx
import React, { useState, useEffect } from 'react';
import { useLanguage } from '@/context/LanguageProvider';
import type { Language, SettingsLanguageSectionLabels } from '@/types';
import Button from '@/components/common/Button';

interface LanguageSettingsSectionProps {
  labels: SettingsLanguageSectionLabels | undefined;
  isUpdatingPage?: boolean; // Indicates if the parent page is fetching new labels
}

const LanguageSettingsSection: React.FC<LanguageSettingsSectionProps> = ({ labels, isUpdatingPage }) => {
  const { language, setLanguage } = useLanguage();
  const [selectedLocalLang, setSelectedLocalLang] = useState<Language>(language);
  const [showSuccess, setShowSuccess] = useState(false);

  useEffect(() => {
    setSelectedLocalLang(language); // Sync with global changes
    if (showSuccess) setShowSuccess(false); // Hide success if global lang changes elsewhere
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [language]); // Only re-sync local if global language changes

  if (!labels) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Loading language settings...</p>;
  }

  const handleSave = () => {
    if (selectedLocalLang !== language) {
      setLanguage(selectedLocalLang); // This will trigger page label refetch
      setShowSuccess(true);
      setTimeout(() => setShowSuccess(false), 2500);
    }
  };

  const currentLangDisplay = labels.currentLanguageIs.replace('{lang}', language.toUpperCase());

  return (
    <section> {/* Sections could also use page-content class if desired */}
      <h4>{labels.sectionTitle}</h4>
      <p>{currentLangDisplay}</p>
      <div>
        <label htmlFor="lang-select-component" style={{ marginRight: '8px' }}>{labels.selectLanguagePrompt}</label>
        <select
          id="lang-select-component"
          value={selectedLocalLang}
          onChange={e => {
            setSelectedLocalLang(e.target.value as Language);
            if (showSuccess) setShowSuccess(false);
          }}
          disabled={isUpdatingPage}
        >
          <option value="en">{labels.langNameEn}</option>
          <option value="zh">{labels.langNameZh}</option>
        </select>
      </div>
      <Button
        onClick={handleSave}
        disabled={isUpdatingPage || selectedLocalLang === language}
        style={{marginTop: '15px'}}
        variant="primary"
      >
        {labels.saveButtonText}
      </Button>
      {showSuccess && <p style={{ color: 'green', marginTop: '10px', fontStyle:'italic' }}>{labels.successMessage}</p>}
    </section>
  );
};
export default LanguageSettingsSection;
```

---

**24. `src/pages/HomePage.tsx`**

```tsx
// src/pages/HomePage.tsx
import React from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchHomePageView } from '@/services';
import WelcomeSection from '@/features/home/WelcomeSection';
import MoodsSection from '@/features/home/MoodsSection';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import Button from '@/components/common/Button'; // Example of using common button
import type { HomePageViewDataPayload, HomePageViewLabelsBundle, ApiError } from '@/types';

const HomePage: React.FC = () => {
  const {
    data: pageData, labels: pageLabels, isPending, isError, error, refetch, isFetching
  } = useLocalizedView<HomePageViewDataPayload, HomePageViewLabelsBundle>(
    'homePageViewContent',
    fetchHomePageView
  );

  if (isPending && !pageLabels) { // Full page initial load
    return <LoadingSpinner text="Loading Home Page Content..." />;
  }

  if (isError && !pageLabels) { // Critical: Page labels failed
    return (
      <div className="page-content">
        <ErrorDisplay error={error} title="Home Page Error" onRetry={refetch} />
      </div>
    );
  }

  // If labels are partially/fully loaded, but an error occurred or still pending data
  // We can render the page shell with what we have.
  const isLoadingData = isPending || (isFetching && !pageData); // True if data is still being fetched/refetched

  return (
    <div className="page-container"> {/* Optional container for page styling */}
      <h2>{pageLabels?.pageTitle || "Dashboard"}</h2>

      <WelcomeSection labels={pageLabels?.welcomeSection} username={pageData?.username} />

      <MoodsSection
        labels={pageLabels?.moodsSection}
        moods={pageData?.moods}
        onRefresh={refetch}
        isFetching={isFetching}
      />

      {/* Example of a page-level button using a page-level label */}
      {pageLabels?.someActionText && (
        <Button onClick={() => alert('Action Confirmed!')} style={{marginTop: '20px'}}>
          {pageLabels.someActionText}
        </Button>
      )}

      {/* Show specific data error if labels loaded but data part failed */}
      {isError && pageData === undefined && pageLabels && (
         <ErrorDisplay
            error={error}
            title={pageLabels.moodsSection?.sectionTitle || "Data Fetch Error"}
            messageTemplate="Could not load mood data. Details: {message}"
            onRetry={refetch}
         />
       )}
       {isLoadingData && pageLabels && ( // Show spinner for data if labels are present
           <LoadingSpinner text="Fetching latest data..." />
       )}
    </div>
  );
};
export default HomePage;
```

---

**25. `src/pages/SettingsPage.tsx`**

```tsx
// src/pages/SettingsPage.tsx
import React from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchSettingsPageView } from '@/services';
import LanguageSettingsSection from '@/features/settings/LanguageSettingsSection';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import type { SettingsPageViewLabelsBundle, ApiError } from '@/types';

const SettingsPage: React.FC = () => {
  const {
    labels: pageLabels, isPending, isError, error, refetch, isFetching
  } = useLocalizedView<null, SettingsPageViewLabelsBundle>(
    'settingsPageViewContent',
    fetchSettingsPageView
  );

  if (isPending && !pageLabels) { // Full page initial load
    return <LoadingSpinner text="Loading Settings Page Content..." />;
  }

  if (isError || !pageLabels) { // Critical: Page labels failed
     return (
      <div className="page-content">
        <ErrorDisplay
          error={error}
          title={pageLabels?.pageTitle || "Settings Load Error"}
          messageTemplate="Could not load settings. Details: {message}"
          onRetry={refetch}
        />
      </div>
    );
  }

  return (
    <div className="page-content"> {/* Using class for consistent page styling */}
      <h2>{pageLabels.pageTitle || "Settings"}</h2>
      <LanguageSettingsSection
        labels={pageLabels.languageSection}
        isUpdatingPage={isFetching && !!pageLabels} // Page is fetching if labels are present but still fetching
      />
      {/* Other settings sections would be added here */}
    </div>
  );
};
export default SettingsPage;
```

---

**26. `src/router.tsx`**

```tsx
// src/router.tsx
import React, { Suspense, lazy } from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// Lazy load page components
const HomePage = lazy(() => import('@/pages/HomePage'));
const SettingsPage = lazy(() => import('@/pages/SettingsPage'));

const AppRouter: React.FC = () => {
  return (
    <Suspense fallback={<LoadingSpinner text="Loading view..." />}>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/settings" element={<SettingsPage />} />
        <Route path="*" element={<Navigate to="/" replace />} /> {/* Fallback route */}
      </Routes>
    </Suspense>
  );
};
export default AppRouter;
```

---

**27. `src/App.tsx`**

```tsx
// src/App.tsx
import React, { useEffect } from 'react';
import { BrowserRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
// import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { LanguageProvider } from '@/context/LanguageProvider';
import { populateDB } from '@/db';
import AppShell from '@/components/layout/AppShell';
import AppRouter from '@/router';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 2, // 2 minutes
      refetchOnWindowFocus: false, // Personal preference for demos
      retry: 1, // Retry failed queries once
    },
  },
});

const App: React.FC = () => {
  useEffect(() => {
    // Populate Dexie DB on app start for development
    if (import.meta.env.DEV) { // Vite specific dev check
      populateDB().catch(err => {
        console.error("Failed to populate Dexie DB:", err);
      });
    }
  }, []);

  return (
    <QueryClientProvider client={queryClient}>
      <LanguageProvider>
        <BrowserRouter>
          <AppShell> {/* AppShell fetches global layout labels and provides overall structure */}
            <AppRouter /> {/* AppRouter handles page-specific content and routing */}
          </AppShell>
        </BrowserRouter>
      </LanguageProvider>
      {/* <ReactQueryDevtools initialIsOpen={false} /> */}
    </QueryClientProvider>
  );
};
export default App;
```

---

**28. `src/main.tsx`**

```tsx
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';
import './index.css'; // Global styles

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
```

---

This V3 Final version provides a clean, well-structured, and type-safe foundation. The README clearly outlines the architecture, making it suitable for team collaboration. Key improvements include refined naming, a dedicated `useLocalizedView` hook, and clearer separation of concerns with page components fetching all necessary content and delegating rendering to feature-specific sections.
</file>

<file path="src/components/animation/AnimatedButton.tsx">
// src/components/animation/AnimatedButton.tsx
import React from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import Button from '@/components/common/Button';

interface AnimatedButtonProps extends HTMLMotionProps<'button'> {
  variant?: 'primary' | 'secondary' | 'jade' | 'gold';
  isLoading?: boolean;
  loadingText?: string;
  children: React.ReactNode;
  whileHover?: object;
  whileTap?: object;
  className?: string;
  onClick?: () => void;
}

/**
 * åŠ¨ç”»æŒ‰é’®ç»„ä»¶ï¼Œä¸ºButtonç»„ä»¶æ·»åŠ åŠ¨ç”»æ•ˆæœ
 * 
 * @param variant - æŒ‰é’®å˜ä½“
 * @param isLoading - æ˜¯å¦æ˜¾ç¤ºåŠ è½½çŠ¶æ€
 * @param loadingText - åŠ è½½çŠ¶æ€æ–‡æœ¬
 * @param children - å­å…ƒç´ 
 * @param whileHover - æ‚¬åœåŠ¨ç”»
 * @param whileTap - ç‚¹å‡»åŠ¨ç”»
 * @param className - CSSç±»å
 * @param onClick - ç‚¹å‡»äº‹ä»¶å¤„ç†å‡½æ•°
 */
const AnimatedButton: React.FC<AnimatedButtonProps> = ({
  variant = 'primary',
  isLoading = false,
  loadingText,
  children,
  whileHover = { scale: 1.05 },
  whileTap = { scale: 0.95 },
  className = '',
  onClick,
  ...props
}) => {
  // æ ¹æ®å˜ä½“è®¾ç½®ä¸åŒçš„åŠ¨ç”»æ•ˆæœ
  const getAnimationProps = () => {
    switch (variant) {
      case 'jade':
        return {
          whileHover: { 
            scale: 1.05, 
            boxShadow: '0 0 15px rgba(136, 176, 75, 0.5)' 
          },
          whileTap: { 
            scale: 0.95 
          }
        };
      case 'gold':
        return {
          whileHover: { 
            scale: 1.05, 
            boxShadow: '0 0 15px rgba(212, 175, 55, 0.5)' 
          },
          whileTap: { 
            scale: 0.95 
          }
        };
      default:
        return {
          whileHover,
          whileTap
        };
    }
  };

  const animationProps = getAnimationProps();

  return (
    <motion.div
      className={`animated-button-container ${className}`}
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: 10 }}
      {...animationProps}
      {...props}
    >
      <Button
        variant={variant}
        isLoading={isLoading}
        loadingText={loadingText}
        onClick={onClick}
        style={{ width: '100%', height: '100%' }}
      >
        {children}
      </Button>
    </motion.div>
  );
};

export default AnimatedButton;
</file>

<file path="src/components/animation/AnimatedContainer.tsx">
// src/components/animation/AnimatedContainer.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { createContainerVariants } from '@/utils/animation';

interface AnimatedContainerProps extends HTMLMotionProps<'div'> {
  children: ReactNode;
  variants?: Variants;
  staggerChildren?: number;
  delayChildren?: number;
  className?: string;
  initial?: string | object;
  animate?: string | object;
  exit?: string | object;
}

/**
 * åŠ¨ç”»å®¹å™¨ç»„ä»¶ï¼Œç”¨äºä¸ºå­å…ƒç´ æ·»åŠ äº¤é”™åŠ¨ç”»æ•ˆæœ
 * 
 * @param children - å­å…ƒç´ 
 * @param variants - åŠ¨ç”»å˜ä½“
 * @param staggerChildren - å­å…ƒç´ ä¹‹é—´çš„å»¶è¿Ÿæ—¶é—´
 * @param delayChildren - æ‰€æœ‰å­å…ƒç´ çš„åˆå§‹å»¶è¿Ÿ
 * @param className - CSSç±»å
 * @param initial - åˆå§‹åŠ¨ç”»çŠ¶æ€
 * @param animate - åŠ¨ç”»çŠ¶æ€
 * @param exit - é€€å‡ºåŠ¨ç”»çŠ¶æ€
 */
const AnimatedContainer: React.FC<AnimatedContainerProps> = ({
  children,
  variants,
  staggerChildren = 0.1,
  delayChildren = 0,
  className = '',
  initial = 'hidden',
  animate = 'visible',
  exit = 'exit',
  ...props
}) => {
  // å¦‚æœæ²¡æœ‰æä¾›å˜ä½“ï¼Œåˆ™ä½¿ç”¨é»˜è®¤çš„å®¹å™¨å˜ä½“
  const containerVariants = variants || createContainerVariants(staggerChildren, delayChildren);

  return (
    <motion.div
      className={className}
      variants={containerVariants}
      initial={initial}
      animate={animate}
      exit={exit}
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default AnimatedContainer;
</file>

<file path="src/components/animation/AnimatedItem.tsx">
// src/components/animation/AnimatedItem.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { listItem } from '@/utils/animation';

interface AnimatedItemProps extends HTMLMotionProps<'div'> {
  children: ReactNode;
  variants?: Variants;
  index?: number;
  className?: string;
  initial?: string | object;
  animate?: string | object;
  exit?: string | object;
}

/**
 * åŠ¨ç”»é¡¹ç»„ä»¶ï¼Œç”¨äºä¸ºåˆ—è¡¨é¡¹æ·»åŠ åŠ¨ç”»æ•ˆæœ
 * 
 * @param children - å­å…ƒç´ 
 * @param variants - åŠ¨ç”»å˜ä½“
 * @param index - é¡¹ç›®ç´¢å¼•ï¼Œç”¨äºè®¡ç®—å»¶è¿Ÿ
 * @param className - CSSç±»å
 * @param initial - åˆå§‹åŠ¨ç”»çŠ¶æ€
 * @param animate - åŠ¨ç”»çŠ¶æ€
 * @param exit - é€€å‡ºåŠ¨ç”»çŠ¶æ€
 */
const AnimatedItem: React.FC<AnimatedItemProps> = ({
  children,
  variants = listItem,
  index = 0,
  className = '',
  initial = 'hidden',
  animate = 'visible',
  exit = 'exit',
  ...props
}) => {
  return (
    <motion.div
      className={className}
      variants={variants}
      initial={initial}
      animate={animate}
      exit={exit}
      custom={index}
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default AnimatedItem;
</file>

<file path="src/components/animation/ChallengeCompletionAnimation.tsx">
// src/components/animation/ChallengeCompletionAnimation.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { playChallengeCompletionSound } from '@/utils/sound';

interface ChallengeCompletionAnimationProps {
  challengeTitle: string;
  challengeDescription?: string;
  onAnimationComplete?: () => void;
  style?: 'default' | 'epic' | 'legendary';
  playSound?: boolean;
  soundVolume?: number;
}

/**
 * æŒ‘æˆ˜å®ŒæˆåŠ¨ç”»ç»„ä»¶
 * åœ¨æŒ‘æˆ˜å®Œæˆæ—¶æ˜¾ç¤ºåŠ¨ç”»æ•ˆæœ
 */
const ChallengeCompletionAnimation: React.FC<ChallengeCompletionAnimationProps> = ({
  challengeTitle,
  challengeDescription,
  onAnimationComplete,
  style = 'default',
  playSound = true,
  soundVolume = 0.5
}) => {
  const [isAnimating, setIsAnimating] = useState(true);
  const [particles, setParticles] = useState<React.ReactNode[]>([]);

  // æ’­æ”¾éŸ³æ•ˆ
  useEffect(() => {
    if (playSound) {
      // æ ¹æ®åŠ¨ç”»æ ·å¼ç¡®å®šæŒ‘æˆ˜éš¾åº¦
      const difficulty = style === 'legendary' ? 'legendary' :
                         style === 'epic' ? 'epic' : 'normal';
      playChallengeCompletionSound(difficulty, soundVolume);
    }
  }, [playSound, style, soundVolume]);

  // ç”Ÿæˆç²’å­æ•ˆæœ
  useEffect(() => {
    const particleCount = style === 'legendary' ? 100 : style === 'epic' ? 70 : 40;
    const newParticles = [];

    for (let i = 0; i < particleCount; i++) {
      newParticles.push(generateParticle(i, style));
    }

    setParticles(newParticles);
  }, [style]);

  // ç”Ÿæˆå•ä¸ªç²’å­
  const generateParticle = (index: number, style: string) => {
    // ä¼ è¯´çº§æŒ‘æˆ˜å®ŒæˆåŠ¨ç”»
    if (style === 'legendary') {
      // å½©è™¹è‰²ç²’å­
      const colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];

      // éšæœºé€‰æ‹©ç²’å­ç±»å‹
      const particleType = Math.random() > 0.7 ? 'star' : Math.random() > 0.5 ? 'circle' : 'square';

      if (particleType === 'star') {
        const size = Math.random() * 20 + 10;
        const angle = Math.random() * 360;
        const distance = Math.random() * 150 + 100;
        const delay = Math.random() * 1;
        const duration = Math.random() * 2 + 2;

        return (
          <motion.div
            key={`star-${index}`}
            style={{
              position: 'absolute',
              width: size,
              height: size,
              top: '50%',
              left: '50%',
              margin: `-${size / 2}px 0 0 -${size / 2}px`,
              clipPath: 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
              backgroundColor: randomColor,
              boxShadow: `0 0 10px ${randomColor}`,
              zIndex: 10
            }}
            initial={{
              x: 0,
              y: 0,
              opacity: 0,
              rotate: 0,
              scale: 0
            }}
            animate={{
              x: Math.cos(angle * Math.PI / 180) * distance,
              y: Math.sin(angle * Math.PI / 180) * distance,
              opacity: [0, 1, 1, 0.8, 0],
              rotate: 360,
              scale: [0, 1.5, 1, 1.2, 0]
            }}
            transition={{
              duration: duration,
              delay: delay,
              ease: 'easeInOut',
              times: [0, 0.2, 0.4, 0.8, 1]
            }}
          />
        );
      } else if (particleType === 'circle') {
        const size = Math.random() * 15 + 5;
        const angle = Math.random() * 360;
        const distance = Math.random() * 200 + 50;
        const delay = Math.random() * 0.8;
        const duration = Math.random() * 2 + 1.5;

        return (
          <motion.div
            key={`circle-${index}`}
            style={{
              position: 'absolute',
              width: size,
              height: size,
              borderRadius: '50%',
              backgroundColor: randomColor,
              boxShadow: `0 0 10px ${randomColor}`,
              top: '50%',
              left: '50%',
              margin: `-${size / 2}px 0 0 -${size / 2}px`,
              zIndex: 10
            }}
            initial={{
              x: 0,
              y: 0,
              opacity: 0,
              scale: 0.5
            }}
            animate={{
              x: Math.cos(angle * Math.PI / 180) * distance,
              y: Math.sin(angle * Math.PI / 180) * distance,
              opacity: [0, 1, 0.8, 0],
              scale: [0.5, 1.5, 1, 0]
            }}
            transition={{
              duration: duration,
              delay: delay,
              ease: 'easeOut',
              times: [0, 0.3, 0.7, 1]
            }}
          />
        );
      } else {
        const size = Math.random() * 12 + 8;
        const angle = Math.random() * 360;
        const distance = Math.random() * 180 + 80;
        const delay = Math.random() * 0.5;
        const duration = Math.random() * 1.5 + 1;
        const rotation = Math.random() * 720 - 360;

        return (
          <motion.div
            key={`square-${index}`}
            style={{
              position: 'absolute',
              width: size,
              height: size,
              backgroundColor: randomColor,
              boxShadow: `0 0 8px ${randomColor}`,
              top: '50%',
              left: '50%',
              margin: `-${size / 2}px 0 0 -${size / 2}px`,
              zIndex: 10
            }}
            initial={{
              x: 0,
              y: 0,
              opacity: 0,
              rotate: 0,
              scale: 0.5
            }}
            animate={{
              x: Math.cos(angle * Math.PI / 180) * distance,
              y: Math.sin(angle * Math.PI / 180) * distance,
              opacity: [0, 1, 0.7, 0],
              rotate: rotation,
              scale: [0.5, 1.2, 0.8, 0]
            }}
            transition={{
              duration: duration,
              delay: delay,
              ease: 'easeOut',
              times: [0, 0.3, 0.7, 1]
            }}
          />
        );
      }
    }
    // å²è¯—çº§æŒ‘æˆ˜å®ŒæˆåŠ¨ç”»
    else if (style === 'epic') {
      const colors = ['#a335ee', '#9370DB', '#8A2BE2', '#9932CC', '#BA55D3'];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];

      const size = Math.random() * 15 + 5;
      const angle = Math.random() * 360;
      const distance = Math.random() * 150 + 50;
      const delay = Math.random() * 0.5;
      const duration = Math.random() * 1.5 + 1;

      return (
        <motion.div
          key={`epic-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            borderRadius: Math.random() > 0.5 ? '50%' : '0%',
            backgroundColor: randomColor,
            boxShadow: `0 0 8px ${randomColor}`,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0,
            rotate: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0],
            rotate: Math.random() > 0.5 ? 360 : 0
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    }
    // é»˜è®¤æŒ‘æˆ˜å®ŒæˆåŠ¨ç”»
    else {
      const colors = ['#FFD700', '#FFA500', '#FF8C00', '#FF7F50', '#FF6347'];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];

      const size = Math.random() * 10 + 5;
      const angle = Math.random() * 360;
      const distance = Math.random() * 100 + 50;
      const delay = Math.random() * 0.3;
      const duration = Math.random() * 1 + 0.8;

      return (
        <motion.div
          key={`default-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            borderRadius: '50%',
            backgroundColor: randomColor,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    }
  };

  // å¤„ç†åŠ¨ç”»å®Œæˆ
  const handleAnimationComplete = () => {
    setIsAnimating(false);
    if (onAnimationComplete) {
      onAnimationComplete();
    }
  };

  return (
    <AnimatePresence>
      {isAnimating && (
        <motion.div
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            zIndex: 1000,
            pointerEvents: 'none'
          }}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.3 }}
        >
          {/* ç²’å­æ•ˆæœ */}
          {particles}

          {/* ä¸­å¿ƒæ–‡æœ¬ */}
          <motion.div
            style={{
              backgroundColor: style === 'legendary' ? 'rgba(0, 0, 0, 0.8)' :
                              style === 'epic' ? 'rgba(50, 0, 80, 0.8)' :
                              'rgba(50, 30, 0, 0.8)',
              color: '#fff',
              padding: '30px 50px',
              borderRadius: '15px',
              textAlign: 'center',
              zIndex: 20,
              border: style === 'legendary' ? '3px solid gold' :
                      style === 'epic' ? '2px solid #a335ee' :
                      '1px solid #FFA500',
              boxShadow: style === 'legendary' ? '0 0 20px gold' :
                         style === 'epic' ? '0 0 15px #a335ee' :
                         '0 0 10px #FFA500'
            }}
            initial={{ scale: 0, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0, opacity: 0 }}
            transition={{ duration: 0.5, delay: 0.2 }}
            onAnimationComplete={handleAnimationComplete}
          >
            <motion.h2
              style={{
                fontSize: '2rem',
                marginBottom: '1rem',
                color: style === 'legendary' ? 'gold' :
                       style === 'epic' ? '#a335ee' :
                       '#FFA500'
              }}
              initial={{ y: -20, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ duration: 0.3, delay: 0.3 }}
            >
              æŒ‘æˆ˜å®Œæˆï¼
            </motion.h2>
            <motion.h3
              initial={{ y: -10, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ duration: 0.3, delay: 0.5 }}
            >
              {challengeTitle}
            </motion.h3>
            {challengeDescription && (
              <motion.p
                initial={{ y: 20, opacity: 0 }}
                animate={{ y: 0, opacity: 1 }}
                transition={{ duration: 0.3, delay: 0.7 }}
              >
                {challengeDescription}
              </motion.p>
            )}
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default ChallengeCompletionAnimation;
</file>

<file path="src/components/animation/GoldenGlow.tsx">
// src/components/animation/GoldenGlow.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { goldenGlow } from '@/utils/animation';

interface GoldenGlowProps extends HTMLMotionProps<'div'> {
  children: ReactNode;
  variants?: Variants;
  className?: string;
  intensity?: 'low' | 'medium' | 'high';
  onClick?: () => void;
}

/**
 * é‡‘å…‰æ•ˆæœåŠ¨ç”»ç»„ä»¶ï¼Œç”¨äºåˆ›å»ºä¸­å›½é£é‡‘å…‰åŠ¨ç”»æ•ˆæœ
 * 
 * @param children - å­å…ƒç´ 
 * @param variants - åŠ¨ç”»å˜ä½“
 * @param className - CSSç±»å
 * @param intensity - å¼ºåº¦
 * @param onClick - ç‚¹å‡»äº‹ä»¶å¤„ç†å‡½æ•°
 */
const GoldenGlow: React.FC<GoldenGlowProps> = ({
  children,
  variants = goldenGlow,
  className = '',
  intensity = 'medium',
  onClick,
  ...props
}) => {
  // æ ¹æ®å¼ºåº¦è®¾ç½®æ ·å¼
  const intensityStyles = {
    low: { 
      boxShadow: '0 0 10px 2px rgba(212, 175, 55, 0.3)',
      filter: 'brightness(1.1) saturate(1.1)'
    },
    medium: { 
      boxShadow: '0 0 15px 5px rgba(212, 175, 55, 0.5)',
      filter: 'brightness(1.2) saturate(1.2)'
    },
    high: { 
      boxShadow: '0 0 20px 10px rgba(212, 175, 55, 0.7)',
      filter: 'brightness(1.3) saturate(1.3)'
    }
  };

  return (
    <motion.div
      className={`golden-glow ${className}`}
      variants={variants}
      initial="hidden"
      animate="visible"
      exit="exit"
      style={{
        position: 'relative',
        ...intensityStyles[intensity],
        ...props.style
      }}
      onClick={onClick}
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default GoldenGlow;
</file>

<file path="src/components/animation/InkSplash.tsx">
// src/components/animation/InkSplash.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { inkSplash } from '@/utils/animation';

interface InkSplashProps extends HTMLMotionProps<'div'> {
  children?: ReactNode;
  variants?: Variants;
  className?: string;
  size?: 'small' | 'medium' | 'large';
  color?: string;
  onClick?: () => void;
}

/**
 * æ°´å¢¨æ•ˆæœåŠ¨ç”»ç»„ä»¶ï¼Œç”¨äºåˆ›å»ºä¸­å›½é£æ°´å¢¨åŠ¨ç”»æ•ˆæœ
 * 
 * @param children - å­å…ƒç´ 
 * @param variants - åŠ¨ç”»å˜ä½“
 * @param className - CSSç±»å
 * @param size - å¤§å°
 * @param color - é¢œè‰²
 * @param onClick - ç‚¹å‡»äº‹ä»¶å¤„ç†å‡½æ•°
 */
const InkSplash: React.FC<InkSplashProps> = ({
  children,
  variants = inkSplash,
  className = '',
  size = 'medium',
  color = 'var(--royal-jade)',
  onClick,
  ...props
}) => {
  // æ ¹æ®å¤§å°è®¾ç½®æ ·å¼
  const sizeStyles = {
    small: { width: '50px', height: '50px' },
    medium: { width: '100px', height: '100px' },
    large: { width: '150px', height: '150px' }
  };

  return (
    <motion.div
      className={`ink-splash ${className}`}
      variants={variants}
      initial="hidden"
      animate="visible"
      exit="exit"
      style={{
        ...sizeStyles[size],
        backgroundColor: color,
        borderRadius: '50%',
        filter: 'blur(5px)',
        position: 'relative',
        overflow: 'hidden',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        ...props.style
      }}
      onClick={onClick}
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default InkSplash;
</file>

<file path="src/components/animation/PageTransition.tsx">
// src/components/animation/PageTransition.tsx
import React, { ReactNode } from 'react';
import { motion, Variants, HTMLMotionProps } from 'framer-motion';
import { pageTransition } from '@/utils/animation';

interface PageTransitionProps extends HTMLMotionProps<'div'> {
  children: ReactNode;
  variants?: Variants;
  className?: string;
}

/**
 * é¡µé¢è¿‡æ¸¡ç»„ä»¶ï¼Œç”¨äºä¸ºé¡µé¢æ·»åŠ è¿›å…¥å’Œé€€å‡ºåŠ¨ç”»
 * 
 * @param children - å­å…ƒç´ 
 * @param variants - åŠ¨ç”»å˜ä½“
 * @param className - CSSç±»å
 */
const PageTransition: React.FC<PageTransitionProps> = ({
  children,
  variants = pageTransition,
  className = '',
  ...props
}) => {
  return (
    <motion.div
      className={className}
      variants={variants}
      initial="hidden"
      animate="visible"
      exit="exit"
      {...props}
    >
      {children}
    </motion.div>
  );
};

export default PageTransition;
</file>

<file path="src/components/animation/README.md">
# åŠ¨ç”»ç»„ä»¶æ–‡æ¡£

## RewardAnimation ç»„ä»¶

`RewardAnimation` æ˜¯ä¸€ä¸ªç”¨äºå±•ç¤ºå¥–åŠ±è·å–åŠ¨ç”»çš„ç»„ä»¶ï¼Œæ”¯æŒå¤šç§åŠ¨ç”»æ•ˆæœå’ŒéŸ³æ•ˆï¼Œæ ¹æ®å¥–åŠ±çš„ç¨€æœ‰åº¦æä¾›ä¸åŒçš„è§†è§‰æ•ˆæœã€‚

## TaskCompletionAnimation ç»„ä»¶

`TaskCompletionAnimation` æ˜¯ä¸€ä¸ªç”¨äºå±•ç¤ºä»»åŠ¡å®ŒæˆåŠ¨ç”»çš„ç»„ä»¶ï¼Œæ”¯æŒå¤šç§åŠ¨ç”»æ•ˆæœå’ŒéŸ³æ•ˆï¼Œæ ¹æ®ä»»åŠ¡çš„ä¼˜å…ˆçº§å’Œç±»å‹æä¾›ä¸åŒçš„è§†è§‰æ•ˆæœã€‚

## ChallengeCompletionAnimation ç»„ä»¶

`ChallengeCompletionAnimation` æ˜¯ä¸€ä¸ªç”¨äºå±•ç¤ºæŒ‘æˆ˜å®ŒæˆåŠ¨ç”»çš„ç»„ä»¶ï¼Œæ”¯æŒå¤šç§åŠ¨ç”»æ•ˆæœå’ŒéŸ³æ•ˆï¼Œæ ¹æ®æŒ‘æˆ˜çš„éš¾åº¦æä¾›ä¸åŒçš„è§†è§‰æ•ˆæœã€‚

### ä½¿ç”¨æ–¹æ³•

```tsx
import RewardAnimation from '@/components/animation/RewardAnimation';
import { RewardType, RewardRarity } from '@/services/rewardService';

// åŸºæœ¬ç”¨æ³•
<RewardAnimation
  type={RewardType.COIN}
  rarity={RewardRarity.COMMON}
  iconPath="/assets/rewards/coin.svg"
  amount={10}
  size={100}
/>

// é«˜çº§ç”¨æ³•
<RewardAnimation
  type={RewardType.ITEM}
  rarity={RewardRarity.LEGENDARY}
  iconPath="/assets/rewards/legendary_item.svg"
  amount={1}
  size={150}
  animationStyle="burst"
  playSound={true}
  soundVolume={0.7}
  onAnimationComplete={() => console.log('åŠ¨ç”»æ’­æ”¾å®Œæˆ')}
/>
```

### å±æ€§

| å±æ€§å | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|--------|------|--------|------|
| type | RewardType | å¿…å¡« | å¥–åŠ±ç±»å‹ |
| rarity | RewardRarity | å¿…å¡« | å¥–åŠ±ç¨€æœ‰åº¦ |
| iconPath | string | å¿…å¡« | å¥–åŠ±å›¾æ ‡è·¯å¾„ |
| amount | number | 1 | å¥–åŠ±æ•°é‡ |
| size | number | 100 | åŠ¨ç”»å®¹å™¨å¤§å°ï¼ˆåƒç´ ï¼‰ |
| animationStyle | 'default' \| 'burst' \| 'float' \| 'spin' \| 'pulse' | 'default' | åŠ¨ç”»æ ·å¼ |
| playSound | boolean | true | æ˜¯å¦æ’­æ”¾éŸ³æ•ˆ |
| soundVolume | number | 0.5 | éŸ³æ•ˆéŸ³é‡ï¼ˆ0-1ï¼‰ |
| onAnimationComplete | () => void | undefined | åŠ¨ç”»å®Œæˆå›è°ƒå‡½æ•° |

### åŠ¨ç”»æ ·å¼è¯´æ˜

1. **default**: é»˜è®¤åŠ¨ç”»ï¼Œé€‚ç”¨äºæ™®é€šå¥–åŠ±
2. **burst**: çˆ†å‘å¼åŠ¨ç”»ï¼Œé€‚ç”¨äºä¼ è¯´çº§å¥–åŠ±
3. **spin**: æ—‹è½¬åŠ¨ç”»ï¼Œé€‚ç”¨äºå²è¯—çº§å¥–åŠ±
4. **pulse**: è„‰å†²åŠ¨ç”»ï¼Œé€‚ç”¨äºç¨€æœ‰å¥–åŠ±
5. **float**: æµ®åŠ¨åŠ¨ç”»ï¼Œé€‚ç”¨äºä¸å¸¸è§å¥–åŠ±

### ç¨€æœ‰åº¦ç‰¹æ•ˆ

- **ä¼ è¯´çº§ (Legendary)**: å½©è™¹è¾¹æ¡†ã€æ˜Ÿæ˜Ÿç²’å­ã€é‡‘è‰²å…‰æ™•
- **å²è¯—çº§ (Epic)**: ç´«è‰²è¾¹æ¡†ã€å¼ºçƒˆå…‰æ™•æ•ˆæœ
- **ç¨€æœ‰çº§ (Rare)**: è“è‰²è¾¹æ¡†ã€ä¸­ç­‰å…‰æ™•æ•ˆæœ
- **ä¸å¸¸è§ (Uncommon)**: ç»¿è‰²å…‰æ™•
- **æ™®é€š (Common)**: åŸºç¡€å…‰æ™•

### éŸ³æ•ˆç³»ç»Ÿ

ç»„ä»¶ä½¿ç”¨ `sound.ts` å·¥å…·ç±»æ’­æ”¾éŸ³æ•ˆï¼Œæ ¹æ®å¥–åŠ±ç¨€æœ‰åº¦æ’­æ”¾ä¸åŒçš„éŸ³æ•ˆã€‚éŸ³æ•ˆæ–‡ä»¶åº”æ”¾ç½®åœ¨ `/public/assets/sounds/` ç›®å½•ä¸‹ã€‚

### ç¤ºä¾‹ä»£ç 

```tsx
// åœ¨å¥–åŠ±æ¨¡æ€æ¡†ä¸­ä½¿ç”¨
const getAnimationStyleForRarity = (rarity: string): 'default' | 'burst' | 'float' | 'spin' | 'pulse' => {
  switch (rarity) {
    case 'legendary': return 'burst';
    case 'epic': return 'spin';
    case 'rare': return 'pulse';
    case 'uncommon': return 'float';
    default: return 'default';
  }
};

<RewardAnimation
  type={reward.type}
  rarity={reward.rarity}
  iconPath={reward.iconPath}
  amount={reward.amount}
  size={120}
  onAnimationComplete={handleAnimationComplete}
  animationStyle={getAnimationStyleForRarity(reward.rarity)}
  playSound={true}
  soundVolume={0.6}
/>
```

## TaskCompletionAnimation ä½¿ç”¨æ–¹æ³•

```tsx
import TaskCompletionAnimation from '@/components/animation/TaskCompletionAnimation';
import { TaskRecord, TaskPriority, TaskType } from '@/services/taskService';

// åŸºæœ¬ç”¨æ³•
<TaskCompletionAnimation
  task={completedTask}
  onAnimationComplete={() => console.log('ä»»åŠ¡å®ŒæˆåŠ¨ç”»ç»“æŸ')}
/>

// é«˜çº§ç”¨æ³•
<TaskCompletionAnimation
  task={completedTask}
  style={completedTask.priority === TaskPriority.HIGH ? 'fireworks' :
         completedTask.type === TaskType.MAIN ? 'stars' : 'confetti'}
  playSound={true}
  soundVolume={0.7}
  onAnimationComplete={handleAnimationComplete}
/>
```

### å±æ€§

| å±æ€§å | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|--------|------|--------|------|
| task | TaskRecord | å¿…å¡« | å®Œæˆçš„ä»»åŠ¡ |
| onAnimationComplete | () => void | undefined | åŠ¨ç”»å®Œæˆå›è°ƒå‡½æ•° |
| style | 'default' \| 'confetti' \| 'fireworks' \| 'stars' | 'default' | åŠ¨ç”»æ ·å¼ |
| playSound | boolean | true | æ˜¯å¦æ’­æ”¾éŸ³æ•ˆ |
| soundVolume | number | 0.5 | éŸ³æ•ˆéŸ³é‡ï¼ˆ0-1ï¼‰ |

## ChallengeCompletionAnimation ä½¿ç”¨æ–¹æ³•

```tsx
import ChallengeCompletionAnimation from '@/components/animation/ChallengeCompletionAnimation';

// åŸºæœ¬ç”¨æ³•
<ChallengeCompletionAnimation
  challengeTitle="æ¯å‘¨æŒ‘æˆ˜ï¼šç«¹æ—æ¢é™©"
  onAnimationComplete={() => console.log('æŒ‘æˆ˜å®ŒæˆåŠ¨ç”»ç»“æŸ')}
/>

// é«˜çº§ç”¨æ³•
<ChallengeCompletionAnimation
  challengeTitle="ä¼ è¯´æŒ‘æˆ˜ï¼šç†ŠçŒ«å¤§å¸ˆ"
  challengeDescription="å®Œæˆæ‰€æœ‰ç†ŠçŒ«è®­ç»ƒè¯¾ç¨‹"
  style="legendary"
  playSound={true}
  soundVolume={0.8}
  onAnimationComplete={handleAnimationComplete}
/>
```

### å±æ€§

| å±æ€§å | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|--------|------|--------|------|
| challengeTitle | string | å¿…å¡« | æŒ‘æˆ˜æ ‡é¢˜ |
| challengeDescription | string | undefined | æŒ‘æˆ˜æè¿° |
| onAnimationComplete | () => void | undefined | åŠ¨ç”»å®Œæˆå›è°ƒå‡½æ•° |
| style | 'default' \| 'epic' \| 'legendary' | 'default' | åŠ¨ç”»æ ·å¼ |
| playSound | boolean | true | æ˜¯å¦æ’­æ”¾éŸ³æ•ˆ |
| soundVolume | number | 0.5 | éŸ³æ•ˆéŸ³é‡ï¼ˆ0-1ï¼‰ |

## æ³¨æ„äº‹é¡¹

1. ç¡®ä¿éŸ³æ•ˆæ–‡ä»¶å·²æ­£ç¡®æ”¾ç½®åœ¨ `/public/assets/sounds/` ç›®å½•ä¸‹
2. å¯¹äºé«˜é¢‘ç‡è§¦å‘çš„åŠ¨ç”»ï¼Œè€ƒè™‘è®¾ç½® `playSound={false}` ä»¥é¿å…éŸ³æ•ˆé‡å 
3. åŠ¨ç”»å®Œæˆåä¼šè°ƒç”¨ `onAnimationComplete` å›è°ƒå‡½æ•°ï¼Œå¯ç”¨äºè§¦å‘åç»­æ“ä½œ
4. ç»„ä»¶å†…éƒ¨ä½¿ç”¨ `AnimatePresence` å¤„ç†åŠ¨ç”»çš„è¿›å…¥å’Œé€€å‡ºï¼Œç¡®ä¿åœ¨çˆ¶ç»„ä»¶ä¸­æ­£ç¡®å¤„ç†ç»„ä»¶çš„æŒ‚è½½å’Œå¸è½½
5. ä»»åŠ¡å’ŒæŒ‘æˆ˜å®ŒæˆåŠ¨ç”»ä¼šæ ¹æ®ä»»åŠ¡/æŒ‘æˆ˜çš„é‡è¦æ€§è‡ªåŠ¨é€‰æ‹©ä¸åŒçš„åŠ¨ç”»æ•ˆæœ
6. æ‰€æœ‰åŠ¨ç”»ç»„ä»¶éƒ½æ”¯æŒè‡ªå®šä¹‰æ ·å¼å’ŒéŸ³æ•ˆ
</file>

<file path="src/components/animation/TaskCompletionAnimation.tsx">
// src/components/animation/TaskCompletionAnimation.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { TaskRecord } from '@/services/taskService';
import { playTaskCompletionSound } from '@/utils/sound';

interface TaskCompletionAnimationProps {
  task: TaskRecord;
  onAnimationComplete?: () => void;
  style?: 'default' | 'confetti' | 'fireworks' | 'stars';
  playSound?: boolean;
  soundVolume?: number;
}

/**
 * ä»»åŠ¡å®ŒæˆåŠ¨ç”»ç»„ä»¶
 * åœ¨ä»»åŠ¡å®Œæˆæ—¶æ˜¾ç¤ºåŠ¨ç”»æ•ˆæœ
 */
const TaskCompletionAnimation: React.FC<TaskCompletionAnimationProps> = ({
  task,
  onAnimationComplete,
  style = 'default',
  playSound = true,
  soundVolume = 0.5
}) => {
  const [isAnimating, setIsAnimating] = useState(true);
  const [particles, setParticles] = useState<React.ReactNode[]>([]);

  // æ’­æ”¾éŸ³æ•ˆ
  useEffect(() => {
    if (playSound) {
      playTaskCompletionSound(task.type, task.priority, soundVolume);
    }
  }, [playSound, task.type, task.priority, soundVolume]);

  // ç”Ÿæˆç²’å­æ•ˆæœ
  useEffect(() => {
    const particleCount = style === 'confetti' ? 50 : style === 'fireworks' ? 30 : style === 'stars' ? 20 : 10;
    const newParticles = [];

    for (let i = 0; i < particleCount; i++) {
      newParticles.push(generateParticle(i, style));
    }

    setParticles(newParticles);
  }, [style]);

  // ç”Ÿæˆå•ä¸ªç²’å­
  const generateParticle = (index: number, style: string) => {
    const colors = ['#FFD700', '#FF6347', '#7CFC00', '#00BFFF', '#FF69B4', '#9370DB'];
    const randomColor = colors[Math.floor(Math.random() * colors.length)];

    // æ ¹æ®æ ·å¼ç”Ÿæˆä¸åŒçš„ç²’å­
    if (style === 'confetti') {
      const angle = Math.random() * 360;
      const distance = Math.random() * 100 + 50;
      const size = Math.random() * 10 + 5;
      const delay = Math.random() * 0.3;
      const duration = Math.random() * 1 + 1;
      const rotation = Math.random() * 720 - 360;

      return (
        <motion.div
          key={`confetti-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size / 2,
            backgroundColor: randomColor,
            top: '50%',
            left: '50%',
            margin: `-${size / 4}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0,
            rotate: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 1, 0],
            rotate: rotation,
            scale: [1, 1.2, 0.8, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    } else if (style === 'fireworks') {
      const angle = (index / 30) * 360;
      const distance = Math.random() * 50 + 100;
      const size = Math.random() * 6 + 2;
      const delay = Math.random() * 0.2;
      const duration = Math.random() * 0.8 + 0.6;

      return (
        <motion.div
          key={`firework-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            borderRadius: '50%',
            backgroundColor: randomColor,
            boxShadow: `0 0 ${size * 2}px ${randomColor}`,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0,
            scale: 0.5
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0],
            scale: [0.5, 1.5, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    } else if (style === 'stars') {
      const angle = Math.random() * 360;
      const distance = Math.random() * 80 + 40;
      const size = Math.random() * 15 + 10;
      const delay = Math.random() * 0.5;
      const duration = Math.random() * 1 + 1;

      return (
        <motion.div
          key={`star-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            clipPath: 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
            backgroundColor: randomColor,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0,
            rotate: 0,
            scale: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0],
            rotate: 360,
            scale: [0, 1, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    } else {
      // é»˜è®¤æ ·å¼
      const angle = Math.random() * 360;
      const distance = Math.random() * 60 + 30;
      const size = Math.random() * 8 + 4;
      const delay = Math.random() * 0.3;
      const duration = Math.random() * 0.7 + 0.5;

      return (
        <motion.div
          key={`default-${index}`}
          style={{
            position: 'absolute',
            width: size,
            height: size,
            borderRadius: '50%',
            backgroundColor: randomColor,
            top: '50%',
            left: '50%',
            margin: `-${size / 2}px 0 0 -${size / 2}px`,
            zIndex: 10
          }}
          initial={{
            x: 0,
            y: 0,
            opacity: 0
          }}
          animate={{
            x: Math.cos(angle * Math.PI / 180) * distance,
            y: Math.sin(angle * Math.PI / 180) * distance,
            opacity: [0, 1, 0]
          }}
          transition={{
            duration: duration,
            delay: delay,
            ease: 'easeOut'
          }}
        />
      );
    }
  };

  // å¤„ç†åŠ¨ç”»å®Œæˆ
  const handleAnimationComplete = () => {
    setIsAnimating(false);
    if (onAnimationComplete) {
      onAnimationComplete();
    }
  };

  return (
    <AnimatePresence>
      {isAnimating && (
        <motion.div
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            zIndex: 1000,
            pointerEvents: 'none'
          }}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.3 }}
        >
          {/* ç²’å­æ•ˆæœ */}
          {particles}

          {/* ä¸­å¿ƒæ–‡æœ¬ */}
          <motion.div
            style={{
              backgroundColor: 'rgba(0, 0, 0, 0.7)',
              color: '#fff',
              padding: '20px 40px',
              borderRadius: '10px',
              textAlign: 'center',
              zIndex: 20
            }}
            initial={{ scale: 0, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0, opacity: 0 }}
            transition={{ duration: 0.5, delay: 0.2 }}
            onAnimationComplete={handleAnimationComplete}
          >
            <motion.h2
              initial={{ y: -20, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ duration: 0.3, delay: 0.3 }}
            >
              ä»»åŠ¡å®Œæˆï¼
            </motion.h2>
            <motion.p
              initial={{ y: 20, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ duration: 0.3, delay: 0.5 }}
            >
              {task.title}
            </motion.p>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default TaskCompletionAnimation;
</file>

<file path="src/components/common/Button.tsx">
// src/components/common/Button.tsx
import React from 'react';
import { useComponentLabels } from '@/hooks/useComponentLabels';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'jade' | 'gold';
  isLoading?: boolean;
  loadingText?: string;
}

/**
 * Button component with support for different styles including game-themed variants
 *
 * @param variant - 'primary' (default), 'secondary', 'jade' (game-themed green), 'gold' (premium)
 * @param isLoading - Whether to show loading state
 * @param loadingText - Text to display when loading (overrides default localized text)
 */
const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'primary',
  isLoading = false,
  loadingText,
  ...props
}) => {
  // Get localized labels
  const { labels } = useComponentLabels();
  // Use provided loadingText or fall back to localized label
  const finalLoadingText = loadingText || labels.button.loading;
  // Determine the appropriate CSS class based on variant
  let variantStyle = '';

  switch (variant) {
    case 'jade':
      variantStyle = 'jade-button';
      break;
    case 'gold':
      variantStyle = 'gold-button';
      break;
    case 'secondary':
      variantStyle = 'button-secondary';
      break;
    case 'primary':
    default:
      variantStyle = 'button-primary';
  }

  // Only add button-common class for non-game-themed buttons
  const baseStyle = !['jade', 'gold'].includes(variant) ? 'button-common' : '';

  return (
    <button
      className={`${baseStyle} ${variantStyle}`.trim()}
      disabled={isLoading || props.disabled}
      {...props}
    >
      {isLoading ? finalLoadingText : children}
    </button>
  );
};

export default Button;
</file>

<file path="src/components/common/DataLoader.tsx">
// src/components/common/DataLoader.tsx
import React, { ReactNode } from 'react';
import { motion } from 'framer-motion';
import LoadingSpinner from './LoadingSpinner';
import ErrorDisplay from './ErrorDisplay';
import { useComponentLabels } from '@/hooks/useComponentLabels';

interface DataLoaderProps<T> {
  isLoading: boolean;
  isError: boolean;
  error: Error | null;
  data: T | undefined | null;
  loadingText?: string;
  errorTitle?: string;
  onRetry?: () => void;
  emptyState?: ReactNode;
  children: (data: T) => ReactNode;
  loadingComponent?: ReactNode;
  errorComponent?: ReactNode;
}

/**
 * Generic data loading component
 * Handles loading, error, and empty data states with localized text support
 *
 * @param isLoading - Whether data is currently loading
 * @param isError - Whether an error occurred
 * @param error - Error object
 * @param data - Data to render
 * @param loadingText - Optional custom loading text (overrides localized text)
 * @param errorTitle - Optional custom error title (overrides localized text)
 * @param onRetry - Optional retry callback
 * @param emptyState - Optional custom empty state component
 * @param children - Function to render data
 * @param loadingComponent - Optional custom loading component
 * @param errorComponent - Optional custom error component
 */
function DataLoader<T>({
  isLoading,
  isError,
  error,
  data,
  loadingText,
  errorTitle,
  onRetry,
  emptyState,
  children,
  loadingComponent,
  errorComponent
}: DataLoaderProps<T>) {
  // Get localized labels
  const { labels } = useComponentLabels();

  // Loading state
  if (isLoading && !data) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="data-loader-container"
      >
        {loadingComponent || <LoadingSpinner variant="jade" text={loadingText} type="data" />}
      </motion.div>
    );
  }

  // Error state
  if (isError && !data) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="data-loader-container"
      >
        {errorComponent || (
          <ErrorDisplay
            error={error}
            title={errorTitle}
            onRetry={onRetry}
          />
        )}
      </motion.div>
    );
  }

  // Empty data state
  if (!data) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="data-loader-container"
      >
        {emptyState || (
          <div className="empty-state">
            <p>{labels.emptyState.noData}</p>
          </div>
        )}
      </motion.div>
    );
  }

  // Render data
  return <>{children(data)}</>;
}

export default DataLoader;
</file>

<file path="src/components/common/ErrorDisplay.tsx">
// src/components/common/ErrorDisplay.tsx
import React from 'react';
import type { ApiError } from '@/types';
import Button from './Button'; // Use our common Button
import { useComponentLabels } from '@/hooks/useComponentLabels';

interface ErrorDisplayProps {
  error: ApiError | Error | null;
  title?: string;
  messageTemplate?: string;
  onRetry?: () => void;
  retryButtonText?: string;
  errorType?: 'generic' | 'network' | 'server' | 'unknown';
}

/**
 * Error display component with localized text support
 *
 * @param error - The error object to display
 * @param title - Optional custom title (overrides localized title)
 * @param messageTemplate - Optional custom message template (overrides localized template)
 * @param onRetry - Optional retry callback function
 * @param retryButtonText - Optional custom retry button text (overrides localized text)
 * @param errorType - Type of error, used to select appropriate localized text if no custom text is provided
 */
const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  title,
  messageTemplate,
  onRetry,
  retryButtonText,
  errorType = 'generic',
}) => {
  const { labels } = useComponentLabels();

  // Use provided values or fall back to localized labels
  const displayTitle = title || labels.error.title;
  const displayMessageTemplate = messageTemplate || labels.error.details;
  const displayRetryButtonText = retryButtonText || labels.error.retry;
  if (!error) return null;

  const errorMessage = error.message || labels.error.unknownError;
  const finalMessage = displayMessageTemplate.replace('{message}', errorMessage);
  const errorCode = (error as ApiError)?.errorCode;
  const statusCode = (error as ApiError)?.statusCode;

  return (
    <div className="error-container" role="alert">
      <h3>{displayTitle}</h3>
      <p className="error-text">{finalMessage}</p>
      {errorCode && <p className="error-code-text">Error Code: {errorCode}</p>}
      {statusCode && <p className="error-code-text">Status Code: {statusCode}</p>}
      {onRetry && (
        <Button onClick={onRetry} variant="secondary" style={{ marginTop: '10px' }}>
          {displayRetryButtonText}
        </Button>
      )}
    </div>
  );
};
export default ErrorDisplay;
</file>

<file path="src/components/common/LoadingSpinner.tsx">
// src/components/common/LoadingSpinner.tsx
import React from 'react';
import { useComponentLabels } from '@/hooks/useComponentLabels';

interface LoadingSpinnerProps {
  text?: string;
  variant?: 'default' | 'jade';
  type?: 'generic' | 'data' | 'content' | 'saving' | 'processing';
}

/**
 * Loading spinner component with support for game-themed style
 *
 * @param text - Optional text to display below the spinner (overrides default localized text)
 * @param variant - 'default' or 'jade' (game-themed)
 * @param type - Type of loading operation, used to select appropriate localized text if no text is provided
 */
const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  text,
  variant = 'default',
  type = 'generic'
}) => {
  const { labels } = useComponentLabels();
  const spinnerClass = variant === 'jade' ? 'jade-spinner' : 'loading-spinner';

  // Use provided text or fall back to localized label based on type
  const displayText = text || labels.loading[type];

  return (
    <div className="loading-spinner-overlay">
      <div className={spinnerClass}></div>
      {displayText && <p className="loading-spinner-text">{displayText}</p>}
    </div>
  );
};

export default LoadingSpinner;
</file>

<file path="src/components/common/Modal.tsx">
// src/components/common/Modal.tsx
import React, { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { useComponentLabels } from '@/hooks/useComponentLabels';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
  closeOnOutsideClick?: boolean;
  closeOnEsc?: boolean;
  className?: string;
  overlayClassName?: string;
  contentClassName?: string;
  title?: string;
  ariaLabelledBy?: string;
  ariaDescribedBy?: string;
}

/**
 * Basic modal component
 * Provides reusable modal functionality with animation and customizable styles
 *
 * @param isOpen - Controls whether the modal is displayed
 * @param onClose - Callback function to close the modal
 * @param children - Modal content
 * @param closeOnOutsideClick - Whether to close the modal when clicking outside, defaults to true
 * @param closeOnEsc - Whether to close the modal when pressing ESC, defaults to true
 * @param className - Custom class name for the modal container
 * @param overlayClassName - Custom class name for the overlay
 * @param contentClassName - Custom class name for the content area
 * @param title - Optional title for accessibility
 * @param ariaLabelledBy - Optional ID of element that labels the modal
 * @param ariaDescribedBy - Optional ID of element that describes the modal
 */
const Modal: React.FC<ModalProps> = ({
  isOpen,
  onClose,
  children,
  closeOnOutsideClick = true,
  closeOnEsc = true,
  className = '',
  overlayClassName = '',
  contentClassName = '',
  title,
  ariaLabelledBy,
  ariaDescribedBy,
}) => {
  // Get localized labels
  const { labels } = useComponentLabels();
  const contentRef = useRef<HTMLDivElement>(null);

  // Handle ESC key to close
  useEffect(() => {
    const handleEscKey = (event: KeyboardEvent) => {
      if (closeOnEsc && event.key === 'Escape' && isOpen) {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscKey);
      // Prevent background scrolling
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscKey);
      // Restore background scrolling
      document.body.style.overflow = '';
    };
  }, [isOpen, onClose, closeOnEsc]);

  // Handle clicking outside to close
  const handleOverlayClick = (e: React.MouseEvent) => {
    if (closeOnOutsideClick && e.target === e.currentTarget) {
      onClose();
    }
  };

  // Animation variants
  const overlayVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { duration: 0.3 } },
    exit: { opacity: 0, transition: { duration: 0.2 } }
  };

  const contentVariants = {
    hidden: { opacity: 0, scale: 0.9, y: -20 },
    visible: {
      opacity: 1,
      scale: 1,
      y: 0,
      transition: {
        type: 'spring',
        damping: 25,
        stiffness: 300,
        delay: 0.1
      }
    },
    exit: {
      opacity: 0,
      scale: 0.95,
      y: 10,
      transition: {
        duration: 0.2
      }
    }
  };

  // Use Portal to render the modal to the body
  return createPortal(
    <AnimatePresence>
      {isOpen && (
        <motion.div
          className={`modal-overlay ${overlayClassName}`}
          variants={overlayVariants}
          initial="hidden"
          animate="visible"
          exit="exit"
          onClick={handleOverlayClick}
          role="dialog"
          aria-modal="true"
          aria-label={title || labels.modal.close}
          aria-labelledby={ariaLabelledBy}
          aria-describedby={ariaDescribedBy}
        >
          <motion.div
            ref={contentRef}
            className={`modal-content ${contentClassName}`}
            variants={contentVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
            onClick={(e) => e.stopPropagation()}
          >
            <div className={`modal-container ${className}`}>
              {children}
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>,
    document.body
  );
};

export default Modal;
</file>

<file path="src/components/common/ProgressBar.tsx">
// src/components/common/ProgressBar.tsx
import React from 'react';
import { motion } from 'framer-motion';

interface ProgressBarProps {
  progress: number;
  total?: number;
  showPercentage?: boolean;
  className?: string;
  height?: number;
  color?: string;
  backgroundColor?: string;
  radius?: number;
  animate?: boolean;
}

/**
 * è¿›åº¦æ¡ç»„ä»¶
 * æ˜¾ç¤ºä»»åŠ¡æˆ–å¥–åŠ±çš„å®Œæˆè¿›åº¦
 * 
 * @param progress å½“å‰è¿›åº¦å€¼
 * @param total æ€»è¿›åº¦å€¼ï¼Œé»˜è®¤ä¸º100
 * @param showPercentage æ˜¯å¦æ˜¾ç¤ºç™¾åˆ†æ¯”æ–‡æœ¬
 * @param className è‡ªå®šä¹‰CSSç±»å
 * @param height è¿›åº¦æ¡é«˜åº¦ï¼Œé»˜è®¤ä¸º10px
 * @param color è¿›åº¦æ¡é¢œè‰²ï¼Œé»˜è®¤ä¸ºä¸»é¢˜è‰²
 * @param backgroundColor è¿›åº¦æ¡èƒŒæ™¯è‰²ï¼Œé»˜è®¤ä¸ºåŠé€æ˜ç°è‰²
 * @param radius è¿›åº¦æ¡åœ†è§’åŠå¾„ï¼Œé»˜è®¤ä¸º4px
 * @param animate æ˜¯å¦å¯ç”¨åŠ¨ç”»æ•ˆæœï¼Œé»˜è®¤ä¸ºtrue
 */
const ProgressBar: React.FC<ProgressBarProps> = ({
  progress,
  total = 100,
  showPercentage = false,
  className = '',
  height = 10,
  color,
  backgroundColor,
  radius = 4,
  animate = true
}) => {
  // è®¡ç®—ç™¾åˆ†æ¯”
  const percentage = Math.min(Math.max(0, Math.round((progress / total) * 100)), 100);
  
  // åŠ¨ç”»å˜ä½“
  const variants = {
    initial: { width: '0%' },
    animate: { width: `${percentage}%` }
  };

  return (
    <div 
      className={`progress-bar-container ${className}`}
      style={{
        height: `${height}px`,
        backgroundColor: backgroundColor || 'rgba(0, 0, 0, 0.1)',
        borderRadius: `${radius}px`,
        overflow: 'hidden',
        position: 'relative'
      }}
    >
      <motion.div
        className="progress-bar-fill"
        style={{
          height: '100%',
          backgroundColor: color || 'var(--primary-color, #4caf50)',
          borderRadius: `${radius}px`
        }}
        initial={animate ? "initial" : false}
        animate={animate ? "animate" : false}
        variants={variants}
        transition={{ duration: 0.5, ease: "easeOut" }}
      />
      
      {showPercentage && (
        <div 
          className="progress-bar-text"
          style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: percentage > 50 ? '#fff' : '#000',
            fontSize: `${height < 20 ? 10 : 14}px`,
            fontWeight: 'bold',
            textShadow: percentage > 50 ? '0 0 2px rgba(0,0,0,0.5)' : 'none'
          }}
        >
          {percentage}%
        </div>
      )}
    </div>
  );
};

export default ProgressBar;
</file>

<file path="src/components/common/SyncStatusIndicator.tsx">
// src/components/common/SyncStatusIndicator.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { SyncStatus, getCurrentSyncStatus, getPendingSyncCount, manualSync } from '@/services/dataSyncService';

interface SyncStatusIndicatorProps {
  showCount?: boolean;
  showLabel?: boolean;
  variant?: 'minimal' | 'standard' | 'detailed';
}

/**
 * æ•°æ®åŒæ­¥çŠ¶æ€æŒ‡ç¤ºå™¨ç»„ä»¶
 * æ˜¾ç¤ºå½“å‰åŒæ­¥çŠ¶æ€å’Œå¾…åŒæ­¥é¡¹ç›®æ•°é‡
 *
 * @param showCount - æ˜¯å¦æ˜¾ç¤ºå¾…åŒæ­¥é¡¹ç›®æ•°é‡
 * @param showLabel - æ˜¯å¦æ˜¾ç¤ºçŠ¶æ€æ ‡ç­¾
 * @param variant - æ˜¾ç¤ºå˜ä½“
 */
const SyncStatusIndicator: React.FC<SyncStatusIndicatorProps> = ({
  showCount = true,
  showLabel = true,
  variant = 'standard'
}) => {
  const [syncStatus, setSyncStatus] = useState<SyncStatus>(SyncStatus.IDLE);
  const [pendingCount, setPendingCount] = useState<number>(0);
  const [isVisible, setIsVisible] = useState<boolean>(false);

  // æ›´æ–°åŒæ­¥çŠ¶æ€å’Œå¾…åŒæ­¥é¡¹ç›®æ•°é‡
  useEffect(() => {
    const updateStatus = async () => {
      try {
        const status = getCurrentSyncStatus();
        let count = 0;

        try {
          count = await getPendingSyncCount();
        } catch (countErr) {
          console.error('Failed to get pending sync count:', countErr);
        }

        setSyncStatus(status);
        setPendingCount(count);

        // å¦‚æœæœ‰å¾…åŒæ­¥é¡¹ç›®æˆ–æ­£åœ¨åŒæ­¥ï¼Œåˆ™æ˜¾ç¤ºæŒ‡ç¤ºå™¨
        setIsVisible(count > 0 || status === SyncStatus.SYNCING);
      } catch (err) {
        console.error('Failed to update sync status:', err);
      }
    };

    // åˆå§‹æ›´æ–°
    updateStatus();

    // å®šæœŸæ›´æ–°ï¼Œæ›´é¢‘ç¹åœ°æ£€æŸ¥
    const interval = setInterval(updateStatus, 1000);

    // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨ï¼Œåœ¨ç½‘ç»œçŠ¶æ€å˜åŒ–æ—¶æ›´æ–°
    window.addEventListener('online', updateStatus);
    window.addEventListener('offline', updateStatus);

    // æ·»åŠ è‡ªå®šä¹‰äº‹ä»¶ç›‘å¬å™¨ï¼Œåœ¨æ·»åŠ åŒæ­¥é¡¹ç›®æ—¶æ›´æ–°
    const handleSyncItemAdded = () => updateStatus();
    window.addEventListener('syncItemAdded', handleSyncItemAdded);

    // æ·»åŠ è‡ªå®šä¹‰äº‹ä»¶ç›‘å¬å™¨ï¼Œåœ¨åŒæ­¥çŠ¶æ€å˜åŒ–æ—¶æ›´æ–°
    const handleSyncStatusChanged = (event: Event) => {
      const customEvent = event as CustomEvent<SyncStatus>;
      setSyncStatus(customEvent.detail);
      updateStatus();
    };
    window.addEventListener('syncStatusChanged', handleSyncStatusChanged);

    return () => {
      clearInterval(interval);
      window.removeEventListener('online', updateStatus);
      window.removeEventListener('offline', updateStatus);
      window.removeEventListener('syncItemAdded', handleSyncItemAdded);
      window.removeEventListener('syncStatusChanged', handleSyncStatusChanged);
    };
  }, []);

  // æ‰‹åŠ¨è§¦å‘åŒæ­¥
  const handleManualSync = async () => {
    try {
      await manualSync();
    } catch (err) {
      console.error('Manual sync failed:', err);
    }
  };

  // è·å–çŠ¶æ€å›¾æ ‡
  const getStatusIcon = () => {
    switch (syncStatus) {
      case SyncStatus.SYNCING:
        return (
          <motion.div
            animate={{ rotate: 360 }}
            transition={{ repeat: Infinity, duration: 1, ease: 'linear' }}
            className="sync-icon syncing"
          >
            â†»
          </motion.div>
        );
      case SyncStatus.SUCCESS:
        return <div className="sync-icon success">âœ“</div>;
      case SyncStatus.ERROR:
        return <div className="sync-icon error">âœ—</div>;
      default:
        return <div className="sync-icon idle">âŸ³</div>;
    }
  };

  // è·å–çŠ¶æ€æ ‡ç­¾
  const getStatusLabel = () => {
    switch (syncStatus) {
      case SyncStatus.SYNCING:
        return 'åŒæ­¥ä¸­...';
      case SyncStatus.SUCCESS:
        return 'åŒæ­¥æˆåŠŸ';
      case SyncStatus.ERROR:
        return 'åŒæ­¥å¤±è´¥';
      default:
        return 'å¾…åŒæ­¥';
    }
  };

  // å§‹ç»ˆæ˜¾ç¤ºåŒæ­¥çŠ¶æ€æŒ‡ç¤ºå™¨ï¼Œé™¤éæ˜¯æœ€å°å˜ä½“ä¸”æ²¡æœ‰å¾…åŒæ­¥é¡¹ç›®
  if (!isVisible && variant === 'minimal') {
    return null;
  }

  // æœ€å°å˜ä½“
  if (variant === 'minimal') {
    return (
      <motion.div
        className="sync-status-indicator minimal"
        initial={{ opacity: 0, scale: 0.8 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.8 }}
        onClick={handleManualSync}
      >
        {getStatusIcon()}
      </motion.div>
    );
  }

  // è·å–çŠ¶æ€ç±»å
  const getStatusClassName = () => {
    switch (syncStatus) {
      case SyncStatus.SYNCING:
        return 'syncing';
      case SyncStatus.SUCCESS:
        return 'success';
      case SyncStatus.ERROR:
        return 'error';
      default:
        return 'idle';
    }
  };

  // æ ‡å‡†å˜ä½“
  return (
    <AnimatePresence>
      <motion.div
        className={`sync-status-indicator ${variant} ${getStatusClassName()}`}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: 20 }}
        onClick={handleManualSync}
      >
        {getStatusIcon()}

        {showLabel && (
          <span className="sync-label">{getStatusLabel()}</span>
        )}

        {showCount && pendingCount > 0 && (
          <span className="sync-count">{pendingCount}</span>
        )}
      </motion.div>
    </AnimatePresence>
  );
};

export default SyncStatusIndicator;
</file>

<file path="src/components/decoration/ChineseDecoration.tsx">
// src/components/decoration/ChineseDecoration.tsx
import React from 'react';

/**
 * ä¸­å›½é£è£…é¥°ç»„ä»¶
 * æ·»åŠ å„ç§ä¸­å›½é£è£…é¥°å…ƒç´ åˆ°åº”ç”¨ç¨‹åºä¸­
 */
const ChineseDecoration: React.FC = () => {
  return (
    <>
      {/* äº‘æœµè£…é¥° */}
      <div className="chinese-cloud top-right" />
      <div className="chinese-cloud top-left" />
      
      {/* ä¸­å›½ç»“è£…é¥° */}
      <div className="chinese-knot top-right" />
      
      {/* è·èŠ±è£…é¥° */}
      <div className="lotus-flower bottom-left" />
      
      {/* å±±æ°´ç”»è£…é¥° */}
      <div className="mountain-landscape bottom" />
    </>
  );
};

export default ChineseDecoration;
</file>

<file path="src/components/decoration/InkAnimation.tsx">
// src/components/decoration/InkAnimation.tsx
import React, { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

interface InkAnimationProps {
  text: string;
  duration?: number;
  fontSize?: number;
  color?: string;
  onComplete?: () => void;
}

/**
 * ä¸­å›½é£æ°´å¢¨åŠ¨ç”»ç»„ä»¶
 * ç”¨äºæ–‡å­—çš„æ°´å¢¨æ¸²æŸ“æ•ˆæœ
 * 
 * @param text - è¦æ˜¾ç¤ºçš„æ–‡å­—
 * @param duration - åŠ¨ç”»æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
 * @param fontSize - å­—ä½“å¤§å°
 * @param color - æ–‡å­—é¢œè‰²
 * @param onComplete - åŠ¨ç”»å®Œæˆå›è°ƒ
 */
const InkAnimation: React.FC<InkAnimationProps> = ({
  text,
  duration = 2000,
  fontSize = 36,
  color = 'var(--royal-jade)',
  onComplete
}) => {
  const [isVisible, setIsVisible] = useState(true);
  const characters = text.split('');
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsVisible(false);
      if (onComplete) {
        onComplete();
      }
    }, duration + characters.length * 200);
    
    return () => clearTimeout(timer);
  }, [duration, characters.length, onComplete]);
  
  // å­—ç¬¦åŠ¨ç”»å˜ä½“
  const characterVariants = {
    hidden: { 
      opacity: 0,
      scale: 0.5,
      filter: 'blur(10px)'
    },
    visible: (i: number) => ({
      opacity: 1,
      scale: 1,
      filter: 'blur(0px)',
      transition: {
        delay: i * 0.1,
        duration: 0.5,
        ease: [0.17, 0.67, 0.83, 0.67] // æ¨¡æ‹Ÿæ°´å¢¨æ‰©æ•£æ•ˆæœ
      }
    }),
    exit: (i: number) => ({
      opacity: 0,
      scale: 1.2,
      filter: 'blur(5px)',
      transition: {
        delay: i * 0.05,
        duration: 0.3,
        ease: 'easeOut'
      }
    })
  };
  
  // å¢¨æ»´åŠ¨ç”»å˜ä½“
  const inkDropVariants = {
    hidden: { 
      opacity: 0,
      scale: 0
    },
    visible: (i: number) => ({
      opacity: [0, 0.7, 0.3],
      scale: [0, 1.5, 1],
      transition: {
        delay: i * 0.1,
        duration: 0.8,
        ease: 'easeOut'
      }
    }),
    exit: (i: number) => ({
      opacity: 0,
      scale: 1.5,
      transition: {
        delay: i * 0.05,
        duration: 0.3,
        ease: 'easeOut'
      }
    })
  };
  
  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          style={{
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            position: 'relative',
            padding: '20px'
          }}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          {characters.map((char, index) => (
            <motion.div
              key={`${char}-${index}`}
              style={{
                position: 'relative',
                margin: '0 2px'
              }}
              custom={index}
              variants={characterVariants}
              initial="hidden"
              animate="visible"
              exit="exit"
            >
              {/* å¢¨æ»´æ•ˆæœ */}
              <motion.div
                style={{
                  position: 'absolute',
                  top: '50%',
                  left: '50%',
                  width: `${fontSize * 1.5}px`,
                  height: `${fontSize * 1.5}px`,
                  borderRadius: '50%',
                  backgroundColor: color,
                  transform: 'translate(-50%, -50%)',
                  zIndex: -1,
                  opacity: 0.2
                }}
                custom={index}
                variants={inkDropVariants}
                initial="hidden"
                animate="visible"
                exit="exit"
              />
              
              {/* æ–‡å­— */}
              <motion.span
                style={{
                  fontFamily: 'var(--font-title)',
                  fontSize: `${fontSize}px`,
                  color: color,
                  position: 'relative',
                  zIndex: 1
                }}
              >
                {char}
              </motion.span>
            </motion.div>
          ))}
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default InkAnimation;
</file>

<file path="src/components/decoration/LanternDecoration.tsx">
// src/components/decoration/LanternDecoration.tsx
import React from 'react';
import { motion } from 'framer-motion';

interface LanternDecorationProps {
  count?: number;
  character?: string;
  position?: 'top' | 'left' | 'right' | 'bottom';
}

/**
 * ä¸­å›½é£ç¯ç¬¼è£…é¥°ç»„ä»¶
 * ç”¨äºç‰¹æ®Šåœºåˆçš„è£…é¥°ï¼Œå¦‚èŠ‚æ—¥ã€æˆå°±è§£é”ç­‰
 * 
 * @param count - ç¯ç¬¼æ•°é‡
 * @param character - ç¯ç¬¼ä¸Šçš„æ±‰å­—
 * @param position - ç¯ç¬¼ä½ç½®
 */
const LanternDecoration: React.FC<LanternDecorationProps> = ({
  count = 2,
  character = 'ç¦',
  position = 'top'
}) => {
  // æ ¹æ®ä½ç½®ç¡®å®šç¯ç¬¼çš„æ ·å¼
  const getPositionStyle = (index: number) => {
    const baseStyle = {
      position: 'fixed' as const,
      zIndex: 10,
      pointerEvents: 'none' as const
    };
    
    const totalWidth = count * 60; // æ¯ä¸ªç¯ç¬¼å®½åº¦çº¦60px
    const startPosition = `calc(50% - ${totalWidth / 2}px)`;
    
    switch (position) {
      case 'top':
        return {
          ...baseStyle,
          top: '10px',
          left: `calc(${startPosition} + ${index * 60}px)`
        };
      case 'bottom':
        return {
          ...baseStyle,
          bottom: '80px', // ä¸ºåº•éƒ¨å¯¼èˆªç•™å‡ºç©ºé—´
          left: `calc(${startPosition} + ${index * 60}px)`
        };
      case 'left':
        return {
          ...baseStyle,
          left: '10px',
          top: `calc(50% - ${totalWidth / 2}px + ${index * 60}px)`
        };
      case 'right':
        return {
          ...baseStyle,
          right: '10px',
          top: `calc(50% - ${totalWidth / 2}px + ${index * 60}px)`
        };
      default:
        return baseStyle;
    }
  };
  
  // ç¯ç¬¼åŠ¨ç”»å˜ä½“
  const lanternVariants = {
    initial: { y: -10, opacity: 0 },
    animate: (i: number) => ({
      y: 0,
      opacity: 1,
      transition: {
        delay: i * 0.2,
        duration: 0.5,
        ease: 'easeOut'
      }
    }),
    swing: (i: number) => ({
      rotate: [0, 3, 0, -3, 0],
      transition: {
        delay: i * 0.1,
        duration: 2,
        ease: 'easeInOut',
        repeat: Infinity,
        repeatType: 'reverse'
      }
    })
  };
  
  return (
    <>
      {Array.from({ length: count }).map((_, index) => (
        <motion.div
          key={index}
          style={{
            ...getPositionStyle(index),
            width: '50px',
            height: '75px',
            backgroundImage: "url('/assets/chinese-lantern.svg')",
            backgroundSize: 'contain',
            backgroundRepeat: 'no-repeat',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center'
          }}
          custom={index}
          variants={lanternVariants}
          initial="initial"
          animate={['animate', 'swing']}
        >
          <motion.span
            style={{
              fontFamily: 'var(--font-title)',
              color: '#FFD700',
              fontSize: '18px',
              marginTop: '-5px'
            }}
            animate={{
              scale: [1, 1.1, 1],
              transition: {
                duration: 2,
                ease: 'easeInOut',
                repeat: Infinity,
                repeatType: 'reverse'
              }
            }}
          >
            {character}
          </motion.span>
        </motion.div>
      ))}
    </>
  );
};

export default LanternDecoration;
</file>

<file path="src/components/game/AbilityCard.tsx">
// src/components/game/AbilityCard.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { PandaAbilityRecord, AbilityType, getAbilityKeyFromName, getLocalizedAbilityName, getLocalizedAbilityDescription } from '@/services/pandaAbilityService';
import { RewardRarity } from '@/services/rewardService';
import { AbilityCardLabels } from '@/types';

interface AbilityCardProps {
  ability: PandaAbilityRecord;
  isUnlocked: boolean;
  onActivate?: () => void;
  className?: string;
  labels?: AbilityCardLabels;
}

/**
 * Panda ability card component
 * Displays detailed information about a panda ability
 *
 * @param ability - Ability data
 * @param isUnlocked - Whether the ability is unlocked
 * @param onActivate - Callback function to activate the ability
 * @param className - Custom class name
 * @param labels - Localized labels for the component
 */
const AbilityCard: React.FC<AbilityCardProps> = ({
  ability,
  isUnlocked,
  onActivate,
  className = '',
  labels
}) => {
  const [localizedName, setLocalizedName] = useState<string>(ability.name);
  const [localizedDescription, setLocalizedDescription] = useState<string>(ability.description);

  // Load localized name and description
  useEffect(() => {
    const abilityKey = getAbilityKeyFromName(ability.name);
    if (abilityKey) {
      // Load localized name
      getLocalizedAbilityName(abilityKey, ability.name)
        .then(name => setLocalizedName(name))
        .catch(err => console.error('Error loading localized ability name:', err));

      // Load localized description
      getLocalizedAbilityDescription(abilityKey, ability.description)
        .then(desc => setLocalizedDescription(desc))
        .catch(err => console.error('Error loading localized ability description:', err));
    }
  }, [ability.name, ability.description]);
  // Get ability type name with localization
  const getAbilityTypeName = (type: AbilityType): string => {
    switch (type) {
      case AbilityType.PASSIVE:
        return labels?.typePassive || 'Passive';
      case AbilityType.ACTIVE:
        return labels?.typeActive || 'Active';
      case AbilityType.ULTIMATE:
        return labels?.typeUltimate || 'Ultimate';
      default:
        return labels?.typeUnknown || 'Unknown';
    }
  };

  // Get rarity name with localization
  const getRarityName = (rarity: RewardRarity): string => {
    switch (rarity) {
      case RewardRarity.COMMON:
        return labels?.rarityCommon || 'Common';
      case RewardRarity.UNCOMMON:
        return labels?.rarityUncommon || 'Uncommon';
      case RewardRarity.RARE:
        return labels?.rarityRare || 'Rare';
      case RewardRarity.EPIC:
        return labels?.rarityEpic || 'Epic';
      case RewardRarity.LEGENDARY:
        return labels?.rarityLegendary || 'Legendary';
      default:
        return labels?.rarityCommon || 'Common';
    }
  };

  // Get rarity color
  const getRarityColor = (rarity: RewardRarity): string => {
    switch (rarity) {
      case RewardRarity.COMMON:
        return 'var(--text-primary)';
      case RewardRarity.UNCOMMON:
        return 'var(--jade-green)';
      case RewardRarity.RARE:
        return 'var(--imperial-blue)';
      case RewardRarity.EPIC:
        return 'var(--imperial-purple)';
      case RewardRarity.LEGENDARY:
        return 'var(--imperial-gold)';
      default:
        return 'var(--text-primary)';
    }
  };

  // Check if ability is available (unlocked and not on cooldown)
  const isAvailable = (): boolean => {
    if (!isUnlocked) {
      return false;
    }

    // Passive abilities are always available
    if (ability.type === AbilityType.PASSIVE) {
      return true;
    }

    // Check cooldown time
    if (ability.lastUsedAt && ability.cooldownMinutes) {
      const now = new Date();
      const cooldownEndTime = new Date(ability.lastUsedAt);
      cooldownEndTime.setMinutes(cooldownEndTime.getMinutes() + ability.cooldownMinutes);

      return now >= cooldownEndTime;
    }

    return true;
  };

  // Get remaining cooldown time with localization
  const getCooldownRemaining = (): string => {
    if (!ability.lastUsedAt || !ability.cooldownMinutes) {
      return '';
    }

    const now = new Date();
    const cooldownEndTime = new Date(ability.lastUsedAt);
    cooldownEndTime.setMinutes(cooldownEndTime.getMinutes() + ability.cooldownMinutes);

    if (now >= cooldownEndTime) {
      return '';
    }

    const remainingMs = cooldownEndTime.getTime() - now.getTime();
    const remainingMinutes = Math.ceil(remainingMs / (1000 * 60));

    const minutesUnit = labels?.minutesUnit || 'min';
    const hourUnit = 'h'; // We could add this to labels if needed

    if (remainingMinutes < 60) {
      return `${remainingMinutes} ${minutesUnit}`;
    } else {
      const hours = Math.floor(remainingMinutes / 60);
      const minutes = remainingMinutes % 60;
      return `${hours}${hourUnit}${minutes > 0 ? ` ${minutes}${minutesUnit}` : ''}`;
    }
  };

  return (
    <motion.div
      className={`ability-card ${className} ${isUnlocked ? 'unlocked' : 'locked'} ${ability.type.toLowerCase()}-ability`}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
    >
      <div className="ability-card-header">
        <div className="ability-icon">
          <img
            src={ability.iconPath}
            alt={ability.name}
            onError={(e) => {
              const target = e.target as HTMLImageElement;
              target.onerror = null;
              target.src = '/assets/abilities/default-ability.svg';
            }}
          />
        </div>
        <div className="ability-info">
          <h3 className="ability-name" style={{ color: getRarityColor(ability.rarity) }}>
            {localizedName}
          </h3>
          <div className="ability-meta">
            <span className="ability-type">{getAbilityTypeName(ability.type)}</span>
            <span className="ability-rarity">{getRarityName(ability.rarity)}</span>
          </div>
        </div>
      </div>

      <div className="ability-card-body">
        <p className="ability-description">{localizedDescription}</p>

        {!isUnlocked && (
          <div className="ability-unlock-info">
            <span className="ability-lock-icon">ğŸ”’</span>
            <span>{labels?.requiredLevelLabel || 'Required Level'} {ability.requiredLevel}</span>
          </div>
        )}

        {isUnlocked && ability.type !== AbilityType.PASSIVE && (
          <div className="ability-cooldown">
            {getCooldownRemaining() ? (
              <span className="cooldown-remaining">{labels?.cooldownRemainingLabel || 'Cooling down'}: {getCooldownRemaining()}</span>
            ) : (
              <span className="cooldown-info">{labels?.cooldownLabel || 'Cooldown'}: {ability.cooldownMinutes} {labels?.minutesUnit || 'min'}</span>
            )}
          </div>
        )}
      </div>

      {isUnlocked && ability.type !== AbilityType.PASSIVE && (
        <div className="ability-card-footer">
          <button
            className={`activate-button ${isAvailable() ? 'available' : 'unavailable'}`}
            onClick={onActivate}
            disabled={!isAvailable()}
          >
            {ability.isActive
              ? (labels?.alreadyActivatedText || 'Already Activated')
              : (labels?.activateButtonText || 'Activate Ability')}
          </button>
        </div>
      )}
    </motion.div>
  );
};

export default AbilityCard;
</file>

<file path="src/components/game/AbilityUnlockNotification.tsx">
// src/components/game/AbilityUnlockNotification.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { PandaAbilityRecord } from '@/services/pandaAbilityService';
import ScrollDialog from './ScrollDialog';
import Button from '@/components/common/Button';
import { AbilityUnlockNotificationLabels } from '@/types';

interface AbilityUnlockNotificationProps {
  newlyUnlockedAbilities: PandaAbilityRecord[];
  onClose: () => void;
  labels?: AbilityUnlockNotificationLabels;
}

/**
 * Panda ability unlock notification component
 * Displays a notification when new abilities are unlocked
 *
 * @param newlyUnlockedAbilities - List of newly unlocked abilities
 * @param onClose - Callback function to close the notification
 * @param labels - Localized labels for the component
 */
const AbilityUnlockNotification: React.FC<AbilityUnlockNotificationProps> = ({
  newlyUnlockedAbilities,
  onClose,
  labels
}) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [showAll, setShowAll] = useState(false);

  // Currently displayed ability
  const currentAbility = newlyUnlockedAbilities[currentIndex];

  // Whether there are abilities to display
  const hasAbilities = newlyUnlockedAbilities.length > 0;

  // Whether there is a next ability
  const hasNextAbility = currentIndex < newlyUnlockedAbilities.length - 1;

  // Show next ability
  const showNextAbility = () => {
    if (hasNextAbility) {
      setCurrentIndex(prev => prev + 1);
    } else {
      setShowAll(true);
    }
  };

  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0, scale: 0.9 },
    visible: {
      opacity: 1,
      scale: 1,
      transition: {
        duration: 0.5,
        delayChildren: 0.3,
        staggerChildren: 0.2
      }
    },
    exit: {
      opacity: 0,
      scale: 0.9,
      transition: { duration: 0.3 }
    }
  };

  const itemVariants = {
    hidden: { y: 20, opacity: 0 },
    visible: {
      y: 0,
      opacity: 1,
      transition: { duration: 0.5 }
    }
  };

  // Render single ability unlock notification
  const renderSingleAbility = () => {
    if (!currentAbility) return null;

    return (
      <motion.div
        className="ability-unlock-single"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <motion.div className="ability-unlock-icon" variants={itemVariants}>
          <img
            src={currentAbility.iconPath}
            alt={currentAbility.name}
            onError={(e) => {
              const target = e.target as HTMLImageElement;
              target.onerror = null;
              target.src = '/assets/abilities/default-ability.svg';
            }}
          />
        </motion.div>

        <motion.h3 className="ability-unlock-title" variants={itemVariants}>
          {labels?.newAbilityTitle || 'New Ability Unlocked!'}
        </motion.h3>

        <motion.h4 className="ability-unlock-name" variants={itemVariants}>
          {currentAbility.name}
        </motion.h4>

        <motion.p className="ability-unlock-description" variants={itemVariants}>
          {currentAbility.description}
        </motion.p>

        <motion.div className="ability-unlock-actions" variants={itemVariants}>
          {hasNextAbility ? (
            <Button variant="jade" onClick={showNextAbility}>
              {labels?.nextButtonText || 'Next Ability'}
            </Button>
          ) : (
            <Button variant="jade" onClick={() => setShowAll(true)}>
              {labels?.viewAllButtonText || 'View All Abilities'}
            </Button>
          )}
        </motion.div>
      </motion.div>
    );
  };

  // Render list of all unlocked abilities
  const renderAllAbilities = () => {
    return (
      <motion.div
        className="ability-unlock-all"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <motion.h3 className="ability-unlock-title" variants={itemVariants}>
          {labels?.allUnlockedTitle || 'Newly Unlocked Abilities'}
        </motion.h3>

        <motion.div className="ability-unlock-list" variants={itemVariants}>
          {newlyUnlockedAbilities.map((ability, index) => (
            <div key={index} className="ability-unlock-item">
              <div className="ability-unlock-item-icon">
                <img
                  src={ability.iconPath}
                  alt={ability.name}
                  onError={(e) => {
                    const target = e.target as HTMLImageElement;
                    target.onerror = null;
                    target.src = '/assets/abilities/default-ability.svg';
                  }}
                />
              </div>
              <div className="ability-unlock-item-info">
                <h4 className="ability-unlock-item-name">{ability.name}</h4>
                <p className="ability-unlock-item-description">{ability.description}</p>
              </div>
            </div>
          ))}
        </motion.div>

        <motion.div className="ability-unlock-actions" variants={itemVariants}>
          <Button variant="gold" onClick={onClose}>
            {labels?.closeButtonText || 'Close'}
          </Button>
        </motion.div>
      </motion.div>
    );
  };

  // If no abilities, don't show notification
  if (!hasAbilities) {
    return null;
  }

  return (
    <ScrollDialog
      isOpen={true}
      onClose={onClose}
      title={labels?.title || 'Ability Unlocked'}
      closeOnOutsideClick={false}
      closeOnEsc={false}
      showCloseButton={showAll}
      footer={null}
    >
      <div className="ability-unlock-content">
        <AnimatePresence mode="wait">
          {!showAll ? (
            <motion.div key="single" className="ability-unlock-view">
              {renderSingleAbility()}
            </motion.div>
          ) : (
            <motion.div key="all" className="ability-unlock-view">
              {renderAllAbilities()}
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </ScrollDialog>
  );
};

export default AbilityUnlockNotification;
</file>

<file path="src/components/game/ChallengeCard.tsx">
// src/components/game/ChallengeCard.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { ChallengeRecord, ChallengeStatus, ChallengeDifficulty } from '@/services/challengeService';
import ProgressBar from '@/components/common/ProgressBar';
import { formatTime } from '@/utils/dateUtils';

interface ChallengeCardProps {
  challenge: ChallengeRecord;
  onClick?: (challenge: ChallengeRecord) => void;
  onComplete?: (challengeId: number) => void;
  labels?: {
    statusActive?: string;
    statusCompleted?: string;
    statusExpired?: string;
    statusUpcoming?: string;
    difficultyEasy?: string;
    difficultyMedium?: string;
    difficultyHard?: string;
    difficultyExpert?: string;
    startLabel?: string;
    endLabel?: string;
    completedOnLabel?: string;
    completeButtonText?: string;
    inProgressText?: string;
  };
}

/**
 * æŒ‘æˆ˜å¡ç‰‡ç»„ä»¶
 * æ˜¾ç¤ºæŒ‘æˆ˜çš„åŸºæœ¬ä¿¡æ¯å’Œè¿›åº¦
 */
const ChallengeCard: React.FC<ChallengeCardProps> = ({ challenge, onClick, onComplete, labels }) => {
  // è·å–æŒ‘æˆ˜çŠ¶æ€å¯¹åº”çš„æ ·å¼ç±»
  const getStatusClass = () => {
    switch (challenge.status) {
      case ChallengeStatus.ACTIVE:
        return 'challenge-active';
      case ChallengeStatus.COMPLETED:
        return 'challenge-completed';
      case ChallengeStatus.EXPIRED:
        return 'challenge-expired';
      case ChallengeStatus.UPCOMING:
        return 'challenge-upcoming';
      default:
        return '';
    }
  };

  // è·å–æŒ‘æˆ˜éš¾åº¦å¯¹åº”çš„æ ·å¼ç±»
  const getDifficultyClass = () => {
    switch (challenge.difficulty) {
      case ChallengeDifficulty.EASY:
        return 'difficulty-easy';
      case ChallengeDifficulty.MEDIUM:
        return 'difficulty-medium';
      case ChallengeDifficulty.HARD:
        return 'difficulty-hard';
      case ChallengeDifficulty.EXPERT:
        return 'difficulty-expert';
      default:
        return '';
    }
  };

  // è·å–æŒ‘æˆ˜éš¾åº¦å¯¹åº”çš„æ–‡æœ¬
  const getDifficultyText = () => {
    switch (challenge.difficulty) {
      case ChallengeDifficulty.EASY:
        return labels?.difficultyEasy || 'Easy';
      case ChallengeDifficulty.MEDIUM:
        return labels?.difficultyMedium || 'Medium';
      case ChallengeDifficulty.HARD:
        return labels?.difficultyHard || 'Hard';
      case ChallengeDifficulty.EXPERT:
        return labels?.difficultyExpert || 'Expert';
      default:
        return '';
    }
  };

  // è·å–æŒ‘æˆ˜çŠ¶æ€å¯¹åº”çš„æ–‡æœ¬
  const getStatusText = () => {
    switch (challenge.status) {
      case ChallengeStatus.ACTIVE:
        return labels?.statusActive || 'Active';
      case ChallengeStatus.COMPLETED:
        return labels?.statusCompleted || 'Completed';
      case ChallengeStatus.EXPIRED:
        return labels?.statusExpired || 'Expired';
      case ChallengeStatus.UPCOMING:
        return labels?.statusUpcoming || 'Upcoming';
      default:
        return '';
    }
  };

  // å¤„ç†ç‚¹å‡»äº‹ä»¶
  const handleClick = () => {
    if (onClick) {
      onClick(challenge);
    }
  };

  // å¤„ç†å®ŒæˆæŒ‘æˆ˜äº‹ä»¶
  const handleComplete = (e: React.MouseEvent) => {
    e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
    if (onComplete && challenge.status === ChallengeStatus.ACTIVE) {
      onComplete(challenge.id!);
    }
  };

  return (
    <motion.div
      className={`challenge-card ${getStatusClass()} ${getDifficultyClass()}`}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={handleClick}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      transition={{ duration: 0.3 }}
    >
      <div className="challenge-card-header">
        <div className="challenge-icon">
          <img src={challenge.iconPath} alt={challenge.title} />
        </div>
        <div className="challenge-title-section">
          <h3 className="challenge-title">{challenge.title}</h3>
          <div className="challenge-meta">
            <span className={`challenge-difficulty ${getDifficultyClass()}`}>
              {getDifficultyText()}
            </span>
            <span className={`challenge-status ${getStatusClass()}`}>
              {getStatusText()}
            </span>
          </div>
        </div>
      </div>

      <div className="challenge-card-body">
        <p className="challenge-description">{challenge.description}</p>

        <div className="challenge-progress-section">
          <ProgressBar
            progress={challenge.progress}
            total={100}
            showPercentage
            className={getStatusClass()}
          />
          <div className="challenge-dates">
            <span>{labels?.startLabel || 'Start'}: {formatTime(challenge.startDate, false)}</span>
            {challenge.endDate && (
              <span>{labels?.endLabel || 'End'}: {formatTime(challenge.endDate, false)}</span>
            )}
          </div>
        </div>
      </div>

      <div className="challenge-card-footer">
        {challenge.status === ChallengeStatus.ACTIVE && (
          <button
            className="complete-challenge-button"
            onClick={handleComplete}
            disabled={challenge.progress < 100}
          >
            {challenge.progress >= 100 ? (labels?.completeButtonText || 'Complete Challenge') : (labels?.inProgressText || 'In Progress...')}
          </button>
        )}
        {challenge.status === ChallengeStatus.COMPLETED && (
          <div className="challenge-completed-info">
            <span className="completion-date">
              {labels?.completedOnLabel || 'Completed on'}: {formatTime(challenge.completedDate!, false)}
            </span>
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default ChallengeCard;
</file>

<file path="src/components/game/ChallengeDiscoveryCard.tsx">
// src/components/game/ChallengeDiscoveryCard.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { ChallengeDiscovery, markDiscoveryAsViewed, acceptChallenge } from '@/services/challengeDiscoveryService';
import { ChallengeRecord, getChallenge, ChallengeDifficulty } from '@/services/challengeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import { ChallengeDiscoveryCardLabels } from '@/types';

interface ChallengeDiscoveryCardProps {
  discovery: ChallengeDiscovery;
  onAccept?: () => void;
  onDecline?: () => void;
  onClose?: () => void;
  labels?: ChallengeDiscoveryCardLabels;
}

/**
 * Challenge discovery card component
 * Used to display discovered challenges and related actions
 *
 * @param discovery - Challenge discovery data
 * @param onAccept - Callback function when challenge is accepted
 * @param onDecline - Callback function when challenge is declined
 * @param onClose - Callback function when card is closed
 * @param labels - Localized labels for the component
 */
const ChallengeDiscoveryCard: React.FC<ChallengeDiscoveryCardProps> = ({
  discovery,
  onAccept,
  onDecline,
  onClose,
  labels
}) => {
  // Add console log to check labels
  console.log('ChallengeDiscoveryCard labels:', labels);
  const [challenge, setChallenge] = useState<ChallengeRecord | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isAccepting, setIsAccepting] = useState(false);
  const [isVisible, setIsVisible] = useState(true);

  // åŠ è½½æŒ‘æˆ˜æ•°æ®
  useEffect(() => {
    const loadChallenge = async () => {
      try {
        setIsLoading(true);
        setError(null);

        // è·å–æŒ‘æˆ˜æ•°æ®
        const challengeData = await getChallenge(discovery.challengeId);
        if (challengeData) {
          setChallenge(challengeData);

          // æ ‡è®°ä¸ºå·²æŸ¥çœ‹
          if (!discovery.isViewed) {
            await markDiscoveryAsViewed(discovery.id!);
          }
        } else {
          setError(labels?.cannotLoadChallenge || 'Unable to load challenge data');
        }
      } catch (err) {
        console.error('Failed to load challenge:', err);
        setError(labels?.errorLoadingChallenge || 'Failed to load challenge, please try again');
      } finally {
        setIsLoading(false);
      }
    };

    loadChallenge();
  }, [discovery]);

  // å¤„ç†æ¥å—æŒ‘æˆ˜
  const handleAccept = async () => {
    try {
      setIsAccepting(true);

      // æ¥å—æŒ‘æˆ˜
      await acceptChallenge(discovery.id!);

      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);

      // è§¦å‘å…³é—­åŠ¨ç”»
      setIsVisible(false);

      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onAccept) {
        setTimeout(() => {
          onAccept();
        }, 300); // ç­‰å¾…å…³é—­åŠ¨ç”»å®Œæˆ
      }
    } catch (err) {
      console.error('Failed to accept challenge:', err);
      setError('æ¥å—æŒ‘æˆ˜å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsAccepting(false);
    }
  };

  // å¤„ç†æ‹’ç»æŒ‘æˆ˜
  const handleDecline = () => {
    // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
    playSound(SoundType.BUTTON_CLICK, 0.3);

    // è§¦å‘å…³é—­åŠ¨ç”»
    setIsVisible(false);

    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onDecline) {
      setTimeout(() => {
        onDecline();
      }, 300); // ç­‰å¾…å…³é—­åŠ¨ç”»å®Œæˆ
    }
  };

  // å¤„ç†å…³é—­å¡ç‰‡
  const handleClose = () => {
    // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
    playSound(SoundType.BUTTON_CLICK, 0.3);

    // è§¦å‘å…³é—­åŠ¨ç”»
    setIsVisible(false);

    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onClose) {
      setTimeout(() => {
        onClose();
      }, 300); // ç­‰å¾…å…³é—­åŠ¨ç”»å®Œæˆ
    }
  };

  // è·å–éš¾åº¦æ ‡ç­¾å’Œæ ·å¼
  const getDifficultyInfo = (difficulty: ChallengeDifficulty) => {
    switch (difficulty) {
      case ChallengeDifficulty.EASY:
        return { label: 'ç®€å•', className: 'bg-green-100 text-green-800' };
      case ChallengeDifficulty.MEDIUM:
        return { label: 'ä¸­ç­‰', className: 'bg-blue-100 text-blue-800' };
      case ChallengeDifficulty.HARD:
        return { label: 'å›°éš¾', className: 'bg-orange-100 text-orange-800' };
      case ChallengeDifficulty.EXPERT:
        return { label: 'ä¸“å®¶', className: 'bg-red-100 text-red-800' };
      default:
        return { label: 'æœªçŸ¥', className: 'bg-gray-100 text-gray-800' };
    }
  };

  // è®¡ç®—å‰©ä½™æ—¶é—´
  const getRemainingTime = () => {
    if (!discovery.expiresAt) return 'æ°¸ä¸è¿‡æœŸ';

    const now = new Date();
    const expiresAt = new Date(discovery.expiresAt);
    const diffMs = expiresAt.getTime() - now.getTime();

    if (diffMs <= 0) return 'å·²è¿‡æœŸ';

    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    const diffHours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));

    if (diffDays > 0) {
      return `${diffDays}å¤©${diffHours}å°æ—¶`;
    } else {
      return `${diffHours}å°æ—¶`;
    }
  };

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          className="challenge-discovery-card border-2 border-gold rounded-lg overflow-hidden bg-white shadow-lg"
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.9 }}
          transition={{ duration: 0.3 }}
        >
          {/* å¡ç‰‡å¤´éƒ¨ */}
          <div className="card-header bg-amber-50 p-4 border-b border-amber-200 relative">
            <div className="absolute top-2 right-2">
              <button
                onClick={handleClose}
                className="text-gray-500 hover:text-gray-700"
                aria-label={labels?.closeButtonAriaLabel || "Close"}
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                </svg>
              </button>
            </div>
            <h3 className="text-xl font-bold text-amber-800">å‘ç°æ–°æŒ‘æˆ˜ï¼</h3>
            <p className="text-sm text-amber-600">
              å‰©ä½™æ—¶é—´: {getRemainingTime()}
            </p>
          </div>

          {/* å¡ç‰‡å†…å®¹ */}
          <div className="card-content p-4">
            {isLoading ? (
              <div className="flex justify-center items-center h-32">
                <LoadingSpinner variant="jade" size="medium" />
              </div>
            ) : error ? (
              <div className="error-message text-red-500 text-center p-4">
                {error}
              </div>
            ) : challenge ? (
              <div className="challenge-info">
                <div className="challenge-header flex items-center mb-3">
                  <div className="challenge-icon mr-3">
                    <img
                      src={challenge.iconPath}
                      alt={challenge.title}
                      className="w-12 h-12 object-contain"
                      onError={(e) => {
                        const target = e.target as HTMLImageElement;
                        target.onerror = null;
                        target.src = '/assets/challenges/default.svg';
                      }}
                    />
                  </div>
                  <div className="challenge-title-container">
                    <h4 className="text-lg font-bold">{challenge.title}</h4>
                    <div className="challenge-meta flex flex-wrap gap-2 mt-1">
                      {challenge.difficulty && (
                        <span className={`px-2 py-1 rounded-full text-xs ${getDifficultyInfo(challenge.difficulty).className}`}>
                          {getDifficultyInfo(challenge.difficulty).label}
                        </span>
                      )}
                    </div>
                  </div>
                </div>

                <div className="challenge-description mb-4">
                  <p className="text-gray-700">{challenge.description}</p>
                </div>

                <div className="challenge-dates text-sm text-gray-600 mb-4">
                  <p>{labels?.startDateLabel || 'Start Date'}: {new Date(challenge.startDate).toLocaleDateString()}</p>
                  {challenge.endDate && (
                    <p>{labels?.endDateLabel || 'End Date'}: {new Date(challenge.endDate).toLocaleDateString()}</p>
                  )}
                </div>
              </div>
            ) : (
              <div className="text-center p-4">
                {labels?.cannotLoadChallenge || 'Unable to load challenge information'}
              </div>
            )}
          </div>

          {/* å¡ç‰‡åº•éƒ¨ */}
          <div className="card-footer bg-gray-50 p-4 border-t border-gray-200 flex justify-end gap-2">
            <Button
              variant="secondary"
              onClick={handleDecline}
              disabled={isAccepting}
            >
              {labels?.laterButton || 'Maybe Later'}
            </Button>
            <Button
              variant="jade"
              onClick={handleAccept}
              disabled={isAccepting || !challenge}
            >
              {isAccepting ? (
                <LoadingSpinner variant="white" size="small" />
              ) : (
                labels?.acceptButton || 'Accept Challenge'
              )}
            </Button>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default ChallengeDiscoveryCard;
</file>

<file path="src/components/game/ChallengeDiscoverySection.tsx">
// src/components/game/ChallengeDiscoverySection.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  getRecommendedChallenges,
  getUnviewedDiscoveries,
  ChallengeRecommendation,
  ChallengeDiscovery
} from '@/services/challengeDiscoveryService';
import { updateChallenge, ChallengeStatus } from '@/services/challengeService';
import ChallengeRecommendationCard from './ChallengeRecommendationCard';
import ChallengeDiscoveryCard from './ChallengeDiscoveryCard';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import { ChallengeDiscoveryCardLabels, ChallengeRecommendationCardLabels } from '@/types';

interface ChallengeDiscoverySectionProps {
  onChallengeAccepted?: () => void;
  onChallengeViewed?: (challengeId: number) => void;
  labels?: {
    challengeDiscoveryCard?: ChallengeDiscoveryCardLabels;
    challengeRecommendationCard?: ChallengeRecommendationCardLabels;
  };
}

/**
 * Challenge discovery section component
 * Used to display challenge discoveries and recommendations
 *
 * @param onChallengeAccepted - Callback function when a challenge is accepted
 * @param onChallengeViewed - Callback function when a challenge is viewed
 * @param labels - Localized labels for the component
 */
const ChallengeDiscoverySection: React.FC<ChallengeDiscoverySectionProps> = ({
  onChallengeAccepted,
  onChallengeViewed,
  labels
}) => {
  // Add console log to check labels
  console.log('ChallengeDiscoverySection labels:', labels);
  const [recommendations, setRecommendations] = useState<ChallengeRecommendation[]>([]);
  const [discoveries, setDiscoveries] = useState<ChallengeDiscovery[]>([]);
  const [currentDiscoveryIndex, setCurrentDiscoveryIndex] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showRecommendations, setShowRecommendations] = useState(false);

  // åŠ è½½æ¨èå’Œå‘ç°
  const loadData = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // è·å–æœªæŸ¥çœ‹çš„æŒ‘æˆ˜å‘ç°
      const unviewedDiscoveries = await getUnviewedDiscoveries();
      setDiscoveries(unviewedDiscoveries);

      // è·å–æ¨èçš„æŒ‘æˆ˜
      const recommendedChallenges = await getRecommendedChallenges(3);
      setRecommendations(recommendedChallenges);
    } catch (err) {
      console.error('Failed to load challenge discoveries:', err);
      setError('åŠ è½½æŒ‘æˆ˜å‘ç°å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadData();
  }, []);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('challengeDiscoveries', loadData);
  useRegisterTableRefresh('challenges', loadData);

  // å¤„ç†æ¥å—æŒ‘æˆ˜
  const handleAcceptChallenge = async (challengeId: number) => {
    try {
      // æ›´æ–°æŒ‘æˆ˜çŠ¶æ€ä¸ºæ´»è·ƒ
      await updateChallenge(challengeId, {
        status: ChallengeStatus.ACTIVE
      });

      // é‡æ–°åŠ è½½æ•°æ®
      await loadData();

      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onChallengeAccepted) {
        onChallengeAccepted();
      }
    } catch (err) {
      console.error('Failed to accept challenge:', err);
      setError('æ¥å—æŒ‘æˆ˜å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };

  // å¤„ç†æŸ¥çœ‹æŒ‘æˆ˜è¯¦æƒ…
  const handleViewChallengeDetails = (challengeId: number) => {
    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onChallengeViewed) {
      onChallengeViewed(challengeId);
    }
  };

  // å¤„ç†æ¥å—å‘ç°çš„æŒ‘æˆ˜
  const handleAcceptDiscovery = () => {
    // ç§»é™¤å½“å‰å‘ç°
    setDiscoveries(prevDiscoveries =>
      prevDiscoveries.filter((_, index) => index !== currentDiscoveryIndex)
    );

    // é‡ç½®ç´¢å¼•
    setCurrentDiscoveryIndex(0);

    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onChallengeAccepted) {
      onChallengeAccepted();
    }
  };

  // å¤„ç†æ‹’ç»å‘ç°çš„æŒ‘æˆ˜
  const handleDeclineDiscovery = () => {
    // ç§»é™¤å½“å‰å‘ç°
    setDiscoveries(prevDiscoveries =>
      prevDiscoveries.filter((_, index) => index !== currentDiscoveryIndex)
    );

    // é‡ç½®ç´¢å¼•
    setCurrentDiscoveryIndex(0);
  };

  // å¤„ç†å…³é—­å‘ç°å¡ç‰‡
  const handleCloseDiscovery = () => {
    // ç§»é™¤å½“å‰å‘ç°
    setDiscoveries(prevDiscoveries =>
      prevDiscoveries.filter((_, index) => index !== currentDiscoveryIndex)
    );

    // é‡ç½®ç´¢å¼•
    setCurrentDiscoveryIndex(0);
  };

  // åˆ‡æ¢æ˜¾ç¤ºæ¨è
  const toggleRecommendations = () => {
    setShowRecommendations(prev => !prev);
  };

  // å½“å‰å‘ç°
  const currentDiscovery = discoveries.length > 0 ? discoveries[currentDiscoveryIndex] : null;

  // å®¹å™¨å˜ä½“
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // é¡¹ç›®å˜ä½“
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  if (isLoading) {
    return (
      <div className="challenge-discovery-section p-4">
        <LoadingSpinner variant="jade" size="medium" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="challenge-discovery-section p-4">
        <div className="error-message text-red-500 mb-2">{error}</div>
        <Button variant="jade" onClick={loadData}>
          é‡è¯•
        </Button>
      </div>
    );
  }

  return (
    <div className="challenge-discovery-section">
      {/* æŒ‘æˆ˜å‘ç°å¡ç‰‡ */}
      {currentDiscovery && (
        <div className="challenge-discovery-container mb-6">
          <ChallengeDiscoveryCard
            discovery={currentDiscovery}
            onAccept={handleAcceptDiscovery}
            onDecline={handleDeclineDiscovery}
            onClose={handleCloseDiscovery}
            labels={labels?.challengeDiscoveryCard}
          />
        </div>
      )}

      {/* æŒ‘æˆ˜æ¨èåŒºåŸŸ */}
      <div className="challenge-recommendations-container">
        <div className="section-header flex justify-between items-center mb-4">
          <h3 className="text-lg font-bold">æ¨èæŒ‘æˆ˜</h3>
          <Button
            variant="secondary"
            size="small"
            onClick={toggleRecommendations}
          >
            {showRecommendations ? 'éšè—æ¨è' : 'æŸ¥çœ‹æ¨è'}
          </Button>
        </div>

        <AnimatePresence>
          {showRecommendations && (
            <motion.div
              className="recommendations-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
              variants={containerVariants}
              initial="hidden"
              animate="visible"
              exit={{ opacity: 0 }}
            >
              {recommendations.length > 0 ? (
                recommendations.map((recommendation, index) => (
                  <motion.div
                    key={`recommendation-${recommendation.challenge.id}`}
                    variants={itemVariants}
                  >
                    <ChallengeRecommendationCard
                      recommendation={recommendation}
                      onAccept={handleAcceptChallenge}
                      onViewDetails={handleViewChallengeDetails}
                      labels={labels?.challengeRecommendationCard}
                    />
                  </motion.div>
                ))
              ) : (
                <motion.div
                  className="no-recommendations col-span-full text-center p-4 text-gray-500"
                  variants={itemVariants}
                >
                  æš‚æ— æ¨èæŒ‘æˆ˜
                </motion.div>
              )}
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );
};

export default ChallengeDiscoverySection;
</file>

<file path="src/components/game/ChallengeList.tsx">
// src/components/game/ChallengeList.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  ChallengeRecord,
  ChallengeStatus,
  ChallengeType,
  ChallengeDifficulty,
  getAllChallenges,
  completeChallenge
} from '@/services/challengeService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import ChallengeCard from './ChallengeCard';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import RewardModal from '@/components/game/RewardModal';
import { RewardRecord } from '@/services/rewardService';
import ScrollDialog from './ScrollDialog';

interface ChallengeListProps {
  filter?: {
    status?: ChallengeStatus;
    type?: ChallengeType;
    difficulty?: ChallengeDifficulty;
  };
  onSelectChallenge?: (challenge: ChallengeRecord) => void;
  labels?: {
    statusLabel?: string;
    typeLabel?: string;
    difficultyLabel?: string;
    progressLabel?: string;
    statusActive?: string;
    statusCompleted?: string;
    statusExpired?: string;
    statusUpcoming?: string;
    difficultyEasy?: string;
    difficultyMedium?: string;
    difficultyHard?: string;
    difficultyExpert?: string;
    startLabel?: string;
    endLabel?: string;
    completedOnLabel?: string;
    completeButtonText?: string;
    inProgressText?: string;
    noItemsMessage?: string;
  };
}

/**
 * Challenge List Component
 * Displays a list of challenges with filtering and selection support
 */
const ChallengeList: React.FC<ChallengeListProps> = ({ filter, onSelectChallenge, labels }) => {
  const [challenges, setChallenges] = useState<ChallengeRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [showRewardModal, setShowRewardModal] = useState(false);
  const [selectedChallenge, setSelectedChallenge] = useState<ChallengeRecord | null>(null);
  const [showChallengeDetails, setShowChallengeDetails] = useState(false);

  // Load challenges
  const loadChallenges = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const challengeList = await getAllChallenges(filter);
      setChallenges(challengeList);
    } catch (err) {
      console.error('Failed to load challenges:', err);
      setError('Failed to load challenges. Please try again.');
    } finally {
      setIsLoading(false);
    }
  }, [filter]);

  // Initial loading
  useEffect(() => {
    loadChallenges();
  }, [loadChallenges]);

  // Define challenge data update handler
  const handleChallengeDataUpdate = useCallback((challengeData: any) => {
    // If there is specific challenge data, update that challenge
    if (challengeData && challengeData.id) {
      setChallenges(prevChallenges => {
        // Check if challenge already exists
        const challengeExists = prevChallenges.some(challenge => challenge.id === challengeData.id);

        if (challengeExists) {
          // Update existing challenge
          return prevChallenges.map(challenge =>
            challenge.id === challengeData.id ? { ...challenge, ...challengeData } : challenge
          );
        } else {
          // Add new challenge (if it matches filter criteria)
          if (!filter ||
              ((!filter.status || challengeData.status === filter.status) &&
               (!filter.type || challengeData.type === filter.type) &&
               (!filter.difficulty || challengeData.difficulty === filter.difficulty))) {
            return [...prevChallenges, challengeData];
          }
          return prevChallenges;
        }
      });
    } else {
      // If no specific challenge data, reload all challenges
      loadChallenges();
    }
  }, [loadChallenges, filter]);

  // Use useRegisterTableRefresh hook to listen for changes in the challenges table
  useRegisterTableRefresh('challenges', handleChallengeDataUpdate);

  // Handle challenge selection
  const handleSelectChallenge = (challenge: ChallengeRecord) => {
    setSelectedChallenge(challenge);
    setShowChallengeDetails(true);

    if (onSelectChallenge) {
      onSelectChallenge(challenge);
    }
  };

  // Handle challenge completion
  const handleCompleteChallenge = async (challengeId: number) => {
    try {
      setIsLoading(true);

      // Complete challenge and get rewards
      const challengeRewards = await completeChallenge(challengeId);

      // Update challenge list
      setChallenges(prevChallenges =>
        prevChallenges.map(challenge =>
          challenge.id === challengeId
            ? {
                ...challenge,
                status: ChallengeStatus.COMPLETED,
                progress: 100,
                completedDate: new Date()
              }
            : challenge
        )
      );

      // Show rewards
      if (challengeRewards && challengeRewards.length > 0) {
        setRewards(challengeRewards);
        setShowRewardModal(true);
      }
    } catch (err) {
      console.error('Failed to complete challenge:', err);
      setError('Failed to complete challenge. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  // Close reward modal
  const handleCloseRewardModal = () => {
    setShowRewardModal(false);
  };

  // Close challenge details
  const handleCloseChallengeDetails = () => {
    setShowChallengeDetails(false);
    setSelectedChallenge(null);
  };

  // If loading, show loading spinner
  if (isLoading && challenges.length === 0) {
    return <LoadingSpinner />;
  }

  // If error, show error message
  if (error && challenges.length === 0) {
    return <div className="error-message">{error}</div>;
  }

  // If no challenges, show message
  if (challenges.length === 0) {
    return <div className="no-challenges-message">{labels?.noItemsMessage || 'No challenges available'}</div>;
  }

  return (
    <div className="challenge-list">
      <AnimatePresence>
        {challenges.map(challenge => (
          <ChallengeCard
            key={challenge.id}
            challenge={challenge}
            onClick={handleSelectChallenge}
            onComplete={handleCompleteChallenge}
            labels={labels}
          />
        ))}
      </AnimatePresence>

      {/* Reward modal */}
      {showRewardModal && (
        <RewardModal
          rewards={rewards}
          onClose={handleCloseRewardModal}
        />
      )}

      {/* Challenge details */}
      {showChallengeDetails && selectedChallenge && (
        <ScrollDialog
          title={selectedChallenge.title}
          onClose={handleCloseChallengeDetails}
        >
          <div className="challenge-details">
            <div className="challenge-header">
              <img
                src={selectedChallenge.iconPath}
                alt={selectedChallenge.title}
                className="challenge-icon-large"
              />
              <div className="challenge-meta-details">
                <div className="challenge-difficulty">
                  {labels?.difficultyLabel || 'Difficulty'}: {
                    selectedChallenge.difficulty === ChallengeDifficulty.EASY ? (labels?.difficultyEasy || 'Easy') :
                    selectedChallenge.difficulty === ChallengeDifficulty.MEDIUM ? (labels?.difficultyMedium || 'Medium') :
                    selectedChallenge.difficulty === ChallengeDifficulty.HARD ? (labels?.difficultyHard || 'Hard') :
                    selectedChallenge.difficulty === ChallengeDifficulty.EXPERT ? (labels?.difficultyExpert || 'Expert') :
                    selectedChallenge.difficulty
                  }
                </div>
                <div className="challenge-type">
                  {labels?.typeLabel || 'Type'}: {selectedChallenge.type}
                </div>
                <div className="challenge-status">
                  {labels?.statusLabel || 'Status'}: {
                    selectedChallenge.status === ChallengeStatus.ACTIVE ? (labels?.statusActive || 'Active') :
                    selectedChallenge.status === ChallengeStatus.COMPLETED ? (labels?.statusCompleted || 'Completed') :
                    selectedChallenge.status === ChallengeStatus.UPCOMING ? (labels?.statusUpcoming || 'Upcoming') :
                    selectedChallenge.status
                  }
                </div>
              </div>
            </div>

            <div className="challenge-description-full">
              {selectedChallenge.description}
            </div>

            <div className="challenge-progress-details">
              <h4>{labels?.progressLabel || 'Progress'}: {selectedChallenge.progress}%</h4>
              <div className="progress-bar-container">
                <div
                  className="progress-bar-fill"
                  style={{ width: `${selectedChallenge.progress}%` }}
                ></div>
              </div>
            </div>

            <div className="challenge-dates-details">
              <div>{labels?.startLabel || 'Start Date'}: {selectedChallenge.startDate.toLocaleDateString()}</div>
              {selectedChallenge.endDate && (
                <div>{labels?.endLabel || 'End Date'}: {selectedChallenge.endDate.toLocaleDateString()}</div>
              )}
              {selectedChallenge.completedDate && (
                <div>{labels?.completedOnLabel || 'Completed On'}: {selectedChallenge.completedDate.toLocaleDateString()}</div>
              )}
            </div>

            {selectedChallenge.status === ChallengeStatus.ACTIVE && (
              <button
                className="complete-challenge-button-large"
                onClick={() => handleCompleteChallenge(selectedChallenge.id!)}
                disabled={selectedChallenge.progress < 100}
              >
                {selectedChallenge.progress >= 100 ? (labels?.completeButtonText || 'Complete Challenge') : (labels?.inProgressText || 'Keep Going')}
              </button>
            )}
          </div>
        </ScrollDialog>
      )}
    </div>
  );
};

export default ChallengeList;
</file>

<file path="src/components/game/ChallengeRecommendationCard.tsx">
// src/components/game/ChallengeRecommendationCard.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { ChallengeRecommendation } from '@/services/challengeDiscoveryService';
import { ChallengeDifficulty } from '@/services/challengeService';
import Button from '@/components/common/Button';
import { playSound, SoundType } from '@/utils/sound';
import { ChallengeRecommendationCardLabels } from '@/types';

interface ChallengeRecommendationCardProps {
  recommendation: ChallengeRecommendation;
  onAccept?: (challengeId: number) => void;
  onViewDetails?: (challengeId: number) => void;
  labels?: ChallengeRecommendationCardLabels;
}

/**
 * Challenge recommendation card component
 * Used to display recommended challenges and related actions
 *
 * @param recommendation - Challenge recommendation data
 * @param onAccept - Callback function when challenge is accepted
 * @param onViewDetails - Callback function when challenge details are viewed
 * @param labels - Localized labels for the component
 */
const ChallengeRecommendationCard: React.FC<ChallengeRecommendationCardProps> = ({
  recommendation,
  onAccept,
  onViewDetails,
  labels
}) => {
  // Add console log to check labels
  console.log('ChallengeRecommendationCard labels:', labels);
  const { challenge, score, reason } = recommendation;

  // å¤„ç†æ¥å—æŒ‘æˆ˜
  const handleAccept = () => {
    // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
    playSound(SoundType.SUCCESS, 0.5);

    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onAccept) {
      onAccept(challenge.id!);
    }
  };

  // å¤„ç†æŸ¥çœ‹è¯¦æƒ…
  const handleViewDetails = () => {
    // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
    playSound(SoundType.BUTTON_CLICK, 0.3);

    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onViewDetails) {
      onViewDetails(challenge.id!);
    }
  };

  // Get difficulty label and style with localization
  const getDifficultyInfo = (difficulty: ChallengeDifficulty) => {
    switch (difficulty) {
      case ChallengeDifficulty.EASY:
        return {
          label: labels?.difficultyEasy || 'Easy',
          className: 'bg-green-100 text-green-800'
        };
      case ChallengeDifficulty.MEDIUM:
        return {
          label: labels?.difficultyMedium || 'Medium',
          className: 'bg-blue-100 text-blue-800'
        };
      case ChallengeDifficulty.HARD:
        return {
          label: labels?.difficultyHard || 'Hard',
          className: 'bg-orange-100 text-orange-800'
        };
      case ChallengeDifficulty.EXPERT:
        return {
          label: labels?.difficultyExpert || 'Expert',
          className: 'bg-red-100 text-red-800'
        };
      default:
        return {
          label: labels?.difficultyUnknown || 'Unknown',
          className: 'bg-gray-100 text-gray-800'
        };
    }
  };

  // è·å–æ¨èåˆ†æ•°æ ·å¼
  const getScoreStyle = (score: number) => {
    if (score >= 30) {
      return 'text-green-600';
    } else if (score >= 20) {
      return 'text-blue-600';
    } else if (score >= 10) {
      return 'text-amber-600';
    } else {
      return 'text-gray-600';
    }
  };

  return (
    <motion.div
      className="challenge-recommendation-card border rounded-lg overflow-hidden bg-white shadow-md hover:shadow-lg transition-shadow"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
    >
      {/* å¡ç‰‡å¤´éƒ¨ */}
      <div className="card-header bg-gray-50 p-3 border-b border-gray-200 flex justify-between items-center">
        <h3 className="text-md font-bold">{challenge.title}</h3>
        <div className="recommendation-score">
          <span className={`text-sm font-bold ${getScoreStyle(score)}`}>
            {labels?.matchScoreLabel || 'Match Score'}: {Math.min(100, Math.round(score * 2))}%
          </span>
        </div>
      </div>

      {/* å¡ç‰‡å†…å®¹ */}
      <div className="card-content p-3">
        <div className="challenge-meta flex flex-wrap gap-2 mb-2">
          {challenge.difficulty && (
            <span className={`px-2 py-1 rounded-full text-xs ${getDifficultyInfo(challenge.difficulty).className}`}>
              {getDifficultyInfo(challenge.difficulty).label}
            </span>
          )}
          <span className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800">
            {challenge.type.charAt(0).toUpperCase() + challenge.type.slice(1)}
          </span>
        </div>

        <div className="challenge-description mb-2">
          <p className="text-sm text-gray-700 line-clamp-2">{challenge.description}</p>
        </div>

        <div className="recommendation-reason mb-3">
          <p className="text-xs text-gray-600 italic">{reason}</p>
        </div>

        <div className="challenge-dates text-xs text-gray-500 mb-2">
          <p>{labels?.startDateLabel || 'Start Date'}: {new Date(challenge.startDate).toLocaleDateString()}</p>
          {challenge.endDate && (
            <p>{labels?.endDateLabel || 'End Date'}: {new Date(challenge.endDate).toLocaleDateString()}</p>
          )}
        </div>
      </div>

      {/* å¡ç‰‡åº•éƒ¨ */}
      <div className="card-footer bg-gray-50 p-2 border-t border-gray-200 flex justify-end gap-2">
        <Button
          variant="secondary"
          size="small"
          onClick={handleViewDetails}
        >
          {labels?.viewDetailsButton || 'View Details'}
        </Button>
        <Button
          variant="jade"
          size="small"
          onClick={handleAccept}
        >
          {labels?.acceptButton || 'Accept Challenge'}
        </Button>
      </div>
    </motion.div>
  );
};

export default ChallengeRecommendationCard;
</file>

<file path="src/components/game/DialogDemo.tsx">
// src/components/game/DialogDemo.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import ScrollDialog from './ScrollDialog';
import LatticeDialog from './LatticeDialog';
import Button from '@/components/common/Button';

/**
 * å¯¹è¯æ¡†æ¼”ç¤ºç»„ä»¶
 * ç”¨äºå±•ç¤ºä¸åŒé£æ ¼çš„å¯¹è¯æ¡†ç»„ä»¶
 */
const DialogDemo: React.FC = () => {
  const [isScrollDialogOpen, setIsScrollDialogOpen] = useState(false);
  const [isLatticeDialogOpen, setIsLatticeDialogOpen] = useState(false);
  const [isConfirmDialogOpen, setIsConfirmDialogOpen] = useState(false);

  // æ‰“å¼€å·è½´å¯¹è¯æ¡†
  const openScrollDialog = () => {
    setIsScrollDialogOpen(true);
  };

  // å…³é—­å·è½´å¯¹è¯æ¡†
  const closeScrollDialog = () => {
    setIsScrollDialogOpen(false);
  };

  // æ‰“å¼€çª—æ£‚å¯¹è¯æ¡†
  const openLatticeDialog = () => {
    setIsLatticeDialogOpen(true);
  };

  // å…³é—­çª—æ£‚å¯¹è¯æ¡†
  const closeLatticeDialog = () => {
    setIsLatticeDialogOpen(false);
  };

  // æ‰“å¼€ç¡®è®¤å¯¹è¯æ¡†
  const openConfirmDialog = () => {
    setIsConfirmDialogOpen(true);
  };

  // å…³é—­ç¡®è®¤å¯¹è¯æ¡†
  const closeConfirmDialog = () => {
    setIsConfirmDialogOpen(false);
  };

  // ç¡®è®¤æ“ä½œ
  const handleConfirm = () => {
    alert('æ“ä½œå·²ç¡®è®¤ï¼');
    closeConfirmDialog();
  };

  // ç¡®è®¤å¯¹è¯æ¡†çš„åº•éƒ¨æŒ‰é’®
  const confirmDialogFooter = (
    <>
      <Button variant="secondary" onClick={closeConfirmDialog}>
        å–æ¶ˆ
      </Button>
      <Button variant="jade" onClick={handleConfirm}>
        ç¡®è®¤
      </Button>
    </>
  );

  return (
    <div className="dialog-demo">
      <h2>å¯¹è¯æ¡†æ¼”ç¤º</h2>
      
      <div style={{ display: 'flex', gap: '16px', marginBottom: '24px' }}>
        <Button variant="jade" onClick={openScrollDialog}>
          æ‰“å¼€å·è½´å¯¹è¯æ¡†
        </Button>
        
        <Button variant="gold" onClick={openLatticeDialog}>
          æ‰“å¼€çª—æ£‚å¯¹è¯æ¡†
        </Button>
        
        <Button variant="primary" onClick={openConfirmDialog}>
          æ‰“å¼€ç¡®è®¤å¯¹è¯æ¡†
        </Button>
      </div>

      {/* å·è½´é£æ ¼å¯¹è¯æ¡† */}
      <ScrollDialog
        isOpen={isScrollDialogOpen}
        onClose={closeScrollDialog}
        title="ç†ŠçŒ«ä¼ è¯´"
      >
        <div style={{ padding: '0 16px' }}>
          <p>
            å¾ˆä¹…å¾ˆä¹…ä»¥å‰ï¼Œåœ¨ä¸€ä¸ªè¢«ç«¹æ—ç¯ç»•çš„å±±è°·é‡Œï¼Œç”Ÿæ´»ç€ä¸€ç¾¤ç¥å¥‡çš„ç†ŠçŒ«ã€‚å®ƒä»¬ä¸ä»…ä¼šè¯´äººç±»çš„è¯­è¨€ï¼Œè¿˜æŒæ¡ç€å¤è€çš„æ™ºæ…§ã€‚
          </p>
          <p>
            ä¼ è¯´ä¸­ï¼Œè¿™äº›ç†ŠçŒ«æ˜¯å¤©ä¸Šçš„æ˜Ÿè¾°åŒ–èº«ï¼Œå®ƒä»¬æ¥åˆ°äººé—´æ˜¯ä¸ºäº†æŒ‡å¼•äººä»¬æ‰¾åˆ°å†…å¿ƒçš„å¹³é™ä¸åšæŒã€‚æ¯å½“æœ‰äººè¿·å¤±æ–¹å‘æˆ–æ”¾å¼ƒè‡ªå·±çš„ç›®æ ‡æ—¶ï¼Œç†ŠçŒ«å°±ä¼šå‡ºç°ï¼Œç”¨å®ƒä»¬çš„æ™ºæ…§å’Œè€å¿ƒå¸®åŠ©äººä»¬é‡æ–°æ‰¾å›å‰è¿›çš„é“è·¯ã€‚
          </p>
          <p>
            è¿™äº›ç†ŠçŒ«ä¼šæ•™å¯¼äººä»¬å¦‚ä½•åƒç«¹å­ä¸€æ ·åšéŸ§ä¸æ‹”ï¼Œåœ¨é£é›¨ä¸­ä¾ç„¶æŒºç«‹ï¼›å¦‚ä½•åƒæµæ°´ä¸€æ ·çµæ´»åº”å˜ï¼Œç»•è¿‡ç”Ÿæ´»ä¸­çš„éšœç¢ï¼›å¦‚ä½•åƒå±±çŸ³ä¸€æ ·æ²‰ç¨³åšå®šï¼Œä¸è¢«å¤–ç•Œçš„å–§åš£æ‰€åŠ¨æ‘‡ã€‚
          </p>
          <p>
            æ®è¯´ï¼Œåªè¦ä½ çœŸå¿ƒç›¸ä¿¡å¹¶åšæŒä¸æ‡ˆåœ°è¿½æ±‚è‡ªå·±çš„ç›®æ ‡ï¼Œç†ŠçŒ«çš„æ™ºæ…§å°±ä¼šåœ¨ä½ çš„å¿ƒä¸­æ˜¾ç°ï¼ŒæŒ‡å¼•ä½ èµ°å‘æˆåŠŸå’Œå¹¸ç¦ã€‚
          </p>
        </div>
      </ScrollDialog>

      {/* çª—æ£‚é£æ ¼å¯¹è¯æ¡† */}
      <LatticeDialog
        isOpen={isLatticeDialogOpen}
        onClose={closeLatticeDialog}
        title="ç†ŠçŒ«ä¼™ä¼´è®¾ç½®"
      >
        <div>
          <div className="form-group">
            <label htmlFor="panda-name">ç†ŠçŒ«åç§°</label>
            <input
              id="panda-name"
              type="text"
              placeholder="ç»™ä½ çš„ç†ŠçŒ«ä¼™ä¼´èµ·ä¸ªåå­—"
              defaultValue="ç«¹ç«¹"
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="panda-color">ç†ŠçŒ«é¢œè‰²ä¸»é¢˜</label>
            <select id="panda-color" defaultValue="classic">
              <option value="classic">ç»å…¸é»‘ç™½</option>
              <option value="golden">é‡‘è‰²ä¼ è¯´</option>
              <option value="jade">ç¿¡ç¿ ç»¿</option>
              <option value="blue">é’èŠ±è“</option>
            </select>
          </div>
          
          <div className="form-group">
            <label>ç†ŠçŒ«äº’åŠ¨æé†’</label>
            <div style={{ display: 'flex', gap: '16px' }}>
              <label>
                <input type="checkbox" defaultChecked /> å–‚é£Ÿæé†’
              </label>
              <label>
                <input type="checkbox" defaultChecked /> ç©è€æé†’
              </label>
              <label>
                <input type="checkbox" defaultChecked /> è®­ç»ƒæé†’
              </label>
            </div>
          </div>
        </div>
      </LatticeDialog>

      {/* ç¡®è®¤å¯¹è¯æ¡† */}
      <LatticeDialog
        isOpen={isConfirmDialogOpen}
        onClose={closeConfirmDialog}
        title="æ“ä½œç¡®è®¤"
        footer={confirmDialogFooter}
      >
        <div style={{ textAlign: 'center', padding: '16px 0' }}>
          <p>æ‚¨ç¡®å®šè¦æ‰§è¡Œæ­¤æ“ä½œå—ï¼Ÿ</p>
          <p style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>
            æ­¤æ“ä½œæ— æ³•æ’¤é”€ï¼Œè¯·è°¨æ…ç¡®è®¤ã€‚
          </p>
        </div>
      </LatticeDialog>
    </div>
  );
};

export default DialogDemo;
</file>

<file path="src/components/game/LatticeDialog.tsx">
// src/components/game/LatticeDialog.tsx
import React from 'react';
import { motion } from 'framer-motion';
import Modal from '@/components/common/Modal';
import Button from '@/components/common/Button';

interface LatticeDialogProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
  footer?: React.ReactNode;
  closeOnOutsideClick?: boolean;
  closeOnEsc?: boolean;
  showCloseButton?: boolean;
}

/**
 * çª—æ£‚é£æ ¼å¯¹è¯æ¡†ç»„ä»¶
 * è®¾è®¡ä¸ºä¸­å›½ä¼ ç»Ÿçª—æ£‚æ ·å¼ï¼Œé€‚åˆå±•ç¤ºæ“ä½œç¡®è®¤ã€è®¾ç½®æˆ–è¡¨å•
 * 
 * @param isOpen - æ§åˆ¶å¯¹è¯æ¡†æ˜¯å¦æ˜¾ç¤º
 * @param onClose - å…³é—­å¯¹è¯æ¡†çš„å›è°ƒå‡½æ•°
 * @param title - å¯¹è¯æ¡†æ ‡é¢˜
 * @param children - å¯¹è¯æ¡†å†…å®¹
 * @param footer - å¯¹è¯æ¡†åº•éƒ¨å†…å®¹ï¼Œé€šå¸¸æ˜¯æŒ‰é’®
 * @param closeOnOutsideClick - æ˜¯å¦åœ¨ç‚¹å‡»å¤–éƒ¨åŒºåŸŸæ—¶å…³é—­ï¼Œé»˜è®¤ä¸ºtrue
 * @param closeOnEsc - æ˜¯å¦åœ¨æŒ‰ä¸‹ESCé”®æ—¶å…³é—­ï¼Œé»˜è®¤ä¸ºtrue
 * @param showCloseButton - æ˜¯å¦æ˜¾ç¤ºå…³é—­æŒ‰é’®ï¼Œé»˜è®¤ä¸ºtrue
 */
const LatticeDialog: React.FC<LatticeDialogProps> = ({
  isOpen,
  onClose,
  title,
  children,
  footer,
  closeOnOutsideClick = true,
  closeOnEsc = true,
  showCloseButton = true,
}) => {
  // é»˜è®¤åº•éƒ¨å†…å®¹
  const defaultFooter = (
    <Button variant="jade" onClick={onClose}>
      ç¡®è®¤
    </Button>
  );

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      closeOnOutsideClick={closeOnOutsideClick}
      closeOnEsc={closeOnEsc}
      className="lattice-modal"
    >
      <div className="lattice-modal-header">
        <h3 className="lattice-modal-title">{title}</h3>
        {showCloseButton && (
          <motion.button
            className="lattice-modal-close"
            onClick={onClose}
            whileHover={{ scale: 1.1 }}
            whileTap={{ scale: 0.9 }}
            aria-label="å…³é—­"
          >
            Ã—
          </motion.button>
        )}
      </div>

      <div className="lattice-modal-content">
        {children}
      </div>

      {(footer || defaultFooter) && (
        <div className="lattice-modal-footer">
          {footer || defaultFooter}
        </div>
      )}
    </Modal>
  );
};

export default LatticeDialog;
</file>

<file path="src/components/game/LuckyDrawWheel.tsx">
// src/components/game/LuckyDrawWheel.tsx
import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Button from '@/components/common/Button';
import { RewardRecord, RewardRarity } from '@/services/rewardService';
import { playSound, SoundType } from '@/utils/sound';
import RewardAnimation from '@/components/animation/RewardAnimation';
import ScrollDialog from './ScrollDialog';
import { getLuckyPointsTotal, performLuckyDraw } from '@/services/timelyRewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import LuckyPointsDisplay from './LuckyPointsDisplay';

interface LuckyDrawWheelProps {
  isOpen: boolean;
  onClose: () => void;
  onRewardEarned?: (rewards: RewardRecord[]) => void;
}

/**
 * å¹¸è¿æŠ½å¥–è½®ç›˜ç»„ä»¶
 * ç”¨äºå®ç°å¸¦æœ‰æ—‹è½¬è½®ç›˜çš„å¹¸è¿æŠ½å¥–åŠŸèƒ½
 */
const LuckyDrawWheel: React.FC<LuckyDrawWheelProps> = ({
  isOpen,
  onClose,
  onRewardEarned
}) => {
  const [isDrawing, setIsDrawing] = useState(false);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [points, setPoints] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showReward, setShowReward] = useState(false);
  const [currentRewardIndex, setCurrentRewardIndex] = useState(0);
  const [selectedPoints, setSelectedPoints] = useState(10); // é»˜è®¤ä½¿ç”¨10ç‚¹
  const wheelRef = useRef<HTMLDivElement>(null);
  const [wheelRotation, setWheelRotation] = useState(0);
  const [isWheelSpinning, setIsWheelSpinning] = useState(false);

  // æŠ½å¥–é€‰é¡¹
  const drawOptions = [
    { points: 10, label: 'åŸºç¡€æŠ½å¥–', description: 'è·å¾—æ™®é€šå¥–åŠ±çš„æœºä¼š' },
    { points: 30, label: 'é«˜çº§æŠ½å¥–', description: 'è·å¾—ç¨€æœ‰å¥–åŠ±çš„æ›´é«˜æœºä¼š' },
    { points: 50, label: 'è±ªåæŠ½å¥–', description: 'è·å¾—å²è¯—å’Œä¼ è¯´å¥–åŠ±çš„æœ€é«˜æœºä¼š' }
  ];

  // åŠ è½½å¹¸è¿ç‚¹æ•°é‡
  const loadPoints = async () => {
    try {
      setIsLoading(true);
      const total = await getLuckyPointsTotal();
      setPoints(total);
    } catch (err) {
      console.error('Failed to load lucky points:', err);
      setError('åŠ è½½å¹¸è¿ç‚¹å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    if (isOpen) {
      loadPoints();
    }
  }, [isOpen]);

  // å®šä¹‰å¹¸è¿ç‚¹æ•°æ®æ›´æ–°å¤„ç†å‡½æ•°
  const handleLuckyPointsUpdate = () => {
    loadPoints();
  };

  // ä½¿ç”¨ useRegisterTableRefresh hook ç›‘å¬å¹¸è¿ç‚¹è¡¨çš„å˜åŒ–
  useRegisterTableRefresh('luckyPoints', handleLuckyPointsUpdate);

  // å¤„ç†æŠ½å¥–
  const handleDraw = async () => {
    if (points < selectedPoints) {
      setError('å¹¸è¿ç‚¹ä¸è¶³');
      return;
    }

    try {
      setIsDrawing(true);
      setError(null);
      
      // æ’­æ”¾æŠ½å¥–éŸ³æ•ˆ
      playSound(SoundType.BUTTON_CLICK, 0.5);
      
      // æ—‹è½¬æŠ½å¥–è½®ç›˜
      setIsWheelSpinning(true);
      const randomRotation = 1080 + Math.random() * 360; // è‡³å°‘æ—‹è½¬3åœˆ
      setWheelRotation(prevRotation => prevRotation + randomRotation);
      
      // å»¶è¿Ÿè·å–å¥–åŠ±ï¼Œæ¨¡æ‹ŸæŠ½å¥–è¿‡ç¨‹
      setTimeout(async () => {
        // æ‰§è¡ŒæŠ½å¥–
        const result = await performLuckyDraw(selectedPoints);
        
        // æ›´æ–°å¹¸è¿ç‚¹
        setPoints(prev => prev - selectedPoints);
        
        // è®¾ç½®å¥–åŠ±
        setRewards(result.rewards);
        
        // åœæ­¢è½®ç›˜æ—‹è½¬
        setIsWheelSpinning(false);
        
        // æ˜¾ç¤ºå¥–åŠ±
        setTimeout(() => {
          setShowReward(true);
          setCurrentRewardIndex(0);
          
          // æ’­æ”¾å¥–åŠ±éŸ³æ•ˆï¼ˆæ ¹æ®ç¨€æœ‰åº¦ï¼‰
          if (result.rewards.length > 0) {
            const rarity = result.rewards[0].rarity;
            switch (rarity) {
              case RewardRarity.LEGENDARY:
                playSound(SoundType.REWARD_LEGENDARY, 0.7);
                break;
              case RewardRarity.EPIC:
                playSound(SoundType.REWARD_EPIC, 0.7);
                break;
              case RewardRarity.RARE:
                playSound(SoundType.REWARD_RARE, 0.7);
                break;
              case RewardRarity.UNCOMMON:
                playSound(SoundType.REWARD_UNCOMMON, 0.7);
                break;
              default:
                playSound(SoundType.REWARD_COMMON, 0.7);
                break;
            }
          }
          
          // é€šçŸ¥çˆ¶ç»„ä»¶
          if (onRewardEarned) {
            onRewardEarned(result.rewards);
          }
        }, 500);
      }, 3000); // 3ç§’åæ˜¾ç¤ºç»“æœ
    } catch (err) {
      console.error('Failed to perform lucky draw:', err);
      setError('æŠ½å¥–å¤±è´¥ï¼Œè¯·é‡è¯•');
      setIsWheelSpinning(false);
    } finally {
      setIsDrawing(false);
    }
  };

  // å¤„ç†ä¸‹ä¸€ä¸ªå¥–åŠ±
  const handleNextReward = () => {
    if (currentRewardIndex < rewards.length - 1) {
      setCurrentRewardIndex(prevIndex => prevIndex + 1);
      
      // æ’­æ”¾å¥–åŠ±éŸ³æ•ˆï¼ˆæ ¹æ®ç¨€æœ‰åº¦ï¼‰
      const rarity = rewards[currentRewardIndex + 1].rarity;
      switch (rarity) {
        case RewardRarity.LEGENDARY:
          playSound(SoundType.REWARD_LEGENDARY, 0.7);
          break;
        case RewardRarity.EPIC:
          playSound(SoundType.REWARD_EPIC, 0.7);
          break;
        case RewardRarity.RARE:
          playSound(SoundType.REWARD_RARE, 0.7);
          break;
        case RewardRarity.UNCOMMON:
          playSound(SoundType.REWARD_UNCOMMON, 0.7);
          break;
        default:
          playSound(SoundType.REWARD_COMMON, 0.7);
          break;
      }
    } else {
      setShowReward(false);
      setRewards([]);
    }
  };

  // å¤„ç†é€‰æ‹©æŠ½å¥–é€‰é¡¹
  const handleSelectOption = (points: number) => {
    setSelectedPoints(points);
  };

  // å¤„ç†ç»§ç»­æŠ½å¥–
  const handleContinue = () => {
    setShowReward(false);
    setRewards([]);
  };

  // æ¸²æŸ“æŠ½å¥–è½®ç›˜
  const renderWheel = () => {
    // è½®ç›˜ä¸Šçš„å¥–åŠ±ç±»å‹
    const wheelItems = [
      { type: RewardRarity.COMMON, color: '#cccccc', label: 'æ™®é€š' },
      { type: RewardRarity.UNCOMMON, color: '#4caf50', label: 'ä¸å¸¸è§' },
      { type: RewardRarity.RARE, color: '#2196f3', label: 'ç¨€æœ‰' },
      { type: RewardRarity.EPIC, color: '#9c27b0', label: 'å²è¯—' },
      { type: RewardRarity.LEGENDARY, color: '#ffc107', label: 'ä¼ è¯´' },
      { type: RewardRarity.COMMON, color: '#cccccc', label: 'æ™®é€š' },
      { type: RewardRarity.UNCOMMON, color: '#4caf50', label: 'ä¸å¸¸è§' },
      { type: RewardRarity.RARE, color: '#2196f3', label: 'ç¨€æœ‰' }
    ];

    return (
      <div className="lucky-draw-wheel-container relative w-64 h-64 mx-auto my-4">
        {/* è½®ç›˜æŒ‡é’ˆ */}
        <div className="wheel-pointer absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-10">
          <svg width="30" height="30" viewBox="0 0 30 30">
            <polygon points="15,0 30,15 15,30 0,15" fill="#e53935" />
          </svg>
        </div>
        
        {/* è½®ç›˜ */}
        <motion.div
          ref={wheelRef}
          className="lucky-draw-wheel w-full h-full rounded-full border-4 border-gold overflow-hidden relative"
          style={{
            boxShadow: '0 0 20px rgba(255, 215, 0, 0.5)',
            transform: `rotate(${wheelRotation}deg)`,
            transition: isWheelSpinning ? 'transform 3s cubic-bezier(0.2, 0.8, 0.2, 1)' : 'none'
          }}
        >
          {wheelItems.map((item, index) => {
            const angle = (index / wheelItems.length) * 360;
            return (
              <div
                key={`wheel-item-${index}`}
                className="wheel-item absolute w-full h-full"
                style={{
                  transform: `rotate(${angle}deg)`,
                  transformOrigin: 'center',
                  clipPath: `polygon(50% 50%, 50% 0%, ${50 + 50 * Math.cos((angle + 45) * Math.PI / 180)}% ${50 + 50 * Math.sin((angle + 45) * Math.PI / 180)}%)`
                }}
              >
                <div
                  className="w-full h-full flex items-center justify-center"
                  style={{ backgroundColor: item.color }}
                >
                  <span
                    className="text-white font-bold transform rotate-180"
                    style={{
                      position: 'absolute',
                      top: '25%',
                      left: '50%',
                      transform: `translate(-50%, -50%) rotate(${-angle}deg)`,
                      textShadow: '1px 1px 2px rgba(0, 0, 0, 0.5)'
                    }}
                  >
                    {item.label}
                  </span>
                </div>
              </div>
            );
          })}
        </motion.div>
      </div>
    );
  };

  // æ¸²æŸ“å¥–åŠ±å±•ç¤º
  const renderRewardDisplay = () => {
    if (!showReward || rewards.length === 0) return null;

    const currentReward = rewards[currentRewardIndex];

    return (
      <div className="lucky-draw-reward-display flex flex-col items-center justify-center p-4">
        <h3 className="text-xl font-bold mb-4">æ­å–œè·å¾—å¥–åŠ±ï¼</h3>
        
        <div className="reward-animation-container mb-4">
          <RewardAnimation
            type={currentReward.type}
            rarity={currentReward.rarity}
            iconPath={currentReward.iconPath}
            amount={currentReward.amount}
            size={120}
            animationStyle={
              currentReward.rarity === RewardRarity.LEGENDARY ? 'burst' :
              currentReward.rarity === RewardRarity.EPIC ? 'spin' :
              currentReward.rarity === RewardRarity.RARE ? 'pulse' :
              currentReward.rarity === RewardRarity.UNCOMMON ? 'float' : 'default'
            }
            playSound={false}
          />
        </div>
        
        <div className="reward-details text-center mb-4">
          <h4 className="text-lg font-bold">{currentReward.name}</h4>
          <p className="text-sm text-gray-600">{currentReward.description}</p>
          {currentReward.amount > 1 && (
            <p className="text-sm">æ•°é‡: {currentReward.amount}</p>
          )}
        </div>
        
        <div className="reward-navigation">
          {currentRewardIndex < rewards.length - 1 ? (
            <Button variant="jade" onClick={handleNextReward}>
              ä¸‹ä¸€ä¸ªå¥–åŠ±
            </Button>
          ) : (
            <Button variant="gold" onClick={handleContinue}>
              ç»§ç»­æŠ½å¥–
            </Button>
          )}
        </div>
      </div>
    );
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="å¹¸è¿æŠ½å¥–"
      closeOnOutsideClick={!isDrawing && !showReward}
      closeOnEsc={!isDrawing && !showReward}
      showCloseButton={!isDrawing && !showReward}
    >
      <div className="lucky-draw-content p-4">
        <AnimatePresence mode="wait">
          {!showReward ? (
            <motion.div
              key="lucky-draw-main"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.3 }}
            >
              <div className="lucky-points-display text-center mb-4">
                <LuckyPointsDisplay variant="large" />
                <p className="text-lg font-bold mt-2">å½“å‰å¹¸è¿ç‚¹æ•°: <span className="text-gold">{points}</span></p>
              </div>
              
              {renderWheel()}
              
              <div className="lucky-draw-options flex justify-center gap-4 mt-4">
                {drawOptions.map(option => (
                  <motion.div
                    key={option.points}
                    className={`draw-option p-2 border-2 rounded-lg cursor-pointer ${selectedPoints === option.points ? 'border-gold bg-amber-50' : 'border-gray-300'} ${points < option.points ? 'opacity-50 cursor-not-allowed' : ''}`}
                    onClick={() => points >= option.points && handleSelectOption(option.points)}
                    whileHover={{ scale: points >= option.points ? 1.05 : 1 }}
                    whileTap={{ scale: points >= option.points ? 0.95 : 1 }}
                  >
                    <div className="draw-option-header flex items-center justify-between">
                      <div className="draw-option-points flex items-center">
                        <span className="lucky-points-icon mr-1">ğŸ€</span>
                        <span>{option.points}</span>
                      </div>
                      <h3 className="draw-option-label font-bold">{option.label}</h3>
                    </div>
                    <p className="draw-option-description text-xs text-gray-600 mt-1">{option.description}</p>
                  </motion.div>
                ))}
              </div>
              
              <div className="lucky-draw-controls text-center mt-4">
                {error && (
                  <p className="text-red-500 text-sm mb-2">{error}</p>
                )}
                
                <Button
                  variant="gold"
                  onClick={handleDraw}
                  disabled={isDrawing || points < selectedPoints}
                  className="px-8 py-2"
                >
                  {isDrawing ? 'æŠ½å¥–ä¸­...' : 'æŠ½ å¥–'}
                </Button>
              </div>
            </motion.div>
          ) : (
            <motion.div
              key="lucky-draw-reward"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.3 }}
            >
              {renderRewardDisplay()}
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </ScrollDialog>
  );
};

export default LuckyDrawWheel;
</file>

<file path="src/components/game/README.md">
# æ¸¸æˆç»„ä»¶æ–‡æ¡£

æœ¬æ–‡æ¡£è®°å½•äº†PandaHabitåº”ç”¨ä¸­çš„æ¸¸æˆç»„ä»¶ï¼ŒåŒ…æ‹¬å®ƒä»¬çš„åŠŸèƒ½ã€å±æ€§å’Œä½¿ç”¨æ–¹æ³•ã€‚

## å¥–åŠ±å’Œèµ„æºç»„ä»¶

### RewardModal

`RewardModal` æ˜¯ä¸€ä¸ªç”¨äºå±•ç¤ºä»»åŠ¡å®Œæˆåè·å¾—çš„å¥–åŠ±çš„æ¨¡æ€æ¡†ç»„ä»¶ã€‚å®ƒä»¥å·è½´é£æ ¼å±•ç¤ºå¥–åŠ±ï¼Œå¹¶æ”¯æŒå¤šä¸ªå¥–åŠ±çš„å±•ç¤ºã€‚

#### å±æ€§

| å±æ€§å | ç±»å‹ | æè¿° |
|--------|------|------|
| isOpen | boolean | æ§åˆ¶æ¨¡æ€æ¡†æ˜¯å¦æ˜¾ç¤º |
| onClose | () => void | å…³é—­æ¨¡æ€æ¡†çš„å›è°ƒå‡½æ•° |
| rewards | RewardRecord[] | è¦å±•ç¤ºçš„å¥–åŠ±åˆ—è¡¨ |

#### ä½¿ç”¨ç¤ºä¾‹

```tsx
<RewardModal
  isOpen={showRewardModal}
  onClose={handleCloseRewardModal}
  rewards={rewards}
/>
```

### ResourceDisplay

`ResourceDisplay` æ˜¯ä¸€ä¸ªç”¨äºæ˜¾ç¤ºå„ç§ç±»å‹èµ„æºï¼ˆç»éªŒã€é‡‘å¸ã€ç‰©å“ç­‰ï¼‰çš„ç»„ä»¶ã€‚å®ƒæ”¯æŒä¸åŒçš„å°ºå¯¸ã€åŠ¨ç”»æ•ˆæœå’Œç‚¹å‡»äº¤äº’ã€‚

#### å±æ€§

| å±æ€§å | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|--------|------|--------|------|
| type | RewardType | å¿…å¡« | èµ„æºç±»å‹ |
| amount | number | å¿…å¡« | èµ„æºæ•°é‡ |
| rarity | RewardRarity | COMMON | èµ„æºç¨€æœ‰åº¦ |
| iconPath | string | æ ¹æ®ç±»å‹è‡ªåŠ¨é€‰æ‹© | èµ„æºå›¾æ ‡è·¯å¾„ |
| size | 'small' \| 'medium' \| 'large' | 'medium' | ç»„ä»¶å°ºå¯¸ |
| showLabel | boolean | true | æ˜¯å¦æ˜¾ç¤ºèµ„æºç±»å‹æ ‡ç­¾ |
| showAnimation | boolean | false | æ˜¯å¦æ˜¾ç¤ºæ•°é‡å˜åŒ–åŠ¨ç”» |
| onClick | () => void | undefined | ç‚¹å‡»å›è°ƒå‡½æ•° |
| className | string | '' | è‡ªå®šä¹‰CSSç±»å |

#### ä½¿ç”¨ç¤ºä¾‹

```tsx
<ResourceDisplay
  type={RewardType.COIN}
  amount={100}
  rarity={RewardRarity.RARE}
  size="large"
  showAnimation={true}
  onClick={() => console.log('Clicked on coins')}
/>
```

### ResourceList

`ResourceList` æ˜¯ä¸€ä¸ªç”¨äºæ˜¾ç¤ºå¤šç§èµ„æºçš„åˆ—è¡¨ç»„ä»¶ã€‚å®ƒå¯ä»¥æ°´å¹³æˆ–å‚ç›´æ’åˆ—å¤šä¸ªResourceDisplayç»„ä»¶ã€‚

#### å±æ€§

| å±æ€§å | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|--------|------|--------|------|
| resources | ResourceItem[] | å¿…å¡« | èµ„æºåˆ—è¡¨ |
| size | 'small' \| 'medium' \| 'large' | 'medium' | èµ„æºæ˜¾ç¤ºå°ºå¯¸ |
| showLabels | boolean | true | æ˜¯å¦æ˜¾ç¤ºèµ„æºç±»å‹æ ‡ç­¾ |
| showAnimation | boolean | false | æ˜¯å¦æ˜¾ç¤ºæ•°é‡å˜åŒ–åŠ¨ç”» |
| onResourceClick | (resource: ResourceItem) => void | undefined | èµ„æºç‚¹å‡»å›è°ƒå‡½æ•° |
| orientation | 'horizontal' \| 'vertical' | 'horizontal' | åˆ—è¡¨æ’åˆ—æ–¹å‘ |
| className | string | '' | è‡ªå®šä¹‰CSSç±»å |

#### ä½¿ç”¨ç¤ºä¾‹

```tsx
<ResourceList
  resources={[
    { id: 1, type: RewardType.EXPERIENCE, amount: 100 },
    { id: 2, type: RewardType.COIN, amount: 50 }
  ]}
  size="medium"
  showAnimation={true}
  onResourceClick={(resource) => console.log('Clicked on', resource)}
/>
```

### ResourceInventory

`ResourceInventory` æ˜¯ä¸€ä¸ªç”¨äºæ˜¾ç¤ºç©å®¶èµ„æºåº“å­˜çš„ç»„ä»¶ã€‚å®ƒè‡ªåŠ¨ä»æœåŠ¡ä¸­è·å–æœ€æ–°çš„èµ„æºæ•°æ®å¹¶æ˜¾ç¤ºã€‚

#### å±æ€§

| å±æ€§å | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|--------|------|--------|------|
| showExperience | boolean | true | æ˜¯å¦æ˜¾ç¤ºç»éªŒå€¼ |
| showCoins | boolean | true | æ˜¯å¦æ˜¾ç¤ºé‡‘å¸ |
| showItems | boolean | false | æ˜¯å¦æ˜¾ç¤ºç‰©å“ |
| showBadges | boolean | false | æ˜¯å¦æ˜¾ç¤ºå¾½ç«  |
| showAnimation | boolean | true | æ˜¯å¦æ˜¾ç¤ºæ•°é‡å˜åŒ–åŠ¨ç”» |
| size | 'small' \| 'medium' \| 'large' | 'medium' | èµ„æºæ˜¾ç¤ºå°ºå¯¸ |
| className | string | '' | è‡ªå®šä¹‰CSSç±»å |

#### ä½¿ç”¨ç¤ºä¾‹

```tsx
<ResourceInventory
  showExperience={true}
  showCoins={true}
  size="medium"
  showAnimation={true}
/>
```

## æŠ½å¥–å’Œåæ€ç»„ä»¶

### LuckyDraw

`LuckyDraw` æ˜¯ä¸€ä¸ªç”¨äºå®ç°å¹¸è¿æŠ½å¥–åŠŸèƒ½çš„ç»„ä»¶ã€‚å®ƒå…è®¸ç”¨æˆ·ä½¿ç”¨å¹¸è¿ç‚¹è¿›è¡ŒæŠ½å¥–ï¼Œå¹¶æ˜¾ç¤ºæŠ½å¥–ç»“æœã€‚

#### å±æ€§

| å±æ€§å | ç±»å‹ | æè¿° |
|--------|------|------|
| onClose | () => void | å…³é—­æŠ½å¥–ç»„ä»¶çš„å›è°ƒå‡½æ•° |
| onRewardEarned | (rewards: RewardRecord[]) => void | è·å¾—å¥–åŠ±åçš„å›è°ƒå‡½æ•° |

#### ä½¿ç”¨ç¤ºä¾‹

```tsx
<LuckyDraw
  onClose={handleCloseLuckyDraw}
  onRewardEarned={handleRewardEarned}
/>
```

### LuckyDrawWheel

`LuckyDrawWheel` æ˜¯ä¸€ä¸ªå¸¦æœ‰æ—‹è½¬è½®ç›˜çš„å¹¸è¿æŠ½å¥–ç»„ä»¶ã€‚å®ƒæä¾›äº†æ›´åä¸½çš„æŠ½å¥–ä½“éªŒï¼ŒåŒ…æ‹¬è½®ç›˜æ—‹è½¬åŠ¨ç”»å’Œå¥–åŠ±å±•ç¤ºã€‚

#### å±æ€§

| å±æ€§å | ç±»å‹ | æè¿° |
|--------|------|------|
| isOpen | boolean | æ§åˆ¶æŠ½å¥–ç»„ä»¶æ˜¯å¦æ˜¾ç¤º |
| onClose | () => void | å…³é—­æŠ½å¥–ç»„ä»¶çš„å›è°ƒå‡½æ•° |
| onRewardEarned | (rewards: RewardRecord[]) => void | è·å¾—å¥–åŠ±åçš„å›è°ƒå‡½æ•° |

#### ä½¿ç”¨ç¤ºä¾‹

```tsx
<LuckyDrawWheel
  isOpen={showLuckyDrawWheel}
  onClose={handleCloseLuckyDrawWheel}
  onRewardEarned={handleRewardEarned}
/>
```

### ReflectionModule

`ReflectionModule` æ˜¯ä¸€ä¸ªç”¨äºå¸®åŠ©ç”¨æˆ·åæ€ä»»åŠ¡å®Œæˆæƒ…å†µå’Œæƒ…ç»ªçŠ¶æ€çš„ç»„ä»¶ã€‚å®ƒæä¾›äº†ä¸€ä¸ªæ¸©å’Œã€éåˆ¤æ–­æ€§çš„å¯¹è¯ç³»ç»Ÿï¼Œå¸®åŠ©ç”¨æˆ·æ¢ç´¢å›°éš¾å¹¶æä¾›æ”¯æŒã€‚

#### å±æ€§

| å±æ€§å | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|--------|------|--------|------|
| isOpen | boolean | å¿…å¡« | æ§åˆ¶åæ€æ¨¡å—æ˜¯å¦æ˜¾ç¤º |
| onClose | () => void | å¿…å¡« | å…³é—­åæ€æ¨¡å—çš„å›è°ƒå‡½æ•° |
| taskName | string | undefined | ç›¸å…³ä»»åŠ¡åç§° |
| taskId | number | undefined | ç›¸å…³ä»»åŠ¡ID |
| mood | 'happy' \| 'neutral' \| 'sad' \| 'concerned' | undefined | åˆå§‹å¿ƒæƒ…çŠ¶æ€ |
| onReflectionComplete | (reflectionData) => void | undefined | åæ€å®Œæˆåçš„å›è°ƒå‡½æ•° |

#### ä½¿ç”¨ç¤ºä¾‹

```tsx
<ReflectionModule
  isOpen={showReflectionModule}
  onClose={handleCloseReflectionModule}
  taskName="æ¯æ—¥å†¥æƒ³"
  taskId={123}
  mood="concerned"
  onReflectionComplete={handleReflectionComplete}
/>
```

## æ³¨æ„äº‹é¡¹

1. æ‰€æœ‰ç»„ä»¶éƒ½éµå¾ªåä¸½æ¸¸æˆé£æ ¼è®¾è®¡ï¼ŒåŒ…æ‹¬ä¸­å›½é£å…ƒç´ ã€åŠ¨ç”»æ•ˆæœå’ŒéŸ³æ•ˆã€‚
2. ç»„ä»¶ä½¿ç”¨Framer Motionå®ç°åŠ¨ç”»æ•ˆæœï¼Œç¡®ä¿æµç•…çš„ç”¨æˆ·ä½“éªŒã€‚
3. ç»„ä»¶ä¸æ•°æ®æœåŠ¡é›†æˆï¼Œè‡ªåŠ¨æ›´æ–°å’ŒåŒæ­¥æ•°æ®ã€‚
4. æ‰€æœ‰ç»„ä»¶éƒ½æ”¯æŒè‡ªå®šä¹‰æ ·å¼å’Œè¡Œä¸ºï¼Œå¯ä»¥æ ¹æ®éœ€è¦è¿›è¡Œå®šåˆ¶ã€‚
5. ç»„ä»¶ä½¿ç”¨TypeScriptç¼–å†™ï¼Œæä¾›ç±»å‹å®‰å…¨å’Œä»£ç æç¤ºã€‚
</file>

<file path="src/components/game/ReflectionModule.tsx">
// src/components/game/ReflectionModule.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Button from '@/components/common/Button';
import ScrollDialog from './ScrollDialog';
import { playSound, SoundType } from '@/utils/sound';
import { TaskRecord } from '@/services/taskService';
import { getPandaMood, updatePandaMood } from '@/services/pandaStateService';

interface ReflectionModuleProps {
  isOpen: boolean;
  onClose: () => void;
  taskName?: string;
  taskId?: number;
  mood?: 'happy' | 'neutral' | 'sad' | 'concerned';
  onReflectionComplete?: (reflectionData: {
    taskId?: number;
    mood?: string;
    reflection: string;
    action: string;
  }) => void;
}

/**
 * åæ€æ¨¡å—ç»„ä»¶
 * ç”¨äºå¸®åŠ©ç”¨æˆ·åæ€ä»»åŠ¡å®Œæˆæƒ…å†µå’Œæƒ…ç»ªçŠ¶æ€
 */
const ReflectionModule: React.FC<ReflectionModuleProps> = ({
  isOpen,
  onClose,
  taskName,
  taskId,
  mood: initialMood,
  onReflectionComplete
}) => {
  const [step, setStep] = useState(1);
  const [mood, setMood] = useState<string>(initialMood || 'neutral');
  const [reflection, setReflection] = useState('');
  const [action, setAction] = useState('');
  const [suggestedActions, setSuggestedActions] = useState<string[]>([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [pandaMessage, setPandaMessage] = useState('');

  // æ ¹æ®ä»»åŠ¡åç§°å’Œå¿ƒæƒ…è®¾ç½®ç†ŠçŒ«æ¶ˆæ¯
  useEffect(() => {
    if (taskName) {
      if (mood === 'sad' || mood === 'concerned') {
        setPandaMessage(`æˆ‘æ³¨æ„åˆ°ä½ æœ€è¿‘åœ¨"${taskName}"è¿™ä¸ªä»»åŠ¡ä¸Šé‡åˆ°äº†ä¸€äº›å›°éš¾ã€‚æƒ³èŠèŠå—ï¼Ÿ`);
      } else {
        setPandaMessage('ä»Šå¤©æ„Ÿè§‰å¦‚ä½•ï¼Ÿæƒ³èŠ±ç‚¹æ—¶é—´åæ€ä¸€ä¸‹å—ï¼Ÿ');
      }
    } else if (mood === 'sad' || mood === 'concerned') {
      setPandaMessage('æˆ‘æ³¨æ„åˆ°ä½ æœ€è¿‘å¿ƒæƒ…ä¸å¤ªå¥½ã€‚æƒ³èŠèŠå—ï¼Ÿ');
    } else {
      setPandaMessage('ä»Šå¤©æ„Ÿè§‰å¦‚ä½•ï¼Ÿæƒ³èŠ±ç‚¹æ—¶é—´åæ€ä¸€ä¸‹å—ï¼Ÿ');
    }
  }, [taskName, mood]);

  // æ ¹æ®åæ€å†…å®¹ç”Ÿæˆå»ºè®®è¡ŒåŠ¨
  useEffect(() => {
    if (reflection && step === 2) {
      // è¿™é‡Œå¯ä»¥æ ¹æ®åæ€å†…å®¹ç”Ÿæˆå»ºè®®è¡ŒåŠ¨
      // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„ç®—æ³•æˆ–APIæ¥ç”Ÿæˆå»ºè®®
      const lowerReflection = reflection.toLowerCase();
      
      if (lowerReflection.includes('å‹åŠ›') || lowerReflection.includes('ç„¦è™‘') || lowerReflection.includes('ç´§å¼ ')) {
        setSuggestedActions([
          'å°è¯•5åˆ†é’Ÿçš„æ·±å‘¼å¸å†¥æƒ³',
          'å‡ºå»æ•£æ­¥15åˆ†é’Ÿ',
          'ä¸æœ‹å‹èŠå¤©åˆ†äº«æ„Ÿå—',
          'å†™ä¸‹ä¸‰ä»¶è®©ä½ æ„Ÿåˆ°æ„Ÿæ¿€çš„äº‹æƒ…'
        ]);
      } else if (lowerReflection.includes('ç–²æƒ«') || lowerReflection.includes('ç´¯') || lowerReflection.includes('æ²¡ç²¾åŠ›')) {
        setSuggestedActions([
          'ç¡®ä¿ä»Šæ™šæ—©ç‚¹ä¼‘æ¯',
          'å°è¯•20åˆ†é’Ÿçš„åˆä¼‘',
          'å‡å°‘ä»Šå¤©çš„ä»»åŠ¡é‡',
          'å–è¶³å¤Ÿçš„æ°´ï¼Œåƒäº›å¥åº·çš„é£Ÿç‰©'
        ]);
      } else if (lowerReflection.includes('æ‹–å»¶') || lowerReflection.includes('ä¸“æ³¨') || lowerReflection.includes('åˆ†å¿ƒ')) {
        setSuggestedActions([
          'ä½¿ç”¨ç•ªèŒ„å·¥ä½œæ³•ï¼Œä¸“æ³¨25åˆ†é’Ÿ',
          'å°†å¤§ä»»åŠ¡åˆ†è§£æˆå°æ­¥éª¤',
          'åˆ›å»ºä¸€ä¸ªæ— å¹²æ‰°çš„å·¥ä½œç¯å¢ƒ',
          'è®¾ç½®ä¸€ä¸ªå°çš„ã€å¯å®ç°çš„ç›®æ ‡'
        ]);
      } else {
        setSuggestedActions([
          'èŠ±5åˆ†é’Ÿè¿›è¡Œæ·±å‘¼å¸å†¥æƒ³',
          'å†™ä¸‹ä¸‰ä»¶è®©ä½ æ„Ÿåˆ°æ„Ÿæ¿€çš„äº‹æƒ…',
          'è®¾å®šä¸€ä¸ªå°çš„ã€å¯å®ç°çš„ç›®æ ‡',
          'ä¸æœ‹å‹æˆ–å®¶äººåˆ†äº«ä½ çš„æ„Ÿå—'
        ]);
      }
    }
  }, [reflection, step]);

  // å¤„ç†æäº¤åæ€
  const handleSubmit = async () => {
    try {
      setIsSubmitting(true);
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // å¦‚æœå¿ƒæƒ…ä¸å¥½ï¼Œå°è¯•æ›´æ–°ä¸ºä¸­æ€§
      if (mood === 'sad' || mood === 'concerned') {
        await updatePandaMood('neutral');
      }
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onReflectionComplete) {
        onReflectionComplete({
          taskId,
          mood,
          reflection,
          action
        });
      }
      
      // é‡ç½®çŠ¶æ€
      setStep(1);
      setReflection('');
      setAction('');
      
      // å…³é—­å¯¹è¯æ¡†
      onClose();
    } catch (error) {
      console.error('Failed to submit reflection:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  // å¤„ç†é€‰æ‹©å»ºè®®è¡ŒåŠ¨
  const handleSelectAction = (selectedAction: string) => {
    setAction(selectedAction);
  };

  // æ¸²æŸ“æ­¥éª¤1ï¼šåæ€è¾“å…¥
  const renderStep1 = () => (
    <div className="reflection-step">
      <div className="panda-message mb-4 p-3 bg-amber-50 rounded-lg border border-amber-200">
        <div className="flex items-start">
          <div className="panda-avatar mr-2">
            <span className="text-2xl">ğŸ¼</span>
          </div>
          <div className="panda-text">
            <p>{pandaMessage}</p>
          </div>
        </div>
      </div>
      
      <div className="reflection-input mb-4">
        <label htmlFor="reflection" className="block text-sm font-medium text-gray-700 mb-1">
          åˆ†äº«ä½ çš„æƒ³æ³•ï¼ˆå¯ä»¥æ˜¯ä»»ä½•æ„Ÿå—ã€å›°éš¾æˆ–æˆå°±ï¼‰
        </label>
        <textarea
          id="reflection"
          className="w-full h-32 p-2 border border-gray-300 rounded-md focus:ring-jade focus:border-jade"
          value={reflection}
          onChange={(e) => setReflection(e.target.value)}
          placeholder="ä»Šå¤©æˆ‘æ„Ÿè§‰..."
        />
      </div>
      
      <div className="reflection-actions flex justify-end">
        <Button variant="jade" onClick={() => setStep(2)} disabled={!reflection.trim()}>
          ç»§ç»­
        </Button>
      </div>
    </div>
  );

  // æ¸²æŸ“æ­¥éª¤2ï¼šè¡ŒåŠ¨é€‰æ‹©
  const renderStep2 = () => (
    <div className="reflection-step">
      <div className="panda-message mb-4 p-3 bg-amber-50 rounded-lg border border-amber-200">
        <div className="flex items-start">
          <div className="panda-avatar mr-2">
            <span className="text-2xl">ğŸ¼</span>
          </div>
          <div className="panda-text">
            <p>è°¢è°¢ä½ çš„åˆ†äº«ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¯èƒ½å¯¹ä½ æœ‰å¸®åŠ©çš„å°è¡ŒåŠ¨ï¼Œä½ å¯ä»¥é€‰æ‹©ä¸€ä¸ªå°è¯•ï¼Œæˆ–è€…åˆ›å»ºè‡ªå·±çš„è¡ŒåŠ¨ã€‚</p>
          </div>
        </div>
      </div>
      
      <div className="suggested-actions mb-4">
        <h3 className="text-sm font-medium text-gray-700 mb-2">å»ºè®®çš„è¡ŒåŠ¨</h3>
        <div className="grid grid-cols-1 gap-2">
          {suggestedActions.map((suggestedAction, index) => (
            <motion.div
              key={index}
              className={`p-2 border rounded-md cursor-pointer ${action === suggestedAction ? 'border-jade bg-jade-50' : 'border-gray-300'}`}
              onClick={() => handleSelectAction(suggestedAction)}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
            >
              {suggestedAction}
            </motion.div>
          ))}
        </div>
      </div>
      
      <div className="custom-action mb-4">
        <label htmlFor="custom-action" className="block text-sm font-medium text-gray-700 mb-1">
          æˆ–è€…ï¼Œåˆ›å»ºä½ è‡ªå·±çš„è¡ŒåŠ¨
        </label>
        <input
          id="custom-action"
          type="text"
          className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade focus:border-jade"
          value={action}
          onChange={(e) => setAction(e.target.value)}
          placeholder="æˆ‘å°†..."
        />
      </div>
      
      <div className="reflection-actions flex justify-between">
        <Button variant="secondary" onClick={() => setStep(1)}>
          è¿”å›
        </Button>
        <Button variant="gold" onClick={handleSubmit} disabled={!action.trim() || isSubmitting}>
          {isSubmitting ? 'æäº¤ä¸­...' : 'å®Œæˆåæ€'}
        </Button>
      </div>
    </div>
  );

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="é™å¿ƒèŒ¶å®¤"
      closeOnOutsideClick={false}
      closeOnEsc={true}
      showCloseButton={true}
    >
      <div className="reflection-module p-4">
        <AnimatePresence mode="wait">
          <motion.div
            key={`step-${step}`}
            initial={{ opacity: 0, x: step === 1 ? -20 : 20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: step === 1 ? 20 : -20 }}
            transition={{ duration: 0.3 }}
          >
            {step === 1 ? renderStep1() : renderStep2()}
          </motion.div>
        </AnimatePresence>
      </div>
    </ScrollDialog>
  );
};

export default ReflectionModule;
</file>

<file path="src/components/game/ResourceDisplay.tsx">
// src/components/game/ResourceDisplay.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { RewardType, RewardRarity } from '@/services/rewardService';
import { playSound, SoundType } from '@/utils/sound';

interface ResourceDisplayProps {
  type: RewardType;
  amount: number;
  rarity?: RewardRarity;
  iconPath?: string;
  size?: 'small' | 'medium' | 'large';
  showLabel?: boolean;
  showAnimation?: boolean;
  onClick?: () => void;
  className?: string;
}

/**
 * èµ„æºæ˜¾ç¤ºç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºå„ç§ç±»å‹çš„èµ„æºï¼ˆç»éªŒã€é‡‘å¸ã€ç‰©å“ç­‰ï¼‰
 */
const ResourceDisplay: React.FC<ResourceDisplayProps> = ({
  type,
  amount,
  rarity = RewardRarity.COMMON,
  iconPath,
  size = 'medium',
  showLabel = true,
  showAnimation = false,
  onClick,
  className = ''
}) => {
  const [isAnimating, setIsAnimating] = useState(false);
  const [displayAmount, setDisplayAmount] = useState(amount);
  const [prevAmount, setPrevAmount] = useState(amount);

  // å½“é‡‘é¢å˜åŒ–æ—¶è§¦å‘åŠ¨ç”»
  useEffect(() => {
    if (amount !== prevAmount && showAnimation) {
      // æ’­æ”¾éŸ³æ•ˆ
      if (amount > prevAmount) {
        // å¢åŠ èµ„æºæ—¶æ’­æ”¾è·å¾—éŸ³æ•ˆ
        playSound(SoundType.SUCCESS, 0.3);
      } else if (amount < prevAmount) {
        // å‡å°‘èµ„æºæ—¶æ’­æ”¾æ¶ˆè€—éŸ³æ•ˆ
        playSound(SoundType.BUTTON_CLICK, 0.3);
      }

      // è§¦å‘åŠ¨ç”»
      setIsAnimating(true);
      
      // æ›´æ–°æ˜¾ç¤ºé‡‘é¢
      const diff = amount - prevAmount;
      const duration = 1000; // åŠ¨ç”»æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
      const steps = 20; // åŠ¨ç”»æ­¥æ•°
      const stepTime = duration / steps;
      const stepAmount = diff / steps;
      
      let currentStep = 0;
      const interval = setInterval(() => {
        currentStep++;
        setDisplayAmount(prevAmount + stepAmount * currentStep);
        
        if (currentStep >= steps) {
          clearInterval(interval);
          setDisplayAmount(amount);
          setIsAnimating(false);
        }
      }, stepTime);
      
      // æ›´æ–°å‰ä¸€ä¸ªé‡‘é¢
      setPrevAmount(amount);
      
      // æ¸…ç†å‡½æ•°
      return () => {
        clearInterval(interval);
      };
    } else if (amount !== prevAmount) {
      // å¦‚æœä¸æ˜¾ç¤ºåŠ¨ç”»ï¼Œç›´æ¥æ›´æ–°é‡‘é¢
      setDisplayAmount(amount);
      setPrevAmount(amount);
    }
  }, [amount, prevAmount, showAnimation]);

  // è·å–èµ„æºç±»å‹çš„ä¸­æ–‡åç§°
  const getTypeName = (): string => {
    switch (type) {
      case RewardType.EXPERIENCE:
        return 'ç»éªŒ';
      case RewardType.COIN:
        return 'ç«¹å¸';
      case RewardType.ITEM:
        return 'ç‰©å“';
      case RewardType.BADGE:
        return 'å¾½ç« ';
      default:
        return 'èµ„æº';
    }
  };

  // è·å–é»˜è®¤å›¾æ ‡è·¯å¾„
  const getDefaultIconPath = (): string => {
    switch (type) {
      case RewardType.EXPERIENCE:
        return '/assets/rewards/experience.svg';
      case RewardType.COIN:
        return '/assets/rewards/coin.svg';
      case RewardType.ITEM:
        return `/assets/rewards/item_${rarity.toLowerCase()}.svg`;
      case RewardType.BADGE:
        return `/assets/rewards/badge_${rarity.toLowerCase()}.svg`;
      default:
        return '/assets/rewards/item_common.svg';
    }
  };

  // è·å–å°ºå¯¸æ ·å¼
  const getSizeStyle = (): { containerSize: string, iconSize: string, fontSize: string } => {
    switch (size) {
      case 'small':
        return {
          containerSize: 'w-16 h-8',
          iconSize: 'w-6 h-6',
          fontSize: 'text-xs'
        };
      case 'large':
        return {
          containerSize: 'w-32 h-16',
          iconSize: 'w-12 h-12',
          fontSize: 'text-lg'
        };
      default: // medium
        return {
          containerSize: 'w-24 h-12',
          iconSize: 'w-8 h-8',
          fontSize: 'text-sm'
        };
    }
  };

  // è·å–ç¨€æœ‰åº¦æ ·å¼
  const getRarityStyle = (): { borderColor: string, glowColor: string, textColor: string } => {
    switch (rarity) {
      case RewardRarity.LEGENDARY:
        return {
          borderColor: 'border-gold',
          glowColor: 'shadow-gold',
          textColor: 'text-gold'
        };
      case RewardRarity.EPIC:
        return {
          borderColor: 'border-purple-500',
          glowColor: 'shadow-purple',
          textColor: 'text-purple-500'
        };
      case RewardRarity.RARE:
        return {
          borderColor: 'border-blue-500',
          glowColor: 'shadow-blue',
          textColor: 'text-blue-500'
        };
      case RewardRarity.UNCOMMON:
        return {
          borderColor: 'border-green-500',
          glowColor: 'shadow-green',
          textColor: 'text-green-500'
        };
      default:
        return {
          borderColor: 'border-gray-300',
          glowColor: 'shadow-sm',
          textColor: 'text-gray-700'
        };
    }
  };

  const { containerSize, iconSize, fontSize } = getSizeStyle();
  const { borderColor, glowColor, textColor } = getRarityStyle();

  return (
    <motion.div
      className={`resource-display flex items-center ${containerSize} ${borderColor} border rounded-full bg-white ${glowColor} ${className}`}
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
      onClick={onClick}
      style={{ cursor: onClick ? 'pointer' : 'default' }}
    >
      {/* èµ„æºå›¾æ ‡ */}
      <div className={`resource-icon ${iconSize} flex-shrink-0 ml-1`}>
        <img
          src={iconPath || getDefaultIconPath()}
          alt={getTypeName()}
          className="w-full h-full object-contain"
          onError={(e) => {
            const target = e.target as HTMLImageElement;
            target.onerror = null;
            target.src = getDefaultIconPath();
          }}
        />
      </div>

      {/* èµ„æºæ•°é‡ */}
      <div className="resource-amount flex flex-col justify-center ml-1 flex-grow">
        <AnimatePresence mode="wait">
          <motion.div
            key={`amount-${displayAmount}`}
            initial={isAnimating ? { y: -10, opacity: 0 } : { y: 0, opacity: 1 }}
            animate={{ y: 0, opacity: 1 }}
            exit={{ y: 10, opacity: 0 }}
            transition={{ duration: 0.2 }}
            className={`${fontSize} font-bold ${textColor} text-center`}
          >
            {Math.round(displayAmount)}
          </motion.div>
        </AnimatePresence>
        
        {/* èµ„æºç±»å‹æ ‡ç­¾ */}
        {showLabel && (
          <div className={`resource-label text-xs text-gray-500 text-center`}>
            {getTypeName()}
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default ResourceDisplay;
</file>

<file path="src/components/game/ResourceInventory.tsx">
// src/components/game/ResourceInventory.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ResourceList from './ResourceList';
import ResourceDisplay from './ResourceDisplay';
import { RewardType, RewardRarity, getPlayerCoins } from '@/services/rewardService';
import { getPandaExperience } from '@/services/pandaStateService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import LoadingSpinner from '@/components/common/LoadingSpinner';

interface ResourceInventoryProps {
  showExperience?: boolean;
  showCoins?: boolean;
  showItems?: boolean;
  showBadges?: boolean;
  showAnimation?: boolean;
  size?: 'small' | 'medium' | 'large';
  className?: string;
}

/**
 * èµ„æºåº“å­˜ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºç©å®¶çš„èµ„æºåº“å­˜
 */
const ResourceInventory: React.FC<ResourceInventoryProps> = ({
  showExperience = true,
  showCoins = true,
  showItems = false,
  showBadges = false,
  showAnimation = true,
  size = 'medium',
  className = ''
}) => {
  const [experience, setExperience] = useState<number>(0);
  const [coins, setCoins] = useState<number>(0);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // åŠ è½½èµ„æºæ•°æ®
  const loadResourceData = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // è·å–ç»éªŒå€¼
      if (showExperience) {
        const exp = await getPandaExperience();
        setExperience(exp);
      }

      // è·å–é‡‘å¸
      if (showCoins) {
        const playerCoins = await getPlayerCoins();
        setCoins(playerCoins);
      }

      // è·å–ç‰©å“å’Œå¾½ç« çš„é€»è¾‘å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ 

    } catch (err) {
      console.error('Failed to load resource data:', err);
      setError('åŠ è½½èµ„æºæ•°æ®å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadResourceData();
  }, [showExperience, showCoins, showItems, showBadges]);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  const handleResourceDataUpdate = () => {
    loadResourceData();
  };

  // ç›‘å¬å¥–åŠ±è¡¨çš„å˜åŒ–
  useRegisterTableRefresh('rewards', handleResourceDataUpdate);

  // ç›‘å¬ç†ŠçŒ«çŠ¶æ€è¡¨çš„å˜åŒ–
  useRegisterTableRefresh('pandaState', handleResourceDataUpdate);

  // åˆ›å»ºèµ„æºåˆ—è¡¨
  const resources = [];

  if (showExperience) {
    resources.push({
      id: 1,
      type: RewardType.EXPERIENCE,
      amount: experience,
      rarity: RewardRarity.COMMON,
      iconPath: '/assets/rewards/experience.svg',
      name: 'ç»éªŒå€¼'
    });
  }

  if (showCoins) {
    resources.push({
      id: 2,
      type: RewardType.COIN,
      amount: coins,
      rarity: RewardRarity.COMMON,
      iconPath: '/assets/rewards/coin.svg',
      name: 'ç«¹å¸'
    });
  }

  // å®¹å™¨å˜ä½“
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        duration: 0.3
      }
    },
    exit: {
      opacity: 0,
      transition: {
        duration: 0.2
      }
    }
  };

  if (isLoading) {
    return (
      <div className={`resource-inventory-loading flex justify-center items-center p-4 ${className}`}>
        <LoadingSpinner variant="jade" size="small" />
      </div>
    );
  }

  if (error) {
    return (
      <div className={`resource-inventory-error text-red-500 text-center p-4 ${className}`}>
        {error}
      </div>
    );
  }

  return (
    <AnimatePresence mode="wait">
      <motion.div
        key="resource-inventory"
        className={`resource-inventory ${className}`}
        variants={containerVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <ResourceList
          resources={resources}
          size={size}
          showLabels={true}
          showAnimation={showAnimation}
          orientation="horizontal"
        />
      </motion.div>
    </AnimatePresence>
  );
};

export default ResourceInventory;
</file>

<file path="src/components/game/ResourceList.tsx">
// src/components/game/ResourceList.tsx
import React from 'react';
import { motion } from 'framer-motion';
import ResourceDisplay from './ResourceDisplay';
import { RewardType, RewardRarity } from '@/services/rewardService';

interface ResourceItem {
  id?: number;
  type: RewardType;
  amount: number;
  rarity?: RewardRarity;
  iconPath?: string;
  name?: string;
}

interface ResourceListProps {
  resources: ResourceItem[];
  size?: 'small' | 'medium' | 'large';
  showLabels?: boolean;
  showAnimation?: boolean;
  onResourceClick?: (resource: ResourceItem) => void;
  orientation?: 'horizontal' | 'vertical';
  className?: string;
}

/**
 * èµ„æºåˆ—è¡¨ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºå¤šç§èµ„æº
 */
const ResourceList: React.FC<ResourceListProps> = ({
  resources,
  size = 'medium',
  showLabels = true,
  showAnimation = false,
  onResourceClick,
  orientation = 'horizontal',
  className = ''
}) => {
  // å®¹å™¨å˜ä½“
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // é¡¹ç›®å˜ä½“
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  // å¤„ç†èµ„æºç‚¹å‡»
  const handleResourceClick = (resource: ResourceItem) => {
    if (onResourceClick) {
      onResourceClick(resource);
    }
  };

  return (
    <motion.div
      className={`resource-list ${orientation === 'horizontal' ? 'flex flex-row flex-wrap gap-2' : 'flex flex-col gap-2'} ${className}`}
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      {resources.map((resource, index) => (
        <motion.div
          key={`resource-${resource.id || index}`}
          variants={itemVariants}
          className="resource-list-item"
        >
          <ResourceDisplay
            type={resource.type}
            amount={resource.amount}
            rarity={resource.rarity}
            iconPath={resource.iconPath}
            size={size}
            showLabel={showLabels}
            showAnimation={showAnimation}
            onClick={() => handleResourceClick(resource)}
          />
        </motion.div>
      ))}
    </motion.div>
  );
};

export default ResourceList;
</file>

<file path="src/components/game/ScrollDialog.tsx">
// src/components/game/ScrollDialog.tsx
import React from 'react';
import { motion } from 'framer-motion';
import Modal from '@/components/common/Modal';
import Button from '@/components/common/Button';

interface ScrollDialogProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
  footer?: React.ReactNode;
  closeOnOutsideClick?: boolean;
  closeOnEsc?: boolean;
  showCloseButton?: boolean;
}

/**
 * å·è½´é£æ ¼å¯¹è¯æ¡†ç»„ä»¶
 * è®¾è®¡ä¸ºå¤ä»£å·è½´æ ·å¼ï¼Œé€‚åˆå±•ç¤ºé‡è¦ä¿¡æ¯ã€æˆå°±æˆ–æ•…äº‹å†…å®¹
 * 
 * @param isOpen - æ§åˆ¶å¯¹è¯æ¡†æ˜¯å¦æ˜¾ç¤º
 * @param onClose - å…³é—­å¯¹è¯æ¡†çš„å›è°ƒå‡½æ•°
 * @param title - å¯¹è¯æ¡†æ ‡é¢˜
 * @param children - å¯¹è¯æ¡†å†…å®¹
 * @param footer - å¯¹è¯æ¡†åº•éƒ¨å†…å®¹ï¼Œé€šå¸¸æ˜¯æŒ‰é’®
 * @param closeOnOutsideClick - æ˜¯å¦åœ¨ç‚¹å‡»å¤–éƒ¨åŒºåŸŸæ—¶å…³é—­ï¼Œé»˜è®¤ä¸ºtrue
 * @param closeOnEsc - æ˜¯å¦åœ¨æŒ‰ä¸‹ESCé”®æ—¶å…³é—­ï¼Œé»˜è®¤ä¸ºtrue
 * @param showCloseButton - æ˜¯å¦æ˜¾ç¤ºå…³é—­æŒ‰é’®ï¼Œé»˜è®¤ä¸ºtrue
 */
const ScrollDialog: React.FC<ScrollDialogProps> = ({
  isOpen,
  onClose,
  title,
  children,
  footer,
  closeOnOutsideClick = true,
  closeOnEsc = true,
  showCloseButton = true,
}) => {
  // é»˜è®¤åº•éƒ¨å†…å®¹
  const defaultFooter = (
    <Button variant="gold" onClick={onClose}>
      å…³é—­
    </Button>
  );

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      closeOnOutsideClick={closeOnOutsideClick}
      closeOnEsc={closeOnEsc}
      className="scroll-modal"
    >
      <div className="scroll-modal-header">
        <h3 className="scroll-modal-title">{title}</h3>
        {showCloseButton && (
          <motion.button
            className="scroll-modal-close"
            onClick={onClose}
            whileHover={{ scale: 1.1 }}
            whileTap={{ scale: 0.9 }}
            aria-label="å…³é—­"
          >
            Ã—
          </motion.button>
        )}
      </div>

      <div className="scroll-modal-content">
        {children}
      </div>

      {(footer || defaultFooter) && (
        <div className="scroll-modal-footer">
          {footer || defaultFooter}
        </div>
      )}
    </Modal>
  );
};

export default ScrollDialog;
</file>

<file path="src/components/game/SocialChallengeCard.tsx">
// src/components/game/SocialChallengeCard.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { SocialChallengeRecord, SocialChallengeType } from '@/services/socialChallengeService';
import { ChallengeDifficulty, ChallengeStatus } from '@/services/challengeService';
import Button from '@/components/common/Button';
import { playSound, SoundType } from '@/utils/sound';

interface SocialChallengeCardProps {
  challenge: SocialChallengeRecord;
  isParticipant?: boolean;
  onJoin?: (challengeId: number) => void;
  onLeave?: (challengeId: number) => void;
  onViewDetails?: (challengeId: number) => void;
  onShare?: (challengeId: number, inviteCode: string) => void;
}

/**
 * ç¤¾äº¤æŒ‘æˆ˜å¡ç‰‡ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºç¤¾äº¤æŒ‘æˆ˜å’Œç›¸å…³æ“ä½œ
 */
const SocialChallengeCard: React.FC<SocialChallengeCardProps> = ({
  challenge,
  isParticipant = false,
  onJoin,
  onLeave,
  onViewDetails,
  onShare
}) => {
  // å¤„ç†åŠ å…¥æŒ‘æˆ˜
  const handleJoin = (e: React.MouseEvent) => {
    e.stopPropagation();
    // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
    playSound(SoundType.BUTTON_CLICK, 0.5);
    
    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onJoin) {
      onJoin(challenge.id!);
    }
  };

  // å¤„ç†ç¦»å¼€æŒ‘æˆ˜
  const handleLeave = (e: React.MouseEvent) => {
    e.stopPropagation();
    // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
    playSound(SoundType.BUTTON_CLICK, 0.5);
    
    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onLeave) {
      onLeave(challenge.id!);
    }
  };

  // å¤„ç†æŸ¥çœ‹è¯¦æƒ…
  const handleViewDetails = () => {
    // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
    playSound(SoundType.BUTTON_CLICK, 0.3);
    
    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onViewDetails) {
      onViewDetails(challenge.id!);
    }
  };

  // å¤„ç†åˆ†äº«æŒ‘æˆ˜
  const handleShare = (e: React.MouseEvent) => {
    e.stopPropagation();
    // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
    playSound(SoundType.BUTTON_CLICK, 0.5);
    
    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onShare && challenge.inviteCode) {
      onShare(challenge.id!, challenge.inviteCode);
    }
  };

  // è·å–æŒ‘æˆ˜ç±»å‹æ ‡ç­¾å’Œæ ·å¼
  const getTypeInfo = (type: SocialChallengeType) => {
    switch (type) {
      case SocialChallengeType.COOPERATIVE:
        return { label: 'åˆä½œ', className: 'bg-green-100 text-green-800' };
      case SocialChallengeType.COMPETITIVE:
        return { label: 'ç«äº‰', className: 'bg-red-100 text-red-800' };
      case SocialChallengeType.TEAM:
        return { label: 'å›¢é˜Ÿ', className: 'bg-blue-100 text-blue-800' };
      default:
        return { label: 'æœªçŸ¥', className: 'bg-gray-100 text-gray-800' };
    }
  };

  // è·å–éš¾åº¦æ ‡ç­¾å’Œæ ·å¼
  const getDifficultyInfo = (difficulty: ChallengeDifficulty) => {
    switch (difficulty) {
      case ChallengeDifficulty.EASY:
        return { label: 'ç®€å•', className: 'bg-green-100 text-green-800' };
      case ChallengeDifficulty.MEDIUM:
        return { label: 'ä¸­ç­‰', className: 'bg-blue-100 text-blue-800' };
      case ChallengeDifficulty.HARD:
        return { label: 'å›°éš¾', className: 'bg-orange-100 text-orange-800' };
      case ChallengeDifficulty.EXPERT:
        return { label: 'ä¸“å®¶', className: 'bg-red-100 text-red-800' };
      default:
        return { label: 'æœªçŸ¥', className: 'bg-gray-100 text-gray-800' };
    }
  };

  // è·å–çŠ¶æ€æ ‡ç­¾å’Œæ ·å¼
  const getStatusInfo = (status: ChallengeStatus) => {
    switch (status) {
      case ChallengeStatus.ACTIVE:
        return { label: 'è¿›è¡Œä¸­', className: 'bg-green-100 text-green-800' };
      case ChallengeStatus.COMPLETED:
        return { label: 'å·²å®Œæˆ', className: 'bg-blue-100 text-blue-800' };
      case ChallengeStatus.FAILED:
        return { label: 'å¤±è´¥', className: 'bg-red-100 text-red-800' };
      case ChallengeStatus.UPCOMING:
        return { label: 'å³å°†å¼€å§‹', className: 'bg-amber-100 text-amber-800' };
      default:
        return { label: 'æœªçŸ¥', className: 'bg-gray-100 text-gray-800' };
    }
  };

  const typeInfo = getTypeInfo(challenge.type);
  const difficultyInfo = getDifficultyInfo(challenge.difficulty);
  const statusInfo = getStatusInfo(challenge.status);

  return (
    <motion.div
      className="social-challenge-card border rounded-lg overflow-hidden bg-white shadow-md hover:shadow-lg transition-shadow"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={handleViewDetails}
    >
      {/* å¡ç‰‡å¤´éƒ¨ */}
      <div className="card-header p-4 border-b border-gray-200">
        <div className="flex justify-between items-start">
          <div className="challenge-icon-title flex items-center">
            <div className="challenge-icon mr-3">
              <img
                src={challenge.iconPath || '/assets/challenges/social_default.svg'}
                alt={challenge.title}
                className="w-10 h-10 object-contain"
                onError={(e) => {
                  const target = e.target as HTMLImageElement;
                  target.onerror = null;
                  target.src = '/assets/challenges/social_default.svg';
                }}
              />
            </div>
            <div>
              <h3 className="text-lg font-bold">{challenge.title}</h3>
              <div className="challenge-meta flex flex-wrap gap-2 mt-1">
                <span className={`px-2 py-1 rounded-full text-xs ${typeInfo.className}`}>
                  {typeInfo.label}
                </span>
                <span className={`px-2 py-1 rounded-full text-xs ${difficultyInfo.className}`}>
                  {difficultyInfo.label}
                </span>
                <span className={`px-2 py-1 rounded-full text-xs ${statusInfo.className}`}>
                  {statusInfo.label}
                </span>
                {challenge.isPublic ? (
                  <span className="px-2 py-1 rounded-full text-xs bg-blue-100 text-blue-800">
                    å…¬å¼€
                  </span>
                ) : (
                  <span className="px-2 py-1 rounded-full text-xs bg-purple-100 text-purple-800">
                    ç§å¯†
                  </span>
                )}
              </div>
            </div>
          </div>
          <div className="challenge-participants">
            <span className="text-sm text-gray-600">
              {challenge.participantIds.length}/{challenge.maxParticipants} å‚ä¸è€…
            </span>
          </div>
        </div>
      </div>
      
      {/* å¡ç‰‡å†…å®¹ */}
      <div className="card-content p-4">
        <div className="challenge-description mb-4">
          <p className="text-sm text-gray-700 line-clamp-3">{challenge.description}</p>
        </div>
        
        <div className="challenge-progress mb-4">
          <div className="flex justify-between items-center mb-1">
            <span className="text-xs text-gray-600">è¿›åº¦</span>
            <span className="text-xs font-bold">{challenge.progress}%</span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-2.5">
            <div
              className="bg-jade-500 h-2.5 rounded-full"
              style={{ width: `${challenge.progress}%` }}
            ></div>
          </div>
        </div>
        
        <div className="challenge-dates text-xs text-gray-500 mb-2">
          <p>å¼€å§‹æ—¥æœŸ: {new Date(challenge.startDate).toLocaleDateString()}</p>
          {challenge.endDate && (
            <p>ç»“æŸæ—¥æœŸ: {new Date(challenge.endDate).toLocaleDateString()}</p>
          )}
        </div>
      </div>
      
      {/* å¡ç‰‡åº•éƒ¨ */}
      <div className="card-footer bg-gray-50 p-3 border-t border-gray-200 flex justify-end gap-2">
        {isParticipant ? (
          <>
            {challenge.inviteCode && (
              <Button
                variant="secondary"
                size="small"
                onClick={handleShare}
              >
                åˆ†äº«
              </Button>
            )}
            {challenge.status === ChallengeStatus.ACTIVE && challenge.creatorId !== 'current-user' && (
              <Button
                variant="danger"
                size="small"
                onClick={handleLeave}
              >
                é€€å‡º
              </Button>
            )}
          </>
        ) : (
          <Button
            variant="jade"
            size="small"
            onClick={handleJoin}
            disabled={
              challenge.status !== ChallengeStatus.ACTIVE ||
              challenge.participantIds.length >= challenge.maxParticipants
            }
          >
            åŠ å…¥
          </Button>
        )}
      </div>
    </motion.div>
  );
};

export default SocialChallengeCard;
</file>

<file path="src/components/game/SocialChallengeDetailDialog.tsx">
// src/components/game/SocialChallengeDetailDialog.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  SocialChallengeRecord, 
  SocialChallengeType,
  SocialChallengeParticipation,
  getSocialChallenge,
  getChallengeParticipations,
  joinSocialChallenge,
  leaveSocialChallenge,
  contributeToChallenge
} from '@/services/socialChallengeService';
import { ChallengeDifficulty, ChallengeStatus } from '@/services/challengeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from './ScrollDialog';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface SocialChallengeDetailDialogProps {
  isOpen: boolean;
  onClose: () => void;
  challengeId: number;
  onChallengeUpdated?: () => void;
}

/**
 * ç¤¾äº¤æŒ‘æˆ˜è¯¦æƒ…å¯¹è¯æ¡†ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºç¤¾äº¤æŒ‘æˆ˜çš„è¯¦ç»†ä¿¡æ¯å’Œå‚ä¸è€…åˆ—è¡¨
 */
const SocialChallengeDetailDialog: React.FC<SocialChallengeDetailDialogProps> = ({
  isOpen,
  onClose,
  challengeId,
  onChallengeUpdated
}) => {
  const [challenge, setChallenge] = useState<SocialChallengeRecord | null>(null);
  const [participations, setParticipations] = useState<SocialChallengeParticipation[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isJoining, setIsJoining] = useState(false);
  const [isLeaving, setIsLeaving] = useState(false);
  const [isContributing, setIsContributing] = useState(false);
  const [contributionAmount, setContributionAmount] = useState(10);
  const [inviteCode, setInviteCode] = useState('');
  const [showInviteCode, setShowInviteCode] = useState(false);
  
  // å½“å‰ç”¨æˆ·IDï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥ä»ç”¨æˆ·ä¼šè¯ä¸­è·å–ï¼‰
  const currentUserId = 'current-user';
  
  // æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æ˜¯å‚ä¸è€…
  const isParticipant = challenge?.participantIds.includes(currentUserId) || false;
  
  // æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æ˜¯åˆ›å»ºè€…
  const isCreator = challenge?.creatorId === currentUserId;

  // åŠ è½½æŒ‘æˆ˜æ•°æ®
  const loadChallengeData = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // è·å–æŒ‘æˆ˜æ•°æ®
      const challengeData = await getSocialChallenge(challengeId);
      if (challengeData) {
        setChallenge(challengeData);
        setInviteCode(challengeData.inviteCode || '');
        
        // è·å–å‚ä¸è®°å½•
        const participationData = await getChallengeParticipations(challengeId);
        setParticipations(participationData);
      } else {
        setError('æ— æ³•åŠ è½½æŒ‘æˆ˜æ•°æ®');
      }
    } catch (err) {
      console.error('Failed to load challenge data:', err);
      setError('åŠ è½½æŒ‘æˆ˜æ•°æ®å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    if (isOpen && challengeId) {
      loadChallengeData();
    }
  }, [isOpen, challengeId]);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('socialChallenges', loadChallengeData);
  useRegisterTableRefresh('socialChallengeParticipations', loadChallengeData);

  // å¤„ç†åŠ å…¥æŒ‘æˆ˜
  const handleJoin = async () => {
    if (!challenge) return;
    
    try {
      setIsJoining(true);
      setError(null);
      
      // åŠ å…¥æŒ‘æˆ˜
      await joinSocialChallenge(
        challengeId,
        currentUserId,
        challenge.isPublic ? undefined : inviteCode
      );
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // é‡æ–°åŠ è½½æ•°æ®
      await loadChallengeData();
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onChallengeUpdated) {
        onChallengeUpdated();
      }
    } catch (err) {
      console.error('Failed to join challenge:', err);
      setError('åŠ å…¥æŒ‘æˆ˜å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsJoining(false);
    }
  };

  // å¤„ç†ç¦»å¼€æŒ‘æˆ˜
  const handleLeave = async () => {
    try {
      setIsLeaving(true);
      setError(null);
      
      // ç¦»å¼€æŒ‘æˆ˜
      await leaveSocialChallenge(challengeId, currentUserId);
      
      // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
      playSound(SoundType.BUTTON_CLICK, 0.5);
      
      // é‡æ–°åŠ è½½æ•°æ®
      await loadChallengeData();
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onChallengeUpdated) {
        onChallengeUpdated();
      }
    } catch (err) {
      console.error('Failed to leave challenge:', err);
      setError('ç¦»å¼€æŒ‘æˆ˜å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLeaving(false);
    }
  };

  // å¤„ç†è´¡çŒ®è¿›åº¦
  const handleContribute = async () => {
    try {
      setIsContributing(true);
      setError(null);
      
      // è´¡çŒ®è¿›åº¦
      await contributeToChallenge(challengeId, currentUserId, contributionAmount);
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // é‡æ–°åŠ è½½æ•°æ®
      await loadChallengeData();
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onChallengeUpdated) {
        onChallengeUpdated();
      }
    } catch (err) {
      console.error('Failed to contribute to challenge:', err);
      setError('è´¡çŒ®è¿›åº¦å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsContributing(false);
    }
  };

  // å¤„ç†å¤åˆ¶é‚€è¯·ç 
  const handleCopyInviteCode = () => {
    if (!inviteCode) return;
    
    navigator.clipboard.writeText(inviteCode)
      .then(() => {
        // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
        playSound(SoundType.SUCCESS, 0.3);
        alert('é‚€è¯·ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
      })
      .catch(err => {
        console.error('Failed to copy invite code:', err);
        alert('å¤åˆ¶é‚€è¯·ç å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶');
      });
  };

  // è·å–æŒ‘æˆ˜ç±»å‹æ ‡ç­¾
  const getTypeLabel = (type: SocialChallengeType): string => {
    switch (type) {
      case SocialChallengeType.COOPERATIVE:
        return 'åˆä½œå‹';
      case SocialChallengeType.COMPETITIVE:
        return 'ç«äº‰å‹';
      case SocialChallengeType.TEAM:
        return 'å›¢é˜Ÿå‹';
      default:
        return 'æœªçŸ¥';
    }
  };

  // è·å–éš¾åº¦æ ‡ç­¾
  const getDifficultyLabel = (difficulty: ChallengeDifficulty): string => {
    switch (difficulty) {
      case ChallengeDifficulty.EASY:
        return 'ç®€å•';
      case ChallengeDifficulty.MEDIUM:
        return 'ä¸­ç­‰';
      case ChallengeDifficulty.HARD:
        return 'å›°éš¾';
      case ChallengeDifficulty.EXPERT:
        return 'ä¸“å®¶';
      default:
        return 'æœªçŸ¥';
    }
  };

  // è·å–çŠ¶æ€æ ‡ç­¾
  const getStatusLabel = (status: ChallengeStatus): string => {
    switch (status) {
      case ChallengeStatus.ACTIVE:
        return 'è¿›è¡Œä¸­';
      case ChallengeStatus.COMPLETED:
        return 'å·²å®Œæˆ';
      case ChallengeStatus.FAILED:
        return 'å¤±è´¥';
      case ChallengeStatus.UPCOMING:
        return 'å³å°†å¼€å§‹';
      default:
        return 'æœªçŸ¥';
    }
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="ç¤¾äº¤æŒ‘æˆ˜è¯¦æƒ…"
      closeOnOutsideClick={!isJoining && !isLeaving && !isContributing}
      closeOnEsc={!isJoining && !isLeaving && !isContributing}
      showCloseButton={!isJoining && !isLeaving && !isContributing}
    >
      <div className="social-challenge-detail p-4">
        {isLoading ? (
          <div className="loading-container flex justify-center items-center h-64">
            <LoadingSpinner variant="jade" size="medium" />
          </div>
        ) : error ? (
          <div className="error-container text-center p-4">
            <div className="error-message text-red-500 mb-4">{error}</div>
            <Button variant="jade" onClick={loadChallengeData}>
              é‡è¯•
            </Button>
          </div>
        ) : challenge ? (
          <div className="challenge-content">
            {/* æŒ‘æˆ˜å¤´éƒ¨ */}
            <div className="challenge-header mb-6">
              <div className="flex items-center mb-3">
                <div className="challenge-icon mr-4">
                  <img
                    src={challenge.iconPath || '/assets/challenges/social_default.svg'}
                    alt={challenge.title}
                    className="w-16 h-16 object-contain"
                    onError={(e) => {
                      const target = e.target as HTMLImageElement;
                      target.onerror = null;
                      target.src = '/assets/challenges/social_default.svg';
                    }}
                  />
                </div>
                <div>
                  <h2 className="text-2xl font-bold">{challenge.title}</h2>
                  <div className="challenge-meta flex flex-wrap gap-2 mt-1">
                    <span className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800">
                      {getTypeLabel(challenge.type)}
                    </span>
                    <span className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800">
                      {getDifficultyLabel(challenge.difficulty)}
                    </span>
                    <span className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800">
                      {getStatusLabel(challenge.status)}
                    </span>
                    {challenge.isPublic ? (
                      <span className="px-2 py-1 rounded-full text-xs bg-blue-100 text-blue-800">
                        å…¬å¼€
                      </span>
                    ) : (
                      <span className="px-2 py-1 rounded-full text-xs bg-purple-100 text-purple-800">
                        ç§å¯†
                      </span>
                    )}
                  </div>
                </div>
              </div>
              
              <div className="challenge-description mb-4">
                <p className="text-gray-700">{challenge.description}</p>
              </div>
              
              <div className="challenge-dates text-sm text-gray-600 mb-4">
                <p>å¼€å§‹æ—¥æœŸ: {new Date(challenge.startDate).toLocaleDateString()}</p>
                {challenge.endDate && (
                  <p>ç»“æŸæ—¥æœŸ: {new Date(challenge.endDate).toLocaleDateString()}</p>
                )}
                <p>åˆ›å»ºæ—¥æœŸ: {new Date(challenge.createdAt).toLocaleDateString()}</p>
              </div>
              
              <div className="challenge-progress mb-4">
                <div className="flex justify-between items-center mb-1">
                  <span className="text-sm text-gray-600">è¿›åº¦</span>
                  <span className="text-sm font-bold">{challenge.progress}%</span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2.5">
                  <div
                    className="bg-jade-500 h-2.5 rounded-full"
                    style={{ width: `${challenge.progress}%` }}
                  ></div>
                </div>
              </div>
              
              {/* é‚€è¯·ç ï¼ˆä»…å¯¹å‚ä¸è€…æ˜¾ç¤ºï¼‰ */}
              {isParticipant && !challenge.isPublic && (
                <div className="invite-code-section mb-4">
                  <div className="flex items-center justify-between">
                    <h3 className="text-md font-bold">é‚€è¯·ç </h3>
                    <Button
                      variant="secondary"
                      size="small"
                      onClick={() => setShowInviteCode(!showInviteCode)}
                    >
                      {showInviteCode ? 'éšè—' : 'æ˜¾ç¤º'}
                    </Button>
                  </div>
                  {showInviteCode && (
                    <div className="invite-code-display mt-2 flex items-center">
                      <div className="invite-code bg-gray-100 p-2 rounded-md font-mono">
                        {inviteCode}
                      </div>
                      <Button
                        variant="secondary"
                        size="small"
                        className="ml-2"
                        onClick={handleCopyInviteCode}
                      >
                        å¤åˆ¶
                      </Button>
                    </div>
                  )}
                </div>
              )}
            </div>
            
            {/* å‚ä¸è€…åˆ—è¡¨ */}
            <div className="participants-section mb-6">
              <h3 className="text-lg font-bold mb-2">å‚ä¸è€… ({challenge.participantIds.length}/{challenge.maxParticipants})</h3>
              <div className="participants-list bg-gray-50 p-3 rounded-md">
                {participations.length > 0 ? (
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                    {participations.map((participation) => (
                      <div
                        key={participation.id}
                        className="participant-item flex items-center justify-between p-2 border-b border-gray-200 last:border-b-0"
                      >
                        <div className="participant-info">
                          <div className="flex items-center">
                            <div className="participant-avatar mr-2">
                              <div className="w-8 h-8 bg-gray-300 rounded-full flex items-center justify-center">
                                <span className="text-gray-600">
                                  {participation.userId.charAt(0).toUpperCase()}
                                </span>
                              </div>
                            </div>
                            <div>
                              <p className="text-sm font-medium">
                                {participation.userId === challenge.creatorId ? (
                                  <span className="flex items-center">
                                    {participation.userId}
                                    <span className="ml-1 text-xs px-1 py-0.5 bg-amber-100 text-amber-800 rounded">åˆ›å»ºè€…</span>
                                  </span>
                                ) : (
                                  participation.userId
                                )}
                              </p>
                              <p className="text-xs text-gray-500">
                                åŠ å…¥äº {new Date(participation.joinedAt).toLocaleDateString()}
                              </p>
                            </div>
                          </div>
                        </div>
                        <div className="participant-contribution">
                          <span className="text-sm font-bold">{participation.contribution}</span>
                          <span className="text-xs text-gray-500 ml-1">è´¡çŒ®</span>
                        </div>
                      </div>
                    ))}
                  </div>
                ) : (
                  <p className="text-center text-gray-500 py-2">æš‚æ— å‚ä¸è€…</p>
                )}
              </div>
            </div>
            
            {/* æ“ä½œåŒºåŸŸ */}
            <div className="actions-section">
              {isParticipant ? (
                <div className="participant-actions">
                  {/* è´¡çŒ®è¿›åº¦ï¼ˆä»…å¯¹æ´»è·ƒæŒ‘æˆ˜æ˜¾ç¤ºï¼‰ */}
                  {challenge.status === ChallengeStatus.ACTIVE && (
                    <div className="contribute-section mb-4">
                      <h3 className="text-lg font-bold mb-2">è´¡çŒ®è¿›åº¦</h3>
                      <div className="flex items-center">
                        <input
                          type="range"
                          min="1"
                          max="20"
                          value={contributionAmount}
                          onChange={(e) => setContributionAmount(parseInt(e.target.value))}
                          className="flex-grow mr-2"
                        />
                        <span className="text-lg font-bold w-8 text-center">{contributionAmount}</span>
                      </div>
                      <Button
                        variant="jade"
                        onClick={handleContribute}
                        disabled={isContributing || challenge.progress >= 100}
                        className="mt-2 w-full"
                      >
                        {isContributing ? (
                          <LoadingSpinner variant="white" size="small" />
                        ) : (
                          'è´¡çŒ®è¿›åº¦'
                        )}
                      </Button>
                    </div>
                  )}
                  
                  {/* ç¦»å¼€æŒ‘æˆ˜æŒ‰é’®ï¼ˆéåˆ›å»ºè€…å¯è§ï¼‰ */}
                  {!isCreator && challenge.status === ChallengeStatus.ACTIVE && (
                    <Button
                      variant="danger"
                      onClick={handleLeave}
                      disabled={isLeaving}
                      className="w-full"
                    >
                      {isLeaving ? (
                        <LoadingSpinner variant="white" size="small" />
                      ) : (
                        'ç¦»å¼€æŒ‘æˆ˜'
                      )}
                    </Button>
                  )}
                </div>
              ) : (
                <div className="non-participant-actions">
                  {/* åŠ å…¥æŒ‘æˆ˜æŒ‰é’® */}
                  {challenge.status === ChallengeStatus.ACTIVE && challenge.participantIds.length < challenge.maxParticipants && (
                    <div>
                      {!challenge.isPublic && (
                        <div className="invite-code-input mb-2">
                          <label htmlFor="inviteCode" className="block text-sm font-medium text-gray-700 mb-1">
                            é‚€è¯·ç 
                          </label>
                          <input
                            type="text"
                            id="inviteCode"
                            value={inviteCode}
                            onChange={(e) => setInviteCode(e.target.value)}
                            className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
                            placeholder="è¾“å…¥é‚€è¯·ç "
                            required={!challenge.isPublic}
                          />
                        </div>
                      )}
                      <Button
                        variant="jade"
                        onClick={handleJoin}
                        disabled={isJoining || (!challenge.isPublic && !inviteCode)}
                        className="w-full"
                      >
                        {isJoining ? (
                          <LoadingSpinner variant="white" size="small" />
                        ) : (
                          'åŠ å…¥æŒ‘æˆ˜'
                        )}
                      </Button>
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        ) : (
          <div className="not-found-container text-center p-4">
            <p className="text-gray-500">æŒ‘æˆ˜ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤</p>
          </div>
        )}
      </div>
    </ScrollDialog>
  );
};

export default SocialChallengeDetailDialog;
</file>

<file path="src/components/game/SocialChallengeForm.tsx">
// src/components/game/SocialChallengeForm.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { 
  SocialChallengeRecord, 
  SocialChallengeType,
  createSocialChallenge
} from '@/services/socialChallengeService';
import { ChallengeDifficulty, ChallengeStatus } from '@/services/challengeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from './ScrollDialog';

interface SocialChallengeFormProps {
  isOpen: boolean;
  onClose: () => void;
  onChallengeCreated?: (challenge: SocialChallengeRecord) => void;
}

/**
 * ç¤¾äº¤æŒ‘æˆ˜è¡¨å•ç»„ä»¶
 * ç”¨äºåˆ›å»ºæ–°çš„ç¤¾äº¤æŒ‘æˆ˜
 */
const SocialChallengeForm: React.FC<SocialChallengeFormProps> = ({
  isOpen,
  onClose,
  onChallengeCreated
}) => {
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [type, setType] = useState<SocialChallengeType>(SocialChallengeType.COOPERATIVE);
  const [difficulty, setDifficulty] = useState<ChallengeDifficulty>(ChallengeDifficulty.MEDIUM);
  const [maxParticipants, setMaxParticipants] = useState(5);
  const [isPublic, setIsPublic] = useState(true);
  const [startDate, setStartDate] = useState<string>(new Date().toISOString().split('T')[0]);
  const [endDate, setEndDate] = useState<string>('');
  const [iconPath, setIconPath] = useState('');
  
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // å¤„ç†æäº¤è¡¨å•
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!title.trim()) {
      setError('è¯·è¾“å…¥æŒ‘æˆ˜æ ‡é¢˜');
      return;
    }
    
    if (!description.trim()) {
      setError('è¯·è¾“å…¥æŒ‘æˆ˜æè¿°');
      return;
    }
    
    if (!startDate) {
      setError('è¯·é€‰æ‹©å¼€å§‹æ—¥æœŸ');
      return;
    }
    
    try {
      setIsSubmitting(true);
      setError(null);
      
      // åˆ›å»ºç¤¾äº¤æŒ‘æˆ˜
      const challenge = await createSocialChallenge({
        title: title.trim(),
        description: description.trim(),
        type,
        difficulty,
        status: ChallengeStatus.ACTIVE,
        creatorId: 'current-user', // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥æ˜¯å½“å‰ç”¨æˆ·çš„ID
        maxParticipants,
        startDate: new Date(startDate),
        endDate: endDate ? new Date(endDate) : undefined,
        iconPath: iconPath || undefined,
        isPublic
      });
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // é‡ç½®è¡¨å•
      resetForm();
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onChallengeCreated) {
        onChallengeCreated(challenge);
      }
      
      // å…³é—­å¯¹è¯æ¡†
      onClose();
    } catch (err) {
      console.error('Failed to create social challenge:', err);
      setError('åˆ›å»ºæŒ‘æˆ˜å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsSubmitting(false);
    }
  };

  // é‡ç½®è¡¨å•
  const resetForm = () => {
    setTitle('');
    setDescription('');
    setType(SocialChallengeType.COOPERATIVE);
    setDifficulty(ChallengeDifficulty.MEDIUM);
    setMaxParticipants(5);
    setIsPublic(true);
    setStartDate(new Date().toISOString().split('T')[0]);
    setEndDate('');
    setIconPath('');
    setError(null);
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="åˆ›å»ºç¤¾äº¤æŒ‘æˆ˜"
      closeOnOutsideClick={!isSubmitting}
      closeOnEsc={!isSubmitting}
      showCloseButton={!isSubmitting}
    >
      <div className="social-challenge-form p-4">
        <form onSubmit={handleSubmit}>
          {error && (
            <div className="error-message text-red-500 mb-4 p-2 bg-red-50 rounded-md">
              {error}
            </div>
          )}
          
          {/* æŒ‘æˆ˜æ ‡é¢˜ */}
          <div className="form-group mb-4">
            <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-1">
              æŒ‘æˆ˜æ ‡é¢˜ <span className="text-red-500">*</span>
            </label>
            <input
              type="text"
              id="title"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
              placeholder="è¾“å…¥æŒ‘æˆ˜æ ‡é¢˜"
              required
            />
          </div>
          
          {/* æŒ‘æˆ˜æè¿° */}
          <div className="form-group mb-4">
            <label htmlFor="description" className="block text-sm font-medium text-gray-700 mb-1">
              æŒ‘æˆ˜æè¿° <span className="text-red-500">*</span>
            </label>
            <textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500 h-24"
              placeholder="è¾“å…¥æŒ‘æˆ˜æè¿°"
              required
            />
          </div>
          
          {/* æŒ‘æˆ˜ç±»å‹ */}
          <div className="form-group mb-4">
            <label htmlFor="type" className="block text-sm font-medium text-gray-700 mb-1">
              æŒ‘æˆ˜ç±»å‹ <span className="text-red-500">*</span>
            </label>
            <select
              id="type"
              value={type}
              onChange={(e) => setType(e.target.value as SocialChallengeType)}
              className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
              required
            >
              <option value={SocialChallengeType.COOPERATIVE}>åˆä½œå‹</option>
              <option value={SocialChallengeType.COMPETITIVE}>ç«äº‰å‹</option>
              <option value={SocialChallengeType.TEAM}>å›¢é˜Ÿå‹</option>
            </select>
          </div>
          
          {/* æŒ‘æˆ˜éš¾åº¦ */}
          <div className="form-group mb-4">
            <label htmlFor="difficulty" className="block text-sm font-medium text-gray-700 mb-1">
              æŒ‘æˆ˜éš¾åº¦ <span className="text-red-500">*</span>
            </label>
            <select
              id="difficulty"
              value={difficulty}
              onChange={(e) => setDifficulty(e.target.value as ChallengeDifficulty)}
              className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
              required
            >
              <option value={ChallengeDifficulty.EASY}>ç®€å•</option>
              <option value={ChallengeDifficulty.MEDIUM}>ä¸­ç­‰</option>
              <option value={ChallengeDifficulty.HARD}>å›°éš¾</option>
              <option value={ChallengeDifficulty.EXPERT}>ä¸“å®¶</option>
            </select>
          </div>
          
          {/* æœ€å¤§å‚ä¸äººæ•° */}
          <div className="form-group mb-4">
            <label htmlFor="maxParticipants" className="block text-sm font-medium text-gray-700 mb-1">
              æœ€å¤§å‚ä¸äººæ•° <span className="text-red-500">*</span>
            </label>
            <input
              type="number"
              id="maxParticipants"
              value={maxParticipants}
              onChange={(e) => setMaxParticipants(parseInt(e.target.value))}
              min={2}
              max={20}
              className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
              required
            />
          </div>
          
          {/* æ˜¯å¦å…¬å¼€ */}
          <div className="form-group mb-4">
            <div className="flex items-center">
              <input
                type="checkbox"
                id="isPublic"
                checked={isPublic}
                onChange={(e) => setIsPublic(e.target.checked)}
                className="h-4 w-4 text-jade-600 focus:ring-jade-500 border-gray-300 rounded"
              />
              <label htmlFor="isPublic" className="ml-2 block text-sm text-gray-700">
                å…¬å¼€æŒ‘æˆ˜ï¼ˆä»»ä½•äººéƒ½å¯ä»¥åŠ å…¥ï¼‰
              </label>
            </div>
          </div>
          
          {/* æ—¥æœŸé€‰æ‹© */}
          <div className="form-group mb-4 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label htmlFor="startDate" className="block text-sm font-medium text-gray-700 mb-1">
                å¼€å§‹æ—¥æœŸ <span className="text-red-500">*</span>
              </label>
              <input
                type="date"
                id="startDate"
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
                className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
                required
              />
            </div>
            <div>
              <label htmlFor="endDate" className="block text-sm font-medium text-gray-700 mb-1">
                ç»“æŸæ—¥æœŸ
              </label>
              <input
                type="date"
                id="endDate"
                value={endDate}
                onChange={(e) => setEndDate(e.target.value)}
                min={startDate}
                className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
              />
            </div>
          </div>
          
          {/* å›¾æ ‡è·¯å¾„ */}
          <div className="form-group mb-4">
            <label htmlFor="iconPath" className="block text-sm font-medium text-gray-700 mb-1">
              å›¾æ ‡è·¯å¾„
            </label>
            <input
              type="text"
              id="iconPath"
              value={iconPath}
              onChange={(e) => setIconPath(e.target.value)}
              className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
              placeholder="/assets/challenges/social_default.svg"
            />
          </div>
          
          {/* æäº¤æŒ‰é’® */}
          <div className="form-actions flex justify-end gap-2 mt-6">
            <Button
              variant="secondary"
              type="button"
              onClick={onClose}
              disabled={isSubmitting}
            >
              å–æ¶ˆ
            </Button>
            <Button
              variant="jade"
              type="submit"
              disabled={isSubmitting}
            >
              {isSubmitting ? (
                <LoadingSpinner variant="white" size="small" />
              ) : (
                'åˆ›å»ºæŒ‘æˆ˜'
              )}
            </Button>
          </div>
        </form>
      </div>
    </ScrollDialog>
  );
};

export default SocialChallengeForm;
</file>

<file path="src/components/game/SocialChallengeList.tsx">
// src/components/game/SocialChallengeList.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  SocialChallengeRecord, 
  SocialChallengeType,
  getAllSocialChallenges,
  getUserSocialChallenges,
  getPublicSocialChallenges,
  joinSocialChallenge,
  leaveSocialChallenge
} from '@/services/socialChallengeService';
import { ChallengeStatus } from '@/services/challengeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import SocialChallengeCard from './SocialChallengeCard';
import SocialChallengeForm from './SocialChallengeForm';
import SocialChallengeDetailDialog from './SocialChallengeDetailDialog';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface SocialChallengeListProps {
  filter?: 'all' | 'my' | 'public';
  maxItems?: number;
  showCreateButton?: boolean;
  className?: string;
}

/**
 * ç¤¾äº¤æŒ‘æˆ˜åˆ—è¡¨ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºç¤¾äº¤æŒ‘æˆ˜åˆ—è¡¨
 */
const SocialChallengeList: React.FC<SocialChallengeListProps> = ({
  filter = 'all',
  maxItems,
  showCreateButton = true,
  className = ''
}) => {
  const [challenges, setChallenges] = useState<SocialChallengeRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [selectedChallengeId, setSelectedChallengeId] = useState<number | null>(null);
  const [showDetailDialog, setShowDetailDialog] = useState(false);
  const [joinInviteCode, setJoinInviteCode] = useState('');
  
  // å½“å‰ç”¨æˆ·IDï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥ä»ç”¨æˆ·ä¼šè¯ä¸­è·å–ï¼‰
  const currentUserId = 'current-user';

  // åŠ è½½æŒ‘æˆ˜æ•°æ®
  const loadChallenges = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      let challengesList: SocialChallengeRecord[] = [];
      
      // æ ¹æ®è¿‡æ»¤æ¡ä»¶è·å–æŒ‘æˆ˜
      switch (filter) {
        case 'my':
          challengesList = await getUserSocialChallenges(currentUserId);
          break;
        case 'public':
          challengesList = await getPublicSocialChallenges();
          break;
        default:
          challengesList = await getAllSocialChallenges();
          break;
      }
      
      // é™åˆ¶æ•°é‡
      if (maxItems && challengesList.length > maxItems) {
        challengesList = challengesList.slice(0, maxItems);
      }
      
      setChallenges(challengesList);
    } catch (err) {
      console.error('Failed to load social challenges:', err);
      setError('åŠ è½½ç¤¾äº¤æŒ‘æˆ˜å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadChallenges();
  }, [filter, maxItems]);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('socialChallenges', loadChallenges);
  useRegisterTableRefresh('socialChallengeParticipations', loadChallenges);

  // å¤„ç†åˆ›å»ºæŒ‘æˆ˜
  const handleCreateChallenge = () => {
    setShowCreateForm(true);
  };

  // å¤„ç†æŒ‘æˆ˜åˆ›å»ºå®Œæˆ
  const handleChallengeCreated = (challenge: SocialChallengeRecord) => {
    // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
    playSound(SoundType.SUCCESS, 0.5);
    
    // é‡æ–°åŠ è½½æŒ‘æˆ˜
    loadChallenges();
  };

  // å¤„ç†åŠ å…¥æŒ‘æˆ˜
  const handleJoinChallenge = async (challengeId: number) => {
    try {
      // è·å–æŒ‘æˆ˜
      const challenge = challenges.find(c => c.id === challengeId);
      if (!challenge) return;
      
      // å¦‚æœæ˜¯éå…¬å¼€æŒ‘æˆ˜ï¼Œéœ€è¦é‚€è¯·ç 
      if (!challenge.isPublic) {
        const code = prompt('è¯·è¾“å…¥é‚€è¯·ç ');
        if (!code) return;
        setJoinInviteCode(code);
      }
      
      // åŠ å…¥æŒ‘æˆ˜
      await joinSocialChallenge(
        challengeId,
        currentUserId,
        challenge.isPublic ? undefined : joinInviteCode
      );
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // é‡æ–°åŠ è½½æŒ‘æˆ˜
      loadChallenges();
    } catch (err) {
      console.error('Failed to join challenge:', err);
      alert('åŠ å…¥æŒ‘æˆ˜å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };

  // å¤„ç†ç¦»å¼€æŒ‘æˆ˜
  const handleLeaveChallenge = async (challengeId: number) => {
    try {
      // ç¡®è®¤ç¦»å¼€
      if (!confirm('ç¡®å®šè¦ç¦»å¼€è¿™ä¸ªæŒ‘æˆ˜å—ï¼Ÿ')) return;
      
      // ç¦»å¼€æŒ‘æˆ˜
      await leaveSocialChallenge(challengeId, currentUserId);
      
      // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
      playSound(SoundType.BUTTON_CLICK, 0.5);
      
      // é‡æ–°åŠ è½½æŒ‘æˆ˜
      loadChallenges();
    } catch (err) {
      console.error('Failed to leave challenge:', err);
      alert('ç¦»å¼€æŒ‘æˆ˜å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };

  // å¤„ç†æŸ¥çœ‹æŒ‘æˆ˜è¯¦æƒ…
  const handleViewChallengeDetails = (challengeId: number) => {
    setSelectedChallengeId(challengeId);
    setShowDetailDialog(true);
  };

  // å¤„ç†åˆ†äº«æŒ‘æˆ˜
  const handleShareChallenge = (challengeId: number, inviteCode: string) => {
    // å¤åˆ¶é‚€è¯·ç åˆ°å‰ªè´´æ¿
    navigator.clipboard.writeText(inviteCode)
      .then(() => {
        // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
        playSound(SoundType.SUCCESS, 0.3);
        alert('é‚€è¯·ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
      })
      .catch(err => {
        console.error('Failed to copy invite code:', err);
        alert('å¤åˆ¶é‚€è¯·ç å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶: ' + inviteCode);
      });
  };

  // å¤„ç†æŒ‘æˆ˜æ›´æ–°
  const handleChallengeUpdated = () => {
    // é‡æ–°åŠ è½½æŒ‘æˆ˜
    loadChallenges();
  };

  // å®¹å™¨å˜ä½“
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // é¡¹ç›®å˜ä½“
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  return (
    <div className={`social-challenge-list ${className}`}>
      {/* å¤´éƒ¨ */}
      <div className="list-header flex justify-between items-center mb-4">
        <h2 className="text-xl font-bold">
          {filter === 'my' ? 'æˆ‘çš„ç¤¾äº¤æŒ‘æˆ˜' : 
           filter === 'public' ? 'å…¬å¼€ç¤¾äº¤æŒ‘æˆ˜' : 
           'æ‰€æœ‰ç¤¾äº¤æŒ‘æˆ˜'}
        </h2>
        {showCreateButton && (
          <Button
            variant="jade"
            onClick={handleCreateChallenge}
          >
            åˆ›å»ºæŒ‘æˆ˜
          </Button>
        )}
      </div>
      
      {/* å†…å®¹ */}
      <div className="list-content">
        {isLoading ? (
          <div className="loading-container flex justify-center items-center h-32">
            <LoadingSpinner variant="jade" size="medium" />
          </div>
        ) : error ? (
          <div className="error-container text-center p-4">
            <div className="error-message text-red-500 mb-4">{error}</div>
            <Button variant="jade" onClick={loadChallenges}>
              é‡è¯•
            </Button>
          </div>
        ) : challenges.length > 0 ? (
          <motion.div
            className="challenges-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
            variants={containerVariants}
            initial="hidden"
            animate="visible"
          >
            {challenges.map((challenge) => (
              <motion.div
                key={challenge.id}
                variants={itemVariants}
              >
                <SocialChallengeCard
                  challenge={challenge}
                  isParticipant={challenge.participantIds.includes(currentUserId)}
                  onJoin={handleJoinChallenge}
                  onLeave={handleLeaveChallenge}
                  onViewDetails={handleViewChallengeDetails}
                  onShare={handleShareChallenge}
                />
              </motion.div>
            ))}
          </motion.div>
        ) : (
          <div className="empty-container text-center p-8 bg-gray-50 rounded-lg">
            <p className="text-gray-500 mb-4">
              {filter === 'my' ? 'ä½ è¿˜æ²¡æœ‰å‚ä¸ä»»ä½•ç¤¾äº¤æŒ‘æˆ˜' : 
               filter === 'public' ? 'æš‚æ— å…¬å¼€çš„ç¤¾äº¤æŒ‘æˆ˜' : 
               'æš‚æ— ç¤¾äº¤æŒ‘æˆ˜'}
            </p>
            {filter !== 'my' && showCreateButton && (
              <Button variant="jade" onClick={handleCreateChallenge}>
                åˆ›å»ºç¬¬ä¸€ä¸ªæŒ‘æˆ˜
              </Button>
            )}
          </div>
        )}
      </div>
      
      {/* åˆ›å»ºæŒ‘æˆ˜è¡¨å• */}
      {showCreateForm && (
        <SocialChallengeForm
          isOpen={showCreateForm}
          onClose={() => setShowCreateForm(false)}
          onChallengeCreated={handleChallengeCreated}
        />
      )}
      
      {/* æŒ‘æˆ˜è¯¦æƒ…å¯¹è¯æ¡† */}
      {showDetailDialog && selectedChallengeId !== null && (
        <SocialChallengeDetailDialog
          isOpen={showDetailDialog}
          onClose={() => setShowDetailDialog(false)}
          challengeId={selectedChallengeId}
          onChallengeUpdated={handleChallengeUpdated}
        />
      )}
    </div>
  );
};

export default SocialChallengeList;
</file>

<file path="src/components/game/TaskDetailDialog.tsx">
// src/components/game/TaskDetailDialog.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ScrollDialog from './ScrollDialog';
import Button from '@/components/common/Button';
import { TaskRecord, TaskStatus, TaskPriority, TaskType, updateTask, completeTask } from '@/services/taskService';
import { hasSubtasks, convertTaskToParentTask } from '@/services/subtaskService';
import SubtaskList from '@/components/tasks/SubtaskList';
import { playSound, SoundType } from '@/utils/sound';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { RewardRecord } from '@/services/rewardService';
import RewardModal from './RewardModal';

interface TaskDetailDialogProps {
  isOpen: boolean;
  onClose: () => void;
  task: TaskRecord;
  onTaskUpdated?: () => void;
}

/**
 * ä»»åŠ¡è¯¦æƒ…å¯¹è¯æ¡†ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºä»»åŠ¡è¯¦æƒ…ã€ç®¡ç†å­ä»»åŠ¡å’Œå®Œæˆä»»åŠ¡
 */
const TaskDetailDialog: React.FC<TaskDetailDialogProps> = ({
  isOpen,
  onClose,
  task,
  onTaskUpdated
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasSubtasksList, setHasSubtasksList] = useState(false);
  const [isAddingSubtasks, setIsAddingSubtasks] = useState(false);
  const [subtaskTitles, setSubtaskTitles] = useState<string[]>([]);
  const [currentSubtaskTitle, setCurrentSubtaskTitle] = useState('');
  const [isCompletingTask, setIsCompletingTask] = useState(false);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [showRewardModal, setShowRewardModal] = useState(false);

  // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦æœ‰å­ä»»åŠ¡
  useEffect(() => {
    const checkSubtasks = async () => {
      if (task && task.id) {
        try {
          const hasSubtasksList = await hasSubtasks(task.id);
          setHasSubtasksList(hasSubtasksList);
        } catch (err) {
          console.error('Failed to check subtasks:', err);
        }
      }
    };

    if (isOpen) {
      checkSubtasks();
    }
  }, [task, isOpen]);

  // å¤„ç†æ·»åŠ å­ä»»åŠ¡
  const handleAddSubtask = () => {
    if (!currentSubtaskTitle.trim()) return;
    
    setSubtaskTitles([...subtaskTitles, currentSubtaskTitle.trim()]);
    setCurrentSubtaskTitle('');
  };

  // å¤„ç†ç§»é™¤å­ä»»åŠ¡
  const handleRemoveSubtask = (index: number) => {
    const newSubtaskTitles = [...subtaskTitles];
    newSubtaskTitles.splice(index, 1);
    setSubtaskTitles(newSubtaskTitles);
  };

  // å¤„ç†è½¬æ¢ä¸ºå¸¦æœ‰å­ä»»åŠ¡çš„ä»»åŠ¡
  const handleConvertToParentTask = async () => {
    if (subtaskTitles.length === 0) return;

    try {
      setIsAddingSubtasks(true);
      setError(null);
      
      await convertTaskToParentTask(task.id!, subtaskTitles);
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // é‡ç½®çŠ¶æ€
      setSubtaskTitles([]);
      setHasSubtasksList(true);
      
      // é€šçŸ¥çˆ¶ç»„ä»¶ä»»åŠ¡å·²æ›´æ–°
      if (onTaskUpdated) {
        onTaskUpdated();
      }
    } catch (err) {
      console.error('Failed to convert task to parent task:', err);
      setError('è½¬æ¢ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsAddingSubtasks(false);
    }
  };

  // å¤„ç†å®Œæˆä»»åŠ¡
  const handleCompleteTask = async () => {
    try {
      setIsCompletingTask(true);
      setError(null);
      
      // å®Œæˆä»»åŠ¡
      const result = await completeTask(task.id!);
      
      // è®¾ç½®å¥–åŠ±
      setRewards(result.rewards);
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.TASK_COMPLETE, 0.5);
      
      // æ˜¾ç¤ºå¥–åŠ±æ¨¡æ€æ¡†
      setShowRewardModal(true);
      
      // é€šçŸ¥çˆ¶ç»„ä»¶ä»»åŠ¡å·²æ›´æ–°
      if (onTaskUpdated) {
        onTaskUpdated();
      }
    } catch (err) {
      console.error('Failed to complete task:', err);
      setError('å®Œæˆä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsCompletingTask(false);
    }
  };

  // å¤„ç†å…³é—­å¥–åŠ±æ¨¡æ€æ¡†
  const handleCloseRewardModal = () => {
    setShowRewardModal(false);
    onClose();
  };

  // è·å–ä»»åŠ¡ä¼˜å…ˆçº§æ ‡ç­¾
  const getPriorityLabel = (priority: TaskPriority): string => {
    switch (priority) {
      case TaskPriority.HIGH:
        return 'é«˜';
      case TaskPriority.MEDIUM:
        return 'ä¸­';
      case TaskPriority.LOW:
        return 'ä½';
      default:
        return 'æœªçŸ¥';
    }
  };

  // è·å–ä»»åŠ¡ç±»å‹æ ‡ç­¾
  const getTypeLabel = (type: TaskType): string => {
    switch (type) {
      case TaskType.MAIN:
        return 'ä¸»çº¿ä»»åŠ¡';
      case TaskType.DAILY:
        return 'æ—¥å¸¸ä»»åŠ¡';
      case TaskType.SIDE:
        return 'æ”¯çº¿ä»»åŠ¡';
      default:
        return 'æœªçŸ¥';
    }
  };

  // è·å–ä»»åŠ¡çŠ¶æ€æ ‡ç­¾
  const getStatusLabel = (status: TaskStatus): string => {
    switch (status) {
      case TaskStatus.TODO:
        return 'å¾…åŠ';
      case TaskStatus.IN_PROGRESS:
        return 'è¿›è¡Œä¸­';
      case TaskStatus.COMPLETED:
        return 'å·²å®Œæˆ';
      case TaskStatus.ARCHIVED:
        return 'å·²å½’æ¡£';
      default:
        return 'æœªçŸ¥';
    }
  };

  return (
    <>
      <ScrollDialog
        isOpen={isOpen}
        onClose={onClose}
        title="ä»»åŠ¡è¯¦æƒ…"
        closeOnOutsideClick={!isCompletingTask}
        closeOnEsc={!isCompletingTask}
        showCloseButton={!isCompletingTask}
      >
        <div className="task-detail-content p-4">
          {error && (
            <div className="error-message text-red-500 mb-4">{error}</div>
          )}
          
          <div className="task-header mb-4">
            <h2 className="text-xl font-bold">{task.title}</h2>
            <div className="task-meta flex flex-wrap gap-2 mt-2">
              <span className="task-priority px-2 py-1 rounded-full text-xs bg-amber-100 text-amber-800">
                ä¼˜å…ˆçº§: {getPriorityLabel(task.priority)}
              </span>
              <span className="task-type px-2 py-1 rounded-full text-xs bg-blue-100 text-blue-800">
                {getTypeLabel(task.type)}
              </span>
              <span className={`task-status px-2 py-1 rounded-full text-xs ${
                task.status === TaskStatus.COMPLETED
                  ? 'bg-green-100 text-green-800'
                  : task.status === TaskStatus.IN_PROGRESS
                  ? 'bg-blue-100 text-blue-800'
                  : 'bg-gray-100 text-gray-800'
              }`}>
                {getStatusLabel(task.status)}
              </span>
            </div>
          </div>
          
          {task.description && (
            <div className="task-description mb-4">
              <h3 className="text-lg font-bold mb-1">æè¿°</h3>
              <p className="text-gray-700">{task.description}</p>
            </div>
          )}
          
          {task.dueDate && (
            <div className="task-due-date mb-4">
              <h3 className="text-lg font-bold mb-1">æˆªæ­¢æ—¥æœŸ</h3>
              <p className="text-gray-700">{new Date(task.dueDate).toLocaleDateString()}</p>
            </div>
          )}
          
          {/* å­ä»»åŠ¡åˆ—è¡¨ */}
          {hasSubtasksList && (
            <SubtaskList
              parentTaskId={task.id!}
              onSubtasksChange={setHasSubtasksList}
            />
          )}
          
          {/* æ·»åŠ å­ä»»åŠ¡è¡¨å• */}
          {!hasSubtasksList && task.status !== TaskStatus.COMPLETED && (
            <div className="add-subtasks-section mt-4">
              <h3 className="text-lg font-bold mb-2">æ·»åŠ å­ä»»åŠ¡</h3>
              
              <div className="subtask-input-container mb-2">
                <div className="flex">
                  <input
                    type="text"
                    value={currentSubtaskTitle}
                    onChange={(e) => setCurrentSubtaskTitle(e.target.value)}
                    placeholder="è¾“å…¥å­ä»»åŠ¡æ ‡é¢˜..."
                    className="flex-grow p-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-2 focus:ring-jade-500"
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') {
                        handleAddSubtask();
                      }
                    }}
                  />
                  <Button
                    variant="jade"
                    onClick={handleAddSubtask}
                    disabled={!currentSubtaskTitle.trim()}
                    className="rounded-l-none"
                  >
                    æ·»åŠ 
                  </Button>
                </div>
              </div>
              
              {subtaskTitles.length > 0 && (
                <div className="subtask-list-preview mb-4">
                  <h4 className="text-md font-bold mb-1">å­ä»»åŠ¡åˆ—è¡¨é¢„è§ˆ</h4>
                  <ul className="list-disc pl-5">
                    {subtaskTitles.map((title, index) => (
                      <li key={index} className="flex items-center justify-between mb-1">
                        <span>{title}</span>
                        <button
                          onClick={() => handleRemoveSubtask(index)}
                          className="text-red-500 hover:text-red-700"
                          aria-label="ç§»é™¤å­ä»»åŠ¡"
                        >
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                            <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                          </svg>
                        </button>
                      </li>
                    ))}
                  </ul>
                  
                  <Button
                    variant="gold"
                    onClick={handleConvertToParentTask}
                    disabled={isAddingSubtasks || subtaskTitles.length === 0}
                    className="mt-2"
                  >
                    {isAddingSubtasks ? (
                      <LoadingSpinner variant="white" size="small" />
                    ) : (
                      'åˆ›å»ºå­ä»»åŠ¡'
                    )}
                  </Button>
                </div>
              )}
            </div>
          )}
          
          {/* ä»»åŠ¡æ“ä½œæŒ‰é’® */}
          <div className="task-actions mt-4 flex justify-end">
            {task.status !== TaskStatus.COMPLETED && (
              <Button
                variant="jade"
                onClick={handleCompleteTask}
                disabled={isCompletingTask}
                className="mr-2"
              >
                {isCompletingTask ? (
                  <LoadingSpinner variant="white" size="small" />
                ) : (
                  'å®Œæˆä»»åŠ¡'
                )}
              </Button>
            )}
            
            <Button variant="secondary" onClick={onClose}>
              å…³é—­
            </Button>
          </div>
        </div>
      </ScrollDialog>
      
      {/* å¥–åŠ±æ¨¡æ€æ¡† */}
      {showRewardModal && (
        <RewardModal
          isOpen={showRewardModal}
          onClose={handleCloseRewardModal}
          rewards={rewards}
        />
      )}
    </>
  );
};

export default TaskDetailDialog;
</file>

<file path="src/components/game/TaskForm.tsx">
// src/components/game/TaskForm.tsx
import React, { useState, useEffect } from 'react';
import { 
  TaskRecord, 
  TaskPriority, 
  TaskType, 
  TaskCategoryRecord,
  getAllTaskCategories
} from '@/services/taskService';
import Button from '@/components/common/Button';

interface TaskFormProps {
  initialTask?: Partial<TaskRecord>;
  onSubmit: (task: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'>) => void;
  onCancel: () => void;
}

/**
 * ä»»åŠ¡è¡¨å•ç»„ä»¶ï¼Œç”¨äºåˆ›å»ºå’Œç¼–è¾‘ä»»åŠ¡
 */
const TaskForm: React.FC<TaskFormProps> = ({
  initialTask = {},
  onSubmit,
  onCancel
}) => {
  // è¡¨å•çŠ¶æ€
  const [title, setTitle] = useState(initialTask.title || '');
  const [description, setDescription] = useState(initialTask.description || '');
  const [categoryId, setCategoryId] = useState<number | undefined>(initialTask.categoryId);
  const [type, setType] = useState<TaskType>(initialTask.type || TaskType.DAILY);
  const [priority, setPriority] = useState<TaskPriority>(initialTask.priority || TaskPriority.MEDIUM);
  const [dueDate, setDueDate] = useState<string>(
    initialTask.dueDate 
      ? new Date(initialTask.dueDate).toISOString().split('T')[0] 
      : ''
  );
  const [estimatedMinutes, setEstimatedMinutes] = useState<number | undefined>(
    initialTask.estimatedMinutes
  );
  const [categories, setCategories] = useState<TaskCategoryRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});

  // åŠ è½½ä»»åŠ¡ç±»åˆ«
  useEffect(() => {
    const loadCategories = async () => {
      try {
        setIsLoading(true);
        const allCategories = await getAllTaskCategories();
        setCategories(allCategories);
        
        // å¦‚æœæ²¡æœ‰é€‰æ‹©ç±»åˆ«ï¼Œé»˜è®¤é€‰æ‹©ç¬¬ä¸€ä¸ª
        if (!categoryId && allCategories.length > 0) {
          setCategoryId(allCategories[0].id);
        }
      } catch (error) {
        console.error('Failed to load task categories:', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    loadCategories();
  }, [categoryId]);

  // éªŒè¯è¡¨å•
  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    if (!title.trim()) {
      newErrors.title = 'è¯·è¾“å…¥ä»»åŠ¡æ ‡é¢˜';
    }
    
    if (!categoryId) {
      newErrors.categoryId = 'è¯·é€‰æ‹©ä»»åŠ¡ç±»åˆ«';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // å¤„ç†è¡¨å•æäº¤
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }
    
    const taskData: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'> = {
      title,
      description: description || undefined,
      categoryId: categoryId!,
      type,
      priority,
      dueDate: dueDate ? new Date(dueDate) : undefined,
      estimatedMinutes: estimatedMinutes || undefined
    };
    
    onSubmit(taskData);
  };

  return (
    <form className="task-form bamboo-frame" onSubmit={handleSubmit}>
      <h2>{initialTask.id ? 'ç¼–è¾‘ä»»åŠ¡' : 'åˆ›å»ºæ–°ä»»åŠ¡'}</h2>
      
      <div className="form-group">
        <label htmlFor="task-title">æ ‡é¢˜ *</label>
        <input
          id="task-title"
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          className={errors.title ? 'error' : ''}
          placeholder="è¾“å…¥ä»»åŠ¡æ ‡é¢˜"
        />
        {errors.title && <div className="error-message">{errors.title}</div>}
      </div>
      
      <div className="form-group">
        <label htmlFor="task-description">æè¿°</label>
        <textarea
          id="task-description"
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          placeholder="è¾“å…¥ä»»åŠ¡æè¿°ï¼ˆå¯é€‰ï¼‰"
          rows={3}
        />
      </div>
      
      <div className="form-group">
        <label htmlFor="task-category">ç±»åˆ« *</label>
        <select
          id="task-category"
          value={categoryId}
          onChange={(e) => setCategoryId(Number(e.target.value))}
          className={errors.categoryId ? 'error' : ''}
          disabled={isLoading}
        >
          <option value="">é€‰æ‹©ç±»åˆ«</option>
          {categories.map((category) => (
            <option key={category.id} value={category.id}>
              {category.name}
            </option>
          ))}
        </select>
        {errors.categoryId && <div className="error-message">{errors.categoryId}</div>}
      </div>
      
      <div className="form-group">
        <label htmlFor="task-type">ä»»åŠ¡ç±»å‹</label>
        <select
          id="task-type"
          value={type}
          onChange={(e) => setType(e.target.value as TaskType)}
        >
          <option value={TaskType.DAILY}>æ—¥å¸¸ä»»åŠ¡</option>
          <option value={TaskType.MAIN}>ä¸»çº¿ä»»åŠ¡</option>
          <option value={TaskType.SIDE}>æ”¯çº¿ä»»åŠ¡</option>
        </select>
      </div>
      
      <div className="form-group">
        <label htmlFor="task-priority">ä¼˜å…ˆçº§</label>
        <select
          id="task-priority"
          value={priority}
          onChange={(e) => setPriority(e.target.value as TaskPriority)}
        >
          <option value={TaskPriority.LOW}>ä½</option>
          <option value={TaskPriority.MEDIUM}>ä¸­</option>
          <option value={TaskPriority.HIGH}>é«˜</option>
        </select>
      </div>
      
      <div className="form-group">
        <label htmlFor="task-due-date">æˆªæ­¢æ—¥æœŸ</label>
        <input
          id="task-due-date"
          type="date"
          value={dueDate}
          onChange={(e) => setDueDate(e.target.value)}
        />
      </div>
      
      <div className="form-group">
        <label htmlFor="task-estimated-time">é¢„è®¡æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰</label>
        <input
          id="task-estimated-time"
          type="number"
          min="1"
          value={estimatedMinutes || ''}
          onChange={(e) => setEstimatedMinutes(e.target.value ? Number(e.target.value) : undefined)}
          placeholder="é¢„è®¡å®Œæˆæ—¶é—´ï¼ˆå¯é€‰ï¼‰"
        />
      </div>
      
      <div className="form-actions">
        <Button variant="jade" type="submit">
          {initialTask.id ? 'ä¿å­˜ä¿®æ”¹' : 'åˆ›å»ºä»»åŠ¡'}
        </Button>
        <Button variant="secondary" type="button" onClick={onCancel}>
          å–æ¶ˆ
        </Button>
      </div>
    </form>
  );
};

export default TaskForm;
</file>

<file path="src/components/game/TimelyRewardCard.tsx">
// src/components/game/TimelyRewardCard.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { TimelyRewardRecord, TimelyRewardStatus, TimelyRewardType } from '@/services/timelyRewardService';
import ProgressBar from '@/components/common/ProgressBar';
import { formatTime } from '@/utils/dateUtils';
import { TimelyRewardCardLabels } from '@/types';

interface TimelyRewardCardProps {
  reward: TimelyRewardRecord;
  onClick?: (reward: TimelyRewardRecord) => void;
  onComplete?: (rewardId: number) => void;
  labels?: TimelyRewardCardLabels;
}

/**
 * Timely reward card component
 * Displays basic information and progress of a timely reward
 */
const TimelyRewardCard: React.FC<TimelyRewardCardProps> = ({ reward, onClick, onComplete, labels }) => {
  // Add console log to check labels
  console.log('TimelyRewardCard labels:', labels);
  // è·å–å¥–åŠ±çŠ¶æ€å¯¹åº”çš„æ ·å¼ç±»
  const getStatusClass = () => {
    switch (reward.status) {
      case TimelyRewardStatus.ACTIVE:
        return 'reward-active';
      case TimelyRewardStatus.COMPLETED:
        return 'reward-completed';
      case TimelyRewardStatus.EXPIRED:
        return 'reward-expired';
      case TimelyRewardStatus.UPCOMING:
        return 'reward-upcoming';
      default:
        return '';
    }
  };

  // Get reward type text with localization
  const getTypeText = () => {
    switch (reward.type) {
      case TimelyRewardType.DAILY:
        return labels?.typeDaily || 'Daily Reward';
      case TimelyRewardType.MORNING:
        return labels?.typeMorning || 'Early Bird Reward';
      case TimelyRewardType.STREAK:
        return labels?.typeStreak || 'Streak Reward';
      case TimelyRewardType.SPECIAL:
        return labels?.typeSpecial || 'Special Reward';
      default:
        return '';
    }
  };

  // Get reward status text with localization
  const getStatusText = () => {
    switch (reward.status) {
      case TimelyRewardStatus.ACTIVE:
        return labels?.statusActive || 'Active';
      case TimelyRewardStatus.COMPLETED:
        return labels?.statusCompleted || 'Completed';
      case TimelyRewardStatus.EXPIRED:
        return labels?.statusExpired || 'Expired';
      case TimelyRewardStatus.UPCOMING:
        return labels?.statusUpcoming || 'Upcoming';
      default:
        return '';
    }
  };

  // Calculate remaining time with localization
  const getRemainingTime = () => {
    const now = new Date();
    const endTime = new Date(reward.endTime);

    if (now > endTime) {
      return labels?.timeEnded || 'Ended';
    }

    const diffMs = endTime.getTime() - now.getTime();
    const diffHrs = Math.floor(diffMs / (1000 * 60 * 60));
    const diffMins = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));

    const hourUnit = labels?.hourUnit || 'h';
    const minuteUnit = labels?.minuteUnit || 'm';

    return `${diffHrs}${hourUnit} ${diffMins}${minuteUnit}`;
  };

  // å¤„ç†ç‚¹å‡»äº‹ä»¶
  const handleClick = () => {
    if (onClick) {
      onClick(reward);
    }
  };

  // å¤„ç†å®Œæˆå¥–åŠ±äº‹ä»¶
  const handleComplete = (e: React.MouseEvent) => {
    e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
    if (onComplete && reward.status === TimelyRewardStatus.ACTIVE && reward.progress >= 100) {
      onComplete(reward.id!);
    }
  };

  return (
    <motion.div
      className={`timely-reward-card ${getStatusClass()}`}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={handleClick}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      transition={{ duration: 0.3 }}
    >
      <div className="reward-card-header">
        <div className="reward-icon">
          <img src={reward.iconPath} alt={reward.title} />
        </div>
        <div className="reward-title-section">
          <h3 className="reward-title">{reward.title}</h3>
          <div className="reward-meta">
            <span className="reward-type">{getTypeText()}</span>
            <span className={`reward-status ${getStatusClass()}`}>
              {getStatusText()}
            </span>
          </div>
        </div>
      </div>

      <div className="reward-card-body">
        <p className="reward-description">{reward.description}</p>

        <div className="reward-progress-section">
          <ProgressBar
            progress={reward.progress}
            total={100}
            showPercentage
            className={getStatusClass()}
          />
          <div className="reward-time-info">
            <div className="reward-time-range">
              {formatTime(reward.startTime)} - {formatTime(reward.endTime)}
            </div>
            {reward.status === TimelyRewardStatus.ACTIVE && (
              <div className="reward-remaining-time">
                {labels?.remainingTimeLabel || 'Remaining time'}: {getRemainingTime()}
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="reward-card-footer">
        <div className="reward-points">
          <span className="lucky-points-icon">ğŸ€</span>
          <span className="lucky-points-value">{reward.luckyPoints} {labels?.luckyPointsLabel || 'Lucky Points'}</span>
        </div>

        {reward.status === TimelyRewardStatus.ACTIVE && (
          <button
            className="complete-reward-button"
            onClick={handleComplete}
            disabled={reward.progress < 100}
          >
            {reward.progress >= 100 ? (labels?.claimRewardButton || 'Claim Reward') : (labels?.inProgressButton || 'In Progress...')}
          </button>
        )}
        {reward.status === TimelyRewardStatus.COMPLETED && (
          <div className="reward-completed-info">
            <span className="completion-date">
              {labels?.completedOnLabel || 'Completed on'}: {formatTime(reward.completedTime!)}
            </span>
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default TimelyRewardCard;
</file>

<file path="src/components/layout/Header.tsx">
// src/components/layout/Header.tsx
import React from 'react';
import type { GlobalLayoutLabelsBundle } from '@/types';

interface HeaderProps {
  labels: GlobalLayoutLabelsBundle | undefined;
  isFetching?: boolean;
}

const Header: React.FC<HeaderProps> = ({ labels, isFetching }) => {
  return (
    <header style={{
      opacity: isFetching ? 0.7 : 1,
      display: 'flex',
      justifyContent: 'center',
      padding: '10px 0'
    }}>
      {/* ç§»åŠ¨åº”ç”¨é€šå¸¸ä¸éœ€è¦æ˜¾ç¤ºåº”ç”¨æ ‡é¢˜ */}
      {isFetching && labels &&
        <small style={{ fontStyle: 'italic', color: '#555' }}>(syncing...)</small>
      }
    </header>
  );
};
export default Header;
</file>

<file path="src/components/panda/PandaCustomizationPanel.tsx">
// src/components/panda/PandaCustomizationPanel.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  PandaAccessoryRecord, 
  PandaAccessoryType,
  getOwnedAccessories,
  getEquippedAccessories,
  equipAccessory,
  unequipAccessory
} from '@/services/pandaCustomizationService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from '@/components/game/ScrollDialog';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface PandaCustomizationPanelProps {
  isOpen: boolean;
  onClose: () => void;
  onCustomizationChanged?: () => void;
}

/**
 * ç†ŠçŒ«å®šåˆ¶é¢æ¿ç»„ä»¶
 * ç”¨äºå®šåˆ¶ç†ŠçŒ«çš„å¤–è§‚ï¼ŒåŒ…æ‹¬å¸½å­ã€çœ¼é•œã€å›´å·¾ç­‰è£…é¥°
 */
const PandaCustomizationPanel: React.FC<PandaCustomizationPanelProps> = ({
  isOpen,
  onClose,
  onCustomizationChanged
}) => {
  const [accessories, setAccessories] = useState<PandaAccessoryRecord[]>([]);
  const [equippedAccessories, setEquippedAccessories] = useState<PandaAccessoryRecord[]>([]);
  const [selectedType, setSelectedType] = useState<PandaAccessoryType | 'all'>('all');
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isUpdating, setIsUpdating] = useState(false);
  
  // åŠ è½½è£…é¥°æ•°æ®
  const loadAccessories = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // è·å–å·²æ‹¥æœ‰çš„è£…é¥°
      const ownedAccessories = await getOwnedAccessories();
      setAccessories(ownedAccessories);
      
      // è·å–å·²è£…å¤‡çš„è£…é¥°
      const equipped = await getEquippedAccessories();
      setEquippedAccessories(equipped);
    } catch (err) {
      console.error('Failed to load accessories:', err);
      setError('åŠ è½½è£…é¥°å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    if (isOpen) {
      loadAccessories();
    }
  }, [isOpen]);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('pandaAccessories', loadAccessories);

  // å¤„ç†è£…å¤‡è£…é¥°
  const handleEquipAccessory = async (accessory: PandaAccessoryRecord) => {
    try {
      setIsUpdating(true);
      
      if (accessory.isEquipped) {
        // å–æ¶ˆè£…å¤‡
        await unequipAccessory(accessory.id!);
      } else {
        // è£…å¤‡
        await equipAccessory(accessory.id!);
      }
      
      // æ’­æ”¾éŸ³æ•ˆ
      playSound(SoundType.BUTTON_CLICK, 0.5);
      
      // é‡æ–°åŠ è½½æ•°æ®
      await loadAccessories();
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onCustomizationChanged) {
        onCustomizationChanged();
      }
    } catch (err) {
      console.error('Failed to update accessory:', err);
      setError('æ›´æ–°è£…é¥°å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsUpdating(false);
    }
  };

  // è·å–è£…é¥°ç±»å‹æ ‡ç­¾
  const getAccessoryTypeLabel = (type: PandaAccessoryType): string => {
    switch (type) {
      case PandaAccessoryType.HAT:
        return 'å¸½å­';
      case PandaAccessoryType.GLASSES:
        return 'çœ¼é•œ';
      case PandaAccessoryType.SCARF:
        return 'å›´å·¾';
      case PandaAccessoryType.PENDANT:
        return 'æŒ‚é¥°';
      case PandaAccessoryType.BACKGROUND:
        return 'èƒŒæ™¯';
      case PandaAccessoryType.FRAME:
        return 'è¾¹æ¡†';
      case PandaAccessoryType.EFFECT:
        return 'ç‰¹æ•ˆ';
      default:
        return 'æœªçŸ¥';
    }
  };

  // è·å–ç¨€æœ‰åº¦æ ‡ç­¾å’Œæ ·å¼
  const getRarityInfo = (rarity: string) => {
    switch (rarity) {
      case 'common':
        return { label: 'æ™®é€š', className: 'bg-gray-100 text-gray-800 border-gray-300' };
      case 'uncommon':
        return { label: 'ä¼˜ç§€', className: 'bg-green-100 text-green-800 border-green-300' };
      case 'rare':
        return { label: 'ç¨€æœ‰', className: 'bg-blue-100 text-blue-800 border-blue-300' };
      case 'epic':
        return { label: 'å²è¯—', className: 'bg-purple-100 text-purple-800 border-purple-300' };
      case 'legendary':
        return { label: 'ä¼ è¯´', className: 'bg-amber-100 text-amber-800 border-amber-300' };
      default:
        return { label: 'æœªçŸ¥', className: 'bg-gray-100 text-gray-800 border-gray-300' };
    }
  };

  // è¿‡æ»¤è£…é¥°
  const getFilteredAccessories = (): PandaAccessoryRecord[] => {
    if (selectedType === 'all') {
      return accessories;
    }
    
    return accessories.filter(accessory => accessory.type === selectedType);
  };

  // è·å–å·²è£…å¤‡çš„è£…é¥°
  const getEquippedAccessory = (type: PandaAccessoryType): PandaAccessoryRecord | undefined => {
    return equippedAccessories.find(accessory => accessory.type === type);
  };

  // å®¹å™¨å˜ä½“
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // é¡¹ç›®å˜ä½“
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  // è£…é¥°ç±»å‹é€‰é¡¹
  const accessoryTypes: (PandaAccessoryType | 'all')[] = [
    'all',
    PandaAccessoryType.HAT,
    PandaAccessoryType.GLASSES,
    PandaAccessoryType.SCARF,
    PandaAccessoryType.PENDANT,
    PandaAccessoryType.BACKGROUND,
    PandaAccessoryType.FRAME,
    PandaAccessoryType.EFFECT
  ];

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="ç†ŠçŒ«å®šåˆ¶"
      closeOnOutsideClick={!isUpdating}
      closeOnEsc={!isUpdating}
      showCloseButton={!isUpdating}
    >
      <div className="panda-customization-panel p-4">
        {isLoading ? (
          <div className="loading-container flex justify-center items-center h-32">
            <LoadingSpinner variant="jade" size="medium" />
          </div>
        ) : error ? (
          <div className="error-container text-center p-4">
            <div className="error-message text-red-500 mb-4">{error}</div>
            <Button variant="jade" onClick={loadAccessories}>
              é‡è¯•
            </Button>
          </div>
        ) : (
          <div className="customization-content">
            {/* å½“å‰è£…å¤‡ */}
            <div className="current-equipment mb-6">
              <h3 className="text-lg font-bold mb-3">å½“å‰è£…å¤‡</h3>
              <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                {accessoryTypes.slice(1).map((type) => {
                  const equipped = getEquippedAccessory(type);
                  return (
                    <div key={type} className="equipped-item p-2 border border-gray-200 rounded-lg">
                      <div className="item-type text-sm font-medium mb-1">
                        {getAccessoryTypeLabel(type)}
                      </div>
                      {equipped ? (
                        <div className="item-info flex items-center">
                          <img
                            src={equipped.imagePath}
                            alt={equipped.name}
                            className="w-8 h-8 object-contain mr-2"
                            onError={(e) => {
                              const target = e.target as HTMLImageElement;
                              target.onerror = null;
                              target.src = '/assets/accessories/default.svg';
                            }}
                          />
                          <div className="item-name text-sm truncate">
                            {equipped.name}
                          </div>
                        </div>
                      ) : (
                        <div className="item-empty text-sm text-gray-500">
                          æœªè£…å¤‡
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
            
            {/* è£…é¥°ç±»å‹è¿‡æ»¤å™¨ */}
            <div className="accessory-type-filter mb-4">
              <h3 className="text-lg font-bold mb-2">è£…é¥°ç±»å‹</h3>
              <div className="flex flex-wrap gap-2">
                {accessoryTypes.map((type) => (
                  <button
                    key={type}
                    className={`px-3 py-1 rounded-full text-sm ${
                      selectedType === type ? 'bg-jade-100 text-jade-800 border border-jade-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
                    }`}
                    onClick={() => setSelectedType(type)}
                  >
                    {type === 'all' ? 'å…¨éƒ¨' : getAccessoryTypeLabel(type)}
                  </button>
                ))}
              </div>
            </div>
            
            {/* è£…é¥°åˆ—è¡¨ */}
            <div className="accessories-list">
              <h3 className="text-lg font-bold mb-3">å¯ç”¨è£…é¥°</h3>
              {getFilteredAccessories().length === 0 ? (
                <div className="no-accessories text-center p-4 bg-gray-50 rounded-lg">
                  <p className="text-gray-500">æš‚æ— å¯ç”¨è£…é¥°</p>
                </div>
              ) : (
                <motion.div
                  className="accessories-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
                  variants={containerVariants}
                  initial="hidden"
                  animate="visible"
                >
                  {getFilteredAccessories().map((accessory) => {
                    const rarityInfo = getRarityInfo(accessory.rarity);
                    return (
                      <motion.div
                        key={accessory.id}
                        className={`accessory-item p-3 rounded-lg border ${
                          accessory.isEquipped ? 'border-jade-500 bg-jade-50' : 'border-gray-200 bg-white'
                        }`}
                        variants={itemVariants}
                      >
                        <div className="accessory-header flex justify-between items-start mb-2">
                          <div className="accessory-name font-medium">
                            {accessory.name}
                          </div>
                          <div className="accessory-meta flex gap-1">
                            <span className={`px-2 py-0.5 rounded-full text-xs ${rarityInfo.className}`}>
                              {rarityInfo.label}
                            </span>
                            <span className="px-2 py-0.5 rounded-full text-xs bg-gray-100 text-gray-800">
                              {getAccessoryTypeLabel(accessory.type)}
                            </span>
                          </div>
                        </div>
                        
                        <div className="accessory-image-container mb-2 flex justify-center">
                          <img
                            src={accessory.imagePath}
                            alt={accessory.name}
                            className="h-24 object-contain"
                            onError={(e) => {
                              const target = e.target as HTMLImageElement;
                              target.onerror = null;
                              target.src = '/assets/accessories/default.svg';
                            }}
                          />
                        </div>
                        
                        <div className="accessory-description text-sm text-gray-600 mb-3">
                          {accessory.description}
                        </div>
                        
                        <div className="accessory-actions">
                          <Button
                            variant={accessory.isEquipped ? 'secondary' : 'jade'}
                            onClick={() => handleEquipAccessory(accessory)}
                            disabled={isUpdating}
                            className="w-full"
                          >
                            {isUpdating ? (
                              <LoadingSpinner variant="white" size="small" />
                            ) : accessory.isEquipped ? (
                              'å–æ¶ˆè£…å¤‡'
                            ) : (
                              'è£…å¤‡'
                            )}
                          </Button>
                        </div>
                      </motion.div>
                    );
                  })}
                </motion.div>
              )}
            </div>
          </div>
        )}
      </div>
    </ScrollDialog>
  );
};

export default PandaCustomizationPanel;
</file>

<file path="src/components/panda/PandaEnvironmentPanel.tsx">
// src/components/panda/PandaEnvironmentPanel.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  PandaEnvironmentRecord,
  getOwnedEnvironments,
  getActiveEnvironment,
  activateEnvironment
} from '@/services/pandaCustomizationService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from '@/components/game/ScrollDialog';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface PandaEnvironmentPanelProps {
  isOpen: boolean;
  onClose: () => void;
  onEnvironmentChanged?: () => void;
}

/**
 * ç†ŠçŒ«ç¯å¢ƒé¢æ¿ç»„ä»¶
 * ç”¨äºé€‰æ‹©å’Œå®šåˆ¶ç†ŠçŒ«çš„ç¯å¢ƒï¼ŒåŒ…æ‹¬èƒŒæ™¯ã€äº’åŠ¨å…ƒç´ ç­‰
 */
const PandaEnvironmentPanel: React.FC<PandaEnvironmentPanelProps> = ({
  isOpen,
  onClose,
  onEnvironmentChanged
}) => {
  const [environments, setEnvironments] = useState<PandaEnvironmentRecord[]>([]);
  const [activeEnvironment, setActiveEnvironment] = useState<PandaEnvironmentRecord | null>(null);
  const [selectedTheme, setSelectedTheme] = useState<string>('all');
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isUpdating, setIsUpdating] = useState(false);
  const [previewEnvironment, setPreviewEnvironment] = useState<PandaEnvironmentRecord | null>(null);
  
  // åŠ è½½ç¯å¢ƒæ•°æ®
  const loadEnvironments = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // è·å–å·²æ‹¥æœ‰çš„ç¯å¢ƒ
      const ownedEnvironments = await getOwnedEnvironments();
      setEnvironments(ownedEnvironments);
      
      // è·å–å½“å‰æ¿€æ´»çš„ç¯å¢ƒ
      const active = await getActiveEnvironment();
      if (active) {
        setActiveEnvironment(active);
      }
    } catch (err) {
      console.error('Failed to load environments:', err);
      setError('åŠ è½½ç¯å¢ƒå¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    if (isOpen) {
      loadEnvironments();
    }
  }, [isOpen]);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('pandaEnvironments', loadEnvironments);

  // å¤„ç†æ¿€æ´»ç¯å¢ƒ
  const handleActivateEnvironment = async (environment: PandaEnvironmentRecord) => {
    try {
      setIsUpdating(true);
      
      // æ¿€æ´»ç¯å¢ƒ
      await activateEnvironment(environment.id!);
      
      // æ’­æ”¾éŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // é‡æ–°åŠ è½½æ•°æ®
      await loadEnvironments();
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onEnvironmentChanged) {
        onEnvironmentChanged();
      }
    } catch (err) {
      console.error('Failed to activate environment:', err);
      setError('æ¿€æ´»ç¯å¢ƒå¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsUpdating(false);
    }
  };

  // å¤„ç†é¢„è§ˆç¯å¢ƒ
  const handlePreviewEnvironment = (environment: PandaEnvironmentRecord) => {
    setPreviewEnvironment(environment);
    
    // æ’­æ”¾éŸ³æ•ˆ
    playSound(SoundType.BUTTON_CLICK, 0.3);
  };

  // è·å–ç¨€æœ‰åº¦æ ‡ç­¾å’Œæ ·å¼
  const getRarityInfo = (rarity: string) => {
    switch (rarity) {
      case 'common':
        return { label: 'æ™®é€š', className: 'bg-gray-100 text-gray-800 border-gray-300' };
      case 'uncommon':
        return { label: 'ä¼˜ç§€', className: 'bg-green-100 text-green-800 border-green-300' };
      case 'rare':
        return { label: 'ç¨€æœ‰', className: 'bg-blue-100 text-blue-800 border-blue-300' };
      case 'epic':
        return { label: 'å²è¯—', className: 'bg-purple-100 text-purple-800 border-purple-300' };
      case 'legendary':
        return { label: 'ä¼ è¯´', className: 'bg-amber-100 text-amber-800 border-amber-300' };
      default:
        return { label: 'æœªçŸ¥', className: 'bg-gray-100 text-gray-800 border-gray-300' };
    }
  };

  // è·å–ä¸»é¢˜æ ‡ç­¾
  const getThemeLabel = (theme: string): string => {
    switch (theme) {
      case 'ç«¹æ—':
        return 'ç«¹æ—';
      case 'å›­æ—':
        return 'å›­æ—';
      case 'å±±æ°´':
        return 'å±±æ°´';
      case 'åŸå¸‚':
        return 'åŸå¸‚';
      case 'èŠ‚æ—¥':
        return 'èŠ‚æ—¥';
      default:
        return theme;
    }
  };

  // è¿‡æ»¤ç¯å¢ƒ
  const getFilteredEnvironments = (): PandaEnvironmentRecord[] => {
    if (selectedTheme === 'all') {
      return environments;
    }
    
    return environments.filter(environment => environment.themeType === selectedTheme);
  };

  // è·å–æ‰€æœ‰ä¸»é¢˜
  const getAllThemes = (): string[] => {
    const themes = new Set<string>();
    themes.add('all');
    
    environments.forEach(environment => {
      if (environment.themeType) {
        themes.add(environment.themeType);
      }
    });
    
    return Array.from(themes);
  };

  // å®¹å™¨å˜ä½“
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // é¡¹ç›®å˜ä½“
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="ç¯å¢ƒå®šåˆ¶"
      closeOnOutsideClick={!isUpdating}
      closeOnEsc={!isUpdating}
      showCloseButton={!isUpdating}
    >
      <div className="panda-environment-panel p-4">
        {isLoading ? (
          <div className="loading-container flex justify-center items-center h-32">
            <LoadingSpinner variant="jade" size="medium" />
          </div>
        ) : error ? (
          <div className="error-container text-center p-4">
            <div className="error-message text-red-500 mb-4">{error}</div>
            <Button variant="jade" onClick={loadEnvironments}>
              é‡è¯•
            </Button>
          </div>
        ) : (
          <div className="environment-content">
            {/* å½“å‰ç¯å¢ƒ */}
            {activeEnvironment && (
              <div className="current-environment mb-6">
                <h3 className="text-lg font-bold mb-3">å½“å‰ç¯å¢ƒ</h3>
                <div className="active-environment p-3 border border-jade-300 rounded-lg bg-jade-50">
                  <div className="environment-header flex justify-between items-start mb-2">
                    <div className="environment-name font-medium">
                      {activeEnvironment.name}
                    </div>
                    <div className="environment-meta flex gap-1">
                      <span className={`px-2 py-0.5 rounded-full text-xs ${getRarityInfo(activeEnvironment.rarity).className}`}>
                        {getRarityInfo(activeEnvironment.rarity).label}
                      </span>
                      <span className="px-2 py-0.5 rounded-full text-xs bg-gray-100 text-gray-800">
                        {getThemeLabel(activeEnvironment.themeType)}
                      </span>
                    </div>
                  </div>
                  
                  <div className="environment-image-container mb-2 relative overflow-hidden rounded-lg">
                    <img
                      src={activeEnvironment.backgroundPath}
                      alt={activeEnvironment.name}
                      className="w-full h-40 object-cover"
                      onError={(e) => {
                        const target = e.target as HTMLImageElement;
                        target.onerror = null;
                        target.src = '/assets/environments/default.svg';
                      }}
                    />
                    {activeEnvironment.foregroundPath && (
                      <img
                        src={activeEnvironment.foregroundPath}
                        alt={`${activeEnvironment.name} foreground`}
                        className="absolute top-0 left-0 w-full h-40 object-cover pointer-events-none"
                        onError={(e) => {
                          const target = e.target as HTMLImageElement;
                          target.onerror = null;
                          target.style.display = 'none';
                        }}
                      />
                    )}
                  </div>
                  
                  <div className="environment-description text-sm text-gray-600">
                    {activeEnvironment.description}
                  </div>
                </div>
              </div>
            )}
            
            {/* ç¯å¢ƒé¢„è§ˆ */}
            {previewEnvironment && (
              <div className="environment-preview mb-6">
                <h3 className="text-lg font-bold mb-3">ç¯å¢ƒé¢„è§ˆ</h3>
                <div className="preview-environment p-3 border border-gray-200 rounded-lg">
                  <div className="environment-header flex justify-between items-start mb-2">
                    <div className="environment-name font-medium">
                      {previewEnvironment.name}
                    </div>
                    <div className="environment-meta flex gap-1">
                      <span className={`px-2 py-0.5 rounded-full text-xs ${getRarityInfo(previewEnvironment.rarity).className}`}>
                        {getRarityInfo(previewEnvironment.rarity).label}
                      </span>
                      <span className="px-2 py-0.5 rounded-full text-xs bg-gray-100 text-gray-800">
                        {getThemeLabel(previewEnvironment.themeType)}
                      </span>
                    </div>
                  </div>
                  
                  <div className="environment-image-container mb-2 relative overflow-hidden rounded-lg">
                    <img
                      src={previewEnvironment.backgroundPath}
                      alt={previewEnvironment.name}
                      className="w-full h-40 object-cover"
                      onError={(e) => {
                        const target = e.target as HTMLImageElement;
                        target.onerror = null;
                        target.src = '/assets/environments/default.svg';
                      }}
                    />
                    {previewEnvironment.foregroundPath && (
                      <img
                        src={previewEnvironment.foregroundPath}
                        alt={`${previewEnvironment.name} foreground`}
                        className="absolute top-0 left-0 w-full h-40 object-cover pointer-events-none"
                        onError={(e) => {
                          const target = e.target as HTMLImageElement;
                          target.onerror = null;
                          target.style.display = 'none';
                        }}
                      />
                    )}
                  </div>
                  
                  <div className="environment-description text-sm text-gray-600 mb-3">
                    {previewEnvironment.description}
                  </div>
                  
                  <div className="environment-actions flex justify-end">
                    <Button
                      variant="jade"
                      onClick={() => handleActivateEnvironment(previewEnvironment)}
                      disabled={isUpdating || (activeEnvironment && activeEnvironment.id === previewEnvironment.id)}
                    >
                      {isUpdating ? (
                        <LoadingSpinner variant="white" size="small" />
                      ) : activeEnvironment && activeEnvironment.id === previewEnvironment.id ? (
                        'å½“å‰ç¯å¢ƒ'
                      ) : (
                        'æ¿€æ´»ç¯å¢ƒ'
                      )}
                    </Button>
                  </div>
                </div>
              </div>
            )}
            
            {/* ä¸»é¢˜è¿‡æ»¤å™¨ */}
            <div className="theme-filter mb-4">
              <h3 className="text-lg font-bold mb-2">ä¸»é¢˜</h3>
              <div className="flex flex-wrap gap-2">
                {getAllThemes().map((theme) => (
                  <button
                    key={theme}
                    className={`px-3 py-1 rounded-full text-sm ${
                      selectedTheme === theme ? 'bg-jade-100 text-jade-800 border border-jade-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
                    }`}
                    onClick={() => setSelectedTheme(theme)}
                  >
                    {theme === 'all' ? 'å…¨éƒ¨' : getThemeLabel(theme)}
                  </button>
                ))}
              </div>
            </div>
            
            {/* ç¯å¢ƒåˆ—è¡¨ */}
            <div className="environments-list">
              <h3 className="text-lg font-bold mb-3">å¯ç”¨ç¯å¢ƒ</h3>
              {getFilteredEnvironments().length === 0 ? (
                <div className="no-environments text-center p-4 bg-gray-50 rounded-lg">
                  <p className="text-gray-500">æš‚æ— å¯ç”¨ç¯å¢ƒ</p>
                </div>
              ) : (
                <motion.div
                  className="environments-grid grid grid-cols-1 md:grid-cols-2 gap-4"
                  variants={containerVariants}
                  initial="hidden"
                  animate="visible"
                >
                  {getFilteredEnvironments().map((environment) => {
                    const rarityInfo = getRarityInfo(environment.rarity);
                    const isActive = activeEnvironment && activeEnvironment.id === environment.id;
                    
                    return (
                      <motion.div
                        key={environment.id}
                        className={`environment-item p-3 rounded-lg border cursor-pointer ${
                          isActive ? 'border-jade-500 bg-jade-50' : 'border-gray-200 bg-white'
                        }`}
                        variants={itemVariants}
                        onClick={() => handlePreviewEnvironment(environment)}
                      >
                        <div className="environment-header flex justify-between items-start mb-2">
                          <div className="environment-name font-medium">
                            {environment.name}
                          </div>
                          <div className="environment-meta flex gap-1">
                            <span className={`px-2 py-0.5 rounded-full text-xs ${rarityInfo.className}`}>
                              {rarityInfo.label}
                            </span>
                            <span className="px-2 py-0.5 rounded-full text-xs bg-gray-100 text-gray-800">
                              {getThemeLabel(environment.themeType)}
                            </span>
                          </div>
                        </div>
                        
                        <div className="environment-image-container mb-2 relative overflow-hidden rounded-lg">
                          <img
                            src={environment.backgroundPath}
                            alt={environment.name}
                            className="w-full h-32 object-cover"
                            onError={(e) => {
                              const target = e.target as HTMLImageElement;
                              target.onerror = null;
                              target.src = '/assets/environments/default.svg';
                            }}
                          />
                        </div>
                        
                        <div className="environment-description text-sm text-gray-600 line-clamp-2">
                          {environment.description}
                        </div>
                      </motion.div>
                    );
                  })}
                </motion.div>
              )}
            </div>
          </div>
        )}
      </div>
    </ScrollDialog>
  );
};

export default PandaEnvironmentPanel;
</file>

<file path="src/components/reflection/EnhancedReflectionModule.tsx">
// src/components/reflection/EnhancedReflectionModule.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Button from '@/components/common/Button';
import ScrollDialog from '@/components/game/ScrollDialog';
import { playSound, SoundType } from '@/utils/sound';
import { TaskRecord } from '@/services/taskService';
import { 
  ReflectionTriggerRecord, 
  ReflectionTriggerType,
  createReflection,
  completeReflection,
  markTriggerAsCompleted
} from '@/services/reflectionService';
import { getPandaMood, updatePandaMood } from '@/services/pandaStateService';
import MoodTracker from './MoodTracker';
import LoadingSpinner from '@/components/common/LoadingSpinner';

interface EnhancedReflectionModuleProps {
  isOpen: boolean;
  onClose: () => void;
  taskId?: number;
  taskName?: string;
  trigger?: ReflectionTriggerRecord;
  onReflectionComplete?: () => void;
}

/**
 * å¢å¼ºç‰ˆåæ€æ¨¡å—ç»„ä»¶
 * ç”¨äºå¸®åŠ©ç”¨æˆ·åæ€ä»»åŠ¡å®Œæˆæƒ…å†µå’Œæƒ…ç»ªçŠ¶æ€
 */
const EnhancedReflectionModule: React.FC<EnhancedReflectionModuleProps> = ({
  isOpen,
  onClose,
  taskId,
  taskName,
  trigger,
  onReflectionComplete
}) => {
  const [step, setStep] = useState(1);
  const [mood, setMood] = useState<string>('neutral');
  const [reflection, setReflection] = useState('');
  const [action, setAction] = useState('');
  const [suggestedActions, setSuggestedActions] = useState<string[]>([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [pandaMessage, setPandaMessage] = useState('');
  const [reflectionId, setReflectionId] = useState<number | null>(null);
  const [tags, setTags] = useState<string[]>([]);
  const [selectedTag, setSelectedTag] = useState<string>('');
  const [customTag, setCustomTag] = useState('');
  const [showMoodTracker, setShowMoodTracker] = useState(false);
  
  // å½“å‰ç”¨æˆ·IDï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥ä»ç”¨æˆ·ä¼šè¯ä¸­è·å–ï¼‰
  const userId = 'current-user';

  // æ ¹æ®è§¦å‘ç±»å‹è®¾ç½®åˆå§‹çŠ¶æ€
  useEffect(() => {
    if (trigger) {
      switch (trigger.type) {
        case ReflectionTriggerType.MOOD_CHANGE:
          if (trigger.data?.mood) {
            setMood(trigger.data.mood);
          }
          setPandaMessage('æˆ‘æ³¨æ„åˆ°ä½ çš„æƒ…ç»ªæœ‰äº›æ³¢åŠ¨ã€‚æƒ³èŠèŠå—ï¼Ÿ');
          break;
        case ReflectionTriggerType.TASK_FAILURE:
          setPandaMessage(
            trigger.data?.taskTitle
              ? `ä»»åŠ¡"${trigger.data.taskTitle}"æœªèƒ½æŒ‰æ—¶å®Œæˆã€‚è¿™æ²¡å…³ç³»ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€èµ·åæ€ä¸€ä¸‹ã€‚`
              : 'æœ‰ä¸€ä¸ªä»»åŠ¡æœªèƒ½æŒ‰æ—¶å®Œæˆã€‚è¿™æ²¡å…³ç³»ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€èµ·åæ€ä¸€ä¸‹ã€‚'
          );
          setTaskId(trigger.data?.taskId);
          setTaskName(trigger.data?.taskTitle);
          break;
        case ReflectionTriggerType.DAILY_REFLECTION:
          setPandaMessage('ä»Šå¤©è¿‡å¾—å¦‚ä½•ï¼ŸèŠ±ç‚¹æ—¶é—´åæ€ä¸€ä¸‹ä»Šå¤©çš„ç»å†å§ã€‚');
          break;
        case ReflectionTriggerType.WEEKLY_REVIEW:
          setPandaMessage('è¿™å‘¨è¿‡å¾—å¦‚ä½•ï¼Ÿè®©æˆ‘ä»¬ä¸€èµ·å›é¡¾ä¸€ä¸‹è¿™å‘¨çš„ç»å†ã€‚');
          break;
        default:
          setPandaMessage('æ¬¢è¿æ¥åˆ°é™å¿ƒèŒ¶å®¤ã€‚æƒ³èŠèŠä½ çš„æ„Ÿå—å—ï¼Ÿ');
      }
    } else if (taskName) {
      setPandaMessage(`å…³äºä»»åŠ¡"${taskName}"ï¼Œä½ æœ‰ä»€ä¹ˆæƒ³åˆ†äº«çš„å—ï¼Ÿ`);
    } else {
      setPandaMessage('æ¬¢è¿æ¥åˆ°é™å¿ƒèŒ¶å®¤ã€‚æƒ³èŠèŠä½ çš„æ„Ÿå—å—ï¼Ÿ');
    }
  }, [trigger, taskName]);

  // æ ¹æ®åæ€å†…å®¹ç”Ÿæˆå»ºè®®è¡ŒåŠ¨å’Œæ ‡ç­¾
  useEffect(() => {
    if (reflection && step === 2) {
      // ç”Ÿæˆæ ‡ç­¾
      const extractedTags = extractTags(reflection);
      setTags(extractedTags);
      
      // ç”Ÿæˆå»ºè®®è¡ŒåŠ¨
      const suggestedActions = generateSuggestedActions(reflection, extractedTags);
      setSuggestedActions(suggestedActions);
    }
  }, [reflection, step]);

  // ä»åæ€å†…å®¹ä¸­æå–æ ‡ç­¾
  const extractTags = (text: string): string[] => {
    const lowerText = text.toLowerCase();
    const extractedTags: string[] = [];
    
    // æƒ…ç»ªæ ‡ç­¾
    if (lowerText.includes('å¼€å¿ƒ') || lowerText.includes('é«˜å…´') || lowerText.includes('å¿«ä¹')) {
      extractedTags.push('å¼€å¿ƒ');
    }
    if (lowerText.includes('éš¾è¿‡') || lowerText.includes('ä¼¤å¿ƒ') || lowerText.includes('æ‚²ä¼¤')) {
      extractedTags.push('éš¾è¿‡');
    }
    if (lowerText.includes('ç„¦è™‘') || lowerText.includes('æ‹…å¿ƒ') || lowerText.includes('ç´§å¼ ')) {
      extractedTags.push('ç„¦è™‘');
    }
    if (lowerText.includes('å‹åŠ›') || lowerText.includes('å‹æŠ‘') || lowerText.includes('é‡æ‹…')) {
      extractedTags.push('å‹åŠ›');
    }
    if (lowerText.includes('ç–²æƒ«') || lowerText.includes('ç´¯') || lowerText.includes('ç–²åŠ³')) {
      extractedTags.push('ç–²æƒ«');
    }
    
    // ä¸»é¢˜æ ‡ç­¾
    if (lowerText.includes('å·¥ä½œ') || lowerText.includes('èŒåœº') || lowerText.includes('äº‹ä¸š')) {
      extractedTags.push('å·¥ä½œ');
    }
    if (lowerText.includes('å­¦ä¹ ') || lowerText.includes('è€ƒè¯•') || lowerText.includes('è¯¾ç¨‹')) {
      extractedTags.push('å­¦ä¹ ');
    }
    if (lowerText.includes('å®¶åº­') || lowerText.includes('äº²äºº') || lowerText.includes('çˆ¶æ¯')) {
      extractedTags.push('å®¶åº­');
    }
    if (lowerText.includes('æœ‹å‹') || lowerText.includes('å‹è°Š') || lowerText.includes('ç¤¾äº¤')) {
      extractedTags.push('ç¤¾äº¤');
    }
    if (lowerText.includes('å¥åº·') || lowerText.includes('èº«ä½“') || lowerText.includes('ç–¾ç—…')) {
      extractedTags.push('å¥åº·');
    }
    
    return extractedTags;
  };

  // æ ¹æ®åæ€å†…å®¹å’Œæ ‡ç­¾ç”Ÿæˆå»ºè®®è¡ŒåŠ¨
  const generateSuggestedActions = (text: string, tags: string[]): string[] => {
    const actions: string[] = [];
    const lowerText = text.toLowerCase();
    
    // æ ¹æ®æ ‡ç­¾æ·»åŠ å»ºè®®
    if (tags.includes('ç„¦è™‘') || tags.includes('å‹åŠ›')) {
      actions.push('å°è¯•5åˆ†é’Ÿçš„æ·±å‘¼å¸å†¥æƒ³');
      actions.push('å‡ºå»æ•£æ­¥15åˆ†é’Ÿ');
      actions.push('ä¸æœ‹å‹èŠå¤©åˆ†äº«æ„Ÿå—');
      actions.push('å†™ä¸‹ä¸‰ä»¶è®©ä½ æ„Ÿåˆ°æ„Ÿæ¿€çš„äº‹æƒ…');
    }
    
    if (tags.includes('ç–²æƒ«')) {
      actions.push('ç¡®ä¿ä»Šæ™šæ—©ç‚¹ä¼‘æ¯');
      actions.push('å°è¯•20åˆ†é’Ÿçš„åˆä¼‘');
      actions.push('å‡å°‘ä»Šå¤©çš„ä»»åŠ¡é‡');
      actions.push('å–è¶³å¤Ÿçš„æ°´ï¼Œåƒäº›å¥åº·çš„é£Ÿç‰©');
    }
    
    // æ ¹æ®æ–‡æœ¬å†…å®¹æ·»åŠ å»ºè®®
    if (lowerText.includes('æ‹–å»¶') || lowerText.includes('ä¸“æ³¨') || lowerText.includes('åˆ†å¿ƒ')) {
      actions.push('ä½¿ç”¨ç•ªèŒ„å·¥ä½œæ³•ï¼Œä¸“æ³¨25åˆ†é’Ÿ');
      actions.push('å°†å¤§ä»»åŠ¡åˆ†è§£æˆå°æ­¥éª¤');
      actions.push('åˆ›å»ºä¸€ä¸ªæ— å¹²æ‰°çš„å·¥ä½œç¯å¢ƒ');
      actions.push('è®¾ç½®ä¸€ä¸ªå°çš„ã€å¯å®ç°çš„ç›®æ ‡');
    }
    
    if (lowerText.includes('å­¤ç‹¬') || lowerText.includes('å¯‚å¯')) {
      actions.push('ç»™ä¸€ä½ä¹…æœªè”ç³»çš„æœ‹å‹æ‰“ç”µè¯');
      actions.push('å‚åŠ ä¸€ä¸ªç¤¾åŒºæ´»åŠ¨æˆ–çº¿ä¸Šèšä¼š');
      actions.push('å°è¯•ä¸€é¡¹å¯ä»¥è®¤è¯†æ–°æœ‹å‹çš„çˆ±å¥½');
    }
    
    // å¦‚æœæ²¡æœ‰åŒ¹é…åˆ°ä»»ä½•å»ºè®®ï¼Œæ·»åŠ ä¸€äº›é€šç”¨å»ºè®®
    if (actions.length === 0) {
      actions.push('èŠ±5åˆ†é’Ÿè¿›è¡Œæ·±å‘¼å¸å†¥æƒ³');
      actions.push('å†™ä¸‹ä¸‰ä»¶è®©ä½ æ„Ÿåˆ°æ„Ÿæ¿€çš„äº‹æƒ…');
      actions.push('è®¾å®šä¸€ä¸ªå°çš„ã€å¯å®ç°çš„ç›®æ ‡');
      actions.push('ä¸æœ‹å‹æˆ–å®¶äººåˆ†äº«ä½ çš„æ„Ÿå—');
    }
    
    return actions;
  };

  // å¤„ç†åˆ›å»ºåæ€è®°å½•
  const handleCreateReflection = async () => {
    try {
      // åˆ›å»ºåæ€è®°å½•
      const newReflection = await createReflection({
        userId,
        taskId,
        mood,
        reflection,
        action: '',
        tags
      });
      
      // ä¿å­˜åæ€ID
      setReflectionId(newReflection.id!);
      
      return newReflection.id!;
    } catch (err) {
      console.error('Failed to create reflection:', err);
      throw err;
    }
  };

  // å¤„ç†å®Œæˆåæ€
  const handleCompleteReflection = async () => {
    try {
      setIsSubmitting(true);
      
      // å¦‚æœè¿˜æ²¡æœ‰åˆ›å»ºåæ€è®°å½•ï¼Œå…ˆåˆ›å»º
      let id = reflectionId;
      if (!id) {
        id = await handleCreateReflection();
      }
      
      // å®Œæˆåæ€è®°å½•
      await completeReflection(id, action);
      
      // å¦‚æœæ˜¯ä»è§¦å‘è®°å½•æ‰“å¼€çš„ï¼Œæ ‡è®°è§¦å‘è®°å½•ä¸ºå·²å®Œæˆ
      if (trigger && trigger.id) {
        await markTriggerAsCompleted(trigger.id);
      }
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // å¦‚æœå¿ƒæƒ…ä¸å¥½ï¼Œå°è¯•æ›´æ–°ä¸ºä¸­æ€§
      if (mood === 'sad' || mood === 'anxious' || mood === 'stressed') {
        await updatePandaMood('neutral');
      }
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onReflectionComplete) {
        onReflectionComplete();
      }
      
      // é‡ç½®çŠ¶æ€
      setStep(1);
      setReflection('');
      setAction('');
      setReflectionId(null);
      
      // å…³é—­å¯¹è¯æ¡†
      onClose();
    } catch (err) {
      console.error('Failed to complete reflection:', err);
    } finally {
      setIsSubmitting(false);
    }
  };

  // å¤„ç†é€‰æ‹©å»ºè®®è¡ŒåŠ¨
  const handleSelectAction = (selectedAction: string) => {
    setAction(selectedAction);
  };

  // å¤„ç†æ·»åŠ æ ‡ç­¾
  const handleAddTag = () => {
    if (selectedTag && !tags.includes(selectedTag)) {
      setTags([...tags, selectedTag]);
      setSelectedTag('');
    } else if (customTag && !tags.includes(customTag)) {
      setTags([...tags, customTag]);
      setCustomTag('');
    }
  };

  // å¤„ç†ç§»é™¤æ ‡ç­¾
  const handleRemoveTag = (tag: string) => {
    setTags(tags.filter(t => t !== tag));
  };

  // æ¸²æŸ“æ­¥éª¤1ï¼šåæ€è¾“å…¥
  const renderStep1 = () => (
    <div className="reflection-step">
      <div className="panda-message mb-4 p-3 bg-amber-50 rounded-lg border border-amber-200">
        <div className="flex items-start">
          <div className="panda-avatar mr-2">
            <span className="text-2xl">ğŸ¼</span>
          </div>
          <div className="panda-text">
            <p>{pandaMessage}</p>
          </div>
        </div>
      </div>
      
      {/* æƒ…ç»ªè¿½è¸ªå™¨åˆ‡æ¢æŒ‰é’® */}
      <div className="mood-tracker-toggle mb-4">
        <Button
          variant="secondary"
          onClick={() => setShowMoodTracker(!showMoodTracker)}
          className="w-full"
        >
          {showMoodTracker ? 'éšè—æƒ…ç»ªè¿½è¸ªå™¨' : 'æ˜¾ç¤ºæƒ…ç»ªè¿½è¸ªå™¨'}
        </Button>
      </div>
      
      {/* æƒ…ç»ªè¿½è¸ªå™¨ */}
      <AnimatePresence>
        {showMoodTracker && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.3 }}
            className="mood-tracker-container mb-4 overflow-hidden"
          >
            <MoodTracker
              onMoodRecorded={(moodRecord) => {
                setMood(moodRecord.mood);
                setShowMoodTracker(false);
              }}
            />
          </motion.div>
        )}
      </AnimatePresence>
      
      <div className="reflection-input mb-4">
        <label htmlFor="reflection" className="block text-sm font-medium text-gray-700 mb-1">
          åˆ†äº«ä½ çš„æƒ³æ³•ï¼ˆå¯ä»¥æ˜¯ä»»ä½•æ„Ÿå—ã€å›°éš¾æˆ–æˆå°±ï¼‰
        </label>
        <textarea
          id="reflection"
          className="w-full h-32 p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
          value={reflection}
          onChange={(e) => setReflection(e.target.value)}
          placeholder="ä»Šå¤©æˆ‘æ„Ÿè§‰..."
        />
      </div>
      
      <div className="reflection-actions flex justify-end">
        <Button 
          variant="jade" 
          onClick={async () => {
            // åˆ›å»ºåæ€è®°å½•
            try {
              await handleCreateReflection();
              setStep(2);
            } catch (err) {
              console.error('Failed to proceed to next step:', err);
            }
          }} 
          disabled={!reflection.trim()}
        >
          ç»§ç»­
        </Button>
      </div>
    </div>
  );

  // æ¸²æŸ“æ­¥éª¤2ï¼šè¡ŒåŠ¨é€‰æ‹©
  const renderStep2 = () => (
    <div className="reflection-step">
      <div className="panda-message mb-4 p-3 bg-amber-50 rounded-lg border border-amber-200">
        <div className="flex items-start">
          <div className="panda-avatar mr-2">
            <span className="text-2xl">ğŸ¼</span>
          </div>
          <div className="panda-text">
            <p>è°¢è°¢ä½ çš„åˆ†äº«ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¯èƒ½å¯¹ä½ æœ‰å¸®åŠ©çš„å°è¡ŒåŠ¨ï¼Œä½ å¯ä»¥é€‰æ‹©ä¸€ä¸ªå°è¯•ï¼Œæˆ–è€…åˆ›å»ºè‡ªå·±çš„è¡ŒåŠ¨ã€‚</p>
          </div>
        </div>
      </div>
      
      {/* æ ‡ç­¾åŒºåŸŸ */}
      <div className="tags-section mb-4">
        <h3 className="text-sm font-medium text-gray-700 mb-2">æ ‡ç­¾</h3>
        <div className="tags-container flex flex-wrap gap-2 mb-2">
          {tags.map((tag) => (
            <div
              key={tag}
              className="tag px-2 py-1 bg-gray-100 rounded-full text-xs flex items-center"
            >
              <span>{tag}</span>
              <button
                onClick={() => handleRemoveTag(tag)}
                className="ml-1 text-gray-500 hover:text-gray-700"
              >
                <span>Ã—</span>
              </button>
            </div>
          ))}
        </div>
        <div className="add-tag-container flex gap-2">
          <select
            value={selectedTag}
            onChange={(e) => setSelectedTag(e.target.value)}
            className="flex-grow p-1 text-sm border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
          >
            <option value="">é€‰æ‹©æ ‡ç­¾...</option>
            <option value="å¼€å¿ƒ">å¼€å¿ƒ</option>
            <option value="éš¾è¿‡">éš¾è¿‡</option>
            <option value="ç„¦è™‘">ç„¦è™‘</option>
            <option value="å‹åŠ›">å‹åŠ›</option>
            <option value="ç–²æƒ«">ç–²æƒ«</option>
            <option value="å·¥ä½œ">å·¥ä½œ</option>
            <option value="å­¦ä¹ ">å­¦ä¹ </option>
            <option value="å®¶åº­">å®¶åº­</option>
            <option value="ç¤¾äº¤">ç¤¾äº¤</option>
            <option value="å¥åº·">å¥åº·</option>
          </select>
          <input
            type="text"
            value={customTag}
            onChange={(e) => setCustomTag(e.target.value)}
            placeholder="è‡ªå®šä¹‰æ ‡ç­¾"
            className="flex-grow p-1 text-sm border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
          />
          <Button
            variant="secondary"
            size="small"
            onClick={handleAddTag}
            disabled={!selectedTag && !customTag}
          >
            æ·»åŠ 
          </Button>
        </div>
      </div>
      
      <div className="suggested-actions mb-4">
        <h3 className="text-sm font-medium text-gray-700 mb-2">å»ºè®®çš„è¡ŒåŠ¨</h3>
        <div className="grid grid-cols-1 gap-2">
          {suggestedActions.map((suggestedAction, index) => (
            <motion.div
              key={index}
              className={`p-2 border rounded-md cursor-pointer ${action === suggestedAction ? 'border-jade-500 bg-jade-50' : 'border-gray-300'}`}
              onClick={() => handleSelectAction(suggestedAction)}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
            >
              {suggestedAction}
            </motion.div>
          ))}
        </div>
      </div>
      
      <div className="custom-action mb-4">
        <label htmlFor="custom-action" className="block text-sm font-medium text-gray-700 mb-1">
          æˆ–è€…ï¼Œåˆ›å»ºä½ è‡ªå·±çš„è¡ŒåŠ¨
        </label>
        <input
          id="custom-action"
          type="text"
          className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
          value={action}
          onChange={(e) => setAction(e.target.value)}
          placeholder="æˆ‘å°†..."
        />
      </div>
      
      <div className="reflection-actions flex justify-between">
        <Button variant="secondary" onClick={() => setStep(1)}>
          è¿”å›
        </Button>
        <Button variant="gold" onClick={handleCompleteReflection} disabled={!action.trim() || isSubmitting}>
          {isSubmitting ? (
            <LoadingSpinner variant="white" size="small" />
          ) : (
            'å®Œæˆåæ€'
          )}
        </Button>
      </div>
    </div>
  );

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="é™å¿ƒèŒ¶å®¤"
      closeOnOutsideClick={false}
      closeOnEsc={true}
      showCloseButton={true}
    >
      <div className="reflection-module p-4">
        <AnimatePresence mode="wait">
          <motion.div
            key={`step-${step}`}
            initial={{ opacity: 0, x: step === 1 ? -20 : 20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: step === 1 ? 20 : -20 }}
            transition={{ duration: 0.3 }}
          >
            {step === 1 ? renderStep1() : renderStep2()}
          </motion.div>
        </AnimatePresence>
      </div>
    </ScrollDialog>
  );
};

export default EnhancedReflectionModule;
</file>

<file path="src/components/reflection/MoodTracker.tsx">
// src/components/reflection/MoodTracker.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { MoodType, MoodIntensity, recordMood, getUserMoods, MoodRecord } from '@/services/reflectionService';
import Button from '@/components/common/Button';
import { playSound, SoundType } from '@/utils/sound';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface MoodTrackerProps {
  onMoodRecorded?: (mood: MoodRecord) => void;
  compact?: boolean;
  className?: string;
  labels?: {
    currentMoodQuestion?: string;
    intensityLabel?: string;
    noteLabel?: string;
    recordMoodButton?: string;
    historyLabel?: string;
    noMoodsMessage?: string;
    backLabel?: string;
    intensityStrength?: {
      veryMild?: string;
      mild?: string;
      moderate?: string;
      strong?: string;
      veryStrong?: string;
    };
  };
}

/**
 * æƒ…ç»ªè¿½è¸ªç»„ä»¶
 * ç”¨äºè®°å½•å’Œæ˜¾ç¤ºç”¨æˆ·çš„æƒ…ç»ªçŠ¶æ€
 */
const MoodTracker: React.FC<MoodTrackerProps> = ({
  onMoodRecorded,
  compact = false,
  className = '',
  labels
}) => {
  const [selectedMood, setSelectedMood] = useState<MoodType | null>(null);
  const [intensity, setIntensity] = useState<MoodIntensity>(3);
  const [note, setNote] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [recentMoods, setRecentMoods] = useState<MoodRecord[]>([]);
  const [showHistory, setShowHistory] = useState(false);

  // å½“å‰ç”¨æˆ·IDï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥ä»ç”¨æˆ·ä¼šè¯ä¸­è·å–ï¼‰
  const userId = 'current-user';

  // åŠ è½½æœ€è¿‘çš„æƒ…ç»ªè®°å½•
  const loadRecentMoods = async () => {
    try {
      const moods = await getUserMoods(userId, 5);
      setRecentMoods(moods);
    } catch (err) {
      console.error('Failed to load recent moods:', err);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadRecentMoods();
  }, []);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('moods', loadRecentMoods);

  // å¤„ç†æäº¤æƒ…ç»ª
  const handleSubmit = async () => {
    if (!selectedMood) return;

    try {
      setIsSubmitting(true);

      // è®°å½•æƒ…ç»ª
      const mood = await recordMood({
        userId,
        mood: selectedMood,
        intensity,
        note: note.trim() || undefined
      });

      // æ’­æ”¾éŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);

      // é‡ç½®è¡¨å•
      setSelectedMood(null);
      setIntensity(3);
      setNote('');

      // é‡æ–°åŠ è½½æœ€è¿‘çš„æƒ…ç»ªè®°å½•
      await loadRecentMoods();

      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onMoodRecorded) {
        onMoodRecorded(mood);
      }
    } catch (err) {
      console.error('Failed to record mood:', err);
    } finally {
      setIsSubmitting(false);
    }
  };

  // è·å–æƒ…ç»ªå›¾æ ‡å’Œé¢œè‰²
  const getMoodInfo = (mood: MoodType) => {
    switch (mood) {
      case MoodType.HAPPY:
        return { icon: 'ğŸ˜„', color: 'bg-yellow-100 text-yellow-800', label: 'å¼€å¿ƒ' };
      case MoodType.CONTENT:
        return { icon: 'ğŸ˜Š', color: 'bg-green-100 text-green-800', label: 'æ»¡è¶³' };
      case MoodType.NEUTRAL:
        return { icon: 'ğŸ˜', color: 'bg-gray-100 text-gray-800', label: 'å¹³é™' };
      case MoodType.SAD:
        return { icon: 'ğŸ˜¢', color: 'bg-blue-100 text-blue-800', label: 'éš¾è¿‡' };
      case MoodType.ANXIOUS:
        return { icon: 'ğŸ˜°', color: 'bg-purple-100 text-purple-800', label: 'ç„¦è™‘' };
      case MoodType.STRESSED:
        return { icon: 'ğŸ˜«', color: 'bg-red-100 text-red-800', label: 'å‹åŠ›' };
      case MoodType.TIRED:
        return { icon: 'ğŸ˜´', color: 'bg-gray-200 text-gray-800', label: 'ç–²æƒ«' };
      case MoodType.ENERGETIC:
        return { icon: 'âš¡', color: 'bg-yellow-200 text-yellow-800', label: 'ç²¾åŠ›å……æ²›' };
      case MoodType.MOTIVATED:
        return { icon: 'ğŸ”¥', color: 'bg-orange-100 text-orange-800', label: 'æœ‰åŠ¨åŠ›' };
      case MoodType.FRUSTRATED:
        return { icon: 'ğŸ˜¤', color: 'bg-red-200 text-red-800', label: 'æ²®ä¸§' };
      case MoodType.ANGRY:
        return { icon: 'ğŸ˜ ', color: 'bg-red-100 text-red-800', label: 'ç”Ÿæ°”' };
      case MoodType.CALM:
        return { icon: 'ğŸ˜Œ', color: 'bg-blue-100 text-blue-800', label: 'å¹³é™' };
      default:
        return { icon: 'â“', color: 'bg-gray-100 text-gray-800', label: 'æœªçŸ¥' };
    }
  };

  // è·å–å¼ºåº¦æ ‡ç­¾
  const getIntensityLabel = (intensity: MoodIntensity) => {
    switch (intensity) {
      case 1: return labels?.intensityStrength?.veryMild || 'Very Mild';
      case 2: return labels?.intensityStrength?.mild || 'Mild';
      case 3: return labels?.intensityStrength?.moderate || 'Moderate';
      case 4: return labels?.intensityStrength?.strong || 'Strong';
      case 5: return labels?.intensityStrength?.veryStrong || 'Very Strong';
      default: return 'Unknown';
    }
  };

  // æ¸²æŸ“æƒ…ç»ªé€‰æ‹©å™¨
  const renderMoodSelector = () => {
    const moods = [
      MoodType.HAPPY,
      MoodType.CONTENT,
      MoodType.NEUTRAL,
      MoodType.SAD,
      MoodType.ANXIOUS,
      MoodType.STRESSED,
      MoodType.TIRED,
      MoodType.ENERGETIC,
      MoodType.MOTIVATED,
      MoodType.FRUSTRATED,
      MoodType.ANGRY,
      MoodType.CALM
    ];

    return (
      <div className="mood-selector">
        <h3 className="text-lg font-bold mb-3">
          {labels?.currentMoodQuestion || "How are you feeling right now?"}
        </h3>
        <div className="grid grid-cols-4 gap-3">
          {moods.map((mood) => {
            const { icon, color, label } = getMoodInfo(mood);
            return (
              <motion.div
                key={mood}
                className={`mood-item p-3 rounded-lg cursor-pointer text-center ${
                  selectedMood === mood ? 'ring-2 ring-jade-500 shadow-md' : ''
                } ${color} hover:shadow-md transition-all duration-200`}
                onClick={() => setSelectedMood(mood)}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
              >
                <div className="mood-icon text-2xl mb-1">{icon}</div>
                <div className="mood-label text-xs font-medium">{label}</div>
              </motion.div>
            );
          })}
        </div>
      </div>
    );
  };

  // æ¸²æŸ“å¼ºåº¦é€‰æ‹©å™¨
  const renderIntensitySelector = () => {
    return (
      <div className="intensity-selector mt-4">
        <h3 className="text-lg font-bold mb-2">{labels?.intensityLabel || "How intense is this feeling?"}</h3>
        <div className="flex items-center">
          <input
            type="range"
            min="1"
            max="5"
            value={intensity}
            onChange={(e) => setIntensity(parseInt(e.target.value) as MoodIntensity)}
            className="flex-grow h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
          />
          <span className="ml-3 text-sm font-medium px-2 py-1 bg-jade-100 text-jade-800 rounded-md">
            {getIntensityLabel(intensity)}
          </span>
        </div>
      </div>
    );
  };

  // æ¸²æŸ“ç¬”è®°è¾“å…¥æ¡†
  const renderNoteInput = () => {
    return (
      <div className="note-input mt-4">
        <h3 className="text-lg font-bold mb-2">{labels?.noteLabel || "Anything you'd like to note? (optional)"}</h3>
        <textarea
          value={note}
          onChange={(e) => setNote(e.target.value)}
          className="w-full p-3 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500 h-24"
          placeholder={labels?.notePlaceholder || "Write down your thoughts..."}
        />
      </div>
    );
  };

  // æ¸²æŸ“æœ€è¿‘çš„æƒ…ç»ªè®°å½•
  const renderRecentMoods = () => {
    if (recentMoods.length === 0) {
      return (
        <div className="text-center text-gray-500 p-4">
          {labels?.noMoodsMessage || "No mood records yet"}
        </div>
      );
    }

    return (
      <div className="recent-moods-list">
        {recentMoods.map((mood) => {
          const { icon, color } = getMoodInfo(mood.mood as MoodType);
          return (
            <div
              key={mood.id}
              className="mood-record flex items-center p-2 border-b border-gray-200 last:border-b-0"
            >
              <div className={`mood-icon p-2 rounded-full ${color} mr-3`}>
                <span className="text-xl">{icon}</span>
              </div>
              <div className="mood-info flex-grow">
                <div className="flex justify-between">
                  <span className="font-medium">{getMoodInfo(mood.mood as MoodType).label}</span>
                  <span className="text-sm text-gray-500">
                    {new Date(mood.createdAt).toLocaleString()}
                  </span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-sm text-gray-600">
                    å¼ºåº¦: {getIntensityLabel(mood.intensity as MoodIntensity)}
                  </span>
                </div>
                {mood.note && (
                  <p className="text-sm text-gray-700 mt-1">{mood.note}</p>
                )}
              </div>
            </div>
          );
        })}
      </div>
    );
  };

  // ç´§å‡‘æ¨¡å¼
  if (compact) {
    return (
      <div className={`mood-tracker-compact ${className}`}>
        <div className="flex items-center">
          <div className="mood-selector-compact flex-grow">
            <div className="flex flex-wrap gap-2">
              {[MoodType.HAPPY, MoodType.CONTENT, MoodType.NEUTRAL, MoodType.SAD, MoodType.ANXIOUS].map((mood) => {
                const { icon, color } = getMoodInfo(mood);
                return (
                  <motion.div
                    key={mood}
                    className={`mood-item p-2 rounded-full cursor-pointer ${
                      selectedMood === mood ? 'ring-2 ring-jade-500' : ''
                    } ${color}`}
                    onClick={() => setSelectedMood(mood)}
                    whileHover={{ scale: 1.05 }}
                    whileTap={{ scale: 0.95 }}
                  >
                    <div className="mood-icon text-xl">{icon}</div>
                  </motion.div>
                );
              })}
            </div>
          </div>
          <Button
            variant="jade"
            size="small"
            onClick={handleSubmit}
            disabled={!selectedMood || isSubmitting}
            className="ml-2"
          >
            è®°å½•
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className={`mood-tracker ${className}`}>
      <div className="mood-tracker-header flex justify-between items-center mb-4">
        <h2 className="text-xl font-bold text-jade-700">
          <span className="mr-2">ğŸµ</span>
          {labels?.title || "Mood Tracking"}
        </h2>
        <Button
          variant="secondary"
          size="small"
          onClick={() => setShowHistory(!showHistory)}
        >
          {showHistory ? (labels?.backLabel || "Back") : (labels?.historyLabel || "History")}
        </Button>
      </div>

      <AnimatePresence mode="wait">
        {showHistory ? (
          <motion.div
            key="history"
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: -20 }}
            transition={{ duration: 0.3 }}
            className="mood-history"
          >
            <h3 className="text-lg font-bold mb-2">æœ€è¿‘çš„æƒ…ç»ªè®°å½•</h3>
            {renderRecentMoods()}
          </motion.div>
        ) : (
          <motion.div
            key="form"
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: 20 }}
            transition={{ duration: 0.3 }}
            className="mood-form"
          >
            {renderMoodSelector()}

            {selectedMood && (
              <>
                {renderIntensitySelector()}
                {renderNoteInput()}

                <div className="form-actions mt-4 flex justify-end">
                  <Button
                    variant="jade"
                    onClick={handleSubmit}
                    disabled={isSubmitting}
                  >
                    {labels?.recordMoodButton || "Record Mood"}
                  </Button>
                </div>
              </>
            )}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default MoodTracker;
</file>

<file path="src/components/reflection/README.md">
# åæ€æ¨¡å—æ–‡æ¡£

æœ¬æ–‡æ¡£è®°å½•äº†PandaHabitåº”ç”¨ä¸­çš„åæ€æ¨¡å—ï¼ŒåŒ…æ‹¬å®ƒçš„åŠŸèƒ½ã€ç»„ä»¶å’Œä½¿ç”¨æ–¹æ³•ã€‚

## æ¦‚è¿°

åæ€æ¨¡å—æ˜¯PandaHabitåº”ç”¨ä¸­çš„ä¸€ä¸ªé‡è¦åŠŸèƒ½ï¼Œå®ƒæä¾›äº†ä¸€ä¸ªæ¸©å’Œã€éåˆ¤æ–­æ€§çš„å¯¹è¯ç³»ç»Ÿï¼Œå¸®åŠ©ç”¨æˆ·æ¢ç´¢å›°éš¾å¹¶æä¾›æ”¯æŒã€‚åæ€æ¨¡å—åŒ…æ‹¬æƒ…ç»ªè¿½è¸ªã€åæ€è®°å½•ã€æ”¯æŒæ€§åé¦ˆå’Œå¯è¡Œå»ºè®®ç³»ç»Ÿç­‰åŠŸèƒ½ã€‚

## ç»„ä»¶

### EnhancedReflectionModule

`EnhancedReflectionModule` æ˜¯åæ€æ¨¡å—çš„æ ¸å¿ƒç»„ä»¶ï¼Œå®ƒæä¾›äº†ä¸€ä¸ªäº¤äº’å¼çš„åæ€ä½“éªŒï¼ŒåŒ…æ‹¬æƒ…ç»ªè®°å½•ã€åæ€è¾“å…¥ã€æ ‡ç­¾ç®¡ç†å’Œè¡ŒåŠ¨å»ºè®®ã€‚

#### å±æ€§

| å±æ€§å | ç±»å‹ | æè¿° |
|--------|------|------|
| isOpen | boolean | æ§åˆ¶æ¨¡å—æ˜¯å¦æ˜¾ç¤º |
| onClose | () => void | å…³é—­æ¨¡å—çš„å›è°ƒå‡½æ•° |
| taskId | number | ç›¸å…³ä»»åŠ¡IDï¼ˆå¯é€‰ï¼‰ |
| taskName | string | ç›¸å…³ä»»åŠ¡åç§°ï¼ˆå¯é€‰ï¼‰ |
| trigger | ReflectionTriggerRecord | è§¦å‘è®°å½•ï¼ˆå¯é€‰ï¼‰ |
| onReflectionComplete | () => void | åæ€å®Œæˆåçš„å›è°ƒå‡½æ•°ï¼ˆå¯é€‰ï¼‰ |

#### ä½¿ç”¨ç¤ºä¾‹

```tsx
<EnhancedReflectionModule
  isOpen={showReflectionModule}
  onClose={() => setShowReflectionModule(false)}
  taskId={123}
  taskName="æ¯æ—¥å†¥æƒ³"
  onReflectionComplete={handleReflectionComplete}
/>
```

### MoodTracker

`MoodTracker` æ˜¯ä¸€ä¸ªç”¨äºè®°å½•å’Œæ˜¾ç¤ºç”¨æˆ·æƒ…ç»ªçŠ¶æ€çš„ç»„ä»¶ï¼Œå®ƒæ”¯æŒå¤šç§æƒ…ç»ªç±»å‹å’Œå¼ºåº¦çº§åˆ«ã€‚

#### å±æ€§

| å±æ€§å | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|--------|------|--------|------|
| onMoodRecorded | (mood: MoodRecord) => void | undefined | æƒ…ç»ªè®°å½•åçš„å›è°ƒå‡½æ•° |
| compact | boolean | false | æ˜¯å¦ä½¿ç”¨ç´§å‡‘æ¨¡å¼ |
| className | string | '' | è‡ªå®šä¹‰CSSç±»å |

#### ä½¿ç”¨ç¤ºä¾‹

```tsx
<MoodTracker
  onMoodRecorded={handleMoodRecorded}
  compact={false}
/>
```

### ReflectionTriggerNotification

`ReflectionTriggerNotification` æ˜¯ä¸€ä¸ªç”¨äºæ˜¾ç¤ºåæ€è§¦å‘é€šçŸ¥çš„ç»„ä»¶ï¼Œå®ƒä¼šåœ¨ç‰¹å®šæ¡ä»¶ä¸‹ï¼ˆå¦‚æƒ…ç»ªå˜åŒ–ã€ä»»åŠ¡å¤±è´¥ç­‰ï¼‰æç¤ºç”¨æˆ·è¿›è¡Œåæ€ã€‚

#### å±æ€§

| å±æ€§å | ç±»å‹ | æè¿° |
|--------|------|------|
| onTriggerAccepted | (trigger: ReflectionTriggerRecord) => void | ç”¨æˆ·æ¥å—è§¦å‘åçš„å›è°ƒå‡½æ•° |
| onTriggerDismissed | (trigger: ReflectionTriggerRecord) => void | ç”¨æˆ·å¿½ç•¥è§¦å‘åçš„å›è°ƒå‡½æ•° |

#### ä½¿ç”¨ç¤ºä¾‹

```tsx
<ReflectionTriggerNotification
  onTriggerAccepted={handleTriggerAccepted}
  onTriggerDismissed={handleTriggerDismissed}
/>
```

### ReflectionHistory

`ReflectionHistory` æ˜¯ä¸€ä¸ªç”¨äºæ˜¾ç¤ºç”¨æˆ·åæ€å†å²è®°å½•çš„ç»„ä»¶ï¼Œå®ƒæ”¯æŒæŒ‰æ ‡ç­¾ç­›é€‰å’ŒæŸ¥çœ‹è¯¦æƒ…ã€‚

#### å±æ€§

| å±æ€§å | ç±»å‹ | æè¿° |
|--------|------|------|
| isOpen | boolean | æ§åˆ¶ç»„ä»¶æ˜¯å¦æ˜¾ç¤º |
| onClose | () => void | å…³é—­ç»„ä»¶çš„å›è°ƒå‡½æ•° |
| onReflectionSelected | (reflection: ReflectionRecord) => void | é€‰æ‹©åæ€è®°å½•åçš„å›è°ƒå‡½æ•° |

#### ä½¿ç”¨ç¤ºä¾‹

```tsx
<ReflectionHistory
  isOpen={showReflectionHistory}
  onClose={() => setShowReflectionHistory(false)}
  onReflectionSelected={handleReflectionSelected}
/>
```

## æœåŠ¡

### reflectionService

`reflectionService` æ˜¯åæ€æ¨¡å—çš„æ ¸å¿ƒæœåŠ¡ï¼Œå®ƒæä¾›äº†ç®¡ç†åæ€è®°å½•ã€è§¦å‘è®°å½•å’Œæƒ…ç»ªè®°å½•çš„åŠŸèƒ½ã€‚

#### ä¸»è¦å‡½æ•°

| å‡½æ•°å | æè¿° |
|--------|------|
| createReflection | åˆ›å»ºåæ€è®°å½• |
| completeReflection | å®Œæˆåæ€è®°å½• |
| getUserReflections | è·å–ç”¨æˆ·çš„åæ€è®°å½• |
| createReflectionTrigger | åˆ›å»ºåæ€è§¦å‘è®°å½• |
| getUnviewedReflectionTriggers | è·å–æœªæŸ¥çœ‹çš„åæ€è§¦å‘è®°å½• |
| markTriggerAsViewed | æ ‡è®°è§¦å‘è®°å½•ä¸ºå·²æŸ¥çœ‹ |
| markTriggerAsCompleted | æ ‡è®°è§¦å‘è®°å½•ä¸ºå·²å®Œæˆ |
| recordMood | è®°å½•ç”¨æˆ·æƒ…ç»ª |
| getUserMoods | è·å–ç”¨æˆ·çš„æƒ…ç»ªè®°å½• |
| checkTaskFailureTrigger | æ£€æŸ¥ä»»åŠ¡å¤±è´¥æ˜¯å¦éœ€è¦è§¦å‘åæ€ |
| checkDailyReflectionTrigger | æ£€æŸ¥æ˜¯å¦éœ€è¦è§¦å‘æ¯æ—¥åæ€ |
| checkWeeklyReviewTrigger | æ£€æŸ¥æ˜¯å¦éœ€è¦è§¦å‘æ¯å‘¨å›é¡¾ |

## é¡µé¢

### TeaRoomPage

`TeaRoomPage` æ˜¯åæ€æ¨¡å—çš„ä¸»é¡µé¢ï¼Œå®ƒé›†æˆäº†æ‰€æœ‰åæ€ç›¸å…³çš„ç»„ä»¶ï¼Œæä¾›äº†ä¸€ä¸ªå®Œæ•´çš„åæ€ä½“éªŒã€‚

## åŠŸèƒ½

### åæ€æœºä¼šçš„è§¦å‘æ£€æµ‹

åæ€æ¨¡å—ä¼šåœ¨ä»¥ä¸‹æƒ…å†µä¸‹è§¦å‘åæ€æœºä¼šï¼š

1. **æƒ…ç»ªå˜åŒ–**ï¼šå½“ç”¨æˆ·è®°å½•è´Ÿé¢æƒ…ç»ªä¸”å¼ºåº¦è¾ƒé«˜æ—¶
2. **ä»»åŠ¡å¤±è´¥**ï¼šå½“ä»»åŠ¡è¿‡æœŸä¸”æœªå®Œæˆæ—¶
3. **æ¯æ—¥åæ€**ï¼šæ¯å¤©è§¦å‘ä¸€æ¬¡
4. **æ¯å‘¨å›é¡¾**ï¼šæ¯å‘¨è§¦å‘ä¸€æ¬¡
5. **æ‰‹åŠ¨è§¦å‘**ï¼šç”¨æˆ·ä¸»åŠ¨å¼€å§‹åæ€

### æ¸©å’Œã€éåˆ¤æ–­æ€§çš„å¯¹è¯ç³»ç»Ÿ

åæ€æ¨¡å—ä½¿ç”¨æ¸©å’Œã€éåˆ¤æ–­æ€§çš„è¯­è¨€ä¸ç”¨æˆ·äº¤æµï¼Œå¸®åŠ©ç”¨æˆ·æ¢ç´¢å›°éš¾å¹¶æä¾›æ”¯æŒã€‚ä¾‹å¦‚ï¼š

- "æˆ‘æ³¨æ„åˆ°ä½ æœ€è¿‘å¿ƒæƒ…ä¸å¤ªå¥½ã€‚æƒ³èŠèŠå—ï¼Ÿ"
- "ä»»åŠ¡æœªèƒ½æŒ‰æ—¶å®Œæˆã€‚è¿™æ²¡å…³ç³»ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€èµ·åæ€ä¸€ä¸‹ã€‚"
- "è°¢è°¢ä½ çš„åˆ†äº«ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¯èƒ½å¯¹ä½ æœ‰å¸®åŠ©çš„å°è¡ŒåŠ¨ã€‚"

### ç”¨æˆ·è¾“å…¥æ”¶é›†å’Œå¤„ç†

åæ€æ¨¡å—æ”¶é›†ç”¨æˆ·çš„åæ€å†…å®¹ï¼Œå¹¶ä»ä¸­æå–å…³é”®è¯å’Œä¸»é¢˜ï¼Œç”¨äºç”Ÿæˆæ ‡ç­¾å’Œå»ºè®®è¡ŒåŠ¨ã€‚

### æ”¯æŒæ€§åé¦ˆç”Ÿæˆ

åæ€æ¨¡å—æ ¹æ®ç”¨æˆ·çš„åæ€å†…å®¹ç”Ÿæˆæ”¯æŒæ€§åé¦ˆï¼Œå¸®åŠ©ç”¨æˆ·ç†è§£è‡ªå·±çš„æ„Ÿå—å’Œæƒ³æ³•ã€‚

### å¯è¡Œå»ºè®®ç³»ç»Ÿ

åæ€æ¨¡å—æ ¹æ®ç”¨æˆ·çš„åæ€å†…å®¹å’Œæ ‡ç­¾ç”Ÿæˆå¯è¡Œçš„å»ºè®®è¡ŒåŠ¨ï¼Œå¸®åŠ©ç”¨æˆ·é‡‡å–ç§¯æçš„æ­¥éª¤æ”¹å–„çŠ¶å†µã€‚

### æƒ…ç»ªè·Ÿè¸ªå’Œæ¨¡å¼è¯†åˆ«

åæ€æ¨¡å—é€šè¿‡æƒ…ç»ªè¿½è¸ªåŠŸèƒ½è®°å½•ç”¨æˆ·çš„æƒ…ç»ªçŠ¶æ€ï¼Œå¹¶è¯†åˆ«æƒ…ç»ªæ¨¡å¼ï¼Œå¸®åŠ©ç”¨æˆ·äº†è§£è‡ªå·±çš„æƒ…ç»ªå˜åŒ–ã€‚

### è‡ªæˆ‘åŒæƒ…å¼ºåŒ–æœºåˆ¶

åæ€æ¨¡å—é€šè¿‡æ¸©å’Œçš„è¯­è¨€å’Œæ”¯æŒæ€§åé¦ˆï¼Œé¼“åŠ±ç”¨æˆ·å¯¹è‡ªå·±ä¿æŒåŒæƒ…å’Œç†è§£ï¼Œå‡å°‘è‡ªæˆ‘æ‰¹è¯„ã€‚

### é™å¿ƒèŒ¶å®¤ç¯å¢ƒ

åæ€æ¨¡å—æä¾›äº†ä¸€ä¸ªåä¸º"é™å¿ƒèŒ¶å®¤"çš„è™šæ‹Ÿç¯å¢ƒï¼Œè¥é€ ä¸€ä¸ªå®‰é™ã€æ”¾æ¾çš„æ°›å›´ï¼Œå¸®åŠ©ç”¨æˆ·è¿›è¡Œåæ€ã€‚

## æ³¨æ„äº‹é¡¹

1. åæ€æ¨¡å—çš„æ‰€æœ‰ç»„ä»¶éƒ½éµå¾ªåä¸½æ¸¸æˆé£æ ¼è®¾è®¡ï¼ŒåŒ…æ‹¬åŠ¨ç”»æ•ˆæœå’ŒéŸ³æ•ˆã€‚
2. åæ€æ¨¡å—ä¸æ•°æ®æœåŠ¡é›†æˆï¼Œè‡ªåŠ¨æ›´æ–°å’ŒåŒæ­¥æ•°æ®ã€‚
3. åæ€æ¨¡å—æ”¯æŒå¤šè¯­è¨€ï¼Œå¯ä»¥æ ¹æ®ç”¨æˆ·çš„è¯­è¨€è®¾ç½®æ˜¾ç¤ºç›¸åº”çš„å†…å®¹ã€‚
4. åæ€æ¨¡å—çš„è§¦å‘æœºåˆ¶å¯ä»¥æ ¹æ®ç”¨æˆ·çš„ä½¿ç”¨æƒ…å†µè¿›è¡Œè°ƒæ•´ï¼Œé¿å…è¿‡äºé¢‘ç¹çš„æ‰“æ‰°ã€‚
5. åæ€æ¨¡å—çš„å»ºè®®è¡ŒåŠ¨åº”è¯¥æ˜¯å…·ä½“ã€å¯è¡Œçš„ï¼Œå¸®åŠ©ç”¨æˆ·é‡‡å–å®é™…è¡ŒåŠ¨ã€‚
</file>

<file path="src/components/reflection/ReflectionHistory.tsx">
// src/components/reflection/ReflectionHistory.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  ReflectionRecord,
  getUserReflections
} from '@/services/reflectionService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import ScrollDialog from '@/components/game/ScrollDialog';

interface ReflectionHistoryProps {
  isOpen: boolean;
  onClose: () => void;
  onReflectionSelected?: (reflection: ReflectionRecord) => void;
}

/**
 * åæ€å†å²ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºç”¨æˆ·çš„åæ€å†å²è®°å½•
 */
const ReflectionHistory: React.FC<ReflectionHistoryProps> = ({
  isOpen,
  onClose,
  onReflectionSelected
}) => {
  const [reflections, setReflections] = useState<ReflectionRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedReflection, setSelectedReflection] = useState<ReflectionRecord | null>(null);
  const [filterTag, setFilterTag] = useState<string>('');
  const [allTags, setAllTags] = useState<string[]>([]);
  
  // å½“å‰ç”¨æˆ·IDï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥ä»ç”¨æˆ·ä¼šè¯ä¸­è·å–ï¼‰
  const userId = 'current-user';

  // åŠ è½½åæ€å†å²
  const loadReflections = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // è·å–ç”¨æˆ·çš„åæ€è®°å½•
      const userReflections = await getUserReflections(userId);
      setReflections(userReflections);
      
      // æå–æ‰€æœ‰æ ‡ç­¾
      const tags = new Set<string>();
      userReflections.forEach(reflection => {
        if (reflection.tags) {
          reflection.tags.forEach(tag => tags.add(tag));
        }
      });
      setAllTags(Array.from(tags));
    } catch (err) {
      console.error('Failed to load reflections:', err);
      setError('åŠ è½½åæ€å†å²å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    if (isOpen) {
      loadReflections();
    }
  }, [isOpen]);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('reflections', loadReflections);

  // å¤„ç†é€‰æ‹©åæ€
  const handleSelectReflection = (reflection: ReflectionRecord) => {
    setSelectedReflection(reflection);
    
    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onReflectionSelected) {
      onReflectionSelected(reflection);
    }
  };

  // å¤„ç†è¿”å›åˆ—è¡¨
  const handleBackToList = () => {
    setSelectedReflection(null);
  };

  // å¤„ç†ç­›é€‰æ ‡ç­¾
  const handleFilterByTag = (tag: string) => {
    setFilterTag(tag === filterTag ? '' : tag);
  };

  // è·å–ç­›é€‰åçš„åæ€è®°å½•
  const getFilteredReflections = (): ReflectionRecord[] => {
    if (!filterTag) {
      return reflections;
    }
    
    return reflections.filter(reflection => 
      reflection.tags && reflection.tags.includes(filterTag)
    );
  };

  // æ¸²æŸ“åæ€åˆ—è¡¨
  const renderReflectionList = () => {
    const filteredReflections = getFilteredReflections();
    
    if (filteredReflections.length === 0) {
      return (
        <div className="empty-state text-center p-4">
          <p className="text-gray-500">
            {filterTag ? `æ²¡æœ‰åŒ…å«"${filterTag}"æ ‡ç­¾çš„åæ€è®°å½•` : 'æš‚æ— åæ€è®°å½•'}
          </p>
        </div>
      );
    }
    
    return (
      <div className="reflections-list">
        {filteredReflections.map((reflection) => (
          <motion.div
            key={reflection.id}
            className="reflection-item p-3 border-b border-gray-200 last:border-b-0 cursor-pointer hover:bg-gray-50"
            onClick={() => handleSelectReflection(reflection)}
            whileHover={{ x: 5 }}
          >
            <div className="reflection-header flex justify-between items-start mb-2">
              <div className="reflection-date text-sm text-gray-500">
                {new Date(reflection.createdAt).toLocaleString()}
              </div>
              <div className="reflection-mood px-2 py-1 rounded-full text-xs bg-gray-100">
                {reflection.mood}
              </div>
            </div>
            <div className="reflection-content mb-2">
              <p className="text-gray-700 line-clamp-2">{reflection.reflection}</p>
            </div>
            {reflection.tags && reflection.tags.length > 0 && (
              <div className="reflection-tags flex flex-wrap gap-1">
                {reflection.tags.map((tag) => (
                  <span
                    key={tag}
                    className="tag px-2 py-0.5 bg-gray-100 rounded-full text-xs"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleFilterByTag(tag);
                    }}
                  >
                    {tag}
                  </span>
                ))}
              </div>
            )}
          </motion.div>
        ))}
      </div>
    );
  };

  // æ¸²æŸ“åæ€è¯¦æƒ…
  const renderReflectionDetail = () => {
    if (!selectedReflection) return null;
    
    return (
      <div className="reflection-detail">
        <div className="reflection-header mb-4">
          <div className="flex justify-between items-center">
            <div className="reflection-date text-sm text-gray-500">
              {new Date(selectedReflection.createdAt).toLocaleString()}
            </div>
            <div className="reflection-mood px-2 py-1 rounded-full text-xs bg-gray-100">
              {selectedReflection.mood}
            </div>
          </div>
        </div>
        
        <div className="reflection-content mb-4">
          <h3 className="text-md font-bold mb-2">åæ€å†…å®¹</h3>
          <div className="p-3 bg-gray-50 rounded-md">
            <p className="text-gray-700">{selectedReflection.reflection}</p>
          </div>
        </div>
        
        {selectedReflection.action && (
          <div className="reflection-action mb-4">
            <h3 className="text-md font-bold mb-2">è¡ŒåŠ¨è®¡åˆ’</h3>
            <div className="p-3 bg-jade-50 rounded-md border border-jade-100">
              <p className="text-gray-700">{selectedReflection.action}</p>
            </div>
          </div>
        )}
        
        {selectedReflection.tags && selectedReflection.tags.length > 0 && (
          <div className="reflection-tags mb-4">
            <h3 className="text-md font-bold mb-2">æ ‡ç­¾</h3>
            <div className="flex flex-wrap gap-1">
              {selectedReflection.tags.map((tag) => (
                <span
                  key={tag}
                  className="tag px-2 py-1 bg-gray-100 rounded-full text-xs"
                >
                  {tag}
                </span>
              ))}
            </div>
          </div>
        )}
        
        <div className="reflection-actions flex justify-start">
          <Button variant="secondary" onClick={handleBackToList}>
            è¿”å›åˆ—è¡¨
          </Button>
        </div>
      </div>
    );
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="åæ€å†å²"
      closeOnOutsideClick={true}
      closeOnEsc={true}
      showCloseButton={true}
    >
      <div className="reflection-history p-4">
        {isLoading ? (
          <div className="loading-container flex justify-center items-center h-32">
            <LoadingSpinner variant="jade" size="medium" />
          </div>
        ) : error ? (
          <div className="error-container text-center p-4">
            <div className="error-message text-red-500 mb-4">{error}</div>
            <Button variant="jade" onClick={loadReflections}>
              é‡è¯•
            </Button>
          </div>
        ) : (
          <AnimatePresence mode="wait">
            {selectedReflection ? (
              <motion.div
                key="detail"
                initial={{ opacity: 0, x: 20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: -20 }}
                transition={{ duration: 0.3 }}
              >
                {renderReflectionDetail()}
              </motion.div>
            ) : (
              <motion.div
                key="list"
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 20 }}
                transition={{ duration: 0.3 }}
              >
                {/* æ ‡ç­¾ç­›é€‰ */}
                {allTags.length > 0 && (
                  <div className="tags-filter mb-4">
                    <h3 className="text-sm font-medium text-gray-700 mb-2">æŒ‰æ ‡ç­¾ç­›é€‰</h3>
                    <div className="flex flex-wrap gap-2">
                      {allTags.map((tag) => (
                        <motion.div
                          key={tag}
                          className={`tag px-2 py-1 rounded-full text-xs cursor-pointer ${
                            filterTag === tag ? 'bg-jade-100 text-jade-800 border border-jade-300' : 'bg-gray-100 text-gray-800'
                          }`}
                          onClick={() => handleFilterByTag(tag)}
                          whileHover={{ scale: 1.05 }}
                          whileTap={{ scale: 0.95 }}
                        >
                          {tag}
                        </motion.div>
                      ))}
                    </div>
                  </div>
                )}
                
                {renderReflectionList()}
              </motion.div>
            )}
          </AnimatePresence>
        )}
      </div>
    </ScrollDialog>
  );
};

export default ReflectionHistory;
</file>

<file path="src/components/reflection/ReflectionTriggerNotification.tsx">
// src/components/reflection/ReflectionTriggerNotification.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  ReflectionTriggerRecord, 
  ReflectionTriggerType,
  getUnviewedReflectionTriggers,
  markTriggerAsViewed,
  markTriggerAsCompleted
} from '@/services/reflectionService';
import Button from '@/components/common/Button';
import { playSound, SoundType } from '@/utils/sound';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface ReflectionTriggerNotificationProps {
  onTriggerAccepted?: (trigger: ReflectionTriggerRecord) => void;
  onTriggerDismissed?: (trigger: ReflectionTriggerRecord) => void;
}

/**
 * åæ€è§¦å‘é€šçŸ¥ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºåæ€è§¦å‘é€šçŸ¥å¹¶å¤„ç†ç”¨æˆ·å“åº”
 */
const ReflectionTriggerNotification: React.FC<ReflectionTriggerNotificationProps> = ({
  onTriggerAccepted,
  onTriggerDismissed
}) => {
  const [triggers, setTriggers] = useState<ReflectionTriggerRecord[]>([]);
  const [currentTriggerIndex, setCurrentTriggerIndex] = useState(0);
  const [isVisible, setIsVisible] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  
  // å½“å‰ç”¨æˆ·IDï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥ä»ç”¨æˆ·ä¼šè¯ä¸­è·å–ï¼‰
  const userId = 'current-user';

  // åŠ è½½æœªæŸ¥çœ‹çš„åæ€è§¦å‘è®°å½•
  const loadTriggers = async () => {
    try {
      setIsLoading(true);
      const unviewedTriggers = await getUnviewedReflectionTriggers(userId);
      setTriggers(unviewedTriggers);
      
      // å¦‚æœæœ‰æœªæŸ¥çœ‹çš„è§¦å‘è®°å½•ï¼Œæ˜¾ç¤ºé€šçŸ¥
      if (unviewedTriggers.length > 0) {
        setIsVisible(true);
        // æ’­æ”¾é€šçŸ¥éŸ³æ•ˆ
        playSound(SoundType.NOTIFICATION, 0.5);
      }
    } catch (err) {
      console.error('Failed to load reflection triggers:', err);
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadTriggers();
  }, []);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('reflectionTriggers', loadTriggers);

  // å¤„ç†æ¥å—åæ€
  const handleAccept = async () => {
    if (triggers.length === 0) return;
    
    const currentTrigger = triggers[currentTriggerIndex];
    
    try {
      // æ ‡è®°ä¸ºå·²æŸ¥çœ‹
      await markTriggerAsViewed(currentTrigger.id!);
      
      // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
      playSound(SoundType.BUTTON_CLICK, 0.5);
      
      // éšè—é€šçŸ¥
      setIsVisible(false);
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onTriggerAccepted) {
        setTimeout(() => {
          onTriggerAccepted(currentTrigger);
        }, 300); // ç­‰å¾…å…³é—­åŠ¨ç”»å®Œæˆ
      }
    } catch (err) {
      console.error('Failed to mark trigger as viewed:', err);
    }
  };

  // å¤„ç†ç¨åæé†’
  const handleRemindLater = async () => {
    if (triggers.length === 0) return;
    
    const currentTrigger = triggers[currentTriggerIndex];
    
    try {
      // æ ‡è®°ä¸ºå·²æŸ¥çœ‹
      await markTriggerAsViewed(currentTrigger.id!);
      
      // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
      playSound(SoundType.BUTTON_CLICK, 0.3);
      
      // ç§»é™¤å½“å‰è§¦å‘è®°å½•
      setTriggers(prevTriggers => 
        prevTriggers.filter((_, index) => index !== currentTriggerIndex)
      );
      
      // é‡ç½®ç´¢å¼•
      setCurrentTriggerIndex(0);
      
      // å¦‚æœæ²¡æœ‰æ›´å¤šè§¦å‘è®°å½•ï¼Œéšè—é€šçŸ¥
      if (triggers.length <= 1) {
        setIsVisible(false);
      }
    } catch (err) {
      console.error('Failed to mark trigger as viewed:', err);
    }
  };

  // å¤„ç†å¿½ç•¥
  const handleDismiss = async () => {
    if (triggers.length === 0) return;
    
    const currentTrigger = triggers[currentTriggerIndex];
    
    try {
      // æ ‡è®°ä¸ºå·²å®Œæˆ
      await markTriggerAsCompleted(currentTrigger.id!);
      
      // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
      playSound(SoundType.BUTTON_CLICK, 0.3);
      
      // ç§»é™¤å½“å‰è§¦å‘è®°å½•
      setTriggers(prevTriggers => 
        prevTriggers.filter((_, index) => index !== currentTriggerIndex)
      );
      
      // é‡ç½®ç´¢å¼•
      setCurrentTriggerIndex(0);
      
      // å¦‚æœæ²¡æœ‰æ›´å¤šè§¦å‘è®°å½•ï¼Œéšè—é€šçŸ¥
      if (triggers.length <= 1) {
        setIsVisible(false);
      }
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onTriggerDismissed) {
        onTriggerDismissed(currentTrigger);
      }
    } catch (err) {
      console.error('Failed to mark trigger as completed:', err);
    }
  };

  // è·å–è§¦å‘ç±»å‹æ ‡ç­¾
  const getTriggerTypeLabel = (type: ReflectionTriggerType): string => {
    switch (type) {
      case ReflectionTriggerType.MOOD_CHANGE:
        return 'æƒ…ç»ªå˜åŒ–';
      case ReflectionTriggerType.TASK_FAILURE:
        return 'ä»»åŠ¡å¤±è´¥';
      case ReflectionTriggerType.DAILY_REFLECTION:
        return 'æ¯æ—¥åæ€';
      case ReflectionTriggerType.WEEKLY_REVIEW:
        return 'æ¯å‘¨å›é¡¾';
      case ReflectionTriggerType.MANUAL:
        return 'æ‰‹åŠ¨è§¦å‘';
      default:
        return 'æœªçŸ¥';
    }
  };

  // è·å–è§¦å‘æ¶ˆæ¯
  const getTriggerMessage = (trigger: ReflectionTriggerRecord): string => {
    switch (trigger.type) {
      case ReflectionTriggerType.MOOD_CHANGE:
        return 'ç†ŠçŒ«æ³¨æ„åˆ°ä½ çš„æƒ…ç»ªæœ‰äº›æ³¢åŠ¨ï¼Œæƒ³å’Œä½ èŠèŠå—ï¼Ÿ';
      case ReflectionTriggerType.TASK_FAILURE:
        return trigger.data?.taskTitle
          ? `ä»»åŠ¡"${trigger.data.taskTitle}"æœªèƒ½æŒ‰æ—¶å®Œæˆï¼Œæƒ³èŠ±ç‚¹æ—¶é—´åæ€ä¸€ä¸‹å—ï¼Ÿ`
          : 'æœ‰ä¸€ä¸ªä»»åŠ¡æœªèƒ½æŒ‰æ—¶å®Œæˆï¼Œæƒ³èŠ±ç‚¹æ—¶é—´åæ€ä¸€ä¸‹å—ï¼Ÿ';
      case ReflectionTriggerType.DAILY_REFLECTION:
        return 'ä»Šå¤©è¿‡å¾—å¦‚ä½•ï¼Ÿæƒ³èŠ±ç‚¹æ—¶é—´è¿›è¡Œæ¯æ—¥åæ€å—ï¼Ÿ';
      case ReflectionTriggerType.WEEKLY_REVIEW:
        return 'è¿™å‘¨è¿‡å¾—å¦‚ä½•ï¼Ÿæƒ³èŠ±ç‚¹æ—¶é—´è¿›è¡Œæ¯å‘¨å›é¡¾å—ï¼Ÿ';
      case ReflectionTriggerType.MANUAL:
        return 'æƒ³èŠ±ç‚¹æ—¶é—´è¿›è¡Œåæ€å—ï¼Ÿ';
      default:
        return 'ç†ŠçŒ«æƒ³å’Œä½ èŠèŠï¼Œæœ‰æ—¶é—´å—ï¼Ÿ';
    }
  };

  // å¦‚æœæ²¡æœ‰è§¦å‘è®°å½•æˆ–ä¸å¯è§ï¼Œä¸æ˜¾ç¤ºä»»ä½•å†…å®¹
  if (triggers.length === 0 || !isVisible) {
    return null;
  }

  const currentTrigger = triggers[currentTriggerIndex];

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          className="reflection-trigger-notification fixed bottom-4 right-4 w-80 bg-white rounded-lg shadow-lg overflow-hidden border border-amber-200 z-50"
          initial={{ opacity: 0, y: 50, scale: 0.9 }}
          animate={{ opacity: 1, y: 0, scale: 1 }}
          exit={{ opacity: 0, y: 50, scale: 0.9 }}
          transition={{ duration: 0.3 }}
        >
          {/* é€šçŸ¥å¤´éƒ¨ */}
          <div className="notification-header bg-amber-50 p-3 border-b border-amber-200">
            <div className="flex items-center">
              <div className="panda-avatar mr-2">
                <span className="text-2xl">ğŸ¼</span>
              </div>
              <div className="flex-grow">
                <h3 className="text-md font-bold text-amber-800">é™å¿ƒèŒ¶å®¤</h3>
                <p className="text-xs text-amber-600">
                  {getTriggerTypeLabel(currentTrigger.type)}
                </p>
              </div>
              <div className="trigger-count">
                {triggers.length > 1 && (
                  <span className="text-xs bg-amber-100 text-amber-800 px-2 py-1 rounded-full">
                    {currentTriggerIndex + 1}/{triggers.length}
                  </span>
                )}
              </div>
            </div>
          </div>
          
          {/* é€šçŸ¥å†…å®¹ */}
          <div className="notification-content p-3">
            <p className="text-gray-700 mb-3">
              {getTriggerMessage(currentTrigger)}
            </p>
            
            <div className="notification-actions flex justify-end gap-2">
              <Button
                variant="secondary"
                size="small"
                onClick={handleDismiss}
              >
                å¿½ç•¥
              </Button>
              <Button
                variant="secondary"
                size="small"
                onClick={handleRemindLater}
              >
                ç¨å
              </Button>
              <Button
                variant="jade"
                size="small"
                onClick={handleAccept}
              >
                å¼€å§‹
              </Button>
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default ReflectionTriggerNotification;
</file>

<file path="src/components/store/CurrencyDisplay.tsx">
// src/components/store/CurrencyDisplay.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { UserCurrencyRecord } from '@/services/storeService';

interface CurrencyDisplayProps {
  currency: UserCurrencyRecord;
  isVip?: boolean;
  compact?: boolean;
  className?: string;
  labels?: {
    coinsLabel?: string;
    jadeLabel?: string;
    vipLabel?: string;
  };
}

/**
 * è´§å¸æ˜¾ç¤ºç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºç”¨æˆ·çš„é‡‘å¸å’Œç‰çŸ³
 */
const CurrencyDisplay: React.FC<CurrencyDisplayProps> = ({
  currency,
  isVip = false,
  compact = false,
  className = '',
  labels
}) => {
  // æ ¼å¼åŒ–æ•°å­—
  const formatNumber = (num: number): string => {
    if (num >= 1000000) {
      return `${(num / 1000000).toFixed(1)}M`;
    }
    if (num >= 1000) {
      return `${(num / 1000).toFixed(1)}K`;
    }
    return num.toString();
  };

  // ç´§å‡‘æ¨¡å¼
  if (compact) {
    return (
      <div className={`currency-display-compact flex items-center ${className}`}>
        <div className="coins-display flex items-center mr-3">
          <span className="coin-icon mr-1">ğŸª™</span>
          <span className="coin-value font-medium">{formatNumber(currency.coins)}</span>
        </div>
        <div className="jade-display flex items-center">
          <span className="jade-icon mr-1">ğŸ’</span>
          <span className="jade-value font-medium">{formatNumber(currency.jade)}</span>
        </div>
        {isVip && (
          <div className="vip-badge ml-3 px-2 py-0.5 rounded-full text-xs bg-amber-100 text-amber-800 border border-amber-300">
            VIP
          </div>
        )}
      </div>
    );
  }

  return (
    <div className={`currency-display p-4 bg-white rounded-lg shadow-md border border-amber-200 ${className}`}>
      <div className="flex justify-between items-center">
        <div className="currency-section flex items-center gap-6">
          <div className="coins-display flex items-center">
            <motion.div
              className="coin-icon text-2xl mr-3 bg-amber-100 p-2 rounded-full"
              initial={{ rotateY: 0 }}
              whileHover={{ rotateY: 180 }}
              transition={{ duration: 0.5 }}
            >
              ğŸª™
            </motion.div>
            <div>
              <div className="coin-value font-bold text-lg">{formatNumber(currency.coins)}</div>
              <div className="coin-label text-xs text-gray-500">{labels?.coinsLabel || "Coins"}</div>
            </div>
          </div>
          <div className="jade-display flex items-center">
            <motion.div
              className="jade-icon text-2xl mr-3 bg-jade-100 p-2 rounded-full"
              initial={{ rotate: 0 }}
              whileHover={{ rotate: 360 }}
              transition={{ duration: 0.5 }}
            >
              ğŸ’
            </motion.div>
            <div>
              <div className="jade-value font-bold text-lg">{formatNumber(currency.jade)}</div>
              <div className="jade-label text-xs text-gray-500">{labels?.jadeLabel || "Jade"}</div>
            </div>
          </div>
        </div>

        {isVip && (
          <div className="vip-section">
            <div className="vip-badge px-4 py-2 rounded-full bg-amber-100 text-amber-800 border border-amber-300 font-medium flex items-center">
              <span className="mr-1">âœ¨</span>
              {labels?.vipLabel || "VIP Member"}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default CurrencyDisplay;
</file>

<file path="src/components/store/StoreCategoryList.tsx">
// src/components/store/StoreCategoryList.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { 
  StoreCategoryRecord, 
  getStoreCategories
} from '@/services/storeService';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface StoreCategoryListProps {
  onCategorySelect: (category: StoreCategoryRecord) => void;
  selectedCategoryId?: number;
}

/**
 * å•†åº—ç±»åˆ«åˆ—è¡¨ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºå’Œé€‰æ‹©å•†åº—ç±»åˆ«
 */
const StoreCategoryList: React.FC<StoreCategoryListProps> = ({
  onCategorySelect,
  selectedCategoryId
}) => {
  const [categories, setCategories] = useState<StoreCategoryRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // åŠ è½½å•†åº—ç±»åˆ«
  const loadCategories = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // è·å–å•†åº—ç±»åˆ«
      const storeCategories = await getStoreCategories();
      setCategories(storeCategories);
    } catch (err) {
      console.error('Failed to load store categories:', err);
      setError('åŠ è½½å•†åº—ç±»åˆ«å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadCategories();
  }, []);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('storeCategories', loadCategories);

  // å¤„ç†é€‰æ‹©ç±»åˆ«
  const handleSelectCategory = (category: StoreCategoryRecord) => {
    // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
    playSound(SoundType.BUTTON_CLICK, 0.3);
    
    // é€šçŸ¥çˆ¶ç»„ä»¶
    onCategorySelect(category);
  };

  // å®¹å™¨å˜ä½“
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // é¡¹ç›®å˜ä½“
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  if (isLoading) {
    return (
      <div className="store-category-list p-4 flex justify-center">
        <LoadingSpinner variant="jade" size="medium" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="store-category-list p-4">
        <div className="error-message text-red-500 mb-2">{error}</div>
        <button
          className="retry-button text-jade-600 underline"
          onClick={loadCategories}
        >
          é‡è¯•
        </button>
      </div>
    );
  }

  if (categories.length === 0) {
    return (
      <div className="store-category-list p-4">
        <p className="text-gray-500">æš‚æ— å•†åº—ç±»åˆ«</p>
      </div>
    );
  }

  return (
    <motion.div
      className="store-category-list"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <div className="categories-container flex overflow-x-auto py-2 px-4 scrollbar-hide">
        {categories.map((category) => (
          <motion.div
            key={category.id}
            className="category-item flex-shrink-0 mr-4 last:mr-0"
            variants={itemVariants}
          >
            <button
              className={`category-button flex flex-col items-center p-2 rounded-lg ${
                selectedCategoryId === category.id ? 'bg-jade-100 border-2 border-jade-500' : 'bg-white border border-gray-200'
              }`}
              onClick={() => handleSelectCategory(category)}
            >
              <div className="category-icon mb-1">
                <img
                  src={category.iconPath}
                  alt={category.name}
                  className="w-12 h-12 object-contain"
                  onError={(e) => {
                    const target = e.target as HTMLImageElement;
                    target.onerror = null;
                    target.src = '/assets/store/default-category.png';
                  }}
                />
              </div>
              <div className="category-name text-sm">
                {category.name}
              </div>
            </button>
          </motion.div>
        ))}
      </div>
    </motion.div>
  );
};

export default StoreCategoryList;
</file>

<file path="src/components/store/StoreItemCard.tsx">
// src/components/store/StoreItemCard.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { 
  StoreItemRecord, 
  StoreItemRarity, 
  PriceType,
  purchaseStoreItem
} from '@/services/storeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';

interface StoreItemCardProps {
  item: StoreItemRecord;
  onPurchase?: (item: StoreItemRecord) => void;
  onPreview?: (item: StoreItemRecord) => void;
  userCoins?: number;
  userJade?: number;
  isVip?: boolean;
}

/**
 * å•†åº—ç‰©å“å¡ç‰‡ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºå•†åº—ç‰©å“å’Œè´­ä¹°æŒ‰é’®
 */
const StoreItemCard: React.FC<StoreItemCardProps> = ({
  item,
  onPurchase,
  onPreview,
  userCoins = 0,
  userJade = 0,
  isVip = false
}) => {
  const [isPurchasing, setIsPurchasing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // å¤„ç†è´­ä¹°ç‰©å“
  const handlePurchase = async (e: React.MouseEvent) => {
    e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦VIP
    if (item.vipRequired && !isVip) {
      setError('éœ€è¦VIPä¼šå‘˜æ‰èƒ½è´­ä¹°');
      return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„è´§å¸
    const price = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;
    if (item.priceType === PriceType.COINS && userCoins < price) {
      setError('é‡‘å¸ä¸è¶³');
      return;
    }
    if (item.priceType === PriceType.JADE && userJade < price) {
      setError('ç‰çŸ³ä¸è¶³');
      return;
    }
    
    try {
      setIsPurchasing(true);
      setError(null);
      
      // è´­ä¹°ç‰©å“
      await purchaseStoreItem('current-user', item.id!);
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onPurchase) {
        onPurchase(item);
      }
    } catch (err) {
      console.error('Failed to purchase item:', err);
      setError('è´­ä¹°å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsPurchasing(false);
    }
  };

  // å¤„ç†é¢„è§ˆç‰©å“
  const handlePreview = () => {
    // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
    playSound(SoundType.BUTTON_CLICK, 0.3);
    
    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onPreview) {
      onPreview(item);
    }
  };

  // è·å–ç¨€æœ‰åº¦æ ‡ç­¾å’Œæ ·å¼
  const getRarityInfo = (rarity: StoreItemRarity) => {
    switch (rarity) {
      case StoreItemRarity.COMMON:
        return { label: 'æ™®é€š', className: 'bg-gray-100 text-gray-800 border-gray-300' };
      case StoreItemRarity.UNCOMMON:
        return { label: 'ä¼˜ç§€', className: 'bg-green-100 text-green-800 border-green-300' };
      case StoreItemRarity.RARE:
        return { label: 'ç¨€æœ‰', className: 'bg-blue-100 text-blue-800 border-blue-300' };
      case StoreItemRarity.EPIC:
        return { label: 'å²è¯—', className: 'bg-purple-100 text-purple-800 border-purple-300' };
      case StoreItemRarity.LEGENDARY:
        return { label: 'ä¼ è¯´', className: 'bg-amber-100 text-amber-800 border-amber-300' };
      default:
        return { label: 'æœªçŸ¥', className: 'bg-gray-100 text-gray-800 border-gray-300' };
    }
  };

  // è·å–ä»·æ ¼ç±»å‹å›¾æ ‡
  const getPriceTypeIcon = (priceType: PriceType) => {
    switch (priceType) {
      case PriceType.COINS:
        return 'ğŸª™';
      case PriceType.JADE:
        return 'ğŸ’';
      case PriceType.REAL_MONEY:
        return 'ğŸ’µ';
      default:
        return 'ğŸª™';
    }
  };

  // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰è¶³å¤Ÿçš„è´§å¸
  const canAfford = () => {
    const price = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;
    if (item.priceType === PriceType.COINS) {
      return userCoins >= price;
    }
    if (item.priceType === PriceType.JADE) {
      return userJade >= price;
    }
    return true; // çœŸå®è´§å¸éœ€è¦åœ¨åº”ç”¨å†…è´­ä¹°æµç¨‹ä¸­å¤„ç†
  };

  const rarityInfo = getRarityInfo(item.rarity);
  const priceTypeIcon = getPriceTypeIcon(item.priceType);
  const displayPrice = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;

  return (
    <motion.div
      className={`store-item-card rounded-lg overflow-hidden shadow-md ${
        item.vipRequired ? 'border-2 border-amber-400' : 'border border-gray-200'
      }`}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
      whileHover={{ scale: 1.03 }}
      whileTap={{ scale: 0.98 }}
      onClick={handlePreview}
    >
      {/* ç‰©å“å›¾ç‰‡ */}
      <div className="item-image-container relative">
        <img
          src={item.imagePath}
          alt={item.name}
          className="w-full h-40 object-cover"
          onError={(e) => {
            const target = e.target as HTMLImageElement;
            target.onerror = null;
            target.src = '/assets/store/default-item.png';
          }}
        />
        
        {/* ç¨€æœ‰åº¦æ ‡ç­¾ */}
        <div className={`rarity-badge absolute top-2 right-2 px-2 py-1 rounded-full text-xs ${rarityInfo.className}`}>
          {rarityInfo.label}
        </div>
        
        {/* VIPæ ‡ç­¾ */}
        {item.vipRequired && (
          <div className="vip-badge absolute top-2 left-2 px-2 py-1 rounded-full text-xs bg-amber-100 text-amber-800 border border-amber-300">
            VIPä¸“å±
          </div>
        )}
        
        {/* ä¿ƒé”€æ ‡ç­¾ */}
        {item.isOnSale && item.salePrice !== undefined && (
          <div className="sale-badge absolute bottom-2 left-2 px-2 py-1 rounded-full text-xs bg-red-100 text-red-800 border border-red-300">
            ä¿ƒé”€
          </div>
        )}
      </div>
      
      {/* ç‰©å“ä¿¡æ¯ */}
      <div className="item-info p-3">
        <h3 className="item-name text-md font-bold mb-1">{item.name}</h3>
        <p className="item-description text-xs text-gray-600 mb-2 line-clamp-2">
          {item.description}
        </p>
        
        {/* ä»·æ ¼ä¿¡æ¯ */}
        <div className="price-info flex justify-between items-center">
          <div className="price-display flex items-center">
            <span className="price-icon mr-1">{priceTypeIcon}</span>
            <span className="price-value font-bold">
              {displayPrice}
            </span>
            {item.isOnSale && item.salePrice !== undefined && (
              <span className="original-price text-xs text-gray-500 line-through ml-2">
                {item.price}
              </span>
            )}
          </div>
          
          <Button
            variant="jade"
            size="small"
            onClick={handlePurchase}
            disabled={isPurchasing || !canAfford() || (item.vipRequired && !isVip)}
          >
            {isPurchasing ? (
              <LoadingSpinner variant="white" size="small" />
            ) : (
              'è´­ä¹°'
            )}
          </Button>
        </div>
        
        {/* é”™è¯¯ä¿¡æ¯ */}
        {error && (
          <div className="error-message mt-2 text-xs text-red-500">
            {error}
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default StoreItemCard;
</file>

<file path="src/components/store/StoreItemPreview.tsx">
// src/components/store/StoreItemPreview.tsx
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  StoreItemRecord, 
  StoreItemRarity, 
  StoreItemType,
  PriceType,
  purchaseStoreItem
} from '@/services/storeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from '@/components/game/ScrollDialog';

interface StoreItemPreviewProps {
  isOpen: boolean;
  onClose: () => void;
  item: StoreItemRecord;
  onPurchase?: (item: StoreItemRecord) => void;
  userCoins?: number;
  userJade?: number;
  isVip?: boolean;
}

/**
 * å•†åº—ç‰©å“é¢„è§ˆç»„ä»¶
 * ç”¨äºé¢„è§ˆå•†åº—ç‰©å“çš„è¯¦ç»†ä¿¡æ¯å’Œè´­ä¹°
 */
const StoreItemPreview: React.FC<StoreItemPreviewProps> = ({
  isOpen,
  onClose,
  item,
  onPurchase,
  userCoins = 0,
  userJade = 0,
  isVip = false
}) => {
  const [isPurchasing, setIsPurchasing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isPreviewAnimating, setIsPreviewAnimating] = useState(false);
  
  // å¤„ç†è´­ä¹°ç‰©å“
  const handlePurchase = async () => {
    // æ£€æŸ¥æ˜¯å¦éœ€è¦VIP
    if (item.vipRequired && !isVip) {
      setError('éœ€è¦VIPä¼šå‘˜æ‰èƒ½è´­ä¹°');
      return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„è´§å¸
    const price = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;
    if (item.priceType === PriceType.COINS && userCoins < price) {
      setError('é‡‘å¸ä¸è¶³');
      return;
    }
    if (item.priceType === PriceType.JADE && userJade < price) {
      setError('ç‰çŸ³ä¸è¶³');
      return;
    }
    
    try {
      setIsPurchasing(true);
      setError(null);
      
      // è´­ä¹°ç‰©å“
      await purchaseStoreItem('current-user', item.id!);
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onPurchase) {
        onPurchase(item);
      }
      
      // å…³é—­é¢„è§ˆ
      onClose();
    } catch (err) {
      console.error('Failed to purchase item:', err);
      setError('è´­ä¹°å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsPurchasing(false);
    }
  };

  // è·å–ç¨€æœ‰åº¦æ ‡ç­¾å’Œæ ·å¼
  const getRarityInfo = (rarity: StoreItemRarity) => {
    switch (rarity) {
      case StoreItemRarity.COMMON:
        return { label: 'æ™®é€š', className: 'bg-gray-100 text-gray-800 border-gray-300' };
      case StoreItemRarity.UNCOMMON:
        return { label: 'ä¼˜ç§€', className: 'bg-green-100 text-green-800 border-green-300' };
      case StoreItemRarity.RARE:
        return { label: 'ç¨€æœ‰', className: 'bg-blue-100 text-blue-800 border-blue-300' };
      case StoreItemRarity.EPIC:
        return { label: 'å²è¯—', className: 'bg-purple-100 text-purple-800 border-purple-300' };
      case StoreItemRarity.LEGENDARY:
        return { label: 'ä¼ è¯´', className: 'bg-amber-100 text-amber-800 border-amber-300' };
      default:
        return { label: 'æœªçŸ¥', className: 'bg-gray-100 text-gray-800 border-gray-300' };
    }
  };

  // è·å–ç‰©å“ç±»å‹æ ‡ç­¾
  const getItemTypeLabel = (type: StoreItemType) => {
    switch (type) {
      case StoreItemType.AVATAR:
        return 'ç†ŠçŒ«å¤´åƒ';
      case StoreItemType.ACCESSORY:
        return 'ç†ŠçŒ«é…ä»¶';
      case StoreItemType.BACKGROUND:
        return 'èƒŒæ™¯';
      case StoreItemType.THEME:
        return 'ä¸»é¢˜';
      case StoreItemType.ABILITY:
        return 'èƒ½åŠ›';
      case StoreItemType.CONSUMABLE:
        return 'æ¶ˆè€—å“';
      case StoreItemType.VIP:
        return 'VIPä¼šå‘˜';
      default:
        return 'æœªçŸ¥';
    }
  };

  // è·å–ä»·æ ¼ç±»å‹å›¾æ ‡å’Œæ ‡ç­¾
  const getPriceTypeInfo = (priceType: PriceType) => {
    switch (priceType) {
      case PriceType.COINS:
        return { icon: 'ğŸª™', label: 'é‡‘å¸' };
      case PriceType.JADE:
        return { icon: 'ğŸ’', label: 'ç‰çŸ³' };
      case PriceType.REAL_MONEY:
        return { icon: 'ğŸ’µ', label: 'çœŸå®è´§å¸' };
      default:
        return { icon: 'ğŸª™', label: 'é‡‘å¸' };
    }
  };

  // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰è¶³å¤Ÿçš„è´§å¸
  const canAfford = () => {
    const price = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;
    if (item.priceType === PriceType.COINS) {
      return userCoins >= price;
    }
    if (item.priceType === PriceType.JADE) {
      return userJade >= price;
    }
    return true; // çœŸå®è´§å¸éœ€è¦åœ¨åº”ç”¨å†…è´­ä¹°æµç¨‹ä¸­å¤„ç†
  };

  // å¤„ç†é¢„è§ˆåŠ¨ç”»
  const handlePreviewAnimation = () => {
    setIsPreviewAnimating(true);
    setTimeout(() => {
      setIsPreviewAnimating(false);
    }, 2000);
  };

  const rarityInfo = getRarityInfo(item.rarity);
  const itemTypeLabel = getItemTypeLabel(item.type);
  const priceTypeInfo = getPriceTypeInfo(item.priceType);
  const displayPrice = item.isOnSale && item.salePrice !== undefined ? item.salePrice : item.price;

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="ç‰©å“é¢„è§ˆ"
      closeOnOutsideClick={!isPurchasing}
      closeOnEsc={!isPurchasing}
      showCloseButton={!isPurchasing}
    >
      <div className="store-item-preview p-4">
        {/* ç‰©å“å›¾ç‰‡ */}
        <div className="item-image-container mb-4 relative">
          <div className="preview-image-wrapper relative overflow-hidden rounded-lg border border-gray-200">
            <img
              src={item.imagePath}
              alt={item.name}
              className={`w-full h-64 object-contain ${isPreviewAnimating ? 'animate-pulse' : ''}`}
              onError={(e) => {
                const target = e.target as HTMLImageElement;
                target.onerror = null;
                target.src = '/assets/store/default-item.png';
              }}
            />
            
            {/* é¢„è§ˆåŠ¨ç”»æŒ‰é’® */}
            {(item.type === StoreItemType.AVATAR || item.type === StoreItemType.ACCESSORY) && (
              <button
                className="preview-animation-button absolute bottom-2 right-2 bg-white bg-opacity-80 p-2 rounded-full shadow-md"
                onClick={handlePreviewAnimation}
              >
                <span role="img" aria-label="preview">ğŸ‘ï¸</span>
              </button>
            )}
          </div>
          
          {/* ç¨€æœ‰åº¦æ ‡ç­¾ */}
          <div className={`rarity-badge absolute top-2 right-2 px-2 py-1 rounded-full text-xs ${rarityInfo.className}`}>
            {rarityInfo.label}
          </div>
          
          {/* VIPæ ‡ç­¾ */}
          {item.vipRequired && (
            <div className="vip-badge absolute top-2 left-2 px-2 py-1 rounded-full text-xs bg-amber-100 text-amber-800 border border-amber-300">
              VIPä¸“å±
            </div>
          )}
          
          {/* ä¿ƒé”€æ ‡ç­¾ */}
          {item.isOnSale && item.salePrice !== undefined && (
            <div className="sale-badge absolute bottom-2 left-2 px-2 py-1 rounded-full text-xs bg-red-100 text-red-800 border border-red-300">
              ä¿ƒé”€
            </div>
          )}
        </div>
        
        {/* ç‰©å“ä¿¡æ¯ */}
        <div className="item-info mb-4">
          <h3 className="item-name text-xl font-bold mb-2">{item.name}</h3>
          
          <div className="item-meta flex flex-wrap gap-2 mb-2">
            <span className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800">
              {itemTypeLabel}
            </span>
            <span className={`px-2 py-1 rounded-full text-xs ${rarityInfo.className}`}>
              {rarityInfo.label}
            </span>
          </div>
          
          <p className="item-description text-gray-700 mb-4">
            {item.description}
          </p>
          
          {/* æ ‡ç­¾ */}
          {item.tags && item.tags.length > 0 && (
            <div className="item-tags flex flex-wrap gap-1 mb-4">
              {item.tags.map((tag, index) => (
                <span
                  key={index}
                  className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-600"
                >
                  {tag}
                </span>
              ))}
            </div>
          )}
          
          {/* é™é‡ä¿¡æ¯ */}
          {item.limitedQuantity && item.remainingQuantity !== undefined && (
            <div className="limited-quantity mb-4">
              <p className="text-sm text-gray-600">
                é™é‡: {item.remainingQuantity}/{item.limitedQuantity}
              </p>
              <div className="w-full bg-gray-200 rounded-full h-2 mt-1">
                <div
                  className="bg-jade-500 h-2 rounded-full"
                  style={{ width: `${(item.remainingQuantity / item.limitedQuantity) * 100}%` }}
                ></div>
              </div>
            </div>
          )}
          
          {/* ä¿ƒé”€ä¿¡æ¯ */}
          {item.isOnSale && item.salePrice !== undefined && item.saleEndDate && (
            <div className="sale-info mb-4">
              <p className="text-sm text-red-600">
                ä¿ƒé”€æˆªæ­¢æ—¥æœŸ: {new Date(item.saleEndDate).toLocaleDateString()}
              </p>
            </div>
          )}
        </div>
        
        {/* ä»·æ ¼å’Œè´­ä¹° */}
        <div className="price-purchase-section">
          <div className="price-info flex items-center mb-4">
            <span className="price-label text-gray-600 mr-2">ä»·æ ¼:</span>
            <span className="price-icon mr-1">{priceTypeInfo.icon}</span>
            <span className="price-value font-bold text-lg">
              {displayPrice}
            </span>
            <span className="price-type text-sm text-gray-500 ml-1">
              ({priceTypeInfo.label})
            </span>
            {item.isOnSale && item.salePrice !== undefined && (
              <span className="original-price text-sm text-gray-500 line-through ml-2">
                {item.price}
              </span>
            )}
          </div>
          
          {/* é”™è¯¯ä¿¡æ¯ */}
          {error && (
            <div className="error-message mb-4 p-2 bg-red-50 rounded-md text-red-500">
              {error}
            </div>
          )}
          
          {/* è´­ä¹°æŒ‰é’® */}
          <div className="purchase-button">
            <Button
              variant="jade"
              onClick={handlePurchase}
              disabled={isPurchasing || !canAfford() || (item.vipRequired && !isVip)}
              className="w-full"
            >
              {isPurchasing ? (
                <LoadingSpinner variant="white" size="small" />
              ) : (
                'è´­ä¹°'
              )}
            </Button>
            
            {!canAfford() && (
              <p className="text-sm text-red-500 mt-2 text-center">
                {item.priceType === PriceType.COINS ? 'é‡‘å¸ä¸è¶³' : 'ç‰çŸ³ä¸è¶³'}
              </p>
            )}
            
            {item.vipRequired && !isVip && (
              <p className="text-sm text-amber-500 mt-2 text-center">
                éœ€è¦VIPä¼šå‘˜æ‰èƒ½è´­ä¹°
              </p>
            )}
          </div>
        </div>
      </div>
    </ScrollDialog>
  );
};

export default StoreItemPreview;
</file>

<file path="src/components/store/VipSubscriptionCard.tsx">
// src/components/store/VipSubscriptionCard.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { 
  VipSubscriptionRecord, 
  activateVipSubscription
} from '@/services/storeService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';

interface VipSubscriptionCardProps {
  tier: number;
  title: string;
  description: string;
  price: number;
  duration: number; // å¤©æ•°
  benefits: string[];
  imagePath: string;
  currentSubscription?: VipSubscriptionRecord | null;
  onSubscribe?: (tier: number, duration: number) => void;
}

/**
 * VIPè®¢é˜…å¡ç‰‡ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºVIPè®¢é˜…ä¿¡æ¯å’Œè®¢é˜…æŒ‰é’®
 */
const VipSubscriptionCard: React.FC<VipSubscriptionCardProps> = ({
  tier,
  title,
  description,
  price,
  duration,
  benefits,
  imagePath,
  currentSubscription,
  onSubscribe
}) => {
  const [isSubscribing, setIsSubscribing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // æ£€æŸ¥æ˜¯å¦å·²ç»è®¢é˜…äº†è¯¥ç­‰çº§æˆ–æ›´é«˜ç­‰çº§çš„VIP
  const isAlreadySubscribed = () => {
    if (!currentSubscription) return false;
    return currentSubscription.tier >= tier;
  };

  // å¤„ç†è®¢é˜…
  const handleSubscribe = async () => {
    try {
      setIsSubscribing(true);
      setError(null);
      
      // æ¿€æ´»VIPè®¢é˜…
      await activateVipSubscription(
        'current-user',
        tier,
        duration,
        'in_app_purchase', // æ”¯ä»˜æ–¹å¼
        `vip_${tier}_${Date.now()}` // æ¨¡æ‹Ÿäº¤æ˜“ID
      );
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onSubscribe) {
        onSubscribe(tier, duration);
      }
    } catch (err) {
      console.error('Failed to subscribe to VIP:', err);
      setError('è®¢é˜…å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsSubscribing(false);
    }
  };

  // è·å–å‰©ä½™å¤©æ•°
  const getRemainingDays = () => {
    if (!currentSubscription || !currentSubscription.endDate) return 0;
    
    const endDate = new Date(currentSubscription.endDate);
    const now = new Date();
    const diffTime = endDate.getTime() - now.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    return Math.max(0, diffDays);
  };

  // è·å–VIPç­‰çº§æ ‡ç­¾
  const getTierLabel = (tier: number) => {
    switch (tier) {
      case 1:
        return 'åŸºç¡€';
      case 2:
        return 'é«˜çº§';
      case 3:
        return 'è±ªå';
      default:
        return `ç­‰çº§ ${tier}`;
    }
  };

  const tierLabel = getTierLabel(tier);
  const remainingDays = getRemainingDays();
  const isSubscribed = isAlreadySubscribed();

  return (
    <motion.div
      className={`vip-subscription-card rounded-lg overflow-hidden shadow-md ${
        isSubscribed ? 'border-2 border-amber-500' : 'border border-gray-200'
      }`}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
      whileHover={{ scale: 1.03 }}
      whileTap={{ scale: 0.98 }}
    >
      {/* VIPå›¾ç‰‡ */}
      <div className="vip-image-container relative">
        <img
          src={imagePath}
          alt={title}
          className="w-full h-40 object-cover"
          onError={(e) => {
            const target = e.target as HTMLImageElement;
            target.onerror = null;
            target.src = '/assets/store/default-vip.png';
          }}
        />
        
        {/* VIPç­‰çº§æ ‡ç­¾ */}
        <div className="tier-badge absolute top-2 right-2 px-2 py-1 rounded-full text-xs bg-amber-100 text-amber-800 border border-amber-300">
          {tierLabel} VIP
        </div>
        
        {/* å·²è®¢é˜…æ ‡ç­¾ */}
        {isSubscribed && (
          <div className="subscribed-badge absolute top-2 left-2 px-2 py-1 rounded-full text-xs bg-green-100 text-green-800 border border-green-300">
            å·²è®¢é˜…
          </div>
        )}
      </div>
      
      {/* VIPä¿¡æ¯ */}
      <div className="vip-info p-3">
        <h3 className="vip-title text-md font-bold mb-1">{title}</h3>
        <p className="vip-description text-xs text-gray-600 mb-2">
          {description}
        </p>
        
        {/* VIPç¦åˆ© */}
        <div className="vip-benefits mb-3">
          <h4 className="text-xs font-bold text-gray-700 mb-1">ä¼šå‘˜ç¦åˆ©</h4>
          <ul className="benefits-list text-xs text-gray-600">
            {benefits.map((benefit, index) => (
              <li key={index} className="flex items-start mb-1">
                <span className="mr-1">âœ“</span>
                <span>{benefit}</span>
              </li>
            ))}
          </ul>
        </div>
        
        {/* ä»·æ ¼å’Œè®¢é˜… */}
        <div className="price-subscribe-section">
          <div className="price-info flex justify-between items-center mb-2">
            <div className="price-display">
              <span className="price-value font-bold">Â¥{price}</span>
              <span className="duration text-xs text-gray-500 ml-1">
                / {duration} å¤©
              </span>
            </div>
            
            {isSubscribed && (
              <div className="remaining-days text-xs text-green-600">
                å‰©ä½™ {remainingDays} å¤©
              </div>
            )}
          </div>
          
          <Button
            variant={isSubscribed ? 'secondary' : 'gold'}
            onClick={handleSubscribe}
            disabled={isSubscribing}
            className="w-full"
          >
            {isSubscribing ? (
              <LoadingSpinner variant="white" size="small" />
            ) : isSubscribed ? (
              'ç»­è®¢'
            ) : (
              'è®¢é˜…'
            )}
          </Button>
        </div>
        
        {/* é”™è¯¯ä¿¡æ¯ */}
        {error && (
          <div className="error-message mt-2 text-xs text-red-500">
            {error}
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default VipSubscriptionCard;
</file>

<file path="src/components/task/TaskCard.tsx">
// src/components/task/TaskCard.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { 
  TaskRecord, 
  completeTask, 
  TaskStatus,
  TaskPriority
} from '@/services/taskService';
import { getTaskCategory } from '@/services/taskCategoryService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import TaskDetailDialog from './TaskDetailDialog';

interface TaskCardProps {
  task: TaskRecord;
  onTaskCompleted?: (task: TaskRecord) => void;
  onTaskUpdated?: () => void;
}

/**
 * ä»»åŠ¡å¡ç‰‡ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºä»»åŠ¡ä¿¡æ¯å’Œæ“ä½œ
 */
const TaskCard: React.FC<TaskCardProps> = ({
  task,
  onTaskCompleted,
  onTaskUpdated
}) => {
  const [isCompleting, setIsCompleting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [categoryName, setCategoryName] = useState<string>('');
  const [showDetailDialog, setShowDetailDialog] = useState(false);
  
  // åŠ è½½ä»»åŠ¡åˆ†ç±»
  React.useEffect(() => {
    const loadCategory = async () => {
      if (task.categoryId) {
        try {
          const category = await getTaskCategory(task.categoryId);
          if (category) {
            setCategoryName(category.name);
          }
        } catch (err) {
          console.error('Failed to load task category:', err);
        }
      }
    };
    
    loadCategory();
  }, [task.categoryId]);

  // å¤„ç†å®Œæˆä»»åŠ¡
  const handleCompleteTask = async (e: React.MouseEvent) => {
    e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
    
    try {
      setIsCompleting(true);
      setError(null);
      
      // å®Œæˆä»»åŠ¡
      const completedTask = await completeTask(task.id!);
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onTaskCompleted) {
        onTaskCompleted(completedTask);
      }
    } catch (err) {
      console.error('Failed to complete task:', err);
      setError('å®Œæˆä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsCompleting(false);
    }
  };

  // å¤„ç†æŸ¥çœ‹ä»»åŠ¡è¯¦æƒ…
  const handleViewDetails = () => {
    // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
    playSound(SoundType.BUTTON_CLICK, 0.3);
    
    // æ˜¾ç¤ºè¯¦æƒ…å¯¹è¯æ¡†
    setShowDetailDialog(true);
  };

  // è·å–ä¼˜å…ˆçº§æ ‡ç­¾å’Œæ ·å¼
  const getPriorityInfo = (priority: TaskPriority) => {
    switch (priority) {
      case TaskPriority.HIGH:
        return { label: 'é«˜', className: 'bg-red-100 text-red-800' };
      case TaskPriority.MEDIUM:
        return { label: 'ä¸­', className: 'bg-yellow-100 text-yellow-800' };
      case TaskPriority.LOW:
        return { label: 'ä½', className: 'bg-green-100 text-green-800' };
      default:
        return { label: 'æœªçŸ¥', className: 'bg-gray-100 text-gray-800' };
    }
  };

  // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å·²è¿‡æœŸ
  const isOverdue = () => {
    return task.dueDate && new Date(task.dueDate) < new Date() && task.status !== TaskStatus.COMPLETED;
  };

  return (
    <>
      <motion.div
        className={`task-card p-3 rounded-lg shadow-md ${
          task.status === TaskStatus.COMPLETED ? 'bg-gray-50' : 'bg-white'
        } ${
          isOverdue() ? 'border-l-4 border-red-500' : ''
        }`}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3 }}
        whileHover={{ scale: 1.02 }}
        whileTap={{ scale: 0.98 }}
        onClick={handleViewDetails}
      >
        <div className="task-header flex justify-between items-start mb-2">
          <div className="task-title-container">
            <h3 className={`text-md font-bold ${
              task.status === TaskStatus.COMPLETED ? 'line-through text-gray-500' : ''
            }`}>
              {task.title}
            </h3>
            <div className="task-meta flex flex-wrap gap-1 mt-1">
              {task.categoryId && (
                <span className="px-2 py-0.5 rounded-full text-xs bg-gray-100 text-gray-800">
                  {categoryName}
                </span>
              )}
              <span className={`px-2 py-0.5 rounded-full text-xs ${getPriorityInfo(task.priority).className}`}>
                {getPriorityInfo(task.priority).label}
              </span>
              {isOverdue() && (
                <span className="px-2 py-0.5 rounded-full text-xs bg-red-100 text-red-800">
                  å·²è¿‡æœŸ
                </span>
              )}
            </div>
          </div>
          <div className="task-actions">
            {task.status !== TaskStatus.COMPLETED && (
              <Button
                variant="jade"
                size="small"
                onClick={handleCompleteTask}
                disabled={isCompleting}
              >
                {isCompleting ? (
                  <LoadingSpinner variant="white" size="small" />
                ) : (
                  'å®Œæˆ'
                )}
              </Button>
            )}
          </div>
        </div>
        
        {task.description && (
          <div className="task-description mb-2">
            <p className={`text-sm ${
              task.status === TaskStatus.COMPLETED ? 'text-gray-400' : 'text-gray-600'
            }`}>
              {task.description.length > 100 ? `${task.description.substring(0, 100)}...` : task.description}
            </p>
          </div>
        )}
        
        <div className="task-footer flex justify-between items-center">
          <div className="task-dates text-xs text-gray-500">
            {task.dueDate && (
              <span className={`${isOverdue() ? 'text-red-500 font-medium' : ''}`}>
                æˆªæ­¢æ—¥æœŸ: {new Date(task.dueDate).toLocaleDateString()}
              </span>
            )}
          </div>
          <div className="task-details-link text-xs text-jade-600 cursor-pointer">
            æŸ¥çœ‹è¯¦æƒ…
          </div>
        </div>
        
        {error && (
          <div className="error-message mt-2 text-xs text-red-500">
            {error}
          </div>
        )}
      </motion.div>
      
      {/* ä»»åŠ¡è¯¦æƒ…å¯¹è¯æ¡† */}
      {showDetailDialog && (
        <TaskDetailDialog
          isOpen={showDetailDialog}
          onClose={() => setShowDetailDialog(false)}
          taskId={task.id!}
          onTaskUpdated={onTaskUpdated}
          onTaskCompleted={onTaskCompleted}
        />
      )}
    </>
  );
};

export default TaskCard;
</file>

<file path="src/components/task/TaskDetailDialog.tsx">
// src/components/task/TaskDetailDialog.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  TaskRecord, 
  getTask, 
  updateTask, 
  completeTask,
  TaskStatus,
  TaskPriority
} from '@/services/taskService';
import { getTaskCategory } from '@/services/taskCategoryService';
import { getTaskReminders } from '@/services/taskReminderService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from '@/components/game/ScrollDialog';
import SubtaskList from '@/components/task/SubtaskList';
import TaskReminderForm from '@/components/task/TaskReminderForm';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';

interface TaskDetailDialogProps {
  isOpen: boolean;
  onClose: () => void;
  taskId: number;
  onTaskUpdated?: () => void;
  onTaskCompleted?: (task: TaskRecord) => void;
}

/**
 * ä»»åŠ¡è¯¦æƒ…å¯¹è¯æ¡†ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºä»»åŠ¡è¯¦æƒ…ã€å­ä»»åŠ¡å’Œæé†’
 */
const TaskDetailDialog: React.FC<TaskDetailDialogProps> = ({
  isOpen,
  onClose,
  taskId,
  onTaskUpdated,
  onTaskCompleted
}) => {
  const [task, setTask] = useState<TaskRecord | null>(null);
  const [categoryName, setCategoryName] = useState<string>('');
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isCompleting, setIsCompleting] = useState(false);
  const [activeTab, setActiveTab] = useState<'details' | 'subtasks' | 'reminders'>('details');
  const [showReminderForm, setShowReminderForm] = useState(false);
  const [reminders, setReminders] = useState<any[]>([]);
  
  // åŠ è½½ä»»åŠ¡æ•°æ®
  const loadTaskData = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // è·å–ä»»åŠ¡æ•°æ®
      const taskData = await getTask(taskId);
      if (taskData) {
        setTask(taskData);
        
        // è·å–ä»»åŠ¡åˆ†ç±»
        if (taskData.categoryId) {
          const category = await getTaskCategory(taskData.categoryId);
          if (category) {
            setCategoryName(category.name);
          }
        }
        
        // è·å–ä»»åŠ¡æé†’
        const taskReminders = await getTaskReminders(taskId);
        setReminders(taskReminders);
      } else {
        setError('æ— æ³•åŠ è½½ä»»åŠ¡æ•°æ®');
      }
    } catch (err) {
      console.error('Failed to load task data:', err);
      setError('åŠ è½½ä»»åŠ¡æ•°æ®å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    if (isOpen && taskId) {
      loadTaskData();
    }
  }, [isOpen, taskId]);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('tasks', loadTaskData);
  useRegisterTableRefresh('subtasks', loadTaskData);
  useRegisterTableRefresh('taskReminders', loadTaskData);

  // å¤„ç†å®Œæˆä»»åŠ¡
  const handleCompleteTask = async () => {
    if (!task) return;
    
    try {
      setIsCompleting(true);
      
      // å®Œæˆä»»åŠ¡
      const completedTask = await completeTask(task.id!);
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onTaskCompleted) {
        onTaskCompleted(completedTask);
      }
      
      // å…³é—­å¯¹è¯æ¡†
      onClose();
    } catch (err) {
      console.error('Failed to complete task:', err);
      setError('å®Œæˆä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsCompleting(false);
    }
  };

  // å¤„ç†æ›´æ–°ä»»åŠ¡ä¼˜å…ˆçº§
  const handleUpdatePriority = async (priority: TaskPriority) => {
    if (!task) return;
    
    try {
      // æ›´æ–°ä»»åŠ¡
      await updateTask(task.id!, { priority });
      
      // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
      playSound(SoundType.BUTTON_CLICK, 0.3);
      
      // é‡æ–°åŠ è½½ä»»åŠ¡æ•°æ®
      await loadTaskData();
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onTaskUpdated) {
        onTaskUpdated();
      }
    } catch (err) {
      console.error('Failed to update task priority:', err);
      setError('æ›´æ–°ä»»åŠ¡ä¼˜å…ˆçº§å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };

  // å¤„ç†åˆ›å»ºæé†’
  const handleCreateReminder = () => {
    setShowReminderForm(true);
  };

  // å¤„ç†æé†’åˆ›å»ºå®Œæˆ
  const handleReminderCreated = () => {
    // é‡æ–°åŠ è½½ä»»åŠ¡æ•°æ®
    loadTaskData();
    
    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onTaskUpdated) {
      onTaskUpdated();
    }
  };

  // è·å–ä¼˜å…ˆçº§æ ‡ç­¾å’Œæ ·å¼
  const getPriorityInfo = (priority: TaskPriority) => {
    switch (priority) {
      case TaskPriority.HIGH:
        return { label: 'é«˜', className: 'bg-red-100 text-red-800' };
      case TaskPriority.MEDIUM:
        return { label: 'ä¸­', className: 'bg-yellow-100 text-yellow-800' };
      case TaskPriority.LOW:
        return { label: 'ä½', className: 'bg-green-100 text-green-800' };
      default:
        return { label: 'æœªçŸ¥', className: 'bg-gray-100 text-gray-800' };
    }
  };

  // æ¸²æŸ“ä»»åŠ¡è¯¦æƒ…
  const renderTaskDetails = () => {
    if (!task) return null;
    
    return (
      <div className="task-details">
        <div className="task-header mb-4">
          <div className="task-meta flex flex-wrap gap-2 mb-2">
            {task.categoryId && (
              <span className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800">
                {categoryName}
              </span>
            )}
            <span className={`px-2 py-1 rounded-full text-xs ${getPriorityInfo(task.priority).className}`}>
              {getPriorityInfo(task.priority).label}ä¼˜å…ˆçº§
            </span>
            {task.dueDate && (
              <span className="px-2 py-1 rounded-full text-xs bg-blue-100 text-blue-800">
                æˆªæ­¢æ—¥æœŸ: {new Date(task.dueDate).toLocaleDateString()}
              </span>
            )}
          </div>
          
          <h3 className="text-xl font-bold">{task.title}</h3>
          
          {task.description && (
            <div className="task-description mt-2">
              <p className="text-gray-700">{task.description}</p>
            </div>
          )}
        </div>
        
        <div className="task-actions mb-4">
          <h3 className="text-md font-bold mb-2">ä»»åŠ¡æ“ä½œ</h3>
          <div className="grid grid-cols-2 gap-2">
            <Button
              variant="jade"
              onClick={handleCompleteTask}
              disabled={isCompleting || task.status === TaskStatus.COMPLETED}
            >
              {isCompleting ? (
                <LoadingSpinner variant="white" size="small" />
              ) : (
                task.status === TaskStatus.COMPLETED ? 'å·²å®Œæˆ' : 'å®Œæˆä»»åŠ¡'
              )}
            </Button>
            <Button
              variant="secondary"
              onClick={handleCreateReminder}
            >
              åˆ›å»ºæé†’
            </Button>
          </div>
        </div>
        
        <div className="priority-selector mb-4">
          <h3 className="text-md font-bold mb-2">è°ƒæ•´ä¼˜å…ˆçº§</h3>
          <div className="grid grid-cols-3 gap-2">
            <button
              className={`p-2 rounded-md ${
                task.priority === TaskPriority.LOW ? 'bg-green-100 text-green-800 border border-green-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
              }`}
              onClick={() => handleUpdatePriority(TaskPriority.LOW)}
            >
              ä½
            </button>
            <button
              className={`p-2 rounded-md ${
                task.priority === TaskPriority.MEDIUM ? 'bg-yellow-100 text-yellow-800 border border-yellow-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
              }`}
              onClick={() => handleUpdatePriority(TaskPriority.MEDIUM)}
            >
              ä¸­
            </button>
            <button
              className={`p-2 rounded-md ${
                task.priority === TaskPriority.HIGH ? 'bg-red-100 text-red-800 border border-red-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
              }`}
              onClick={() => handleUpdatePriority(TaskPriority.HIGH)}
            >
              é«˜
            </button>
          </div>
        </div>
        
        <div className="task-dates">
          <div className="text-sm text-gray-500">
            <p>åˆ›å»ºæ—¶é—´: {new Date(task.createdAt).toLocaleString()}</p>
            {task.updatedAt && (
              <p>æ›´æ–°æ—¶é—´: {new Date(task.updatedAt).toLocaleString()}</p>
            )}
          </div>
        </div>
      </div>
    );
  };

  // æ¸²æŸ“å­ä»»åŠ¡
  const renderSubtasks = () => {
    if (!task) return null;
    
    return (
      <div className="task-subtasks">
        <SubtaskList
          parentTaskId={task.id!}
          onSubtasksUpdated={() => {
            // é‡æ–°åŠ è½½ä»»åŠ¡æ•°æ®
            loadTaskData();
            
            // é€šçŸ¥çˆ¶ç»„ä»¶
            if (onTaskUpdated) {
              onTaskUpdated();
            }
          }}
        />
      </div>
    );
  };

  // æ¸²æŸ“æé†’
  const renderReminders = () => {
    if (!task) return null;
    
    return (
      <div className="task-reminders">
        <div className="reminders-header flex justify-between items-center mb-4">
          <h3 className="text-md font-bold">ä»»åŠ¡æé†’</h3>
          <Button
            variant="jade"
            size="small"
            onClick={handleCreateReminder}
          >
            æ·»åŠ æé†’
          </Button>
        </div>
        
        {reminders.length === 0 ? (
          <div className="no-reminders text-center p-4 bg-gray-50 rounded-md">
            <p className="text-gray-500">æš‚æ— æé†’</p>
          </div>
        ) : (
          <div className="reminders-list">
            {reminders.map((reminder) => (
              <div
                key={reminder.id}
                className="reminder-item p-3 border-b border-gray-200 last:border-b-0"
              >
                <div className="reminder-time font-medium mb-1">
                  {new Date(reminder.reminderTime).toLocaleString()}
                </div>
                <div className="reminder-message text-gray-700 mb-1">
                  {reminder.message || 'ä»»åŠ¡æé†’'}
                </div>
                <div className="reminder-status flex gap-2">
                  {reminder.isViewed && (
                    <span className="text-xs px-2 py-0.5 bg-gray-100 text-gray-800 rounded-full">
                      å·²æŸ¥çœ‹
                    </span>
                  )}
                  {reminder.isCompleted && (
                    <span className="text-xs px-2 py-0.5 bg-green-100 text-green-800 rounded-full">
                      å·²å®Œæˆ
                    </span>
                  )}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    );
  };

  return (
    <>
      <ScrollDialog
        isOpen={isOpen}
        onClose={onClose}
        title="ä»»åŠ¡è¯¦æƒ…"
        closeOnOutsideClick={!isCompleting}
        closeOnEsc={!isCompleting}
        showCloseButton={!isCompleting}
      >
        <div className="task-detail-dialog p-4">
          {isLoading ? (
            <div className="loading-container flex justify-center items-center h-32">
              <LoadingSpinner variant="jade" size="medium" />
            </div>
          ) : error ? (
            <div className="error-container text-center p-4">
              <div className="error-message text-red-500 mb-4">{error}</div>
              <Button variant="jade" onClick={loadTaskData}>
                é‡è¯•
              </Button>
            </div>
          ) : task ? (
            <div className="task-content">
              {/* é€‰é¡¹å¡ */}
              <div className="tabs-container mb-4">
                <div className="tabs flex border-b border-gray-200">
                  <button
                    className={`tab-button py-2 px-4 ${
                      activeTab === 'details' ? 'border-b-2 border-jade-500 text-jade-600 font-medium' : 'text-gray-500'
                    }`}
                    onClick={() => setActiveTab('details')}
                  >
                    è¯¦æƒ…
                  </button>
                  <button
                    className={`tab-button py-2 px-4 ${
                      activeTab === 'subtasks' ? 'border-b-2 border-jade-500 text-jade-600 font-medium' : 'text-gray-500'
                    }`}
                    onClick={() => setActiveTab('subtasks')}
                  >
                    å­ä»»åŠ¡
                  </button>
                  <button
                    className={`tab-button py-2 px-4 ${
                      activeTab === 'reminders' ? 'border-b-2 border-jade-500 text-jade-600 font-medium' : 'text-gray-500'
                    }`}
                    onClick={() => setActiveTab('reminders')}
                  >
                    æé†’
                  </button>
                </div>
              </div>
              
              {/* é€‰é¡¹å¡å†…å®¹ */}
              <AnimatePresence mode="wait">
                <motion.div
                  key={activeTab}
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -10 }}
                  transition={{ duration: 0.2 }}
                >
                  {activeTab === 'details' && renderTaskDetails()}
                  {activeTab === 'subtasks' && renderSubtasks()}
                  {activeTab === 'reminders' && renderReminders()}
                </motion.div>
              </AnimatePresence>
            </div>
          ) : (
            <div className="not-found-container text-center p-4">
              <p className="text-gray-500">ä»»åŠ¡ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤</p>
            </div>
          )}
        </div>
      </ScrollDialog>
      
      {/* æé†’è¡¨å• */}
      {showReminderForm && task && (
        <TaskReminderForm
          isOpen={showReminderForm}
          onClose={() => setShowReminderForm(false)}
          taskId={task.id!}
          onReminderCreated={handleReminderCreated}
        />
      )}
    </>
  );
};

export default TaskDetailDialog;
</file>

<file path="src/components/task/TaskReminderForm.tsx">
// src/components/task/TaskReminderForm.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { 
  scheduleTaskReminder,
  createCustomReminder
} from '@/services/taskReminderService';
import { getTask } from '@/services/taskService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { playSound, SoundType } from '@/utils/sound';
import ScrollDialog from '@/components/game/ScrollDialog';

interface TaskReminderFormProps {
  isOpen: boolean;
  onClose: () => void;
  taskId: number;
  onReminderCreated?: () => void;
}

/**
 * ä»»åŠ¡æé†’è¡¨å•ç»„ä»¶
 * ç”¨äºåˆ›å»ºä»»åŠ¡æé†’
 */
const TaskReminderForm: React.FC<TaskReminderFormProps> = ({
  isOpen,
  onClose,
  taskId,
  onReminderCreated
}) => {
  const [reminderType, setReminderType] = useState<'scheduled' | 'custom'>('scheduled');
  const [reminderDate, setReminderDate] = useState<string>(new Date().toISOString().split('T')[0]);
  const [reminderTime, setReminderTime] = useState<string>('12:00');
  const [customMessage, setCustomMessage] = useState<string>('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [taskTitle, setTaskTitle] = useState<string>('');
  
  // åŠ è½½ä»»åŠ¡æ ‡é¢˜
  React.useEffect(() => {
    const loadTaskTitle = async () => {
      try {
        const task = await getTask(taskId);
        if (task) {
          setTaskTitle(task.title);
        }
      } catch (err) {
        console.error('Failed to load task:', err);
      }
    };
    
    if (isOpen && taskId) {
      loadTaskTitle();
    }
  }, [isOpen, taskId]);

  // å¤„ç†æäº¤è¡¨å•
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      setIsSubmitting(true);
      setError(null);
      
      // åˆ›å»ºæé†’æ—¶é—´
      const reminderDateTime = new Date(`${reminderDate}T${reminderTime}`);
      
      // æ£€æŸ¥æé†’æ—¶é—´æ˜¯å¦æœ‰æ•ˆ
      if (reminderDateTime < new Date()) {
        setError('æé†’æ—¶é—´ä¸èƒ½æ—©äºå½“å‰æ—¶é—´');
        return;
      }
      
      // åˆ›å»ºæé†’
      if (reminderType === 'scheduled') {
        await scheduleTaskReminder(taskId, reminderDateTime);
      } else {
        if (!customMessage.trim()) {
          setError('è¯·è¾“å…¥è‡ªå®šä¹‰æ¶ˆæ¯');
          return;
        }
        
        await createCustomReminder(taskId, reminderDateTime, customMessage);
      }
      
      // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
      playSound(SoundType.SUCCESS, 0.5);
      
      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onReminderCreated) {
        onReminderCreated();
      }
      
      // å…³é—­å¯¹è¯æ¡†
      onClose();
    } catch (err) {
      console.error('Failed to create reminder:', err);
      setError('åˆ›å»ºæé†’å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="åˆ›å»ºä»»åŠ¡æé†’"
      closeOnOutsideClick={!isSubmitting}
      closeOnEsc={!isSubmitting}
      showCloseButton={!isSubmitting}
    >
      <div className="task-reminder-form p-4">
        <form onSubmit={handleSubmit}>
          {error && (
            <div className="error-message text-red-500 mb-4 p-2 bg-red-50 rounded-md">
              {error}
            </div>
          )}
          
          {/* ä»»åŠ¡ä¿¡æ¯ */}
          <div className="task-info mb-4 p-3 bg-gray-50 rounded-md">
            <h3 className="text-md font-bold mb-1">ä»»åŠ¡</h3>
            <p className="text-gray-700">{taskTitle}</p>
          </div>
          
          {/* æé†’ç±»å‹ */}
          <div className="reminder-type-selector mb-4">
            <h3 className="text-md font-bold mb-2">æé†’ç±»å‹</h3>
            <div className="flex gap-2">
              <button
                type="button"
                className={`flex-1 p-2 rounded-md ${
                  reminderType === 'scheduled' ? 'bg-jade-100 text-jade-800 border border-jade-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
                }`}
                onClick={() => setReminderType('scheduled')}
              >
                è®¡åˆ’æé†’
              </button>
              <button
                type="button"
                className={`flex-1 p-2 rounded-md ${
                  reminderType === 'custom' ? 'bg-jade-100 text-jade-800 border border-jade-300' : 'bg-gray-100 text-gray-800 border border-gray-300'
                }`}
                onClick={() => setReminderType('custom')}
              >
                è‡ªå®šä¹‰æé†’
              </button>
            </div>
          </div>
          
          {/* æé†’æ—¶é—´ */}
          <div className="reminder-time-selector mb-4">
            <h3 className="text-md font-bold mb-2">æé†’æ—¶é—´</h3>
            <div className="grid grid-cols-2 gap-2">
              <div>
                <label htmlFor="reminderDate" className="block text-sm text-gray-700 mb-1">
                  æ—¥æœŸ
                </label>
                <input
                  type="date"
                  id="reminderDate"
                  value={reminderDate}
                  onChange={(e) => setReminderDate(e.target.value)}
                  className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
                  required
                />
              </div>
              <div>
                <label htmlFor="reminderTime" className="block text-sm text-gray-700 mb-1">
                  æ—¶é—´
                </label>
                <input
                  type="time"
                  id="reminderTime"
                  value={reminderTime}
                  onChange={(e) => setReminderTime(e.target.value)}
                  className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500"
                  required
                />
              </div>
            </div>
          </div>
          
          {/* è‡ªå®šä¹‰æ¶ˆæ¯ */}
          {reminderType === 'custom' && (
            <div className="custom-message-input mb-4">
              <h3 className="text-md font-bold mb-2">è‡ªå®šä¹‰æ¶ˆæ¯</h3>
              <textarea
                value={customMessage}
                onChange={(e) => setCustomMessage(e.target.value)}
                className="w-full p-2 border border-gray-300 rounded-md focus:ring-jade-500 focus:border-jade-500 h-24"
                placeholder="è¾“å…¥è‡ªå®šä¹‰æé†’æ¶ˆæ¯..."
                required={reminderType === 'custom'}
              />
            </div>
          )}
          
          {/* æäº¤æŒ‰é’® */}
          <div className="form-actions flex justify-end gap-2 mt-4">
            <Button
              variant="secondary"
              type="button"
              onClick={onClose}
              disabled={isSubmitting}
            >
              å–æ¶ˆ
            </Button>
            <Button
              variant="jade"
              type="submit"
              disabled={isSubmitting}
            >
              {isSubmitting ? (
                <LoadingSpinner variant="white" size="small" />
              ) : (
                'åˆ›å»ºæé†’'
              )}
            </Button>
          </div>
        </form>
      </div>
    </ScrollDialog>
  );
};

export default TaskReminderForm;
</file>

<file path="src/components/task/TaskReminderNotification.tsx">
// src/components/task/TaskReminderNotification.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  TaskReminderRecord,
  getUnviewedReminders,
  markReminderAsViewed,
  markReminderAsCompleted
} from '@/services/taskReminderService';
import { getTask } from '@/services/taskService';
import Button from '@/components/common/Button';
import { playSound, SoundType } from '@/utils/sound';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import { useComponentLabels } from '@/hooks/useComponentLabels';

interface TaskReminderNotificationProps {
  onTaskClick?: (taskId: number) => void;
  onDismiss?: (reminder: TaskReminderRecord) => void;
}

/**
 * Task reminder notification component
 * Displays task reminders with a panda messenger theme
 */
const TaskReminderNotification: React.FC<TaskReminderNotificationProps> = ({
  onTaskClick,
  onDismiss
}) => {
  const [reminders, setReminders] = useState<TaskReminderRecord[]>([]);
  const [currentReminderIndex, setCurrentReminderIndex] = useState(0);
  const [isVisible, setIsVisible] = useState(false);
  const [taskTitles, setTaskTitles] = useState<Record<number, string>>({});
  const [isLoading, setIsLoading] = useState(false);

  // Get localized labels
  const { labels } = useComponentLabels();

  // å½“å‰ç”¨æˆ·IDï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥ä»ç”¨æˆ·ä¼šè¯ä¸­è·å–ï¼‰
  const userId = 'current-user';

  // åŠ è½½æœªæŸ¥çœ‹çš„æé†’
  const loadReminders = async () => {
    try {
      setIsLoading(true);
      const unviewedReminders = await getUnviewedReminders(userId);
      setReminders(unviewedReminders);

      // å¦‚æœæœ‰æœªæŸ¥çœ‹çš„æé†’ï¼Œæ˜¾ç¤ºé€šçŸ¥
      if (unviewedReminders.length > 0) {
        setIsVisible(true);

        // åŠ è½½ä»»åŠ¡æ ‡é¢˜
        const titles: Record<number, string> = {};
        for (const reminder of unviewedReminders) {
          const task = await getTask(reminder.taskId);
          if (task) {
            titles[reminder.taskId] = task.title;
          }
        }
        setTaskTitles(titles);

        // æ’­æ”¾é€šçŸ¥éŸ³æ•ˆ
        playSound(SoundType.NOTIFICATION, 0.5);
      }
    } catch (err) {
      console.error('Failed to load task reminders:', err);
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadReminders();
  }, []);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('taskReminders', loadReminders);

  // å¤„ç†æŸ¥çœ‹ä»»åŠ¡
  const handleViewTask = async () => {
    if (reminders.length === 0) return;

    const currentReminder = reminders[currentReminderIndex];

    try {
      // æ ‡è®°ä¸ºå·²æŸ¥çœ‹
      await markReminderAsViewed(currentReminder.id!);

      // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
      playSound(SoundType.BUTTON_CLICK, 0.5);

      // éšè—é€šçŸ¥
      setIsVisible(false);

      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onTaskClick) {
        setTimeout(() => {
          onTaskClick(currentReminder.taskId);
        }, 300); // ç­‰å¾…å…³é—­åŠ¨ç”»å®Œæˆ
      }
    } catch (err) {
      console.error('Failed to mark reminder as viewed:', err);
    }
  };

  // å¤„ç†ç¨åæé†’
  const handleRemindLater = async () => {
    if (reminders.length === 0) return;

    const currentReminder = reminders[currentReminderIndex];

    try {
      // æ ‡è®°ä¸ºå·²æŸ¥çœ‹
      await markReminderAsViewed(currentReminder.id!);

      // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
      playSound(SoundType.BUTTON_CLICK, 0.3);

      // ç§»é™¤å½“å‰æé†’
      setReminders(prevReminders =>
        prevReminders.filter((_, index) => index !== currentReminderIndex)
      );

      // é‡ç½®ç´¢å¼•
      setCurrentReminderIndex(0);

      // å¦‚æœæ²¡æœ‰æ›´å¤šæé†’ï¼Œéšè—é€šçŸ¥
      if (reminders.length <= 1) {
        setIsVisible(false);
      }
    } catch (err) {
      console.error('Failed to mark reminder as viewed:', err);
    }
  };

  // å¤„ç†å¿½ç•¥
  const handleDismiss = async () => {
    if (reminders.length === 0) return;

    const currentReminder = reminders[currentReminderIndex];

    try {
      // æ ‡è®°ä¸ºå·²å®Œæˆ
      await markReminderAsCompleted(currentReminder.id!);

      // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
      playSound(SoundType.BUTTON_CLICK, 0.3);

      // ç§»é™¤å½“å‰æé†’
      setReminders(prevReminders =>
        prevReminders.filter((_, index) => index !== currentReminderIndex)
      );

      // é‡ç½®ç´¢å¼•
      setCurrentReminderIndex(0);

      // å¦‚æœæ²¡æœ‰æ›´å¤šæé†’ï¼Œéšè—é€šçŸ¥
      if (reminders.length <= 1) {
        setIsVisible(false);
      }

      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onDismiss) {
        onDismiss(currentReminder);
      }
    } catch (err) {
      console.error('Failed to mark reminder as completed:', err);
    }
  };

  // å¦‚æœæ²¡æœ‰æé†’æˆ–ä¸å¯è§ï¼Œä¸æ˜¾ç¤ºä»»ä½•å†…å®¹
  if (reminders.length === 0 || !isVisible) {
    return null;
  }

  const currentReminder = reminders[currentReminderIndex];
  const taskTitle = taskTitles[currentReminder.taskId] || labels.taskReminder.unknownTask;

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          className="task-reminder-notification fixed bottom-4 right-4 w-80 bg-white rounded-lg shadow-lg overflow-hidden border border-jade-200 z-50"
          initial={{ opacity: 0, y: 50, scale: 0.9 }}
          animate={{ opacity: 1, y: 0, scale: 1 }}
          exit={{ opacity: 0, y: 50, scale: 0.9 }}
          transition={{ duration: 0.3 }}
        >
          {/* é€šçŸ¥å¤´éƒ¨ */}
          <div className="notification-header bg-jade-50 p-3 border-b border-jade-200">
            <div className="flex items-center">
              <div className="panda-messenger mr-2">
                <span className="text-2xl">ğŸ¼ğŸ“¬</span>
              </div>
              <div className="flex-grow">
                <h3 className="text-md font-bold text-jade-800">{labels.taskReminder.title}</h3>
                <p className="text-xs text-jade-600">
                  {labels.taskReminder.subtitle}
                </p>
              </div>
              <div className="reminder-count">
                {reminders.length > 1 && (
                  <span className="text-xs bg-jade-100 text-jade-800 px-2 py-1 rounded-full">
                    {currentReminderIndex + 1}/{reminders.length}
                  </span>
                )}
              </div>
            </div>
          </div>

          {/* é€šçŸ¥å†…å®¹ */}
          <div className="notification-content p-3">
            <div className="task-title font-bold mb-2">
              {taskTitle}
            </div>
            <p className="text-gray-700 mb-3">
              {currentReminder.message || labels.taskReminder.defaultMessage}
            </p>

            <div className="reminder-time text-xs text-gray-500 mb-3">
              {labels.taskReminder.reminderTimeLabel} {new Date(currentReminder.reminderTime).toLocaleString()}
            </div>

            <div className="notification-actions flex justify-end gap-2">
              <Button
                variant="secondary"
                size="small"
                onClick={handleDismiss}
              >
                {labels.taskReminder.dismissButton}
              </Button>
              <Button
                variant="secondary"
                size="small"
                onClick={handleRemindLater}
              >
                {labels.taskReminder.laterButton}
              </Button>
              <Button
                variant="jade"
                size="small"
                onClick={handleViewTask}
              >
                {labels.taskReminder.viewTaskButton}
              </Button>
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default TaskReminderNotification;
</file>

<file path="src/components/tasks/SubtaskList.tsx">
// src/components/tasks/SubtaskList.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { SubtaskRecord } from '@/services/subtaskService';
import { TaskStatus } from '@/services/taskService';
import { getSubtasks, updateSubtask, completeSubtask, deleteSubtask, createSubtask } from '@/services/subtaskService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';
import { updateSubtaskOrder } from '@/services/subtaskService';
import { playSound, SoundType } from '@/utils/sound';

interface SubtaskListProps {
  parentTaskId: number;
  onSubtasksChange?: (hasSubtasks: boolean) => void;
}

/**
 * å­ä»»åŠ¡åˆ—è¡¨ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºå’Œç®¡ç†ä»»åŠ¡çš„å­ä»»åŠ¡
 */
const SubtaskList: React.FC<SubtaskListProps> = ({ parentTaskId, onSubtasksChange }) => {
  const [subtasks, setSubtasks] = useState<SubtaskRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [newSubtaskTitle, setNewSubtaskTitle] = useState('');
  const [isAddingSubtask, setIsAddingSubtask] = useState(false);

  // åŠ è½½å­ä»»åŠ¡
  const loadSubtasks = async () => {
    try {
      setIsLoading(true);
      setError(null);
      const loadedSubtasks = await getSubtasks(parentTaskId);
      setSubtasks(loadedSubtasks);
      
      // é€šçŸ¥çˆ¶ç»„ä»¶å­ä»»åŠ¡çŠ¶æ€å˜åŒ–
      if (onSubtasksChange) {
        onSubtasksChange(loadedSubtasks.length > 0);
      }
    } catch (err) {
      console.error('Failed to load subtasks:', err);
      setError('åŠ è½½å­ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadSubtasks();
  }, [parentTaskId]);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('subtasks', loadSubtasks);

  // å¤„ç†æ·»åŠ å­ä»»åŠ¡
  const handleAddSubtask = async () => {
    if (!newSubtaskTitle.trim()) return;

    try {
      setIsAddingSubtask(true);
      await createSubtask({
        parentTaskId,
        title: newSubtaskTitle.trim()
      });
      setNewSubtaskTitle('');
      playSound(SoundType.BUTTON_CLICK, 0.3);
      await loadSubtasks();
    } catch (err) {
      console.error('Failed to add subtask:', err);
      setError('æ·»åŠ å­ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsAddingSubtask(false);
    }
  };

  // å¤„ç†å®Œæˆå­ä»»åŠ¡
  const handleCompleteSubtask = async (subtaskId: number) => {
    try {
      await completeSubtask(subtaskId);
      playSound(SoundType.SUCCESS, 0.3);
      // æ•°æ®ä¼šé€šè¿‡åˆ·æ–°æœºåˆ¶è‡ªåŠ¨æ›´æ–°
    } catch (err) {
      console.error('Failed to complete subtask:', err);
      setError('å®Œæˆå­ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };

  // å¤„ç†åˆ é™¤å­ä»»åŠ¡
  const handleDeleteSubtask = async (subtaskId: number) => {
    try {
      await deleteSubtask(subtaskId);
      playSound(SoundType.BUTTON_CLICK, 0.3);
      // æ•°æ®ä¼šé€šè¿‡åˆ·æ–°æœºåˆ¶è‡ªåŠ¨æ›´æ–°
    } catch (err) {
      console.error('Failed to delete subtask:', err);
      setError('åˆ é™¤å­ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };

  // å¤„ç†æ‹–æ”¾ç»“æŸ
  const handleDragEnd = async (result: any) => {
    if (!result.destination) return;

    const sourceIndex = result.source.index;
    const destinationIndex = result.destination.index;

    if (sourceIndex === destinationIndex) return;

    try {
      // è·å–è¢«æ‹–åŠ¨çš„å­ä»»åŠ¡
      const draggedSubtask = subtasks[sourceIndex];
      
      // æ›´æ–°å­ä»»åŠ¡é¡ºåº
      await updateSubtaskOrder(draggedSubtask.id!, destinationIndex);
      
      // é‡æ–°åŠ è½½å­ä»»åŠ¡ä»¥è·å–æœ€æ–°é¡ºåº
      await loadSubtasks();
    } catch (err) {
      console.error('Failed to reorder subtasks:', err);
      setError('é‡æ–°æ’åºå­ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };

  // å­ä»»åŠ¡é¡¹å˜ä½“
  const subtaskVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 },
    exit: { opacity: 0, x: -20 }
  };

  if (isLoading && subtasks.length === 0) {
    return (
      <div className="subtask-list-loading flex justify-center items-center p-4">
        <LoadingSpinner variant="jade" size="small" />
      </div>
    );
  }

  return (
    <div className="subtask-list mt-4">
      <h3 className="text-lg font-bold mb-2">å­ä»»åŠ¡</h3>
      
      {error && (
        <div className="error-message text-red-500 mb-2">{error}</div>
      )}
      
      <DragDropContext onDragEnd={handleDragEnd}>
        <Droppable droppableId="subtasks-list">
          {(provided) => (
            <div
              className="subtasks-container"
              {...provided.droppableProps}
              ref={provided.innerRef}
            >
              <AnimatePresence>
                {subtasks.map((subtask, index) => (
                  <Draggable
                    key={subtask.id}
                    draggableId={`subtask-${subtask.id}`}
                    index={index}
                    isDragDisabled={subtask.status === TaskStatus.COMPLETED}
                  >
                    {(provided, snapshot) => (
                      <motion.div
                        ref={provided.innerRef}
                        {...provided.draggableProps}
                        {...provided.dragHandleProps}
                        className={`subtask-item flex items-center p-2 mb-2 rounded-md border ${
                          subtask.status === TaskStatus.COMPLETED
                            ? 'border-gray-300 bg-gray-50'
                            : 'border-jade-300 bg-white'
                        } ${snapshot.isDragging ? 'shadow-md' : ''}`}
                        variants={subtaskVariants}
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        transition={{ duration: 0.2 }}
                      >
                        <div className="subtask-checkbox mr-2">
                          <input
                            type="checkbox"
                            checked={subtask.status === TaskStatus.COMPLETED}
                            onChange={() => {
                              if (subtask.status !== TaskStatus.COMPLETED) {
                                handleCompleteSubtask(subtask.id!);
                              }
                            }}
                            className="form-checkbox h-5 w-5 text-jade-500 rounded"
                          />
                        </div>
                        <div className="subtask-content flex-grow">
                          <p className={`subtask-title ${
                            subtask.status === TaskStatus.COMPLETED ? 'line-through text-gray-500' : 'text-gray-800'
                          }`}>
                            {subtask.title}
                          </p>
                        </div>
                        <div className="subtask-actions">
                          <button
                            onClick={() => handleDeleteSubtask(subtask.id!)}
                            className="text-red-500 hover:text-red-700"
                            aria-label="åˆ é™¤å­ä»»åŠ¡"
                          >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                              <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" />
                            </svg>
                          </button>
                        </div>
                      </motion.div>
                    )}
                  </Draggable>
                ))}
                {provided.placeholder}
              </AnimatePresence>
            </div>
          )}
        </Droppable>
      </DragDropContext>
      
      <div className="add-subtask-form mt-4">
        <div className="flex">
          <input
            type="text"
            value={newSubtaskTitle}
            onChange={(e) => setNewSubtaskTitle(e.target.value)}
            placeholder="æ·»åŠ æ–°å­ä»»åŠ¡..."
            className="flex-grow p-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-2 focus:ring-jade-500"
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                handleAddSubtask();
              }
            }}
          />
          <Button
            variant="jade"
            onClick={handleAddSubtask}
            disabled={!newSubtaskTitle.trim() || isAddingSubtask}
            className="rounded-l-none"
          >
            {isAddingSubtask ? (
              <LoadingSpinner variant="white" size="small" />
            ) : (
              'æ·»åŠ '
            )}
          </Button>
        </div>
      </div>
    </div>
  );
};

export default SubtaskList;
</file>

<file path="src/context/LanguageProvider.tsx">
// src/context/LanguageProvider.tsx
import React, { createContext, useState, useContext, useEffect, ReactNode, useCallback } from "react";
import type { Language, LanguageContextType } from "@/types";

const DEFAULT_LANGUAGE: Language = "en";
const LOCAL_STORAGE_KEY = "app_lang_v3_final";

const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

export const LanguageProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [language, setLanguageState] = useState<Language>(() => {
    try {
      const saved = localStorage.getItem(LOCAL_STORAGE_KEY) as Language | null;
      return (saved === "en" || saved === "zh") ? saved : DEFAULT_LANGUAGE;
    } catch (e) { console.warn("localStorage access error for language", e); return DEFAULT_LANGUAGE; }
  });

  useEffect(() => {
    try {
      localStorage.setItem(LOCAL_STORAGE_KEY, language);
      document.documentElement.lang = language;
    } catch (e) { console.warn("localStorage write error for language", e); }
  }, [language]);

  const setLanguage = useCallback((lang: Language) => setLanguageState(lang), []);
  const value = { language, setLanguage };

  return <LanguageContext.Provider value={value}>{children}</LanguageContext.Provider>;
};

export const useLanguage = (): LanguageContextType => {
  const context = useContext(LanguageContext);
  if (!context) throw new Error("useLanguage must be used within LanguageProvider");
  return context;
};
</file>

<file path="src/context/PandaStateProvider.tsx">
// src/context/PandaStateProvider.tsx
import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';
import {
  getPandaState,
  updatePandaMood,
  updatePandaEnergy,
  addPandaExperience,
  resetPandaState,
  type PandaStateRecord
} from '@/services/pandaStateService';
import {
  initializePandaAbilities,
  checkAndUnlockAbilities,
  getAllPandaAbilities,
  getUnlockedPandaAbilities,
  activateAbility,
  type PandaAbilityRecord
} from '@/services/pandaAbilityService';
import { useDataRefreshContext } from '@/context/DataRefreshProvider';
import type { PandaMood, EnergyLevel } from '@/components/game/PandaAvatar';

// ç†ŠçŒ«çŠ¶æ€ä¸Šä¸‹æ–‡ç±»å‹
interface PandaStateContextType {
  pandaState: PandaStateRecord | null;
  abilities: PandaAbilityRecord[];
  unlockedAbilities: PandaAbilityRecord[];
  isLoading: boolean;
  error: Error | null;
  setMood: (mood: PandaMood) => Promise<void>;
  setEnergy: (energy: EnergyLevel) => Promise<void>;
  addExperience: (amount: number) => Promise<void>;
  resetState: () => Promise<void>;
  refreshState: () => Promise<void>;
  activateAbility: (abilityId: number) => Promise<void>;
  checkNewAbilities: () => Promise<PandaAbilityRecord[]>;
}

// åˆ›å»ºä¸Šä¸‹æ–‡
const PandaStateContext = createContext<PandaStateContextType | undefined>(undefined);

// Providerç»„ä»¶å±æ€§
interface PandaStateProviderProps {
  children: ReactNode;
}

/**
 * ç†ŠçŒ«çŠ¶æ€Providerç»„ä»¶
 * æä¾›ç†ŠçŒ«çŠ¶æ€ç®¡ç†åŠŸèƒ½
 */
export const PandaStateProvider: React.FC<PandaStateProviderProps> = ({ children }) => {
  const [pandaState, setPandaState] = useState<PandaStateRecord | null>(null);
  const [abilities, setAbilities] = useState<PandaAbilityRecord[]>([]);
  const [unlockedAbilities, setUnlockedAbilities] = useState<PandaAbilityRecord[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);
  const { registerRefreshListener } = useDataRefreshContext();

  // åˆå§‹åŠ è½½ç†ŠçŒ«çŠ¶æ€å’Œèƒ½åŠ›
  useEffect(() => {
    initializeSystem();
  }, []);

  // åˆå§‹åŒ–ç³»ç»Ÿ
  const initializeSystem = async () => {
    try {
      setIsLoading(true);

      // åŠ è½½ç†ŠçŒ«çŠ¶æ€
      try {
        await loadPandaState();
      } catch (stateErr) {
        console.error('Failed to load panda state:', stateErr);
      }

      // åŠ è½½ç†ŠçŒ«èƒ½åŠ›
      try {
        await loadPandaAbilities();
      } catch (abilitiesErr) {
        console.error('Failed to load panda abilities:', abilitiesErr);
      }

      setError(null);
    } catch (err) {
      console.error('Failed to initialize panda system:', err);
      setError(err instanceof Error ? err : new Error('Failed to initialize panda system'));
    } finally {
      setIsLoading(false);
    }
  };

  // å®šä¹‰çŠ¶æ€æ›´æ–°å¤„ç†å‡½æ•°
  const handleStateUpdate = useCallback((stateData: any) => {
    if (stateData) {
      setPandaState(prevState => {
        if (!prevState) return stateData;
        return {
          ...prevState,
          ...stateData
        };
      });
    }
  }, []);

  // å®šä¹‰èƒ½åŠ›æ›´æ–°å¤„ç†å‡½æ•°
  const handleAbilityUpdate = useCallback(async (abilityData: any) => {
    // åªæœ‰å½“æœ‰ç‰¹å®šçš„èƒ½åŠ›æ•°æ®æ—¶æ‰æ›´æ–°ï¼Œé¿å…æ— é™å¾ªç¯
    if (abilityData && abilityData.id) {
      try {
        // æ›´æ–°å•ä¸ªèƒ½åŠ›è€Œä¸æ˜¯é‡æ–°åŠ è½½æ‰€æœ‰èƒ½åŠ›
        setAbilities(prevAbilities => {
          const index = prevAbilities.findIndex(a => a.id === abilityData.id);
          if (index >= 0) {
            const newAbilities = [...prevAbilities];
            newAbilities[index] = { ...newAbilities[index], ...abilityData };
            return newAbilities;
          }
          return [...prevAbilities, abilityData];
        });

        // æ›´æ–°å·²è§£é”èƒ½åŠ›åˆ—è¡¨
        if (abilityData.isUnlocked) {
          setUnlockedAbilities(prevUnlocked => {
            const index = prevUnlocked.findIndex(a => a.id === abilityData.id);
            if (index >= 0) {
              const newUnlocked = [...prevUnlocked];
              newUnlocked[index] = { ...newUnlocked[index], ...abilityData };
              return newUnlocked;
            }
            return [...prevUnlocked, abilityData];
          });
        } else {
          // å¦‚æœèƒ½åŠ›è¢«é”å®šï¼Œä»å·²è§£é”åˆ—è¡¨ä¸­ç§»é™¤
          setUnlockedAbilities(prevUnlocked =>
            prevUnlocked.filter(a => a.id !== abilityData.id)
          );
        }
      } catch (err) {
        console.error('Failed to update ability:', err);
      }
    }
  }, []);

  // ä½¿ç”¨ useEffect æ³¨å†Œç›‘å¬å™¨
  useEffect(() => {
    // æ³¨å†Œç›‘å¬å™¨
    const unregisterState = registerRefreshListener('pandaState', handleStateUpdate);
    const unregisterAbility = registerRefreshListener('abilities', handleAbilityUpdate);

    return () => {
      unregisterState();
      unregisterAbility();
    };
  }, [registerRefreshListener, handleStateUpdate, handleAbilityUpdate]);

  // åŠ è½½ç†ŠçŒ«çŠ¶æ€
  const loadPandaState = async () => {
    try {
      const state = await getPandaState();
      setPandaState(state);

      // æ£€æŸ¥æ˜¯å¦æœ‰æ–°è§£é”çš„èƒ½åŠ›
      if (state) {
        await checkAndUnlockAbilities(state.level);
      }

      setError(null);
    } catch (err) {
      console.error('Failed to load panda state:', err);
      setError(err instanceof Error ? err : new Error('Failed to load panda state'));
    }
  };

  // åŠ è½½ç†ŠçŒ«èƒ½åŠ›
  const loadPandaAbilities = async () => {
    try {
      // åˆå§‹åŒ–ç†ŠçŒ«èƒ½åŠ›ç³»ç»Ÿï¼ˆåªåœ¨ç¬¬ä¸€æ¬¡åŠ è½½æ—¶åˆå§‹åŒ–ï¼‰
      await initializePandaAbilities();

      // è·å–æ‰€æœ‰èƒ½åŠ›
      let allAbilities: PandaAbilityRecord[] = [];
      try {
        allAbilities = await getAllPandaAbilities();
      } catch (allErr) {
        console.error('Failed to get all abilities:', allErr);
        allAbilities = [];
      }

      // å®‰å…¨åœ°æ›´æ–°èƒ½åŠ›åˆ—è¡¨
      if (Array.isArray(allAbilities)) {
        // åªæœ‰å½“èƒ½åŠ›åˆ—è¡¨ä¸ºç©ºæˆ–é•¿åº¦ä¸åŒæ—¶æ‰æ›´æ–°çŠ¶æ€
        if (abilities.length === 0 || abilities.length !== allAbilities.length) {
          setAbilities(allAbilities);
        }
      } else {
        console.error('getAllPandaAbilities did not return an array:', allAbilities);
        if (abilities.length === 0) {
          setAbilities([]);
        }
      }

      // è·å–å·²è§£é”çš„èƒ½åŠ›
      let unlocked: PandaAbilityRecord[] = [];
      try {
        unlocked = await getUnlockedPandaAbilities();
      } catch (unlockErr) {
        console.error('Failed to load unlocked abilities:', unlockErr);
        unlocked = [];
      }

      // å®‰å…¨åœ°æ›´æ–°å·²è§£é”èƒ½åŠ›åˆ—è¡¨
      if (Array.isArray(unlocked)) {
        // åªæœ‰å½“è§£é”èƒ½åŠ›åˆ—è¡¨ä¸ºç©ºæˆ–é•¿åº¦ä¸åŒæ—¶æ‰æ›´æ–°çŠ¶æ€
        if (unlockedAbilities.length === 0 || unlockedAbilities.length !== unlocked.length) {
          setUnlockedAbilities(unlocked);
        }
      } else {
        console.error('getUnlockedPandaAbilities did not return an array:', unlocked);
        if (unlockedAbilities.length === 0) {
          setUnlockedAbilities([]);
        }
      }

      setError(null);
    } catch (err) {
      console.error('Failed to load panda abilities:', err);
      setError(err instanceof Error ? err : new Error('Failed to load panda abilities'));
      // è®¾ç½®é»˜è®¤ç©ºæ•°ç»„ï¼Œé˜²æ­¢UIé”™è¯¯
      if (abilities.length === 0) {
        setAbilities([]);
      }
      if (unlockedAbilities.length === 0) {
        setUnlockedAbilities([]);
      }
    }
  };

  // è®¾ç½®ç†ŠçŒ«æƒ…ç»ª
  const setMood = async (mood: PandaMood) => {
    try {
      setIsLoading(true);
      const updatedState = await updatePandaMood(mood);
      setPandaState(updatedState);
    } catch (err) {
      console.error('Failed to update panda mood:', err);
      setError(err instanceof Error ? err : new Error('Failed to update panda mood'));
    } finally {
      setIsLoading(false);
    }
  };

  // è®¾ç½®ç†ŠçŒ«èƒ½é‡
  const setEnergy = async (energy: EnergyLevel) => {
    try {
      setIsLoading(true);
      const updatedState = await updatePandaEnergy(energy);
      setPandaState(updatedState);
    } catch (err) {
      console.error('Failed to update panda energy:', err);
      setError(err instanceof Error ? err : new Error('Failed to update panda energy'));
    } finally {
      setIsLoading(false);
    }
  };

  // å¢åŠ ç†ŠçŒ«ç»éªŒ
  const addExperience = async (amount: number) => {
    try {
      setIsLoading(true);
      const updatedState = await addPandaExperience(amount);
      setPandaState(updatedState);

      // æ£€æŸ¥æ˜¯å¦æœ‰æ–°è§£é”çš„èƒ½åŠ›
      if (updatedState) {
        await checkAndUnlockAbilities(updatedState.level);
        await loadPandaAbilities(); // é‡æ–°åŠ è½½èƒ½åŠ›ä»¥æ›´æ–°çŠ¶æ€
      }
    } catch (err) {
      console.error('Failed to add panda experience:', err);
      setError(err instanceof Error ? err : new Error('Failed to add panda experience'));
    } finally {
      setIsLoading(false);
    }
  };

  // æ¿€æ´»ç†ŠçŒ«èƒ½åŠ›
  const handleActivateAbility = async (abilityId: number) => {
    try {
      setIsLoading(true);
      await activateAbility(abilityId);
      await loadPandaAbilities(); // é‡æ–°åŠ è½½èƒ½åŠ›ä»¥æ›´æ–°çŠ¶æ€
      setError(null);
    } catch (err) {
      console.error('Failed to activate ability:', err);
      setError(err instanceof Error ? err : new Error('Failed to activate ability'));
    } finally {
      setIsLoading(false);
    }
  };

  // æ£€æŸ¥æ–°è§£é”çš„èƒ½åŠ›
  const checkNewAbilities = async (): Promise<PandaAbilityRecord[]> => {
    try {
      if (!pandaState) {
        return [];
      }

      const newlyUnlocked = await checkAndUnlockAbilities(pandaState.level);
      await loadPandaAbilities(); // é‡æ–°åŠ è½½èƒ½åŠ›ä»¥æ›´æ–°çŠ¶æ€

      return newlyUnlocked;
    } catch (err) {
      console.error('Failed to check new abilities:', err);
      setError(err instanceof Error ? err : new Error('Failed to check new abilities'));
      return [];
    }
  };

  // é‡ç½®ç†ŠçŒ«çŠ¶æ€
  const resetState = async () => {
    try {
      setIsLoading(true);
      const resetedState = await resetPandaState();
      setPandaState(resetedState);
    } catch (err) {
      console.error('Failed to reset panda state:', err);
      setError(err instanceof Error ? err : new Error('Failed to reset panda state'));
    } finally {
      setIsLoading(false);
    }
  };

  // åˆ·æ–°ç†ŠçŒ«çŠ¶æ€
  const refreshState = async () => {
    await loadPandaState();
  };

  // æä¾›ä¸Šä¸‹æ–‡å€¼
  const contextValue: PandaStateContextType = {
    pandaState,
    abilities,
    unlockedAbilities,
    isLoading,
    error,
    setMood,
    setEnergy,
    addExperience,
    resetState,
    refreshState,
    activateAbility: handleActivateAbility,
    checkNewAbilities
  };

  return (
    <PandaStateContext.Provider value={contextValue}>
      {children}
    </PandaStateContext.Provider>
  );
};

/**
 * ä½¿ç”¨ç†ŠçŒ«çŠ¶æ€çš„Hook
 * @returns ç†ŠçŒ«çŠ¶æ€ä¸Šä¸‹æ–‡
 */
export const usePandaState = (): PandaStateContextType => {
  const context = useContext(PandaStateContext);
  if (context === undefined) {
    throw new Error('usePandaState must be used within a PandaStateProvider');
  }
  return context;
};
</file>

<file path="src/db-turso.ts">
// src/db-turso.ts
import { createClient } from '@libsql/client';

// åˆ›å»ºTursoå®¢æˆ·ç«¯
export const tursoClient = createClient({
  url: process.env.TURSO_DATABASE_URL || 'libsql://your-database-url.turso.io',
  authToken: process.env.TURSO_AUTH_TOKEN || 'your-auth-token',
});

// åˆå§‹åŒ–æ•°æ®åº“æ¨¡å¼
export async function initializeSchema() {
  try {
    console.log('Initializing Turso database schema...');
    
    // åˆ›å»ºuiLabelsè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS ui_labels (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        scope_key TEXT NOT NULL,
        label_key TEXT NOT NULL,
        language_code TEXT NOT NULL,
        translated_text TEXT NOT NULL,
        UNIQUE(scope_key, label_key, language_code)
      )
    `);
    
    // åˆ›å»ºpanda_stateè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS panda_state (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        mood TEXT NOT NULL,
        energy TEXT NOT NULL,
        last_updated TEXT NOT NULL,
        level INTEGER NOT NULL,
        experience INTEGER NOT NULL DEFAULT 0
      )
    `);
    
    // åˆ›å»ºtask_categoriesè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS task_categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        color TEXT NOT NULL,
        icon TEXT,
        is_default INTEGER NOT NULL DEFAULT 0
      )
    `);
    
    // åˆ›å»ºtasksè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS tasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        category_id INTEGER,
        priority TEXT NOT NULL,
        status TEXT NOT NULL,
        due_date TEXT,
        created_at TEXT NOT NULL,
        FOREIGN KEY (category_id) REFERENCES task_categories(id)
      )
    `);
    
    // åˆ›å»ºsubtasksè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS subtasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        parent_task_id INTEGER NOT NULL,
        title TEXT NOT NULL,
        status TEXT NOT NULL,
        order_index INTEGER NOT NULL,
        created_at TEXT NOT NULL,
        FOREIGN KEY (parent_task_id) REFERENCES tasks(id) ON DELETE CASCADE
      )
    `);
    
    // åˆ›å»ºtask_completionsè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS task_completions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        task_id INTEGER NOT NULL,
        completed_at TEXT NOT NULL,
        experience_gained INTEGER NOT NULL,
        FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
      )
    `);
    
    // åˆ›å»ºtask_remindersè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS task_reminders (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        task_id INTEGER NOT NULL,
        user_id TEXT NOT NULL,
        reminder_time TEXT NOT NULL,
        is_viewed INTEGER NOT NULL DEFAULT 0,
        is_completed INTEGER NOT NULL DEFAULT 0,
        created_at TEXT NOT NULL,
        FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
      )
    `);
    
    // åˆ›å»ºrewardsè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS rewards (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        type TEXT NOT NULL,
        rarity TEXT NOT NULL,
        task_id INTEGER,
        obtained_at TEXT NOT NULL,
        is_viewed INTEGER NOT NULL DEFAULT 0,
        FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE SET NULL
      )
    `);
    
    // åˆ›å»ºitemsè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        type TEXT NOT NULL,
        rarity TEXT NOT NULL,
        quantity INTEGER NOT NULL DEFAULT 1,
        obtained_at TEXT NOT NULL
      )
    `);
    
    // åˆ›å»ºbadgesè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS badges (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        rarity TEXT NOT NULL,
        obtained_at TEXT NOT NULL,
        is_equipped INTEGER NOT NULL DEFAULT 0
      )
    `);
    
    // åˆ›å»ºabilitiesè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS abilities (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        type TEXT NOT NULL,
        effect_type TEXT NOT NULL,
        required_level INTEGER NOT NULL,
        is_unlocked INTEGER NOT NULL DEFAULT 0,
        is_active INTEGER NOT NULL DEFAULT 0
      )
    `);
    
    // åˆ›å»ºreward_abilitiesè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS reward_abilities (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        rarity TEXT NOT NULL,
        obtained_at TEXT NOT NULL,
        is_unlocked INTEGER NOT NULL DEFAULT 0,
        is_active INTEGER NOT NULL DEFAULT 0
      )
    `);
    
    // åˆ›å»ºpanda_accessoriesè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS panda_accessories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        type TEXT NOT NULL,
        description TEXT,
        image_path TEXT NOT NULL,
        overlay_path TEXT,
        is_equipped INTEGER NOT NULL DEFAULT 0,
        is_owned INTEGER NOT NULL DEFAULT 0,
        obtained_at TEXT,
        store_item_id INTEGER,
        rarity TEXT NOT NULL,
        theme_type TEXT NOT NULL
      )
    `);
    
    // åˆ›å»ºpanda_environmentsè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS panda_environments (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        description TEXT,
        background_path TEXT NOT NULL,
        foreground_path TEXT,
        ambient_sound TEXT,
        is_active INTEGER NOT NULL DEFAULT 0,
        is_owned INTEGER NOT NULL DEFAULT 0,
        obtained_at TEXT,
        store_item_id INTEGER,
        rarity TEXT NOT NULL,
        theme_type TEXT NOT NULL,
        interactive_elements TEXT
      )
    `);
    
    // åˆ›å»ºchallengesè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS challenges (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        type TEXT NOT NULL,
        difficulty TEXT NOT NULL,
        status TEXT NOT NULL,
        progress REAL NOT NULL DEFAULT 0,
        start_date TEXT,
        end_date TEXT,
        created_at TEXT NOT NULL
      )
    `);
    
    // åˆ›å»ºchallenge_categoriesè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS challenge_categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        description TEXT,
        icon_path TEXT
      )
    `);
    
    // åˆ›å»ºchallenge_completionsè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS challenge_completions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        challenge_id INTEGER NOT NULL,
        user_id TEXT NOT NULL,
        completed_date TEXT NOT NULL,
        created_at TEXT NOT NULL,
        FOREIGN KEY (challenge_id) REFERENCES challenges(id) ON DELETE CASCADE
      )
    `);
    
    // åˆ›å»ºchallenge_discoveriesè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS challenge_discoveries (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        challenge_id INTEGER NOT NULL,
        discovered_at TEXT NOT NULL,
        is_viewed INTEGER NOT NULL DEFAULT 0,
        is_accepted INTEGER NOT NULL DEFAULT 0,
        expires_at TEXT,
        FOREIGN KEY (challenge_id) REFERENCES challenges(id) ON DELETE CASCADE
      )
    `);
    
    // åˆ›å»ºreflectionsè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS reflections (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        task_id INTEGER,
        mood TEXT NOT NULL,
        reflection TEXT,
        action TEXT,
        created_at TEXT NOT NULL,
        is_completed INTEGER NOT NULL DEFAULT 0,
        FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE SET NULL
      )
    `);
    
    // åˆ›å»ºreflection_triggersè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS reflection_triggers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        type TEXT NOT NULL,
        created_at TEXT NOT NULL,
        is_viewed INTEGER NOT NULL DEFAULT 0,
        is_completed INTEGER NOT NULL DEFAULT 0
      )
    `);
    
    // åˆ›å»ºmoodsè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS moods (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        mood TEXT NOT NULL,
        intensity INTEGER NOT NULL,
        created_at TEXT NOT NULL
      )
    `);
    
    // åˆ›å»ºstore_categoriesè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS store_categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        order_index INTEGER NOT NULL,
        is_visible INTEGER NOT NULL DEFAULT 1,
        created_at TEXT NOT NULL
      )
    `);
    
    // åˆ›å»ºstore_itemsè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS store_items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        type TEXT NOT NULL,
        rarity TEXT NOT NULL,
        price REAL NOT NULL,
        price_type TEXT NOT NULL,
        is_available INTEGER NOT NULL DEFAULT 1,
        is_featured INTEGER NOT NULL DEFAULT 0,
        is_on_sale INTEGER NOT NULL DEFAULT 0,
        sale_price REAL,
        sale_end_date TEXT,
        category_id INTEGER,
        created_at TEXT NOT NULL,
        FOREIGN KEY (category_id) REFERENCES store_categories(id) ON DELETE SET NULL
      )
    `);
    
    // åˆ›å»ºpurchasesè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS purchases (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        store_item_id INTEGER NOT NULL,
        price REAL NOT NULL,
        price_type TEXT NOT NULL,
        purchase_date TEXT NOT NULL,
        is_refunded INTEGER NOT NULL DEFAULT 0,
        FOREIGN KEY (store_item_id) REFERENCES store_items(id) ON DELETE CASCADE
      )
    `);
    
    // åˆ›å»ºvip_subscriptionsè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS vip_subscriptions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        tier INTEGER NOT NULL,
        start_date TEXT NOT NULL,
        end_date TEXT NOT NULL,
        is_active INTEGER NOT NULL DEFAULT 1,
        created_at TEXT NOT NULL
      )
    `);
    
    // åˆ›å»ºuser_currenciesè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS user_currencies (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        coins INTEGER NOT NULL DEFAULT 0,
        jade INTEGER NOT NULL DEFAULT 0,
        last_updated TEXT NOT NULL
      )
    `);
    
    // åˆ›å»ºtimely_rewardsè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS timely_rewards (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        type TEXT NOT NULL,
        status TEXT NOT NULL,
        start_time TEXT NOT NULL,
        end_time TEXT NOT NULL,
        created_at TEXT NOT NULL
      )
    `);
    
    // åˆ›å»ºlucky_pointsè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS lucky_points (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        amount INTEGER NOT NULL,
        is_spent INTEGER NOT NULL DEFAULT 0,
        expiry_date TEXT,
        created_at TEXT NOT NULL
      )
    `);
    
    // åˆ›å»ºlucky_drawsè¡¨
    await tursoClient.execute(`
      CREATE TABLE IF NOT EXISTS lucky_draws (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        points_spent INTEGER NOT NULL,
        timestamp TEXT NOT NULL,
        created_at TEXT NOT NULL
      )
    `);
    
    console.log('Turso database schema initialized successfully.');
  } catch (error) {
    console.error('Error initializing Turso database schema:', error);
    throw error;
  }
}
</file>

<file path="src/features/home/MoodsSection.tsx">
// src/features/home/MoodsSection.tsx
import React from 'react';
import type { HomeMoodsSectionLabels, MoodItem } from '@/types';
import Button from '@/components/common/Button';

interface MoodsSectionProps {
  labels: HomeMoodsSectionLabels | undefined;
  moods: readonly MoodItem[] | undefined; // Made readonly in type
  onRefresh: () => void;
  isFetching?: boolean;
}

const MoodsSection: React.FC<MoodsSectionProps> = ({ labels, moods, onRefresh, isFetching }) => {
  if (!labels) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Loading moods section...</p>;
  }

  return (
    <section className="page-content" style={{marginTop: '20px'}}> {/* Use class for styling */}
      <h4>{labels.sectionTitle}</h4> {/* Use h4 for sections within a page normally */}
      {moods && moods.length > 0 ? (
        <ul>
          {moods.map(mood => (
            <li key={mood.id}>{mood.name}: <strong>{mood.feeling}</strong></li>
          ))}
        </ul>
      ) : (
        <p>{labels.noMoodsMessage}</p>
      )}
      <Button onClick={onRefresh} isLoading={isFetching} loadingText="Refreshing...">
        {labels.refreshButtonText}
      </Button>
    </section>
  );
};
export default MoodsSection;
</file>

<file path="src/features/home/WelcomeSection.tsx">
// src/features/home/WelcomeSection.tsx
import React from 'react';
import type { HomeWelcomeSectionLabels } from '@/types';

interface WelcomeSectionProps {
  labels: HomeWelcomeSectionLabels | undefined;
  username: string | undefined;
}

const WelcomeSection: React.FC<WelcomeSectionProps> = ({ labels, username }) => {
  if (!labels || username === undefined) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Initializing welcome message...</p>;
  }
  const welcomeText = labels.welcomeMessage.replace('{user}', username);
  return <p>{welcomeText}</p>;
};
export default WelcomeSection;
</file>

<file path="src/features/settings/LanguageSettingsSection.tsx">
// src/features/settings/LanguageSettingsSection.tsx
import React, { useState, useEffect } from 'react';
import { useLanguage } from '@/context/LanguageProvider';
import type { Language, SettingsLanguageSectionLabels } from '@/types';
import Button from '@/components/common/Button';

interface LanguageSettingsSectionProps {
  labels: SettingsLanguageSectionLabels | undefined;
  isUpdatingPage?: boolean; // Indicates if the parent page is fetching new labels
}

const LanguageSettingsSection: React.FC<LanguageSettingsSectionProps> = ({ labels, isUpdatingPage }) => {
  const { language, setLanguage } = useLanguage();
  const [selectedLocalLang, setSelectedLocalLang] = useState<Language>(language);
  const [showSuccess, setShowSuccess] = useState(false);

  useEffect(() => {
    setSelectedLocalLang(language); // Sync with global changes
    if (showSuccess) setShowSuccess(false); // Hide success if global lang changes elsewhere
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [language]); // Only re-sync local if global language changes

  if (!labels) {
    return <p className="loading-text" style={{ fontStyle: 'italic' }}>Loading language settings...</p>;
  }

  const handleSave = () => {
    if (selectedLocalLang !== language) {
      setLanguage(selectedLocalLang); // This will trigger page label refetch
      setShowSuccess(true);
      setTimeout(() => setShowSuccess(false), 2500);
    }
  };

  const currentLangDisplay = labels.currentLanguageIs.replace('{lang}', language.toUpperCase());

  return (
    <section className="task-item"> {/* Apply task-item style for a game-themed look */}
      <h4>{labels.sectionTitle}</h4>
      <p>{currentLangDisplay}</p>
      <div>
        <label htmlFor="lang-select-component" style={{ marginRight: '8px' }}>{labels.selectLanguagePrompt}</label>
        <select
          id="lang-select-component"
          value={selectedLocalLang}
          onChange={e => {
            setSelectedLocalLang(e.target.value as Language);
            if (showSuccess) setShowSuccess(false);
          }}
          disabled={isUpdatingPage}
        >
          <option value="en">{labels.langNameEn}</option>
          <option value="zh">{labels.langNameZh}</option>
        </select>
      </div>
      <Button
        onClick={handleSave}
        disabled={isUpdatingPage || selectedLocalLang === language}
        style={{marginTop: '15px'}}
        variant="jade" // Use jade button style
      >
        {labels.saveButtonText}
      </Button>
      {showSuccess && (
        <p style={{
          color: 'var(--ruyi-green)',
          marginTop: '10px',
          fontStyle:'italic',
          background: 'rgba(46, 139, 87, 0.1)',
          padding: '8px',
          borderRadius: 'var(--radius-sm)'
        }}>
          {labels.successMessage}
        </p>
      )}
    </section>
  );
};
export default LanguageSettingsSection;
</file>

<file path="src/hooks/useInternationalizedQuery.ts">
// src/hooks/useInternationalizedQuery.ts
import {
  useQuery,
  type UseQueryOptions,
  type QueryKey,
  type UseQueryResult,
} from '@tanstack/react-query';
import type { ApiError, LocalizedContent } from '@/types';

interface UseInternationalizedQueryResult<TDataPayload, TLabelsBundle, TErrorResponse> {
  data: TDataPayload | undefined | null; // Data can be TDataPayload OR null
  labels: TLabelsBundle | undefined;
  isPending: boolean;
  isLoading: boolean;
  isFetching: boolean;
  isError: boolean;
  error: TErrorResponse | null;
  refetch: UseQueryResult<LocalizedContent<TDataPayload, TLabelsBundle>, TErrorResponse>['refetch'];
  status: UseQueryResult<LocalizedContent<TDataPayload, TLabelsBundle>, TErrorResponse>['status'];
  isSuccess: boolean;
}

export function useInternationalizedQuery<
  TLocalizedContent extends LocalizedContent<TDataPayload, TLabelsBundle>,
  TErrorResponse extends Error = ApiError,
  TDataPayload = TLocalizedContent['data'],
  TLabelsBundle = TLocalizedContent['labels'],
  TQueryKey extends QueryKey = QueryKey
>(
  options: UseQueryOptions<TLocalizedContent, TErrorResponse, TLocalizedContent, TQueryKey>
): UseInternationalizedQueryResult<TDataPayload, TLabelsBundle, TErrorResponse> {
  const {
    data: queryResult,
    isPending,
    isLoading,
    isFetching,
    isError,
    error,
    refetch,
    status,
    isSuccess,
  } = useQuery<TLocalizedContent, TErrorResponse, TLocalizedContent, TQueryKey>(options);

  return {
    data: queryResult?.data, // queryResult can be undefined during initial fetch
    labels: queryResult?.labels,
    isPending,
    isLoading,
    isFetching,
    isError,
    error,
    refetch,
    status,
    isSuccess,
  };
}
</file>

<file path="src/hooks/useLocalizedView.ts">
// src/hooks/useLocalizedView.ts
import { useLanguage } from '@/context/LanguageProvider';
import { useInternationalizedQuery } from './useInternationalizedQuery';
import type { ApiError, Language, LocalizedContent } from '@/types';
import { QueryKey, UseQueryOptions } from '@tanstack/react-query';

export function useLocalizedView<
  TDataPayload,
  TLabelsBundle
>(
  viewQueryKey: string | QueryKey,
  fetchViewFn: (lang: Language) => Promise<LocalizedContent<TDataPayload, TLabelsBundle>>,
  options?: Omit<UseQueryOptions<LocalizedContent<TDataPayload, TLabelsBundle>, ApiError, LocalizedContent<TDataPayload, TLabelsBundle>, QueryKey>, 'queryKey' | 'queryFn'>
) {
  const { language } = useLanguage();
  const fullQueryKeyWithLang: QueryKey = Array.isArray(viewQueryKey)
    ? [...viewQueryKey, language]
    : [viewQueryKey, language];

  return useInternationalizedQuery<
    LocalizedContent<TDataPayload, TLabelsBundle>,
    ApiError,
    TDataPayload,
    TLabelsBundle
  >({
    queryKey: fullQueryKeyWithLang,
    queryFn: () => fetchViewFn(language),
    enabled: !!language && (options?.enabled === undefined || options.enabled),
    ...options,
  });
}
</file>

<file path="src/main.tsx">
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';
import './index.css'; // Base styles
import './game-theme.css'; // Game-themed styles

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path="src/pages/StorePage.tsx">
// src/pages/StorePage.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  StoreCategoryRecord,
  StoreItemRecord,
  VipSubscriptionRecord,
  UserCurrencyRecord,
  getStoreCategories,
  getCategoryItems,
  getFeaturedItems,
  getSaleItems,
  getUserCurrency,
  getUserVipSubscription,
  isUserVip
} from '@/services/storeService';
import StoreCategoryList from '@/components/store/StoreCategoryList';
import StoreItemCard from '@/components/store/StoreItemCard';
import StoreItemPreview from '@/components/store/StoreItemPreview';
import VipSubscriptionCard from '@/components/store/VipSubscriptionCard';
import CurrencyDisplay from '@/components/store/CurrencyDisplay';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { playSound, SoundType } from '@/utils/sound';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import { pageTransition } from '@/utils/animation';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchStorePageView } from '@/services';
import type { StorePageViewLabelsBundle } from '@/types';

/**
 * å•†åº—é¡µé¢
 * ç”¨äºæ˜¾ç¤ºå’Œè´­ä¹°å•†åº—ç‰©å“
 */
const StorePage: React.FC = () => {
  const [categories, setCategories] = useState<StoreCategoryRecord[]>([]);
  const [selectedCategory, setSelectedCategory] = useState<StoreCategoryRecord | null>(null);
  const [items, setItems] = useState<StoreItemRecord[]>([]);
  const [featuredItems, setFeaturedItems] = useState<StoreItemRecord[]>([]);
  const [saleItems, setSaleItems] = useState<StoreItemRecord[]>([]);
  const [selectedItem, setSelectedItem] = useState<StoreItemRecord | null>(null);
  const [showItemPreview, setShowItemPreview] = useState(false);
  const [showVipSection, setShowVipSection] = useState(false);
  const [userCurrency, setUserCurrency] = useState<UserCurrencyRecord | null>(null);
  const [vipSubscription, setVipSubscription] = useState<VipSubscriptionRecord | null>(null);
  const [isVip, setIsVip] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // è·å–æœ¬åœ°åŒ–æ ‡ç­¾
  const {
    labels: pageLabels,
    isPending: isLabelsPending,
    isError: isLabelsError,
    error: labelsError,
    refetch: refetchLabels
  } = useLocalizedView<null, StorePageViewLabelsBundle>(
    'storePageViewContent',
    fetchStorePageView
  );

  // å½“å‰ç”¨æˆ·IDï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥ä»ç”¨æˆ·ä¼šè¯ä¸­è·å–ï¼‰
  const userId = 'current-user';

  // åŠ è½½å•†åº—æ•°æ®
  const loadStoreData = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // è·å–å•†åº—ç±»åˆ«
      const storeCategories = await getStoreCategories();
      setCategories(storeCategories);

      // å¦‚æœæœ‰ç±»åˆ«ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ª
      if (storeCategories.length > 0) {
        setSelectedCategory(storeCategories[0]);

        // è·å–è¯¥ç±»åˆ«çš„ç‰©å“
        const categoryItems = await getCategoryItems(storeCategories[0].id!);
        setItems(categoryItems);
      }

      // è·å–ç‰¹è‰²ç‰©å“
      const featured = await getFeaturedItems();
      setFeaturedItems(featured);

      // è·å–ä¿ƒé”€ç‰©å“
      const sale = await getSaleItems();
      setSaleItems(sale);

      // è·å–ç”¨æˆ·è´§å¸
      const currency = await getUserCurrency(userId);
      setUserCurrency(currency);

      // è·å–ç”¨æˆ·VIPè®¢é˜…
      const subscription = await getUserVipSubscription(userId);
      setVipSubscription(subscription);

      // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ˜¯VIP
      const userIsVip = await isUserVip(userId);
      setIsVip(userIsVip);
    } catch (err) {
      console.error('Failed to load store data:', err);
      setError('åŠ è½½å•†åº—æ•°æ®å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadStoreData();
  }, []);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('storeCategories', loadStoreData);
  useRegisterTableRefresh('storeItems', loadStoreData);
  useRegisterTableRefresh('userCurrencies', loadStoreData);
  useRegisterTableRefresh('vipSubscriptions', loadStoreData);

  // å¤„ç†é€‰æ‹©ç±»åˆ«
  const handleCategorySelect = async (category: StoreCategoryRecord) => {
    setSelectedCategory(category);

    try {
      // è·å–è¯¥ç±»åˆ«çš„ç‰©å“
      const categoryItems = await getCategoryItems(category.id!);
      setItems(categoryItems);
    } catch (err) {
      console.error('Failed to load category items:', err);
      setError('åŠ è½½ç±»åˆ«ç‰©å“å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };

  // å¤„ç†é¢„è§ˆç‰©å“
  const handlePreviewItem = (item: StoreItemRecord) => {
    setSelectedItem(item);
    setShowItemPreview(true);
  };

  // å¤„ç†è´­ä¹°ç‰©å“
  const handlePurchaseItem = async () => {
    // é‡æ–°åŠ è½½æ•°æ®
    await loadStoreData();
  };

  // å¤„ç†è®¢é˜…VIP
  const handleSubscribeVip = async () => {
    // é‡æ–°åŠ è½½æ•°æ®
    await loadStoreData();
  };

  // å¤„ç†åˆ‡æ¢VIPéƒ¨åˆ†
  const handleToggleVipSection = () => {
    // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
    playSound(SoundType.BUTTON_CLICK, 0.3);

    setShowVipSection(!showVipSection);
  };

  // å®¹å™¨å˜ä½“
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  // é¡¹ç›®å˜ä½“
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  // VIPè®¢é˜…é€‰é¡¹
  const vipOptions = [
    {
      tier: 1,
      title: 'åŸºç¡€VIP',
      description: 'è§£é”åŸºç¡€VIPç‰¹æƒï¼Œäº«å—æ›´å¤šæ¸¸æˆä¹è¶£',
      price: 18,
      duration: 30,
      benefits: [
        'è§£é”VIPä¸“å±ç‰©å“',
        'æ¯æ—¥é¢å¤–10é‡‘å¸',
        'å•†åº—9æŠ˜ä¼˜æƒ '
      ],
      imagePath: '/assets/store/vip-basic.png'
    },
    {
      tier: 2,
      title: 'é«˜çº§VIP',
      description: 'è§£é”é«˜çº§VIPç‰¹æƒï¼Œäº«å—æ›´å¤šæ¸¸æˆä¹è¶£',
      price: 38,
      duration: 30,
      benefits: [
        'åŒ…å«åŸºç¡€VIPæ‰€æœ‰ç‰¹æƒ',
        'æ¯æ—¥é¢å¤–20é‡‘å¸',
        'æ¯å‘¨èµ é€1ç‰çŸ³',
        'å•†åº—8æŠ˜ä¼˜æƒ '
      ],
      imagePath: '/assets/store/vip-premium.png'
    },
    {
      tier: 3,
      title: 'è±ªåVIP',
      description: 'è§£é”è±ªåVIPç‰¹æƒï¼Œäº«å—æœ€ä½³æ¸¸æˆä½“éªŒ',
      price: 68,
      duration: 30,
      benefits: [
        'åŒ…å«é«˜çº§VIPæ‰€æœ‰ç‰¹æƒ',
        'æ¯æ—¥é¢å¤–30é‡‘å¸',
        'æ¯å‘¨èµ é€3ç‰çŸ³',
        'å•†åº—7æŠ˜ä¼˜æƒ ',
        'ä¸“å±ç†ŠçŒ«å¤´åƒå’ŒèƒŒæ™¯'
      ],
      imagePath: '/assets/store/vip-deluxe.png'
    }
  ];

  // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
  if (isLabelsPending && !pageLabels) {
    return (
      <motion.div
        className="page-container"
        variants={pageTransition}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <div className="loading-container flex justify-center items-center h-64">
          <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "åŠ è½½å•†åº—å†…å®¹..."} />
        </div>
      </motion.div>
    );
  }

  // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
  if (isLabelsError && !pageLabels) {
    return (
      <motion.div
        className="page-container"
        variants={pageTransition}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <div className="error-container text-center p-4">
          <ErrorDisplay
            error={labelsError}
            title={pageLabels?.errorTitle || "å•†åº—é¡µé¢é”™è¯¯"}
            onRetry={refetchLabels}
          />
        </div>
      </motion.div>
    );
  }

  return (
    <motion.div
      className="page-container"
      variants={pageTransition}
      initial="hidden"
      animate="visible"
      exit="exit"
    >
      <div className="bamboo-frame">
        <h2>{pageLabels?.pageTitle || "å•†åº—"}</h2>

        {isLoading ? (
          <div className="loading-container flex justify-center items-center h-64">
            <LoadingSpinner variant="jade" size="large" />
          </div>
        ) : error ? (
          <div className="error-container text-center p-4">
            <div className="error-message text-red-500 mb-4">{error}</div>
            <Button variant="jade" onClick={loadStoreData}>
              {pageLabels?.retryButtonText || "é‡è¯•"}
            </Button>
          </div>
        ) : (
          <div className="store-content">
            {/* ç”¨æˆ·è´§å¸æ˜¾ç¤ºå’ŒVIPåˆ‡æ¢ */}
            <div className="store-header-section mb-6 flex flex-col md:flex-row justify-between items-center gap-4">
              {userCurrency && (
                <div className="currency-section flex-grow">
                  <CurrencyDisplay
                    currency={userCurrency}
                    isVip={isVip}
                    labels={pageLabels?.currencySection}
                  />
                </div>
              )}

              {/* VIPåˆ‡æ¢æŒ‰é’® */}
              <div className="vip-toggle-section">
                <Button
                  variant={showVipSection ? 'gold' : 'secondary'}
                  onClick={handleToggleVipSection}
                  className="px-6 py-2"
                >
                  {showVipSection
                    ? (pageLabels?.vipToggleButton?.backToStore || 'Return to Store')
                    : (pageLabels?.vipToggleButton?.showVip || 'View VIP Membership')}
                </Button>
              </div>
            </div>

            <AnimatePresence mode="wait">
              {showVipSection ? (
                <motion.div
                  key="vip-section"
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -20 }}
                  transition={{ duration: 0.3 }}
                  className="vip-section"
                >
                  <div className="vip-header mb-6 text-center">
                    <h3 className="text-xl font-bold text-amber-700">
                      <span className="mr-2">âœ¨</span>
                      {pageLabels?.vipToggleButton?.showVip || 'VIP Membership'}
                      <span className="ml-2">âœ¨</span>
                    </h3>
                    <p className="text-gray-600 mt-2">
                      {pageLabels?.vipSection?.description || 'Unlock exclusive benefits and enhance your experience'}
                    </p>
                  </div>

                  <div className="vip-options-grid grid grid-cols-1 md:grid-cols-3 gap-6">
                    {vipOptions.map((option) => (
                      <VipSubscriptionCard
                        key={option.tier}
                        tier={option.tier}
                        title={option.title}
                        description={option.description}
                        price={option.price}
                        duration={option.duration}
                        benefits={option.benefits}
                        imagePath={option.imagePath}
                        currentSubscription={vipSubscription}
                        onSubscribe={handleSubscribeVip}
                      />
                    ))}
                  </div>
                </motion.div>
              ) : (
                <motion.div
                  key="store-section"
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -20 }}
                  transition={{ duration: 0.3 }}
                  className="store-section"
                >
                  {/* å•†åº—ç±»åˆ« */}
                  {categories.length > 0 && (
                    <div className="categories-section mb-6 bg-white p-3 rounded-lg shadow-sm border border-jade-200">
                      <h3 className="text-lg font-bold mb-3 text-jade-700">
                        <span className="mr-2">ğŸª</span>
                        {pageLabels?.categoriesTitle || 'Categories'}
                      </h3>
                      <StoreCategoryList
                        onCategorySelect={handleCategorySelect}
                        selectedCategoryId={selectedCategory?.id}
                      />
                    </div>
                  )}

                  {/* ç‰¹è‰²ç‰©å“ */}
                  {featuredItems.length > 0 && (
                    <div className="featured-items-section mb-8">
                      <div className="section-header flex items-center mb-4 border-b-2 border-amber-300 pb-2">
                        <span className="text-2xl mr-2">âœ¨</span>
                        <h3 className="text-xl font-bold text-amber-700">{pageLabels?.featuredItemsTitle || 'Featured Items'}</h3>
                      </div>
                      <motion.div
                        className="featured-items-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
                        variants={containerVariants}
                        initial="hidden"
                        animate="visible"
                      >
                        {featuredItems.map((item) => (
                          <motion.div
                            key={item.id}
                            variants={itemVariants}
                          >
                            <StoreItemCard
                              item={item}
                              onPurchase={handlePurchaseItem}
                              onPreview={handlePreviewItem}
                              userCoins={userCurrency?.coins}
                              userJade={userCurrency?.jade}
                              isVip={isVip}
                            />
                          </motion.div>
                        ))}
                      </motion.div>
                    </div>
                  )}

                  {/* ä¿ƒé”€ç‰©å“ */}
                  {saleItems.length > 0 && (
                    <div className="sale-items-section mb-8">
                      <div className="section-header flex items-center mb-4 border-b-2 border-cinnabar-red pb-2">
                        <span className="text-2xl mr-2">ğŸ”¥</span>
                        <h3 className="text-xl font-bold text-cinnabar-red">{pageLabels?.saleItemsTitle || 'Sale Items'}</h3>
                      </div>
                      <motion.div
                        className="sale-items-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
                        variants={containerVariants}
                        initial="hidden"
                        animate="visible"
                      >
                        {saleItems.map((item) => (
                          <motion.div
                            key={item.id}
                            variants={itemVariants}
                          >
                            <StoreItemCard
                              item={item}
                              onPurchase={handlePurchaseItem}
                              onPreview={handlePreviewItem}
                              userCoins={userCurrency?.coins}
                              userJade={userCurrency?.jade}
                              isVip={isVip}
                            />
                          </motion.div>
                        ))}
                      </motion.div>
                    </div>
                  )}

                  {/* ç±»åˆ«ç‰©å“ */}
                  {selectedCategory && (
                    <div className="category-items-section mb-6">
                      <div className="section-header flex items-center mb-4 border-b-2 border-jade-500 pb-2">
                        <span className="text-2xl mr-2">ğŸ“¦</span>
                        <h3 className="text-xl font-bold text-jade-700">{selectedCategory.name || pageLabels?.categoryItemsTitle || 'Category Items'}</h3>
                      </div>
                      {items.length > 0 ? (
                        <motion.div
                          className="category-items-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
                          variants={containerVariants}
                          initial="hidden"
                          animate="visible"
                        >
                          {items.map((item) => (
                            <motion.div
                              key={item.id}
                              variants={itemVariants}
                            >
                              <StoreItemCard
                                item={item}
                                onPurchase={handlePurchaseItem}
                                onPreview={handlePreviewItem}
                                userCoins={userCurrency?.coins}
                                userJade={userCurrency?.jade}
                                isVip={isVip}
                              />
                            </motion.div>
                          ))}
                        </motion.div>
                      ) : (
                        <div className="no-items text-center p-6 bg-gray-50 rounded-lg border border-gray-200">
                          <p className="text-gray-500">{pageLabels?.noItemsMessage || 'No items available in this category'}</p>
                        </div>
                      )}
                    </div>
                  )}
                </motion.div>
              )}
            </AnimatePresence>
          </div>
        )}
      </div>

      {/* ç‰©å“é¢„è§ˆå¯¹è¯æ¡† */}
      {selectedItem && (
        <StoreItemPreview
          isOpen={showItemPreview}
          onClose={() => setShowItemPreview(false)}
          item={selectedItem}
          onPurchase={handlePurchaseItem}
          userCoins={userCurrency?.coins}
          userJade={userCurrency?.jade}
          isVip={isVip}
        />
      )}
    </motion.div>
  );
};

export default StorePage;
</file>

<file path="src/pages/TeaRoomPage.tsx">
// src/pages/TeaRoomPage.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  ReflectionTriggerRecord,
  ReflectionTriggerType,
  getUnviewedReflectionTriggers,
  markTriggerAsViewed,
  createReflectionTrigger
} from '@/services/reflectionService';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import EnhancedReflectionModule from '@/components/reflection/EnhancedReflectionModule';
import ReflectionHistory from '@/components/reflection/ReflectionHistory';
import MoodTracker from '@/components/reflection/MoodTracker';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchTeaRoomPageView } from '@/services';
import type { TeaRoomPageViewLabelsBundle } from '@/types';
import { pageTransition } from '@/utils/animation';
import ReflectionTriggerNotification from '@/components/reflection/ReflectionTriggerNotification';
import { playSound, SoundType } from '@/utils/sound';

/**
 * Tea Room Page
 * Provides reflection, mood tracking, and supportive feedback
 */
const TeaRoomPage: React.FC = () => {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showReflectionModule, setShowReflectionModule] = useState(false);
  const [showReflectionHistory, setShowReflectionHistory] = useState(false);
  const [selectedTrigger, setSelectedTrigger] = useState<ReflectionTriggerRecord | null>(null);

  // Current user ID (in a real application, this should be retrieved from the user session)
  const userId = 'current-user';

  // Get localized labels
  const {
    labels: pageLabels,
    isPending: isLabelsPending,
    isError: isLabelsError,
    error: labelsError,
    refetch: refetchLabels
  } = useLocalizedView<null, TeaRoomPageViewLabelsBundle>(
    'teaRoomPageViewContent',
    fetchTeaRoomPageView
  );

  // Load page data
  const loadPageData = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // Load other data here

    } catch (err) {
      console.error('Failed to load tea room data:', err);
      setError('Failed to load data, please try again');
    } finally {
      setIsLoading(false);
    }
  };

  // Initial loading
  useEffect(() => {
    loadPageData();
  }, []);

  // Register data refresh listeners
  useRegisterTableRefresh('reflections', loadPageData);
  useRegisterTableRefresh('reflectionTriggers', loadPageData);
  useRegisterTableRefresh('moods', loadPageData);

  // Handle start reflection
  const handleStartReflection = () => {
    // Play click sound
    playSound(SoundType.BUTTON_CLICK, 0.5);

    // Create manual trigger record
    createReflectionTrigger({
      userId,
      type: ReflectionTriggerType.MANUAL
    });

    // Show reflection module
    setShowReflectionModule(true);
  };

  // Handle view history
  const handleViewHistory = () => {
    // Play click sound
    playSound(SoundType.BUTTON_CLICK, 0.5);

    // Show reflection history
    setShowReflectionHistory(true);
  };

  // Handle trigger accepted
  const handleTriggerAccepted = (trigger: ReflectionTriggerRecord) => {
    setSelectedTrigger(trigger);
    setShowReflectionModule(true);
  };

  // Handle reflection complete
  const handleReflectionComplete = () => {
    // Reset selected trigger
    setSelectedTrigger(null);

    // Reload page data
    loadPageData();
  };

  // Render page content
  const renderPageContent = () => {
    return (
      <div className="tea-room-content">
        <div className="bamboo-frame">
          <h2>{pageLabels?.pageTitle || "Tea Room"}</h2>
          <p className="text-gray-600 mb-6">
            {pageLabels?.reflectionSection?.description || "Take some time to reflect on your experiences, feelings, and thoughts to better understand yourself and find direction."}
          </p>

          <div className="tea-room-sections grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Mood Tracking Section */}
            <div className="mood-tracking-section bg-white p-4 rounded-lg shadow-md border-l-4 border-jade-500">
              <h2 className="text-xl font-bold text-jade-700 mb-4">
                <span className="mr-2">ğŸµ</span>
                {pageLabels?.moodTrackingSection?.title || "Mood Tracking"}
              </h2>
              <MoodTracker
              labels={pageLabels?.moodTrackingSection}
            />
            </div>

            {/* Reflection Section */}
            <div className="reflection-section bg-white p-4 rounded-lg shadow-md border-l-4 border-amber-500">
              <h2 className="text-xl font-bold text-amber-700 mb-4">
                <span className="mr-2">ğŸª·</span>
                {pageLabels?.reflectionSection?.title || "Reflection"}
              </h2>
              <p className="text-gray-600 mb-4">
                {pageLabels?.reflectionSection?.description || "Taking time to reflect on your experiences, feelings, and thoughts can help you better understand yourself and find direction."}
              </p>
              <div className="reflection-actions flex flex-col gap-2">
                <Button
                  variant="jade"
                  onClick={handleStartReflection}
                  className="w-full"
                >
                  {pageLabels?.reflectionSection?.startReflectionButton || "Start Reflection"}
                </Button>
                <Button
                  variant="secondary"
                  onClick={handleViewHistory}
                  className="w-full"
                >
                  {pageLabels?.reflectionSection?.viewHistoryButton || "View History"}
                </Button>
              </div>
            </div>
          </div>

          {/* Daily Tips Section */}
          <div className="daily-tips-section bg-white p-4 rounded-lg shadow-md mt-6 border border-amber-200">
            <h2 className="text-xl font-bold text-amber-700 mb-4">
              <span className="mr-2">ğŸ’¡</span>
              {pageLabels?.dailyTipSection?.title || "Daily Wisdom"}
            </h2>
            <div className="daily-tip p-3 bg-amber-50 rounded-lg">
              <div className="flex items-start">
                <div className="tip-icon mr-3">
                  <span className="text-2xl">ğŸ‹</span>
                </div>
                <div className="tip-content">
                  <p className="text-gray-700">
                    {pageLabels?.dailyTipSection?.content || "Self-compassion is an essential part of mental health. When facing difficulties, try to treat yourself as you would a good friend, with understanding and kindness."}
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Reflection Module */}
        {showReflectionModule && (
          <EnhancedReflectionModule
            isOpen={showReflectionModule}
            onClose={() => setShowReflectionModule(false)}
            trigger={selectedTrigger || undefined}
            onReflectionComplete={handleReflectionComplete}
          />
        )}

        {/* Reflection History */}
        {showReflectionHistory && (
          <ReflectionHistory
            isOpen={showReflectionHistory}
            onClose={() => setShowReflectionHistory(false)}
          />
        )}

        {/* Reflection Trigger Notification */}
        <ReflectionTriggerNotification
          onTriggerAccepted={handleTriggerAccepted}
        />
      </div>
    );
  };

  // Show loading state
  if (isLabelsPending && !pageLabels) {
    return (
      <motion.div
        className="page-container"
        variants={pageTransition}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <div className="loading-container flex justify-center items-center h-64">
          <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "Loading tea room content..."} />
        </div>
      </motion.div>
    );
  }

  // Show error state
  if (isLabelsError && !pageLabels) {
    return (
      <motion.div
        className="page-container"
        variants={pageTransition}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <div className="error-container text-center p-4">
          <ErrorDisplay
            error={labelsError}
            title={pageLabels?.errorTitle || "Tea Room Page Error"}
            onRetry={refetchLabels}
          />
        </div>
      </motion.div>
    );
  }

  return (
    <motion.div
      className="page-container"
      variants={pageTransition}
      initial="hidden"
      animate="visible"
      exit="exit"
    >
      {isLoading ? (
        <div className="loading-container flex justify-center items-center h-64">
          <LoadingSpinner variant="jade" size="large" text={pageLabels?.loadingMessage || "Loading tea room content..."} />
        </div>
      ) : error ? (
        <div className="error-container text-center p-4">
          <div className="error-message text-red-500 mb-4">{error}</div>
          <Button variant="jade" onClick={loadPageData}>
            {pageLabels?.retryButtonText || "Retry"}
          </Button>
        </div>
      ) : (
        <AnimatePresence>
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.5 }}
          >
            {renderPageContent()}
          </motion.div>
        </AnimatePresence>
      )}
    </motion.div>
  );
};

export default TeaRoomPage;
</file>

<file path="src/services/challengeDiscoveryService.ts">
// src/services/challengeDiscoveryService.ts
import { db } from '@/db';
import { 
  ChallengeRecord, 
  ChallengeType, 
  ChallengeDifficulty, 
  ChallengeStatus,
  getAllChallenges
} from './challengeService';
import { 
  TaskRecord, 
  TaskStatus, 
  TaskType, 
  TaskPriority,
  getAllTasks
} from './taskService';
import { getPandaLevel } from './pandaStateService';

/**
 * æŒ‘æˆ˜æ¨èè®°å½•ç±»å‹
 */
export interface ChallengeRecommendation {
  challenge: ChallengeRecord;
  score: number;
  reason: string;
}

/**
 * æŒ‘æˆ˜å‘ç°è®°å½•ç±»å‹
 */
export interface ChallengeDiscovery {
  id?: number;
  userId: string;
  challengeId: number;
  discoveredAt: Date;
  isViewed: boolean;
  isAccepted: boolean;
  expiresAt?: Date;
}

/**
 * è·å–æ¨èçš„æŒ‘æˆ˜
 * æ ¹æ®ç”¨æˆ·çš„ä»»åŠ¡å®Œæˆæƒ…å†µã€ç†ŠçŒ«ç­‰çº§å’Œåå¥½æ¨èæŒ‘æˆ˜
 */
export async function getRecommendedChallenges(
  limit: number = 3
): Promise<ChallengeRecommendation[]> {
  try {
    // è·å–ç”¨æˆ·çš„ç†ŠçŒ«ç­‰çº§
    const pandaLevel = await getPandaLevel();
    
    // è·å–æ‰€æœ‰æ´»è·ƒå’Œå³å°†å¼€å§‹çš„æŒ‘æˆ˜
    const challenges = await getAllChallenges({
      status: ChallengeStatus.ACTIVE
    });
    
    // è·å–ç”¨æˆ·å·²å®Œæˆçš„ä»»åŠ¡
    const completedTasks = await getAllTasks({
      status: TaskStatus.COMPLETED
    });
    
    // è®¡ç®—æ¯ä¸ªæŒ‘æˆ˜çš„æ¨èåˆ†æ•°
    const recommendations: ChallengeRecommendation[] = [];
    
    for (const challenge of challenges) {
      let score = 0;
      let reason = '';
      
      // æ ¹æ®æŒ‘æˆ˜éš¾åº¦å’Œç†ŠçŒ«ç­‰çº§è®¡ç®—åˆ†æ•°
      if (challenge.difficulty === ChallengeDifficulty.EASY) {
        score += 10;
        reason += 'è¿™ä¸ªæŒ‘æˆ˜éš¾åº¦é€‚ä¸­ï¼Œ';
      } else if (challenge.difficulty === ChallengeDifficulty.MEDIUM && pandaLevel >= 3) {
        score += 15;
        reason += 'è¿™ä¸ªæŒ‘æˆ˜éš¾åº¦é€‚åˆä½ å½“å‰çš„ç­‰çº§ï¼Œ';
      } else if (challenge.difficulty === ChallengeDifficulty.HARD && pandaLevel >= 5) {
        score += 20;
        reason += 'è¿™ä¸ªæŒ‘æˆ˜æœ‰ä¸€å®šéš¾åº¦ï¼Œä½†ä½ å·²ç»è¾¾åˆ°äº†è¶³å¤Ÿçš„ç­‰çº§ï¼Œ';
      } else if (challenge.difficulty === ChallengeDifficulty.EXPERT && pandaLevel >= 8) {
        score += 25;
        reason += 'è¿™ä¸ªæŒ‘æˆ˜éå¸¸æœ‰æŒ‘æˆ˜æ€§ï¼Œé€‚åˆä½ çš„é«˜ç­‰çº§ï¼Œ';
      }
      
      // æ ¹æ®æŒ‘æˆ˜ç±»å‹è®¡ç®—åˆ†æ•°
      if (challenge.type === ChallengeType.DAILY) {
        score += 5;
        reason += 'è¿™æ˜¯ä¸€ä¸ªæ—¥å¸¸æŒ‘æˆ˜ï¼Œ';
      } else if (challenge.type === ChallengeType.WEEKLY) {
        score += 10;
        reason += 'è¿™æ˜¯ä¸€ä¸ªæ¯å‘¨æŒ‘æˆ˜ï¼Œ';
      } else if (challenge.type === ChallengeType.EVENT) {
        score += 15;
        reason += 'è¿™æ˜¯ä¸€ä¸ªé™æ—¶æ´»åŠ¨æŒ‘æˆ˜ï¼Œ';
      }
      
      // æ ¹æ®å·²å®Œæˆä»»åŠ¡çš„ç›¸å…³æ€§è®¡ç®—åˆ†æ•°
      const relatedTaskCount = completedTasks.filter(task => {
        // æ£€æŸ¥ä»»åŠ¡æ ‡é¢˜æˆ–æè¿°æ˜¯å¦ä¸æŒ‘æˆ˜ç›¸å…³
        const taskTitle = task.title.toLowerCase();
        const taskDesc = task.description?.toLowerCase() || '';
        const challengeTitle = challenge.title.toLowerCase();
        const challengeDesc = challenge.description.toLowerCase();
        
        return (
          taskTitle.includes(challengeTitle) ||
          taskDesc.includes(challengeTitle) ||
          challengeTitle.includes(taskTitle) ||
          taskDesc.includes(challengeDesc) ||
          challengeDesc.includes(taskTitle)
        );
      }).length;
      
      if (relatedTaskCount > 0) {
        score += relatedTaskCount * 5;
        reason += `ä½ å·²ç»å®Œæˆäº†${relatedTaskCount}ä¸ªç›¸å…³ä»»åŠ¡ï¼Œ`;
      }
      
      // æ·»åŠ åˆ°æ¨èåˆ—è¡¨
      recommendations.push({
        challenge,
        score,
        reason: reason + 'æ¨èä½ å°è¯•è¿™ä¸ªæŒ‘æˆ˜ã€‚'
      });
    }
    
    // æŒ‰åˆ†æ•°æ’åºå¹¶é™åˆ¶æ•°é‡
    return recommendations
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);
  } catch (err) {
    console.error('Failed to get recommended challenges:', err);
    return [];
  }
}

/**
 * å‘ç°æ–°æŒ‘æˆ˜
 * æ ¹æ®ç”¨æˆ·çš„ä»»åŠ¡å®Œæˆæƒ…å†µè‡ªåŠ¨å‘ç°æ–°æŒ‘æˆ˜
 */
export async function discoverNewChallenges(): Promise<ChallengeDiscovery[]> {
  try {
    // è·å–ç”¨æˆ·çš„ç†ŠçŒ«ç­‰çº§
    const pandaLevel = await getPandaLevel();
    
    // è·å–æ‰€æœ‰å³å°†å¼€å§‹çš„æŒ‘æˆ˜
    const upcomingChallenges = await getAllChallenges({
      status: ChallengeStatus.UPCOMING
    });
    
    // è·å–ç”¨æˆ·å·²å®Œæˆçš„ä»»åŠ¡
    const completedTasks = await getAllTasks({
      status: TaskStatus.COMPLETED
    });
    
    // è·å–å·²å‘ç°çš„æŒ‘æˆ˜
    const discoveredChallenges = await db.table('challengeDiscoveries')
      .where('userId')
      .equals('current-user') // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥æ˜¯å½“å‰ç”¨æˆ·çš„ID
      .toArray();
    
    const discoveredChallengeIds = discoveredChallenges.map(dc => dc.challengeId);
    
    // ç­›é€‰å‡ºç¬¦åˆå‘ç°æ¡ä»¶çš„æŒ‘æˆ˜
    const newDiscoveries: ChallengeDiscovery[] = [];
    
    for (const challenge of upcomingChallenges) {
      // è·³è¿‡å·²å‘ç°çš„æŒ‘æˆ˜
      if (discoveredChallengeIds.includes(challenge.id!)) {
        continue;
      }
      
      // æ£€æŸ¥æ˜¯å¦ç¬¦åˆå‘ç°æ¡ä»¶
      let shouldDiscover = false;
      
      // æ¡ä»¶1ï¼šç†ŠçŒ«ç­‰çº§è¾¾åˆ°è¦æ±‚
      if (
        (challenge.difficulty === ChallengeDifficulty.EASY && pandaLevel >= 1) ||
        (challenge.difficulty === ChallengeDifficulty.MEDIUM && pandaLevel >= 3) ||
        (challenge.difficulty === ChallengeDifficulty.HARD && pandaLevel >= 5) ||
        (challenge.difficulty === ChallengeDifficulty.EXPERT && pandaLevel >= 8)
      ) {
        shouldDiscover = true;
      }
      
      // æ¡ä»¶2ï¼šå®Œæˆäº†ç›¸å…³ä»»åŠ¡
      const relatedTaskCount = completedTasks.filter(task => {
        const taskTitle = task.title.toLowerCase();
        const taskDesc = task.description?.toLowerCase() || '';
        const challengeTitle = challenge.title.toLowerCase();
        const challengeDesc = challenge.description.toLowerCase();
        
        return (
          taskTitle.includes(challengeTitle) ||
          taskDesc.includes(challengeTitle) ||
          challengeTitle.includes(taskTitle) ||
          taskDesc.includes(challengeDesc) ||
          challengeDesc.includes(taskTitle)
        );
      }).length;
      
      if (relatedTaskCount >= 3) {
        shouldDiscover = true;
      }
      
      // å¦‚æœç¬¦åˆæ¡ä»¶ï¼Œåˆ›å»ºæ–°çš„å‘ç°è®°å½•
      if (shouldDiscover) {
        const now = new Date();
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7å¤©åè¿‡æœŸ
        
        const discovery: ChallengeDiscovery = {
          userId: 'current-user', // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥æ˜¯å½“å‰ç”¨æˆ·çš„ID
          challengeId: challenge.id!,
          discoveredAt: now,
          isViewed: false,
          isAccepted: false,
          expiresAt
        };
        
        // æ·»åŠ åˆ°æ•°æ®åº“
        const id = await db.table('challengeDiscoveries').add(discovery);
        
        newDiscoveries.push({ ...discovery, id: id as number });
      }
    }
    
    return newDiscoveries;
  } catch (err) {
    console.error('Failed to discover new challenges:', err);
    return [];
  }
}

/**
 * è·å–æœªæŸ¥çœ‹çš„æŒ‘æˆ˜å‘ç°
 */
export async function getUnviewedDiscoveries(): Promise<ChallengeDiscovery[]> {
  return db.table('challengeDiscoveries')
    .where('userId')
    .equals('current-user') // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥æ˜¯å½“å‰ç”¨æˆ·çš„ID
    .and(discovery => !discovery.isViewed)
    .toArray();
}

/**
 * æ ‡è®°æŒ‘æˆ˜å‘ç°ä¸ºå·²æŸ¥çœ‹
 */
export async function markDiscoveryAsViewed(discoveryId: number): Promise<void> {
  await db.table('challengeDiscoveries').update(discoveryId, { isViewed: true });
}

/**
 * æ¥å—æŒ‘æˆ˜å‘ç°
 */
export async function acceptChallenge(discoveryId: number): Promise<void> {
  // è·å–å‘ç°è®°å½•
  const discovery = await db.table('challengeDiscoveries').get(discoveryId);
  if (!discovery) {
    throw new Error(`Challenge discovery with id ${discoveryId} not found`);
  }
  
  // è·å–æŒ‘æˆ˜
  const challenge = await db.table('challenges').get(discovery.challengeId);
  if (!challenge) {
    throw new Error(`Challenge with id ${discovery.challengeId} not found`);
  }
  
  // æ›´æ–°æŒ‘æˆ˜çŠ¶æ€ä¸ºæ´»è·ƒ
  await db.table('challenges').update(challenge.id!, {
    status: ChallengeStatus.ACTIVE,
    updatedAt: new Date()
  });
  
  // æ›´æ–°å‘ç°è®°å½•ä¸ºå·²æ¥å—
  await db.table('challengeDiscoveries').update(discoveryId, {
    isAccepted: true,
    isViewed: true
  });
}
</file>

<file path="src/services/challengeService.ts">
// src/services/challengeService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { generateRewardsForChallenge, RewardRecord } from './rewardService';
import { TaskRecord, TaskStatus } from './taskService';

// æŒ‘æˆ˜çŠ¶æ€æšä¸¾
export enum ChallengeStatus {
  ACTIVE = 'active',         // æ´»è·ƒä¸­
  COMPLETED = 'completed',   // å·²å®Œæˆ
  EXPIRED = 'expired',       // å·²è¿‡æœŸ
  UPCOMING = 'upcoming'      // å³å°†å¼€å§‹
}

// æŒ‘æˆ˜ç±»å‹æšä¸¾
export enum ChallengeType {
  DAILY = 'daily',           // æ¯æ—¥æŒ‘æˆ˜
  WEEKLY = 'weekly',         // æ¯å‘¨æŒ‘æˆ˜
  EVENT = 'event',           // æ´»åŠ¨æŒ‘æˆ˜
  ONGOING = 'ongoing'        // æŒç»­æ€§æŒ‘æˆ˜
}

// æŒ‘æˆ˜éš¾åº¦æšä¸¾
export enum ChallengeDifficulty {
  EASY = 'easy',             // ç®€å•
  MEDIUM = 'medium',         // ä¸­ç­‰
  HARD = 'hard',             // å›°éš¾
  EXPERT = 'expert'          // ä¸“å®¶
}

// æŒ‘æˆ˜è®°å½•ç±»å‹
export interface ChallengeRecord {
  id?: number;               // æŒ‘æˆ˜ID
  title: string;             // æŒ‘æˆ˜æ ‡é¢˜
  description: string;       // æŒ‘æˆ˜æè¿°
  type: ChallengeType;       // æŒ‘æˆ˜ç±»å‹
  difficulty: ChallengeDifficulty; // æŒ‘æˆ˜éš¾åº¦
  status: ChallengeStatus;   // æŒ‘æˆ˜çŠ¶æ€
  progress: number;          // è¿›åº¦ï¼ˆ0-100ï¼‰
  startDate: Date;           // å¼€å§‹æ—¥æœŸ
  endDate?: Date;            // ç»“æŸæ—¥æœŸï¼ˆå¯é€‰ï¼ŒæŒç»­æ€§æŒ‘æˆ˜å¯èƒ½æ²¡æœ‰ï¼‰
  completedDate?: Date;      // å®Œæˆæ—¥æœŸ
  taskIds: number[];         // å…³è”çš„ä»»åŠ¡IDåˆ—è¡¨
  rewardIds?: number[];      // å¥–åŠ±IDåˆ—è¡¨
  iconPath: string;          // å›¾æ ‡è·¯å¾„
  createdAt: Date;           // åˆ›å»ºæ—¶é—´
  updatedAt: Date;           // æ›´æ–°æ—¶é—´
}

// æŒ‘æˆ˜å®Œæˆè®°å½•ç±»å‹
export interface ChallengeCompletionRecord {
  id?: number;               // è®°å½•ID
  challengeId: number;       // æŒ‘æˆ˜ID
  userId: string;            // ç”¨æˆ·ID
  completedDate: Date;       // å®Œæˆæ—¥æœŸ
  rewardIds: number[];       // è·å¾—çš„å¥–åŠ±IDåˆ—è¡¨
  createdAt: Date;           // åˆ›å»ºæ—¶é—´
}

// é¢„å®šä¹‰çš„æŒ‘æˆ˜ç±»åˆ«
export const PREDEFINED_CHALLENGE_CATEGORIES = [
  {
    id: 1,
    name: 'å¥åº·ä¹ æƒ¯',
    description: 'åŸ¹å…»å¥åº·çš„ç”Ÿæ´»æ–¹å¼',
    iconPath: '/assets/challenges/health.svg'
  },
  {
    id: 2,
    name: 'å­¦ä¹ æˆé•¿',
    description: 'æå‡çŸ¥è¯†å’ŒæŠ€èƒ½',
    iconPath: '/assets/challenges/learning.svg'
  },
  {
    id: 3,
    name: 'å·¥ä½œæ•ˆç‡',
    description: 'æé«˜å·¥ä½œå’Œå­¦ä¹ æ•ˆç‡',
    iconPath: '/assets/challenges/productivity.svg'
  },
  {
    id: 4,
    name: 'å¿ƒçµæˆé•¿',
    description: 'åŸ¹å…»ç§¯æå¿ƒæ€å’Œæƒ…ç»ªç®¡ç†',
    iconPath: '/assets/challenges/mindfulness.svg'
  },
  {
    id: 5,
    name: 'ç¤¾äº¤å…³ç³»',
    description: 'æ”¹å–„äººé™…å…³ç³»å’Œç¤¾äº¤æŠ€èƒ½',
    iconPath: '/assets/challenges/social.svg'
  }
];

/**
 * åˆå§‹åŒ–æŒ‘æˆ˜ç±»åˆ«
 * å¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰æŒ‘æˆ˜ç±»åˆ«è®°å½•ï¼Œåˆ™æ·»åŠ é¢„å®šä¹‰çš„ç±»åˆ«
 */
export async function initializeChallengeCategories(): Promise<void> {
  try {
    const categories = await db.table('challengeCategories').toArray();

    if (categories.length === 0) {
      // é€ä¸ªæ·»åŠ ç±»åˆ«ï¼Œé¿å…æ‰¹é‡æ·»åŠ æ—¶çš„å†²çª
      for (const category of PREDEFINED_CHALLENGE_CATEGORIES) {
        try {
          // æ£€æŸ¥ç±»åˆ«æ˜¯å¦å·²å­˜åœ¨
          const existingCategory = await db.table('challengeCategories').get(category.id);
          if (!existingCategory) {
            await db.table('challengeCategories').add(category);
          }
        } catch (err) {
          console.warn(`Failed to add challenge category ${category.id}: ${err}`);
        }
      }
    }
  } catch (err) {
    console.error('Failed to initialize challenge categories:', err);
  }
}

/**
 * è·å–æ‰€æœ‰æŒ‘æˆ˜ç±»åˆ«
 */
export async function getAllChallengeCategories(): Promise<any[]> {
  return db.table('challengeCategories').toArray();
}

/**
 * è·å–æ‰€æœ‰æŒ‘æˆ˜
 * @param filter è¿‡æ»¤æ¡ä»¶
 */
export async function getAllChallenges(filter?: {
  status?: ChallengeStatus;
  type?: ChallengeType;
  difficulty?: ChallengeDifficulty;
}): Promise<ChallengeRecord[]> {
  let collection = db.table('challenges').toCollection();

  if (filter) {
    if (filter.status) {
      collection = collection.filter(challenge => challenge.status === filter.status);
    }
    if (filter.type) {
      collection = collection.filter(challenge => challenge.type === filter.type);
    }
    if (filter.difficulty) {
      collection = collection.filter(challenge => challenge.difficulty === filter.difficulty);
    }
  }

  return collection.toArray();
}

/**
 * è·å–å•ä¸ªæŒ‘æˆ˜
 * @param id æŒ‘æˆ˜ID
 */
export async function getChallenge(id: number): Promise<ChallengeRecord | undefined> {
  return db.table('challenges').get(id);
}

/**
 * åˆ›å»ºæ–°æŒ‘æˆ˜
 * @param challengeData æŒ‘æˆ˜æ•°æ®
 */
export async function createChallenge(
  challengeData: Omit<ChallengeRecord, 'id' | 'createdAt' | 'updatedAt' | 'status' | 'progress'>
): Promise<ChallengeRecord> {
  const now = new Date();

  const challenge: ChallengeRecord = {
    ...challengeData,
    status: ChallengeStatus.UPCOMING,
    progress: 0,
    createdAt: now,
    updatedAt: now
  };

  const id = await db.table('challenges').add(challenge);
  const newChallenge = { ...challenge, id: id as number };

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('challenges', 'create', newChallenge);

  return newChallenge;
}

/**
 * æ›´æ–°æŒ‘æˆ˜
 * @param id æŒ‘æˆ˜ID
 * @param challengeData æŒ‘æˆ˜æ•°æ®
 */
export async function updateChallenge(
  id: number,
  challengeData: Partial<ChallengeRecord>
): Promise<ChallengeRecord> {
  const challenge = await db.table('challenges').get(id);

  if (!challenge) {
    throw new Error(`Challenge with id ${id} not found`);
  }

  const updatedChallenge = {
    ...challenge,
    ...challengeData,
    updatedAt: new Date()
  };

  await db.table('challenges').update(id, updatedChallenge);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('challenges', 'update', updatedChallenge);

  return updatedChallenge;
}

/**
 * åˆ é™¤æŒ‘æˆ˜
 * @param id æŒ‘æˆ˜ID
 */
export async function deleteChallenge(id: number): Promise<void> {
  const challenge = await db.table('challenges').get(id);

  if (!challenge) {
    throw new Error(`Challenge with id ${id} not found`);
  }

  await db.table('challenges').delete(id);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('challenges', 'delete', { id });
}

/**
 * æ›´æ–°æŒ‘æˆ˜è¿›åº¦
 * @param id æŒ‘æˆ˜ID
 * @param progress è¿›åº¦å€¼ï¼ˆ0-100ï¼‰
 */
export async function updateChallengeProgress(id: number, progress: number): Promise<ChallengeRecord> {
  const challenge = await db.table('challenges').get(id);

  if (!challenge) {
    throw new Error(`Challenge with id ${id} not found`);
  }

  // ç¡®ä¿è¿›åº¦åœ¨0-100èŒƒå›´å†…
  const validProgress = Math.max(0, Math.min(100, progress));

  // å¦‚æœè¿›åº¦è¾¾åˆ°100%ï¼Œå°†çŠ¶æ€æ›´æ–°ä¸ºå·²å®Œæˆ
  let status = challenge.status;
  let completedDate = challenge.completedDate;

  if (validProgress >= 100 && status !== ChallengeStatus.COMPLETED) {
    status = ChallengeStatus.COMPLETED;
    completedDate = new Date();
  }

  const updatedChallenge = {
    ...challenge,
    progress: validProgress,
    status,
    completedDate,
    updatedAt: new Date()
  };

  await db.table('challenges').update(id, updatedChallenge);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('challenges', 'update', updatedChallenge);

  return updatedChallenge;
}

/**
 * å®ŒæˆæŒ‘æˆ˜
 * @param id æŒ‘æˆ˜ID
 */
export async function completeChallenge(id: number): Promise<RewardRecord[]> {
  const challenge = await db.table('challenges').get(id);

  if (!challenge) {
    throw new Error(`Challenge with id ${id} not found`);
  }

  if (challenge.status === ChallengeStatus.COMPLETED) {
    throw new Error(`Challenge with id ${id} is already completed`);
  }

  // æ›´æ–°æŒ‘æˆ˜çŠ¶æ€
  const updatedChallenge = {
    ...challenge,
    status: ChallengeStatus.COMPLETED,
    progress: 100,
    completedDate: new Date(),
    updatedAt: new Date()
  };

  await db.table('challenges').update(id, updatedChallenge);

  // ç”Ÿæˆå¥–åŠ±
  const rewards = await generateRewardsForChallenge(updatedChallenge);

  // åˆ›å»ºæŒ‘æˆ˜å®Œæˆè®°å½•
  const completionRecord: ChallengeCompletionRecord = {
    challengeId: id,
    userId: 'current-user', // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥æ˜¯å½“å‰ç”¨æˆ·çš„ID
    completedDate: new Date(),
    rewardIds: rewards.map(reward => reward.id!),
    createdAt: new Date()
  };

  await db.table('challengeCompletions').add(completionRecord);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('challenges', 'update', updatedChallenge);
  await addSyncItem('challengeCompletions', 'create', completionRecord);

  return rewards;
}

/**
 * è·å–æŒ‘æˆ˜å…³è”çš„ä»»åŠ¡
 * @param challengeId æŒ‘æˆ˜ID
 */
export async function getChallengeTasks(challengeId: number): Promise<TaskRecord[]> {
  const challenge = await db.table('challenges').get(challengeId);

  if (!challenge) {
    throw new Error(`Challenge with id ${challengeId} not found`);
  }

  if (!challenge.taskIds || challenge.taskIds.length === 0) {
    return [];
  }

  return db.table('tasks')
    .where('id')
    .anyOf(challenge.taskIds)
    .toArray();
}

/**
 * æ›´æ–°æŒ‘æˆ˜è¿›åº¦åŸºäºä»»åŠ¡å®Œæˆæƒ…å†µ
 * @param challengeId æŒ‘æˆ˜ID
 */
export async function updateChallengeProgressFromTasks(challengeId: number): Promise<ChallengeRecord> {
  const challenge = await db.table('challenges').get(challengeId);

  if (!challenge) {
    throw new Error(`Challenge with id ${challengeId} not found`);
  }

  if (!challenge.taskIds || challenge.taskIds.length === 0) {
    return challenge;
  }

  // è·å–æŒ‘æˆ˜å…³è”çš„æ‰€æœ‰ä»»åŠ¡
  const tasks = await getChallengeTasks(challengeId);

  // è®¡ç®—å·²å®Œæˆä»»åŠ¡çš„æ•°é‡
  const completedTasks = tasks.filter(task => task.status === TaskStatus.COMPLETED);

  // è®¡ç®—è¿›åº¦ç™¾åˆ†æ¯”
  const progress = Math.round((completedTasks.length / tasks.length) * 100);

  // æ›´æ–°æŒ‘æˆ˜è¿›åº¦
  return updateChallengeProgress(challengeId, progress);
}

/**
 * Generate test challenge data
 * Creates sample challenges for testing
 */
export async function generateTestChallengeData(): Promise<void> {
  try {
    // Check if challenges already exist
    const existingChallenges = await db.table('challenges').count();
    if (existingChallenges > 0) {
      console.log('Test challenge data already exists, skipping generation');
      return;
    }

    // Initialize challenge categories if needed
    await initializeChallengeCategories();

    // Sample challenge data
    const testChallenges: Omit<ChallengeRecord, 'id' | 'createdAt' | 'updatedAt'>[] = [
      // Active challenges
      {
        title: 'Morning Meditation',
        description: 'Complete a 10-minute meditation session every morning for 7 days to improve focus and mindfulness.',
        type: ChallengeType.DAILY,
        difficulty: ChallengeDifficulty.EASY,
        status: ChallengeStatus.ACTIVE,
        progress: 57,
        startDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000), // 3 days ago
        endDate: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000),   // 4 days from now
        taskIds: [],
        iconPath: '/assets/challenges/meditation.svg'
      },
      {
        title: 'Productivity Sprint',
        description: 'Complete 20 high-priority tasks within 5 days to boost your productivity and task management skills.',
        type: ChallengeType.WEEKLY,
        difficulty: ChallengeDifficulty.MEDIUM,
        status: ChallengeStatus.ACTIVE,
        progress: 35,
        startDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000), // 2 days ago
        endDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),   // 5 days from now
        taskIds: [],
        iconPath: '/assets/challenges/productivity.svg'
      },
      {
        title: 'Healthy Eating Challenge',
        description: 'Prepare and eat healthy meals for 14 days straight. Track your nutrition and avoid processed foods.',
        type: ChallengeType.ONGOING,
        difficulty: ChallengeDifficulty.HARD,
        status: ChallengeStatus.ACTIVE,
        progress: 21,
        startDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000), // 3 days ago
        endDate: new Date(Date.now() + 11 * 24 * 60 * 60 * 1000),  // 11 days from now
        taskIds: [],
        iconPath: '/assets/challenges/health.svg'
      },

      // Completed challenges
      {
        title: 'Reading Marathon',
        description: 'Read for at least 30 minutes every day for a week to develop a reading habit.',
        type: ChallengeType.WEEKLY,
        difficulty: ChallengeDifficulty.EASY,
        status: ChallengeStatus.COMPLETED,
        progress: 100,
        startDate: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000), // 14 days ago
        endDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),     // 7 days ago
        completedDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
        taskIds: [],
        iconPath: '/assets/challenges/learning.svg'
      },
      {
        title: 'Coding Project',
        description: 'Complete a personal coding project within 10 days to improve your programming skills.',
        type: ChallengeType.EVENT,
        difficulty: ChallengeDifficulty.HARD,
        status: ChallengeStatus.COMPLETED,
        progress: 100,
        startDate: new Date(Date.now() - 20 * 24 * 60 * 60 * 1000), // 20 days ago
        endDate: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000),   // 10 days ago
        completedDate: new Date(Date.now() - 11 * 24 * 60 * 60 * 1000),
        taskIds: [],
        iconPath: '/assets/challenges/learning.svg'
      },

      // Upcoming challenges
      {
        title: 'Fitness Challenge',
        description: 'Exercise for at least 30 minutes every day for 21 days to build a fitness habit.',
        type: ChallengeType.ONGOING,
        difficulty: ChallengeDifficulty.MEDIUM,
        status: ChallengeStatus.UPCOMING,
        progress: 0,
        startDate: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000),  // 2 days from now
        endDate: new Date(Date.now() + 23 * 24 * 60 * 60 * 1000),   // 23 days from now
        taskIds: [],
        iconPath: '/assets/challenges/health.svg'
      },
      {
        title: 'Language Learning Sprint',
        description: 'Practice a new language for 15 minutes daily for 30 days to build vocabulary and fluency.',
        type: ChallengeType.EVENT,
        difficulty: ChallengeDifficulty.EXPERT,
        status: ChallengeStatus.UPCOMING,
        progress: 0,
        startDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),  // 5 days from now
        endDate: new Date(Date.now() + 35 * 24 * 60 * 60 * 1000),   // 35 days from now
        taskIds: [],
        iconPath: '/assets/challenges/learning.svg'
      }
    ];

    // Add challenges to database
    const now = new Date();
    for (const challenge of testChallenges) {
      const challengeWithDates = {
        ...challenge,
        createdAt: now,
        updatedAt: now
      };
      await db.table('challenges').add(challengeWithDates);
    }

    console.log('Test challenge data generated successfully');
  } catch (error) {
    console.error('Error generating test challenge data:', error);
  }
}
</file>

<file path="src/services/dataSyncService.ts">
// src/services/dataSyncService.ts
import { db } from '@/db';
import { queryClient } from '@/services/queryClient';

// åŒæ­¥çŠ¶æ€æšä¸¾
export enum SyncStatus {
  IDLE = 'idle',
  SYNCING = 'syncing',
  SUCCESS = 'success',
  ERROR = 'error'
}

// åŒæ­¥é¡¹ç›®ç±»å‹
export interface SyncItem {
  id: string;
  table: string;
  action: 'create' | 'update' | 'delete';
  data: any;
  timestamp: Date;
  retryCount: number;
  status: SyncStatus;
  error?: string;
}

// åŒæ­¥é…ç½®
interface SyncConfig {
  autoSyncInterval: number; // è‡ªåŠ¨åŒæ­¥é—´éš”ï¼ˆæ¯«ç§’ï¼‰
  maxRetryCount: number; // æœ€å¤§é‡è¯•æ¬¡æ•°
  batchSize: number; // æ‰¹é‡åŒæ­¥å¤§å°
}

// é»˜è®¤åŒæ­¥é…ç½®
const DEFAULT_SYNC_CONFIG: SyncConfig = {
  autoSyncInterval: 60000, // 1åˆ†é’Ÿ
  maxRetryCount: 3,
  batchSize: 10
};

// å½“å‰åŒæ­¥çŠ¶æ€
let currentSyncStatus: SyncStatus = SyncStatus.IDLE;
let syncConfig: SyncConfig = DEFAULT_SYNC_CONFIG;
let autoSyncInterval: NodeJS.Timeout | null = null;

/**
 * åˆå§‹åŒ–æ•°æ®åŒæ­¥æœåŠ¡
 * @param config åŒæ­¥é…ç½®
 */
export function initializeDataSync(config: Partial<SyncConfig> = {}): void {
  // åˆå¹¶é…ç½®
  syncConfig = { ...DEFAULT_SYNC_CONFIG, ...config };

  // å¯åŠ¨è‡ªåŠ¨åŒæ­¥
  startAutoSync();

  console.log('Data sync service initialized');
}

/**
 * å¯åŠ¨è‡ªåŠ¨åŒæ­¥
 */
function startAutoSync(): void {
  if (autoSyncInterval) {
    clearInterval(autoSyncInterval);
  }

  autoSyncInterval = setInterval(() => {
    syncPendingItems().catch(err => {
      console.error('Auto sync failed:', err);
    });
  }, syncConfig.autoSyncInterval);
}

/**
 * åœæ­¢è‡ªåŠ¨åŒæ­¥
 */
export function stopAutoSync(): void {
  if (autoSyncInterval) {
    clearInterval(autoSyncInterval);
    autoSyncInterval = null;
  }
}

/**
 * æ·»åŠ åŒæ­¥é¡¹ç›®
 * @param table è¡¨å
 * @param action æ“ä½œç±»å‹
 * @param data æ•°æ®
 */
export async function addSyncItem(
  table: string,
  action: 'create' | 'update' | 'delete',
  data: any
): Promise<void> {
  try {
    // æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
    if (!db.tables.some(t => t.name === 'syncQueue')) {
      console.warn('syncQueue table does not exist yet, creating it');
      // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥åˆ›å»ºè¡¨æˆ–é‡æ–°åˆå§‹åŒ–æ•°æ®åº“
      // ä½†åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬åªæ˜¯è®°å½•è­¦å‘Šå¹¶è¿”å›
      return;
    }

    // æ£€æŸ¥æ•°æ®æ˜¯å¦æœ‰æ•ˆ
    if (!data || !data.id) {
      console.warn('Invalid data for sync item, skipping', data);
      return;
    }

    const syncItem: SyncItem = {
      id: `${table}_${data.id}_${Date.now()}`,
      table,
      action,
      data,
      timestamp: new Date(),
      retryCount: 0,
      status: SyncStatus.IDLE
    };

    // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
    await db.table('syncQueue').add(syncItem);

    // è§¦å‘è‡ªå®šä¹‰äº‹ä»¶ï¼Œé€šçŸ¥åŒæ­¥çŠ¶æ€æŒ‡ç¤ºå™¨æ›´æ–°
    try {
      const syncEvent = new CustomEvent('syncItemAdded', { detail: syncItem });
      window.dispatchEvent(syncEvent);
    } catch (eventErr) {
      console.error('Failed to dispatch sync event:', eventErr);
    }

    console.log(`Sync item added: ${table} ${action}`, data.id);

    // å¦‚æœæ˜¯åœ¨çº¿çŠ¶æ€ï¼Œç«‹å³å°è¯•åŒæ­¥
    if (navigator.onLine) {
      syncPendingItems().catch(err => {
        console.error('Sync failed:', err);
      });
    }
  } catch (err) {
    console.error('Failed to add sync item:', err);
  }
}

/**
 * åŒæ­¥å¾…å¤„ç†é¡¹ç›®
 */
export async function syncPendingItems(): Promise<void> {
  // å¦‚æœå·²ç»åœ¨åŒæ­¥ä¸­ï¼Œåˆ™è·³è¿‡
  if (currentSyncStatus === SyncStatus.SYNCING) {
    return;
  }

  // å¦‚æœç¦»çº¿ï¼Œåˆ™è·³è¿‡
  if (!navigator.onLine) {
    return;
  }

  // æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
  try {
    if (!db.tables.some(table => table.name === 'syncQueue')) {
      console.warn('syncQueue table does not exist yet');
      return;
    }
  } catch (err) {
    console.error('Error checking syncQueue table:', err);
    return;
  }

  try {
    // æ›´æ–°åŒæ­¥çŠ¶æ€å¹¶è§¦å‘äº‹ä»¶
    currentSyncStatus = SyncStatus.SYNCING;
    const syncEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
    window.dispatchEvent(syncEvent);

    console.log('Sync started');

    // è·å–å¾…å¤„ç†é¡¹ç›®
    const pendingItems = await db.table('syncQueue')
      .where('status')
      .equals(SyncStatus.IDLE)
      .or('status')
      .equals(SyncStatus.ERROR)
      .filter(item => item.retryCount < syncConfig.maxRetryCount)
      .limit(syncConfig.batchSize)
      .toArray();

    if (pendingItems.length === 0) {
      currentSyncStatus = SyncStatus.IDLE;
      const syncCompleteEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
      window.dispatchEvent(syncCompleteEvent);
      console.log('No pending items to sync');
      return;
    }

    console.log(`Found ${pendingItems.length} items to sync`);

    // æ‰¹é‡å¤„ç†é¡¹ç›®
    for (const item of pendingItems) {
      try {
        // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥è°ƒç”¨APIè¿›è¡ŒåŒæ­¥
        // è¿™é‡Œåªæ˜¯æ¨¡æ‹ŸåŒæ­¥æˆåŠŸ
        await simulateSyncItem(item);

        // æ›´æ–°é¡¹ç›®çŠ¶æ€
        await db.table('syncQueue').update(item.id, {
          status: SyncStatus.SUCCESS
        });

        // æ›´æ–°ç¼“å­˜ï¼Œä¼ é€’æ•°æ®
        invalidateRelatedQueries(item.table, item.data);
      } catch (err) {
        console.error(`Sync item ${item.id} failed:`, err);

        // æ›´æ–°é‡è¯•æ¬¡æ•°å’ŒçŠ¶æ€
        await db.table('syncQueue').update(item.id, {
          retryCount: item.retryCount + 1,
          status: SyncStatus.ERROR,
          error: err instanceof Error ? err.message : String(err)
        });
      }
    }

    // æ¸…ç†å·²æˆåŠŸçš„é¡¹ç›®
    await db.table('syncQueue')
      .where('status')
      .equals(SyncStatus.SUCCESS)
      .delete();

    // æ›´æ–°åŒæ­¥çŠ¶æ€å¹¶è§¦å‘äº‹ä»¶
    currentSyncStatus = SyncStatus.SUCCESS;
    const syncSuccessEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
    window.dispatchEvent(syncSuccessEvent);

    console.log('Sync completed successfully');

    // 2ç§’åé‡ç½®çŠ¶æ€ä¸ºç©ºé—²
    setTimeout(() => {
      currentSyncStatus = SyncStatus.IDLE;
      const resetEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
      window.dispatchEvent(resetEvent);
    }, 2000);
  } catch (err) {
    console.error('Sync failed:', err);
    currentSyncStatus = SyncStatus.ERROR;

    // è§¦å‘é”™è¯¯äº‹ä»¶
    const syncErrorEvent = new CustomEvent('syncStatusChanged', { detail: currentSyncStatus });
    window.dispatchEvent(syncErrorEvent);
  }
}

/**
 * æ¨¡æ‹ŸåŒæ­¥é¡¹ç›®ï¼ˆå®é™…åº”ç”¨ä¸­åº”æ›¿æ¢ä¸ºçœŸå®APIè°ƒç”¨ï¼‰
 */
async function simulateSyncItem(item: SyncItem): Promise<void> {
  // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
  await new Promise(resolve => setTimeout(resolve, 500));

  // æ¨¡æ‹ŸåŒæ­¥æˆåŠŸ
  console.log(`Simulated sync for item ${item.id}:`, item);
}

/**
 * ä½¿ç›¸å…³æŸ¥è¯¢ç¼“å­˜å¤±æ•ˆ
 * @param table è¡¨å
 * @param data æ•°æ®
 */
function invalidateRelatedQueries(table: string, data?: any): void {
  // è§¦å‘è‡ªå®šä¹‰äº‹ä»¶ï¼Œé€šçŸ¥ç»„ä»¶åˆ·æ–°
  // è¿™å°†é€šè¿‡ DataRefreshProvider ä¼ æ’­åˆ°æ‰€æœ‰ä½¿ç”¨ useDataRefresh å’Œ useTableRefresh çš„ç»„ä»¶
  const refreshEvent = new CustomEvent('dataRefresh', {
    detail: { table, data }
  });
  window.dispatchEvent(refreshEvent);

  // æ ¹æ®è¡¨åä½¿ç›¸å…³æŸ¥è¯¢ç¼“å­˜å¤±æ•ˆ
  switch (table) {
    case 'tasks':
      // å¦‚æœæœ‰ç‰¹å®šä»»åŠ¡IDï¼Œåªä½¿è¯¥ä»»åŠ¡çš„ç¼“å­˜å¤±æ•ˆ
      if (data && data.id) {
        queryClient.invalidateQueries({
          queryKey: ['tasks', data.id],
          exact: true
        });
        // åŒæ—¶ä½¿ä»»åŠ¡åˆ—è¡¨ç¼“å­˜å¤±æ•ˆï¼Œä½†ä¸é‡æ–°è·å–æ•°æ®
        queryClient.invalidateQueries({
          queryKey: ['tasks'],
          exact: true,
          refetchType: 'none'
        });
      } else {
        // å¦åˆ™ä½¿æ‰€æœ‰ä»»åŠ¡ç¼“å­˜å¤±æ•ˆ
        queryClient.invalidateQueries({ queryKey: ['tasks'] });
      }
      break;
    case 'pandaState':
      queryClient.invalidateQueries({ queryKey: ['pandaState'] });
      break;
    case 'abilities':
      queryClient.invalidateQueries({ queryKey: ['abilities'] });
      break;
    case 'rewards':
      queryClient.invalidateQueries({ queryKey: ['rewards'] });
      break;
    default:
      // é»˜è®¤ä½¿æ‰€æœ‰æŸ¥è¯¢ç¼“å­˜å¤±æ•ˆï¼Œä½†ä¸é‡æ–°è·å–æ•°æ®
      queryClient.invalidateQueries({
        refetchType: 'none'
      });
  }
}

/**
 * è·å–å½“å‰åŒæ­¥çŠ¶æ€
 */
export function getCurrentSyncStatus(): SyncStatus {
  return currentSyncStatus;
}

/**
 * è·å–å¾…åŒæ­¥é¡¹ç›®æ•°é‡
 */
export async function getPendingSyncCount(): Promise<number> {
  try {
    // æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
    if (!db.tables.some(table => table.name === 'syncQueue')) {
      console.warn('syncQueue table does not exist yet');
      return 0;
    }

    return db.table('syncQueue')
      .where('status')
      .equals(SyncStatus.IDLE)
      .or('status')
      .equals(SyncStatus.ERROR)
      .count();
  } catch (err) {
    console.error('Error getting pending sync count:', err);
    return 0;
  }
}

/**
 * æ‰‹åŠ¨è§¦å‘åŒæ­¥
 */
export async function manualSync(): Promise<void> {
  return syncPendingItems();
}
</file>

<file path="src/services/index.ts">
// src/services/index.ts
export * from './localizedContentService';
</file>

<file path="src/services/pandaAbilityService.ts">
// src/services/pandaAbilityService.ts
import { db } from '@/db';
import { RewardRarity } from './rewardService';

// Panda ability type enum
export enum AbilityType {
  PASSIVE = 'passive',   // Passive ability (permanent effect)
  ACTIVE = 'active',     // Active ability (needs activation)
  ULTIMATE = 'ultimate'  // Ultimate ability (powerful but with cooldown)
}

// Panda ability effect type enum
export enum AbilityEffectType {
  EXPERIENCE_BOOST = 'experience_boost',       // Experience boost
  ENERGY_BOOST = 'energy_boost',               // Energy boost
  TASK_EFFICIENCY = 'task_efficiency',         // Task efficiency boost
  REWARD_BOOST = 'reward_boost',               // Reward boost
  MOOD_STABILIZER = 'mood_stabilizer',         // Mood stabilizer
  TIME_EXTENSION = 'time_extension',           // Time extension
  FOCUS_ENHANCEMENT = 'focus_enhancement',     // Focus enhancement
  INSPIRATION = 'inspiration',                 // Inspiration
  RESILIENCE = 'resilience',                   // Resilience
  WISDOM = 'wisdom'                            // Wisdom
}

// Panda ability record type
export interface PandaAbilityRecord {
  id?: number;
  name: string;
  description: string;
  type: AbilityType;
  effectType: AbilityEffectType;
  effectValue: number;
  iconPath: string;
  rarity: RewardRarity;
  requiredLevel: number;
  isUnlocked: boolean;
  isActive: boolean;
  cooldownMinutes?: number;
  lastUsedAt?: Date;
  unlockDate?: Date;
}

// Predefined panda abilities list
const PREDEFINED_ABILITIES: PandaAbilityRecord[] = [
  // Passive abilities - Basic
  {
    name: 'Bamboo Heart',
    description: 'Passive: Increases experience gained from completing tasks by 10%',
    type: AbilityType.PASSIVE,
    effectType: AbilityEffectType.EXPERIENCE_BOOST,
    effectValue: 0.1,
    iconPath: '/assets/abilities/bamboo-heart.svg',
    rarity: RewardRarity.COMMON,
    requiredLevel: 2,
    isUnlocked: false,
    isActive: false
  },
  {
    name: 'Panda Vitality',
    description: 'Passive: Increases panda energy recovery rate by 15%',
    type: AbilityType.PASSIVE,
    effectType: AbilityEffectType.ENERGY_BOOST,
    effectValue: 0.15,
    iconPath: '/assets/abilities/panda-vitality.svg',
    rarity: RewardRarity.COMMON,
    requiredLevel: 3,
    isUnlocked: false,
    isActive: false
  },

  // Active abilities - Intermediate
  {
    name: 'Bamboo Focus',
    description: 'Active: When activated, increases experience gained from completing tasks by 25% for 1 hour',
    type: AbilityType.ACTIVE,
    effectType: AbilityEffectType.FOCUS_ENHANCEMENT,
    effectValue: 0.25,
    iconPath: '/assets/abilities/bamboo-focus.svg',
    rarity: RewardRarity.UNCOMMON,
    requiredLevel: 5,
    isUnlocked: false,
    isActive: false,
    cooldownMinutes: 120
  },
  {
    name: 'Panda Wisdom',
    description: 'Active: When activated, increases rewards from completed tasks by 20% for 2 hours',
    type: AbilityType.ACTIVE,
    effectType: AbilityEffectType.REWARD_BOOST,
    effectValue: 0.2,
    iconPath: '/assets/abilities/panda-wisdom.svg',
    rarity: RewardRarity.UNCOMMON,
    requiredLevel: 7,
    isUnlocked: false,
    isActive: false,
    cooldownMinutes: 240
  },

  // Ultimate abilities - Advanced
  {
    name: 'Bamboo Master',
    description: 'Ultimate: When activated, increases all ability effects by 50% for 4 hours',
    type: AbilityType.ULTIMATE,
    effectType: AbilityEffectType.WISDOM,
    effectValue: 0.5,
    iconPath: '/assets/abilities/bamboo-master.svg',
    rarity: RewardRarity.RARE,
    requiredLevel: 10,
    isUnlocked: false,
    isActive: false,
    cooldownMinutes: 1440 // 24 hours
  }
];

/**
 * Initialize panda abilities system
 * If there are no ability records in the database, add predefined abilities
 */
export async function initializePandaAbilities(): Promise<void> {
  const abilities = await db.table('abilities').toArray();

  if (abilities.length === 0) {
    await db.table('abilities').bulkAdd(PREDEFINED_ABILITIES);
  }
}

/**
 * Get all panda abilities
 */
export async function getAllPandaAbilities(): Promise<PandaAbilityRecord[]> {
  return db.table('abilities').toArray();
}

/**
 * Get unlocked panda abilities
 */
export async function getUnlockedPandaAbilities(): Promise<PandaAbilityRecord[]> {
  try {
    // Check if table exists
    if (!db.tables.some(table => table.name === 'abilities')) {
      console.warn('abilities table does not exist yet');
      // Initialize abilities system
      await initializePandaAbilities();
    }

    // Try to get all abilities, then filter in memory
    try {
      const allAbilities = await db.table('abilities').toArray();
      // Ensure the result is an array and each element has the correct properties
      return allAbilities
        .filter(ability => ability && typeof ability === 'object')
        .filter(ability => ability.isUnlocked === true);
    } catch (err) {
      console.error('Error querying unlocked abilities:', err);
      // If query fails, return empty array
      return [];
    }
  } catch (err) {
    console.error('Error in getUnlockedPandaAbilities:', err);
    return [];
  }
}

/**
 * Get available panda abilities (unlocked and not on cooldown)
 */
export async function getAvailablePandaAbilities(): Promise<PandaAbilityRecord[]> {
  const now = new Date();
  const unlockedAbilities = await getUnlockedPandaAbilities();

  return unlockedAbilities.filter(ability => {
    // Passive abilities are always available
    if (ability.type === AbilityType.PASSIVE) {
      return true;
    }

    // Active or ultimate abilities need to check cooldown time
    if (ability.lastUsedAt && ability.cooldownMinutes) {
      const cooldownEndTime = new Date(ability.lastUsedAt);
      cooldownEndTime.setMinutes(cooldownEndTime.getMinutes() + ability.cooldownMinutes);

      return now >= cooldownEndTime;
    }

    return true;
  });
}

/**
 * Check and unlock panda abilities
 * Unlock abilities based on the current panda level
 * @param currentLevel Current panda level
 */
export async function checkAndUnlockAbilities(currentLevel: number): Promise<PandaAbilityRecord[]> {
  const abilities = await getAllPandaAbilities();
  const newlyUnlocked: PandaAbilityRecord[] = [];

  for (const ability of abilities) {
    if (!ability.isUnlocked && ability.requiredLevel <= currentLevel) {
      // Unlock ability
      const now = new Date();
      await db.table('abilities').update(ability.id!, {
        isUnlocked: true,
        unlockDate: now
      });

      // Add to newly unlocked list
      newlyUnlocked.push({
        ...ability,
        isUnlocked: true,
        unlockDate: now
      });
    }
  }

  return newlyUnlocked;
}

/**
 * Activate panda ability
 * @param abilityId ID of the ability to activate
 */
export async function activateAbility(abilityId: number): Promise<PandaAbilityRecord> {
  const ability = await db.table('abilities').get(abilityId);

  if (!ability) {
    throw new Error(`Ability with id ${abilityId} not found`);
  }

  if (!ability.isUnlocked) {
    throw new Error(`Ability with id ${abilityId} is not unlocked yet`);
  }

  // Passive abilities don't need activation
  if (ability.type === AbilityType.PASSIVE) {
    return ability;
  }

  // Check cooldown time
  if (ability.lastUsedAt && ability.cooldownMinutes) {
    const now = new Date();
    const cooldownEndTime = new Date(ability.lastUsedAt);
    cooldownEndTime.setMinutes(cooldownEndTime.getMinutes() + ability.cooldownMinutes);

    if (now < cooldownEndTime) {
      throw new Error(`Ability with id ${abilityId} is still in cooldown`);
    }
  }

  // Activate ability
  const now = new Date();
  const updatedAbility = {
    ...ability,
    isActive: true,
    lastUsedAt: now
  };

  await db.table('abilities').update(abilityId, updatedAbility);
  return updatedAbility;
}

/**
 * Get ability effect description
 * @param effectType Ability effect type
 */
export function getAbilityEffectDescription(effectType: AbilityEffectType): string {
  switch (effectType) {
    case AbilityEffectType.EXPERIENCE_BOOST:
      return 'Experience Boost';
    case AbilityEffectType.ENERGY_BOOST:
      return 'Energy Boost';
    case AbilityEffectType.TASK_EFFICIENCY:
      return 'Task Efficiency Boost';
    case AbilityEffectType.REWARD_BOOST:
      return 'Reward Boost';
    case AbilityEffectType.MOOD_STABILIZER:
      return 'Mood Stabilizer';
    case AbilityEffectType.TIME_EXTENSION:
      return 'Time Extension';
    case AbilityEffectType.FOCUS_ENHANCEMENT:
      return 'Focus Enhancement';
    case AbilityEffectType.INSPIRATION:
      return 'Inspiration';
    case AbilityEffectType.RESILIENCE:
      return 'Resilience';
    case AbilityEffectType.WISDOM:
      return 'Wisdom';
    default:
      return 'Unknown Effect';
  }
}

/**
 * Get localized ability name
 * @param abilityKey The key of the ability (e.g., 'bambooHeart')
 * @param defaultName Default name to use if localized name is not found
 */
export async function getLocalizedAbilityName(abilityKey: string, defaultName: string): Promise<string> {
  const languageCode = localStorage.getItem('language') || 'en';
  try {
    // Query the database directly
    const label = await db.table('uiLabels')
      .where('[scopeKey+labelKey+languageCode]')
      .equals(['abilities', `${abilityKey}.name`, languageCode])
      .first();

    return label ? label.translatedText : defaultName;
  } catch (error) {
    console.error(`Error getting localized name for ability ${abilityKey}:`, error);
    return defaultName;
  }
}

/**
 * Get localized ability description
 * @param abilityKey The key of the ability (e.g., 'bambooHeart')
 * @param defaultDescription Default description to use if localized description is not found
 */
export async function getLocalizedAbilityDescription(abilityKey: string, defaultDescription: string): Promise<string> {
  const languageCode = localStorage.getItem('language') || 'en';
  try {
    // Query the database directly
    const label = await db.table('uiLabels')
      .where('[scopeKey+labelKey+languageCode]')
      .equals(['abilities', `${abilityKey}.description`, languageCode])
      .first();

    return label ? label.translatedText : defaultDescription;
  } catch (error) {
    console.error(`Error getting localized description for ability ${abilityKey}:`, error);
    return defaultDescription;
  }
}

/**
 * Get ability key from name
 * @param name The name of the ability
 */
export function getAbilityKeyFromName(name: string): string {
  const nameMap: Record<string, string> = {
    'Bamboo Heart': 'bambooHeart',
    'Panda Vitality': 'pandaVitality',
    'Bamboo Focus': 'bambooFocus',
    'Panda Wisdom': 'pandaWisdom',
    'Bamboo Master': 'bambooMaster',
    'ç«¹æ—ä¹‹å¿ƒ': 'bambooHeart',
    'ç†ŠçŒ«æ´»åŠ›': 'pandaVitality',
    'ç«¹å½±ä¸“æ³¨': 'bambooFocus',
    'ç†ŠçŒ«æ™ºæ…§': 'pandaWisdom',
    'ç«¹æ—å¤§å¸ˆ': 'bambooMaster'
  };

  return nameMap[name] || '';
}
</file>

<file path="src/services/pandaCustomizationService.ts">
// src/services/pandaCustomizationService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { StoreItemType } from './storeService';

// ç†ŠçŒ«è£…é¥°ç±»å‹
export enum PandaAccessoryType {
  HAT = 'hat',               // å¸½å­
  GLASSES = 'glasses',       // çœ¼é•œ
  SCARF = 'scarf',           // å›´å·¾
  PENDANT = 'pendant',       // æŒ‚é¥°
  BACKGROUND = 'background', // èƒŒæ™¯
  FRAME = 'frame',           // è¾¹æ¡†
  EFFECT = 'effect'          // ç‰¹æ•ˆ
}

// ç†ŠçŒ«è£…é¥°è®°å½•ç±»å‹
export interface PandaAccessoryRecord {
  id?: number;
  name: string;
  type: PandaAccessoryType;
  description: string;
  imagePath: string;
  overlayPath?: string; // å åŠ å›¾å±‚è·¯å¾„
  isEquipped: boolean;
  isOwned: boolean;
  obtainedAt?: Date;
  storeItemId?: number;
  rarity: string;
  themeType: string; // ä¸­å›½é£ä¸»é¢˜ç±»å‹ï¼šä¼ ç»Ÿã€ç°ä»£ã€èŠ‚æ—¥ç­‰
}

// ç†ŠçŒ«ç¯å¢ƒè®°å½•ç±»å‹
export interface PandaEnvironmentRecord {
  id?: number;
  name: string;
  description: string;
  backgroundPath: string;
  foregroundPath?: string;
  ambientSound?: string;
  isActive: boolean;
  isOwned: boolean;
  obtainedAt?: Date;
  storeItemId?: number;
  rarity: string;
  themeType: string; // ä¸­å›½é£ä¸»é¢˜ç±»å‹ï¼šå›­æ—ã€å±±æ°´ã€ç«¹æ—ç­‰
  interactiveElements?: PandaEnvironmentElement[];
}

// ç¯å¢ƒäº’åŠ¨å…ƒç´ ç±»å‹
export interface PandaEnvironmentElement {
  id: string;
  name: string;
  type: string;
  position: { x: number; y: number };
  size: { width: number; height: number };
  imagePath: string;
  animationPath?: string;
  interactionType: 'click' | 'hover' | 'drag';
  interactionEffect: string;
  soundEffect?: string;
}

// é»˜è®¤ç†ŠçŒ«è£…é¥°
const DEFAULT_ACCESSORIES: PandaAccessoryRecord[] = [
  {
    name: 'ç«¹å¶å¸½',
    type: PandaAccessoryType.HAT,
    description: 'ç”¨ç«¹å¶ç¼–ç»‡çš„ç®€å•å¸½å­ï¼Œæ¸…æ–°è‡ªç„¶',
    imagePath: '/assets/accessories/bamboo-hat.svg',
    isEquipped: false,
    isOwned: true,
    obtainedAt: new Date(),
    rarity: 'common',
    themeType: 'ä¼ ç»Ÿ'
  },
  {
    name: 'çº¢ä¸å¸¦',
    type: PandaAccessoryType.SCARF,
    description: 'è±¡å¾å¥½è¿çš„çº¢ä¸å¸¦ï¼Œä¸ºç†ŠçŒ«å¸¦æ¥å–œæ°”',
    imagePath: '/assets/accessories/red-ribbon.svg',
    isEquipped: false,
    isOwned: true,
    obtainedAt: new Date(),
    rarity: 'common',
    themeType: 'ä¼ ç»Ÿ'
  },
  {
    name: 'é‡‘æ¡†',
    type: PandaAccessoryType.FRAME,
    description: 'åä¸½çš„é‡‘è‰²è¾¹æ¡†ï¼Œå½°æ˜¾å°Šè´µ',
    imagePath: '/assets/accessories/gold-frame.svg',
    isEquipped: false,
    isOwned: true,
    obtainedAt: new Date(),
    rarity: 'rare',
    themeType: 'ä¼ ç»Ÿ'
  }
];

// é»˜è®¤ç†ŠçŒ«ç¯å¢ƒ
const DEFAULT_ENVIRONMENTS: PandaEnvironmentRecord[] = [
  {
    name: 'ç«¹æ—å°å¾„',
    description: 'å®é™çš„ç«¹æ—å°å¾„ï¼Œç†ŠçŒ«çš„æœ€çˆ±',
    backgroundPath: '/assets/environments/bamboo-path.svg',
    ambientSound: '/assets/sounds/bamboo-forest.mp3',
    isActive: true,
    isOwned: true,
    obtainedAt: new Date(),
    rarity: 'common',
    themeType: 'ç«¹æ—',
    interactiveElements: [
      {
        id: 'bamboo1',
        name: 'ç«¹å­',
        type: 'plant',
        position: { x: 20, y: 50 },
        size: { width: 30, height: 100 },
        imagePath: '/assets/environments/elements/bamboo.svg',
        animationPath: '/assets/environments/animations/bamboo-sway.json',
        interactionType: 'click',
        interactionEffect: 'sway',
        soundEffect: '/assets/sounds/bamboo-rustle.mp3'
      },
      {
        id: 'butterfly1',
        name: 'è´è¶',
        type: 'animal',
        position: { x: 70, y: 30 },
        size: { width: 20, height: 20 },
        imagePath: '/assets/environments/elements/butterfly.svg',
        animationPath: '/assets/environments/animations/butterfly-flutter.json',
        interactionType: 'hover',
        interactionEffect: 'flutter',
        soundEffect: '/assets/sounds/butterfly-wings.mp3'
      }
    ]
  },
  {
    name: 'ä¸­å¼å›­æ—',
    description: 'ç²¾è‡´çš„ä¸­å¼å›­æ—ï¼Œäº­å°æ¥¼é˜ï¼Œå±±æ°´ç›¸ä¾',
    backgroundPath: '/assets/environments/chinese-garden.svg',
    ambientSound: '/assets/sounds/garden-birds.mp3',
    isActive: false,
    isOwned: true,
    obtainedAt: new Date(),
    rarity: 'uncommon',
    themeType: 'å›­æ—',
    interactiveElements: [
      {
        id: 'pavilion1',
        name: 'äº­å­',
        type: 'structure',
        position: { x: 60, y: 40 },
        size: { width: 50, height: 60 },
        imagePath: '/assets/environments/elements/pavilion.svg',
        interactionType: 'click',
        interactionEffect: 'glow',
        soundEffect: '/assets/sounds/wind-chimes.mp3'
      },
      {
        id: 'koi1',
        name: 'é”¦é²¤',
        type: 'animal',
        position: { x: 30, y: 70 },
        size: { width: 25, height: 15 },
        imagePath: '/assets/environments/elements/koi.svg',
        animationPath: '/assets/environments/animations/koi-swim.json',
        interactionType: 'hover',
        interactionEffect: 'swim',
        soundEffect: '/assets/sounds/water-splash.mp3'
      }
    ]
  }
];

/**
 * åˆå§‹åŒ–ç†ŠçŒ«å®šåˆ¶ç³»ç»Ÿ
 */
export async function initializePandaCustomization(): Promise<void> {
  // æ£€æŸ¥è£…é¥°æ˜¯å¦å·²åˆå§‹åŒ–
  const accessories = await db.table('pandaAccessories').toArray();
  if (accessories.length === 0) {
    await db.table('pandaAccessories').bulkAdd(DEFAULT_ACCESSORIES);
  }

  // æ£€æŸ¥ç¯å¢ƒæ˜¯å¦å·²åˆå§‹åŒ–
  const environments = await db.table('pandaEnvironments').toArray();
  if (environments.length === 0) {
    await db.table('pandaEnvironments').bulkAdd(DEFAULT_ENVIRONMENTS);
  }
}

/**
 * è·å–æ‰€æœ‰ç†ŠçŒ«è£…é¥°
 */
export async function getAllAccessories(): Promise<PandaAccessoryRecord[]> {
  return db.table('pandaAccessories').toArray();
}

/**
 * è·å–å·²æ‹¥æœ‰çš„ç†ŠçŒ«è£…é¥°
 */
export async function getOwnedAccessories(): Promise<PandaAccessoryRecord[]> {
  return db.table('pandaAccessories')
    .filter(accessory => accessory.isOwned === true)
    .toArray();
}

/**
 * è·å–å·²è£…å¤‡çš„ç†ŠçŒ«è£…é¥°
 */
export async function getEquippedAccessories(): Promise<PandaAccessoryRecord[]> {
  return db.table('pandaAccessories')
    .filter(accessory => accessory.isEquipped === true)
    .toArray();
}

/**
 * è£…å¤‡ç†ŠçŒ«è£…é¥°
 * @param accessoryId è£…é¥°ID
 */
export async function equipAccessory(accessoryId: number): Promise<PandaAccessoryRecord> {
  const accessory = await db.table('pandaAccessories').get(accessoryId);

  if (!accessory) {
    throw new Error(`Accessory with id ${accessoryId} not found`);
  }

  if (!accessory.isOwned) {
    throw new Error(`Accessory with id ${accessoryId} is not owned`);
  }

  // å…ˆå–æ¶ˆåŒç±»å‹çš„å…¶ä»–è£…é¥°
  const sameTypeAccessories = await db.table('pandaAccessories')
    .where('type')
    .equals(accessory.type)
    .filter(item => item.isEquipped === true)
    .toArray();

  for (const item of sameTypeAccessories) {
    await db.table('pandaAccessories').update(item.id!, { isEquipped: false });
    await addSyncItem('pandaAccessories', 'update', { ...item, isEquipped: false });
  }

  // è£…å¤‡æ–°è£…é¥°
  const updatedAccessory = { ...accessory, isEquipped: true };
  await db.table('pandaAccessories').update(accessoryId, updatedAccessory);
  await addSyncItem('pandaAccessories', 'update', updatedAccessory);

  return updatedAccessory;
}

/**
 * å–æ¶ˆè£…å¤‡ç†ŠçŒ«è£…é¥°
 * @param accessoryId è£…é¥°ID
 */
export async function unequipAccessory(accessoryId: number): Promise<PandaAccessoryRecord> {
  const accessory = await db.table('pandaAccessories').get(accessoryId);

  if (!accessory) {
    throw new Error(`Accessory with id ${accessoryId} not found`);
  }

  const updatedAccessory = { ...accessory, isEquipped: false };
  await db.table('pandaAccessories').update(accessoryId, updatedAccessory);
  await addSyncItem('pandaAccessories', 'update', updatedAccessory);

  return updatedAccessory;
}

/**
 * æ·»åŠ æ–°çš„ç†ŠçŒ«è£…é¥°
 * @param accessory è£…é¥°æ•°æ®
 */
export async function addAccessory(accessory: Omit<PandaAccessoryRecord, 'id'>): Promise<PandaAccessoryRecord> {
  const id = await db.table('pandaAccessories').add(accessory);
  const newAccessory = { ...accessory, id: id as number };
  await addSyncItem('pandaAccessories', 'create', newAccessory);
  return newAccessory;
}

/**
 * è·å–æ‰€æœ‰ç†ŠçŒ«ç¯å¢ƒ
 */
export async function getAllEnvironments(): Promise<PandaEnvironmentRecord[]> {
  return db.table('pandaEnvironments').toArray();
}

/**
 * è·å–å·²æ‹¥æœ‰çš„ç†ŠçŒ«ç¯å¢ƒ
 */
export async function getOwnedEnvironments(): Promise<PandaEnvironmentRecord[]> {
  return db.table('pandaEnvironments')
    .filter(environment => environment.isOwned === true)
    .toArray();
}

/**
 * è·å–å½“å‰æ¿€æ´»çš„ç†ŠçŒ«ç¯å¢ƒ
 */
export async function getActiveEnvironment(): Promise<PandaEnvironmentRecord | undefined> {
  return db.table('pandaEnvironments')
    .filter(environment => environment.isActive === true)
    .first();
}

/**
 * æ¿€æ´»ç†ŠçŒ«ç¯å¢ƒ
 * @param environmentId ç¯å¢ƒID
 */
export async function activateEnvironment(environmentId: number): Promise<PandaEnvironmentRecord> {
  const environment = await db.table('pandaEnvironments').get(environmentId);

  if (!environment) {
    throw new Error(`Environment with id ${environmentId} not found`);
  }

  if (!environment.isOwned) {
    throw new Error(`Environment with id ${environmentId} is not owned`);
  }

  // å…ˆå–æ¶ˆå…¶ä»–ç¯å¢ƒçš„æ¿€æ´»çŠ¶æ€
  const activeEnvironments = await db.table('pandaEnvironments')
    .filter(environment => environment.isActive === true)
    .toArray();

  for (const item of activeEnvironments) {
    await db.table('pandaEnvironments').update(item.id!, { isActive: false });
    await addSyncItem('pandaEnvironments', 'update', { ...item, isActive: false });
  }

  // æ¿€æ´»æ–°ç¯å¢ƒ
  const updatedEnvironment = { ...environment, isActive: true };
  await db.table('pandaEnvironments').update(environmentId, updatedEnvironment);
  await addSyncItem('pandaEnvironments', 'update', updatedEnvironment);

  return updatedEnvironment;
}

/**
 * æ·»åŠ æ–°çš„ç†ŠçŒ«ç¯å¢ƒ
 * @param environment ç¯å¢ƒæ•°æ®
 */
export async function addEnvironment(environment: Omit<PandaEnvironmentRecord, 'id'>): Promise<PandaEnvironmentRecord> {
  const id = await db.table('pandaEnvironments').add(environment);
  const newEnvironment = { ...environment, id: id as number };
  await addSyncItem('pandaEnvironments', 'create', newEnvironment);
  return newEnvironment;
}

/**
 * ä»å•†åº—è´­ä¹°è£…é¥°æˆ–ç¯å¢ƒåæ·»åŠ åˆ°ç”¨æˆ·æ‹¥æœ‰çš„ç‰©å“ä¸­
 * @param storeItemId å•†åº—ç‰©å“ID
 * @param itemType ç‰©å“ç±»å‹
 * @param itemData ç‰©å“æ•°æ®
 */
export async function addCustomizationFromStore(
  storeItemId: number,
  itemType: StoreItemType,
  itemData: any
): Promise<void> {
  const now = new Date();

  if (itemType === StoreItemType.ACCESSORY) {
    // æ·»åŠ è£…é¥°
    await addAccessory({
      name: itemData.name,
      type: itemData.accessoryType,
      description: itemData.description,
      imagePath: itemData.imagePath,
      overlayPath: itemData.overlayPath,
      isEquipped: false,
      isOwned: true,
      obtainedAt: now,
      storeItemId,
      rarity: itemData.rarity,
      themeType: itemData.themeType
    });
  } else if (itemType === StoreItemType.BACKGROUND) {
    // æ·»åŠ ç¯å¢ƒ
    await addEnvironment({
      name: itemData.name,
      description: itemData.description,
      backgroundPath: itemData.backgroundPath,
      foregroundPath: itemData.foregroundPath,
      ambientSound: itemData.ambientSound,
      isActive: false,
      isOwned: true,
      obtainedAt: now,
      storeItemId,
      rarity: itemData.rarity,
      themeType: itemData.themeType,
      interactiveElements: itemData.interactiveElements
    });
  }
}
</file>

<file path="src/services/queryClient.ts">
// src/services/queryClient.ts
import { QueryClient } from '@tanstack/react-query';

// åˆ›å»º QueryClient å®ä¾‹å¹¶å¯¼å‡ºï¼Œä»¥ä¾¿å…¶ä»–æ¨¡å—ä½¿ç”¨
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 2, // 2 minutes
      refetchOnWindowFocus: false, // Personal preference for demos
      retry: 1, // Retry failed queries once
    },
  },
});
</file>

<file path="src/services/reflectionService.ts">
// src/services/reflectionService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { TaskRecord, TaskStatus } from './taskService';
import { getPandaMood, updatePandaMood } from './pandaStateService';
import type { PandaMood, EnergyLevel } from '@/components/game/PandaAvatar';

// åæ€è®°å½•ç±»å‹
export interface ReflectionRecord {
  id?: number;
  userId: string;
  taskId?: number;
  mood: string;
  reflection: string;
  action: string;
  createdAt: Date;
  completedAt?: Date;
  isCompleted: boolean;
  tags?: string[];
}

// åæ€è§¦å‘ç±»å‹
export enum ReflectionTriggerType {
  MOOD_CHANGE = 'mood_change',
  TASK_FAILURE = 'task_failure',
  DAILY_REFLECTION = 'daily_reflection',
  WEEKLY_REVIEW = 'weekly_review',
  MANUAL = 'manual'
}

// åæ€è§¦å‘è®°å½•ç±»å‹
export interface ReflectionTriggerRecord {
  id?: number;
  userId: string;
  type: ReflectionTriggerType;
  createdAt: Date;
  isViewed: boolean;
  isCompleted: boolean;
  data?: any;
}

// æƒ…ç»ªè®°å½•ç±»å‹
export interface MoodRecord {
  id?: number;
  userId: string;
  mood: PandaMood;
  intensity: number;
  note?: string;
  createdAt: Date;
  tags?: string[];
}

// æƒ…ç»ªç±»å‹
export enum MoodType {
  HAPPY = 'happy',
  CONTENT = 'content',
  NEUTRAL = 'neutral',
  SAD = 'sad',
  ANXIOUS = 'anxious',
  STRESSED = 'stressed',
  TIRED = 'tired',
  ENERGETIC = 'energetic',
  MOTIVATED = 'motivated',
  FRUSTRATED = 'frustrated',
  ANGRY = 'angry',
  CALM = 'calm'
}

// æƒ…ç»ªå¼ºåº¦ï¼ˆ1-5ï¼‰
export type MoodIntensity = 1 | 2 | 3 | 4 | 5;

/**
 * åˆ›å»ºåæ€è®°å½•
 * @param reflection åæ€æ•°æ®
 */
export async function createReflection(
  reflection: Omit<ReflectionRecord, 'id' | 'createdAt' | 'isCompleted'>
): Promise<ReflectionRecord> {
  const now = new Date();

  const newReflection: ReflectionRecord = {
    ...reflection,
    createdAt: now,
    isCompleted: false
  };

  // æ·»åŠ åˆ°æ•°æ®åº“
  const id = await db.table('reflections').add(newReflection);
  const createdReflection = { ...newReflection, id: id as number };

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('reflections', 'create', createdReflection);

  return createdReflection;
}

/**
 * å®Œæˆåæ€è®°å½•
 * @param id åæ€è®°å½•ID
 * @param action é‡‡å–çš„è¡ŒåŠ¨
 */
export async function completeReflection(
  id: number,
  action: string
): Promise<ReflectionRecord> {
  const reflection = await db.table('reflections').get(id);
  if (!reflection) {
    throw new Error(`Reflection with id ${id} not found`);
  }

  const now = new Date();
  const updatedReflection = {
    ...reflection,
    action,
    completedAt: now,
    isCompleted: true
  };

  // æ›´æ–°æ•°æ®åº“
  await db.table('reflections').update(id, updatedReflection);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('reflections', 'update', updatedReflection);

  return updatedReflection;
}

/**
 * è·å–ç”¨æˆ·çš„åæ€è®°å½•
 * @param userId ç”¨æˆ·ID
 * @param limit é™åˆ¶æ•°é‡
 */
export async function getUserReflections(
  userId: string,
  limit?: number
): Promise<ReflectionRecord[]> {
  let query = db.table('reflections')
    .where('userId')
    .equals(userId)
    .reverse();

  if (limit) {
    query = query.limit(limit);
  }

  return query.sortBy('createdAt');
}

/**
 * åˆ›å»ºåæ€è§¦å‘è®°å½•
 * @param trigger è§¦å‘æ•°æ®
 */
export async function createReflectionTrigger(
  trigger: Omit<ReflectionTriggerRecord, 'id' | 'createdAt' | 'isViewed' | 'isCompleted'>
): Promise<ReflectionTriggerRecord> {
  const now = new Date();

  const newTrigger: ReflectionTriggerRecord = {
    ...trigger,
    createdAt: now,
    isViewed: false,
    isCompleted: false
  };

  // æ·»åŠ åˆ°æ•°æ®åº“
  const id = await db.table('reflectionTriggers').add(newTrigger);
  const createdTrigger = { ...newTrigger, id: id as number };

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('reflectionTriggers', 'create', createdTrigger);

  return createdTrigger;
}

/**
 * è·å–ç”¨æˆ·çš„æœªæŸ¥çœ‹åæ€è§¦å‘è®°å½•
 * @param userId ç”¨æˆ·ID
 */
export async function getUnviewedReflectionTriggers(
  userId: string
): Promise<ReflectionTriggerRecord[]> {
  return db.table('reflectionTriggers')
    .where('userId')
    .equals(userId)
    .and(trigger => !trigger.isViewed)
    .sortBy('createdAt');
}

/**
 * æ ‡è®°åæ€è§¦å‘è®°å½•ä¸ºå·²æŸ¥çœ‹
 * @param id è§¦å‘è®°å½•ID
 */
export async function markTriggerAsViewed(
  id: number
): Promise<ReflectionTriggerRecord> {
  const trigger = await db.table('reflectionTriggers').get(id);
  if (!trigger) {
    throw new Error(`Reflection trigger with id ${id} not found`);
  }

  const updatedTrigger = {
    ...trigger,
    isViewed: true
  };

  // æ›´æ–°æ•°æ®åº“
  await db.table('reflectionTriggers').update(id, updatedTrigger);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('reflectionTriggers', 'update', updatedTrigger);

  return updatedTrigger;
}

/**
 * æ ‡è®°åæ€è§¦å‘è®°å½•ä¸ºå·²å®Œæˆ
 * @param id è§¦å‘è®°å½•ID
 */
export async function markTriggerAsCompleted(
  id: number
): Promise<ReflectionTriggerRecord> {
  const trigger = await db.table('reflectionTriggers').get(id);
  if (!trigger) {
    throw new Error(`Reflection trigger with id ${id} not found`);
  }

  const updatedTrigger = {
    ...trigger,
    isViewed: true,
    isCompleted: true
  };

  // æ›´æ–°æ•°æ®åº“
  await db.table('reflectionTriggers').update(id, updatedTrigger);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('reflectionTriggers', 'update', updatedTrigger);

  return updatedTrigger;
}

/**
 * è®°å½•ç”¨æˆ·æƒ…ç»ª
 * @param mood æƒ…ç»ªæ•°æ®
 */
export async function recordMood(
  mood: Omit<MoodRecord, 'id' | 'createdAt'>
): Promise<MoodRecord> {
  const now = new Date();

  const newMood: MoodRecord = {
    ...mood,
    createdAt: now
  };

  // æ·»åŠ åˆ°æ•°æ®åº“
  const id = await db.table('moods').add(newMood);
  const createdMood = { ...newMood, id: id as number };

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('moods', 'create', createdMood);

  // æ›´æ–°ç†ŠçŒ«å¿ƒæƒ…
  await updatePandaMood(mood.mood);

  // æ£€æŸ¥æ˜¯å¦éœ€è¦è§¦å‘åæ€
  await checkMoodTrigger(mood.userId, mood.mood, mood.intensity);

  return createdMood;
}

/**
 * è·å–ç”¨æˆ·çš„æƒ…ç»ªè®°å½•
 * @param userId ç”¨æˆ·ID
 * @param limit é™åˆ¶æ•°é‡
 */
export async function getUserMoods(
  userId: string,
  limit?: number
): Promise<MoodRecord[]> {
  let query = db.table('moods')
    .where('userId')
    .equals(userId)
    .reverse();

  if (limit) {
    query = query.limit(limit);
  }

  return query.sortBy('createdAt');
}

/**
 * æ£€æŸ¥æƒ…ç»ªæ˜¯å¦éœ€è¦è§¦å‘åæ€
 * @param userId ç”¨æˆ·ID
 * @param mood æƒ…ç»ª
 * @param intensity å¼ºåº¦
 */
async function checkMoodTrigger(
  userId: string,
  mood: string,
  intensity: number
): Promise<void> {
  // å¦‚æœæ˜¯è´Ÿé¢æƒ…ç»ªä¸”å¼ºåº¦è¾ƒé«˜ï¼Œè§¦å‘åæ€
  if (
    (mood === MoodType.SAD ||
     mood === MoodType.ANXIOUS ||
     mood === MoodType.STRESSED ||
     mood === MoodType.FRUSTRATED ||
     mood === MoodType.ANGRY) &&
    intensity >= 4
  ) {
    await createReflectionTrigger({
      userId,
      type: ReflectionTriggerType.MOOD_CHANGE,
      data: { mood, intensity }
    });
  }
}

/**
 * æ£€æŸ¥ä»»åŠ¡å¤±è´¥æ˜¯å¦éœ€è¦è§¦å‘åæ€
 * @param userId ç”¨æˆ·ID
 * @param task ä»»åŠ¡
 */
export async function checkTaskFailureTrigger(
  userId: string,
  task: TaskRecord
): Promise<void> {
  // å¦‚æœä»»åŠ¡å·²è¿‡æœŸä¸”æœªå®Œæˆï¼Œè§¦å‘åæ€
  if (
    task.status !== TaskStatus.COMPLETED &&
    task.dueDate &&
    new Date(task.dueDate) < new Date()
  ) {
    await createReflectionTrigger({
      userId,
      type: ReflectionTriggerType.TASK_FAILURE,
      data: { taskId: task.id, taskTitle: task.title }
    });
  }
}

/**
 * æ£€æŸ¥æ˜¯å¦éœ€è¦è§¦å‘æ¯æ—¥åæ€
 * @param userId ç”¨æˆ·ID
 */
export async function checkDailyReflectionTrigger(
  userId: string
): Promise<void> {
  // è·å–æœ€è¿‘çš„æ¯æ—¥åæ€è§¦å‘è®°å½•
  const recentTriggers = await db.table('reflectionTriggers')
    .where('userId')
    .equals(userId)
    .and(trigger => trigger.type === ReflectionTriggerType.DAILY_REFLECTION)
    .reverse()
    .sortBy('createdAt');

  // å¦‚æœæ²¡æœ‰è®°å½•æˆ–æœ€è¿‘çš„è®°å½•æ˜¯æ˜¨å¤©ä¹‹å‰çš„ï¼Œè§¦å‘æ¯æ—¥åæ€
  if (
    recentTriggers.length === 0 ||
    isYesterdayOrBefore(recentTriggers[0].createdAt)
  ) {
    await createReflectionTrigger({
      userId,
      type: ReflectionTriggerType.DAILY_REFLECTION,
      data: {}
    });
  }
}

/**
 * æ£€æŸ¥æ˜¯å¦éœ€è¦è§¦å‘æ¯å‘¨å›é¡¾
 * @param userId ç”¨æˆ·ID
 */
export async function checkWeeklyReviewTrigger(
  userId: string
): Promise<void> {
  // è·å–æœ€è¿‘çš„æ¯å‘¨å›é¡¾è§¦å‘è®°å½•
  const recentTriggers = await db.table('reflectionTriggers')
    .where('userId')
    .equals(userId)
    .and(trigger => trigger.type === ReflectionTriggerType.WEEKLY_REVIEW)
    .reverse()
    .sortBy('createdAt');

  // å¦‚æœæ²¡æœ‰è®°å½•æˆ–æœ€è¿‘çš„è®°å½•æ˜¯ä¸€å‘¨ä¹‹å‰çš„ï¼Œè§¦å‘æ¯å‘¨å›é¡¾
  if (
    recentTriggers.length === 0 ||
    isWeekOrBefore(recentTriggers[0].createdAt)
  ) {
    await createReflectionTrigger({
      userId,
      type: ReflectionTriggerType.WEEKLY_REVIEW,
      data: {}
    });
  }
}

/**
 * åˆ¤æ–­æ—¥æœŸæ˜¯å¦æ˜¯æ˜¨å¤©æˆ–ä¹‹å‰
 * @param date æ—¥æœŸ
 */
function isYesterdayOrBefore(date: Date): boolean {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  yesterday.setHours(0, 0, 0, 0);

  return new Date(date) < yesterday;
}

/**
 * åˆ¤æ–­æ—¥æœŸæ˜¯å¦æ˜¯ä¸€å‘¨æˆ–ä¹‹å‰
 * @param date æ—¥æœŸ
 */
function isWeekOrBefore(date: Date): boolean {
  const weekAgo = new Date();
  weekAgo.setDate(weekAgo.getDate() - 7);
  weekAgo.setHours(0, 0, 0, 0);

  return new Date(date) < weekAgo;
}
</file>

<file path="src/services/socialChallengeService.ts">
// src/services/socialChallengeService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { ChallengeDifficulty, ChallengeStatus } from './challengeService';

// ç¤¾äº¤æŒ‘æˆ˜ç±»å‹
export enum SocialChallengeType {
  COOPERATIVE = 'cooperative', // åˆä½œå‹
  COMPETITIVE = 'competitive', // ç«äº‰å‹
  TEAM = 'team' // å›¢é˜Ÿå‹
}

// ç¤¾äº¤æŒ‘æˆ˜è®°å½•ç±»å‹
export interface SocialChallengeRecord {
  id?: number;
  title: string;
  description: string;
  type: SocialChallengeType;
  difficulty: ChallengeDifficulty;
  status: ChallengeStatus;
  creatorId: string;
  participantIds: string[];
  maxParticipants: number;
  progress: number;
  startDate: Date;
  endDate?: Date;
  createdAt: Date;
  updatedAt: Date;
  iconPath?: string;
  rewards?: any[];
  isPublic: boolean;
  inviteCode?: string;
  milestones?: SocialChallengeMilestone[];
}

// ç¤¾äº¤æŒ‘æˆ˜é‡Œç¨‹ç¢‘ç±»å‹
export interface SocialChallengeMilestone {
  id?: number;
  challengeId: number;
  title: string;
  description?: string;
  targetValue: number;
  currentValue: number;
  isCompleted: boolean;
  completedAt?: Date;
  order: number;
}

// ç¤¾äº¤æŒ‘æˆ˜å‚ä¸è®°å½•ç±»å‹
export interface SocialChallengeParticipation {
  id?: number;
  challengeId: number;
  userId: string;
  joinedAt: Date;
  status: 'active' | 'completed' | 'abandoned';
  contribution: number;
  lastContributedAt?: Date;
}

/**
 * åˆ›å»ºç¤¾äº¤æŒ‘æˆ˜
 * @param challenge ç¤¾äº¤æŒ‘æˆ˜æ•°æ®
 */
export async function createSocialChallenge(
  challenge: Omit<SocialChallengeRecord, 'id' | 'createdAt' | 'updatedAt' | 'progress' | 'participantIds' | 'inviteCode'>
): Promise<SocialChallengeRecord> {
  const now = new Date();
  
  // ç”Ÿæˆé‚€è¯·ç 
  const inviteCode = generateInviteCode();
  
  const newChallenge: SocialChallengeRecord = {
    ...challenge,
    participantIds: [challenge.creatorId], // åˆ›å»ºè€…è‡ªåŠ¨æˆä¸ºå‚ä¸è€…
    progress: 0,
    createdAt: now,
    updatedAt: now,
    inviteCode
  };
  
  // æ·»åŠ åˆ°æ•°æ®åº“
  const id = await db.table('socialChallenges').add(newChallenge);
  const createdChallenge = { ...newChallenge, id: id as number };
  
  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('socialChallenges', 'create', createdChallenge);
  
  // åˆ›å»ºå‚ä¸è®°å½•
  await createParticipation(id as number, challenge.creatorId);
  
  return createdChallenge;
}

/**
 * è·å–ç¤¾äº¤æŒ‘æˆ˜
 * @param id ç¤¾äº¤æŒ‘æˆ˜ID
 */
export async function getSocialChallenge(id: number): Promise<SocialChallengeRecord | null> {
  return db.table('socialChallenges').get(id);
}

/**
 * è·å–æ‰€æœ‰ç¤¾äº¤æŒ‘æˆ˜
 * @param filter è¿‡æ»¤æ¡ä»¶
 */
export async function getAllSocialChallenges(
  filter?: Partial<SocialChallengeRecord>
): Promise<SocialChallengeRecord[]> {
  let collection = db.table('socialChallenges').toCollection();
  
  if (filter) {
    collection = collection.filter(challenge => {
      for (const key in filter) {
        if (filter[key as keyof typeof filter] !== undefined) {
          if (challenge[key as keyof typeof challenge] !== filter[key as keyof typeof filter]) {
            return false;
          }
        }
      }
      return true;
    });
  }
  
  return collection.sortBy('createdAt');
}

/**
 * è·å–ç”¨æˆ·å‚ä¸çš„ç¤¾äº¤æŒ‘æˆ˜
 * @param userId ç”¨æˆ·ID
 */
export async function getUserSocialChallenges(userId: string): Promise<SocialChallengeRecord[]> {
  return db.table('socialChallenges')
    .filter(challenge => challenge.participantIds.includes(userId))
    .sortBy('createdAt');
}

/**
 * è·å–å…¬å¼€çš„ç¤¾äº¤æŒ‘æˆ˜
 */
export async function getPublicSocialChallenges(): Promise<SocialChallengeRecord[]> {
  return db.table('socialChallenges')
    .filter(challenge => 
      challenge.isPublic && 
      challenge.status === ChallengeStatus.ACTIVE &&
      challenge.participantIds.length < challenge.maxParticipants
    )
    .sortBy('createdAt');
}

/**
 * æ›´æ–°ç¤¾äº¤æŒ‘æˆ˜
 * @param id ç¤¾äº¤æŒ‘æˆ˜ID
 * @param updates æ›´æ–°æ•°æ®
 */
export async function updateSocialChallenge(
  id: number,
  updates: Partial<Omit<SocialChallengeRecord, 'id' | 'createdAt'>>
): Promise<SocialChallengeRecord> {
  const challenge = await db.table('socialChallenges').get(id);
  if (!challenge) {
    throw new Error(`Social challenge with id ${id} not found`);
  }
  
  const updatedChallenge = {
    ...challenge,
    ...updates,
    updatedAt: new Date()
  };
  
  // æ›´æ–°æ•°æ®åº“
  await db.table('socialChallenges').update(id, updatedChallenge);
  
  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('socialChallenges', 'update', updatedChallenge);
  
  return updatedChallenge;
}

/**
 * åŠ å…¥ç¤¾äº¤æŒ‘æˆ˜
 * @param challengeId ç¤¾äº¤æŒ‘æˆ˜ID
 * @param userId ç”¨æˆ·ID
 * @param inviteCode é‚€è¯·ç ï¼ˆå¦‚æœæ˜¯éå…¬å¼€æŒ‘æˆ˜ï¼‰
 */
export async function joinSocialChallenge(
  challengeId: number,
  userId: string,
  inviteCode?: string
): Promise<SocialChallengeRecord> {
  const challenge = await db.table('socialChallenges').get(challengeId);
  if (!challenge) {
    throw new Error(`Social challenge with id ${challengeId} not found`);
  }
  
  // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯å‚ä¸è€…
  if (challenge.participantIds.includes(userId)) {
    return challenge;
  }
  
  // æ£€æŸ¥æ˜¯å¦å·²è¾¾åˆ°æœ€å¤§å‚ä¸äººæ•°
  if (challenge.participantIds.length >= challenge.maxParticipants) {
    throw new Error('Challenge has reached maximum number of participants');
  }
  
  // æ£€æŸ¥é‚€è¯·ç ï¼ˆå¦‚æœæ˜¯éå…¬å¼€æŒ‘æˆ˜ï¼‰
  if (!challenge.isPublic && challenge.inviteCode !== inviteCode) {
    throw new Error('Invalid invite code');
  }
  
  // æ›´æ–°å‚ä¸è€…åˆ—è¡¨
  const updatedParticipantIds = [...challenge.participantIds, userId];
  const updatedChallenge = await updateSocialChallenge(challengeId, {
    participantIds: updatedParticipantIds
  });
  
  // åˆ›å»ºå‚ä¸è®°å½•
  await createParticipation(challengeId, userId);
  
  return updatedChallenge;
}

/**
 * ç¦»å¼€ç¤¾äº¤æŒ‘æˆ˜
 * @param challengeId ç¤¾äº¤æŒ‘æˆ˜ID
 * @param userId ç”¨æˆ·ID
 */
export async function leaveSocialChallenge(
  challengeId: number,
  userId: string
): Promise<SocialChallengeRecord> {
  const challenge = await db.table('socialChallenges').get(challengeId);
  if (!challenge) {
    throw new Error(`Social challenge with id ${challengeId} not found`);
  }
  
  // æ£€æŸ¥æ˜¯å¦æ˜¯å‚ä¸è€…
  if (!challenge.participantIds.includes(userId)) {
    return challenge;
  }
  
  // å¦‚æœæ˜¯åˆ›å»ºè€…ï¼Œä¸å…è®¸ç¦»å¼€
  if (challenge.creatorId === userId) {
    throw new Error('Creator cannot leave the challenge');
  }
  
  // æ›´æ–°å‚ä¸è€…åˆ—è¡¨
  const updatedParticipantIds = challenge.participantIds.filter(id => id !== userId);
  const updatedChallenge = await updateSocialChallenge(challengeId, {
    participantIds: updatedParticipantIds
  });
  
  // æ›´æ–°å‚ä¸è®°å½•
  await updateParticipation(challengeId, userId, {
    status: 'abandoned'
  });
  
  return updatedChallenge;
}

/**
 * åˆ›å»ºå‚ä¸è®°å½•
 * @param challengeId ç¤¾äº¤æŒ‘æˆ˜ID
 * @param userId ç”¨æˆ·ID
 */
export async function createParticipation(
  challengeId: number,
  userId: string
): Promise<SocialChallengeParticipation> {
  const now = new Date();
  
  const participation: SocialChallengeParticipation = {
    challengeId,
    userId,
    joinedAt: now,
    status: 'active',
    contribution: 0
  };
  
  // æ·»åŠ åˆ°æ•°æ®åº“
  const id = await db.table('socialChallengeParticipations').add(participation);
  const createdParticipation = { ...participation, id: id as number };
  
  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('socialChallengeParticipations', 'create', createdParticipation);
  
  return createdParticipation;
}

/**
 * æ›´æ–°å‚ä¸è®°å½•
 * @param challengeId ç¤¾äº¤æŒ‘æˆ˜ID
 * @param userId ç”¨æˆ·ID
 * @param updates æ›´æ–°æ•°æ®
 */
export async function updateParticipation(
  challengeId: number,
  userId: string,
  updates: Partial<Omit<SocialChallengeParticipation, 'id' | 'challengeId' | 'userId' | 'joinedAt'>>
): Promise<SocialChallengeParticipation> {
  const participation = await db.table('socialChallengeParticipations')
    .filter(p => p.challengeId === challengeId && p.userId === userId)
    .first();
  
  if (!participation) {
    throw new Error(`Participation record not found for challenge ${challengeId} and user ${userId}`);
  }
  
  const updatedParticipation = {
    ...participation,
    ...updates
  };
  
  // å¦‚æœæ›´æ–°äº†è´¡çŒ®å€¼ï¼Œè®¾ç½®æœ€åè´¡çŒ®æ—¶é—´
  if (updates.contribution !== undefined) {
    updatedParticipation.lastContributedAt = new Date();
  }
  
  // æ›´æ–°æ•°æ®åº“
  await db.table('socialChallengeParticipations').update(participation.id!, updatedParticipation);
  
  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('socialChallengeParticipations', 'update', updatedParticipation);
  
  return updatedParticipation;
}

/**
 * è·å–ç¤¾äº¤æŒ‘æˆ˜çš„å‚ä¸è®°å½•
 * @param challengeId ç¤¾äº¤æŒ‘æˆ˜ID
 */
export async function getChallengeParticipations(
  challengeId: number
): Promise<SocialChallengeParticipation[]> {
  return db.table('socialChallengeParticipations')
    .filter(p => p.challengeId === challengeId)
    .sortBy('joinedAt');
}

/**
 * è´¡çŒ®ç¤¾äº¤æŒ‘æˆ˜è¿›åº¦
 * @param challengeId ç¤¾äº¤æŒ‘æˆ˜ID
 * @param userId ç”¨æˆ·ID
 * @param amount è´¡çŒ®é‡
 */
export async function contributeToChallenge(
  challengeId: number,
  userId: string,
  amount: number
): Promise<SocialChallengeRecord> {
  const challenge = await db.table('socialChallenges').get(challengeId);
  if (!challenge) {
    throw new Error(`Social challenge with id ${challengeId} not found`);
  }
  
  // æ£€æŸ¥æ˜¯å¦æ˜¯å‚ä¸è€…
  if (!challenge.participantIds.includes(userId)) {
    throw new Error('User is not a participant of this challenge');
  }
  
  // è·å–å‚ä¸è®°å½•
  const participation = await db.table('socialChallengeParticipations')
    .filter(p => p.challengeId === challengeId && p.userId === userId)
    .first();
  
  if (!participation) {
    throw new Error(`Participation record not found for challenge ${challengeId} and user ${userId}`);
  }
  
  // æ›´æ–°å‚ä¸è®°å½•
  await updateParticipation(challengeId, userId, {
    contribution: participation.contribution + amount
  });
  
  // æ›´æ–°æŒ‘æˆ˜è¿›åº¦
  const newProgress = Math.min(100, challenge.progress + amount);
  const updatedChallenge = await updateSocialChallenge(challengeId, {
    progress: newProgress
  });
  
  // å¦‚æœè¿›åº¦è¾¾åˆ°100%ï¼Œæ ‡è®°ä¸ºå·²å®Œæˆ
  if (newProgress >= 100 && challenge.status !== ChallengeStatus.COMPLETED) {
    await updateSocialChallenge(challengeId, {
      status: ChallengeStatus.COMPLETED
    });
    
    // æ›´æ–°æ‰€æœ‰æ´»è·ƒå‚ä¸è€…çš„çŠ¶æ€ä¸ºå·²å®Œæˆ
    const participations = await getChallengeParticipations(challengeId);
    for (const p of participations) {
      if (p.status === 'active') {
        await updateParticipation(challengeId, p.userId, {
          status: 'completed'
        });
      }
    }
  }
  
  return updatedChallenge;
}

/**
 * ç”Ÿæˆé‚€è¯·ç 
 */
function generateInviteCode(): string {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for (let i = 0; i < 6; i++) {
    code += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return code;
}
</file>

<file path="src/services/storeService.ts">
// src/services/storeService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { ItemRecord, addItem } from './rewardService';

// å•†åº—ç‰©å“ç±»å‹
export enum StoreItemType {
  AVATAR = 'avatar',           // ç†ŠçŒ«å¤´åƒ
  ACCESSORY = 'accessory',     // ç†ŠçŒ«é…ä»¶
  BACKGROUND = 'background',   // èƒŒæ™¯
  THEME = 'theme',             // ä¸»é¢˜
  ABILITY = 'ability',         // èƒ½åŠ›
  CONSUMABLE = 'consumable',   // æ¶ˆè€—å“
  VIP = 'vip'                  // VIPä¼šå‘˜
}

// å•†åº—ç‰©å“ç¨€æœ‰åº¦
export enum StoreItemRarity {
  COMMON = 'common',
  UNCOMMON = 'uncommon',
  RARE = 'rare',
  EPIC = 'epic',
  LEGENDARY = 'legendary'
}

// å•†åº—ç‰©å“ä»·æ ¼ç±»å‹
export enum PriceType {
  COINS = 'coins',             // æ¸¸æˆå†…è´§å¸
  JADE = 'jade',               // é«˜çº§è´§å¸
  REAL_MONEY = 'real_money'    // çœŸå®è´§å¸
}

// å•†åº—ç‰©å“è®°å½•ç±»å‹
export interface StoreItemRecord {
  id?: number;
  name: string;
  description: string;
  type: StoreItemType;
  rarity: StoreItemRarity;
  price: number;
  priceType: PriceType;
  imagePath: string;
  isAvailable: boolean;
  isFeatured: boolean;
  isOnSale: boolean;
  salePrice?: number;
  saleEndDate?: Date;
  categoryId: number;
  createdAt: Date;
  updatedAt?: Date;
  vipRequired?: boolean;
  limitedQuantity?: number;
  remainingQuantity?: number;
  tags?: string[];
}

// å•†åº—ç±»åˆ«è®°å½•ç±»å‹
export interface StoreCategoryRecord {
  id?: number;
  name: string;
  description: string;
  iconPath: string;
  order: number;
  isVisible: boolean;
  createdAt: Date;
  updatedAt?: Date;
}

// è´­ä¹°è®°å½•ç±»å‹
export interface PurchaseRecord {
  id?: number;
  userId: string;
  storeItemId: number;
  price: number;
  priceType: PriceType;
  purchaseDate: Date;
  transactionId?: string;
  isRefunded: boolean;
  refundDate?: Date;
}

// VIPè®¢é˜…è®°å½•ç±»å‹
export interface VipSubscriptionRecord {
  id?: number;
  userId: string;
  tier: number;
  startDate: Date;
  endDate?: Date;
  isActive: boolean;
  autoRenew: boolean;
  paymentMethod: string;
  transactionId?: string;
  createdAt: Date;
  updatedAt?: Date;
}

// ç”¨æˆ·è´§å¸è®°å½•ç±»å‹
export interface UserCurrencyRecord {
  id?: number;
  userId: string;
  coins: number;
  jade: number;
  lastUpdated: Date;
}

/**
 * è·å–æ‰€æœ‰å•†åº—ç±»åˆ«
 */
export async function getStoreCategories(): Promise<StoreCategoryRecord[]> {
  return db.table('storeCategories')
    .filter(category => category.isVisible === true)
    .sortBy('order');
}

/**
 * è·å–å•†åº—ç±»åˆ«
 * @param id ç±»åˆ«ID
 */
export async function getStoreCategory(id: number): Promise<StoreCategoryRecord | undefined> {
  return db.table('storeCategories').get(id);
}

/**
 * è·å–å•†åº—ç‰©å“
 * @param id ç‰©å“ID
 */
export async function getStoreItem(id: number): Promise<StoreItemRecord | undefined> {
  return db.table('storeItems').get(id);
}

/**
 * è·å–ç±»åˆ«çš„å•†åº—ç‰©å“
 * @param categoryId ç±»åˆ«ID
 */
export async function getCategoryItems(categoryId: number): Promise<StoreItemRecord[]> {
  return db.table('storeItems')
    .where('categoryId')
    .equals(categoryId)
    .and(item => item.isAvailable)
    .toArray();
}

/**
 * è·å–ç‰¹è‰²å•†åº—ç‰©å“
 */
export async function getFeaturedItems(): Promise<StoreItemRecord[]> {
  return db.table('storeItems')
    .filter(item => item.isFeatured === true && item.isAvailable === true)
    .toArray();
}

/**
 * è·å–ä¿ƒé”€å•†åº—ç‰©å“
 */
export async function getSaleItems(): Promise<StoreItemRecord[]> {
  const now = new Date();
  return db.table('storeItems')
    .filter(item =>
      item.isOnSale === true &&
      item.isAvailable === true &&
      (!item.saleEndDate || new Date(item.saleEndDate) > now)
    )
    .toArray();
}

/**
 * è·å–VIPä¸“å±å•†åº—ç‰©å“
 */
export async function getVipItems(): Promise<StoreItemRecord[]> {
  return db.table('storeItems')
    .filter(item => item.vipRequired === true && item.isAvailable === true)
    .toArray();
}

/**
 * è·å–ç”¨æˆ·è´§å¸
 * @param userId ç”¨æˆ·ID
 */
export async function getUserCurrency(userId: string): Promise<UserCurrencyRecord | null> {
  const currency = await db.table('userCurrencies')
    .where('userId')
    .equals(userId)
    .first();

  if (!currency) {
    // å¦‚æœç”¨æˆ·æ²¡æœ‰è´§å¸è®°å½•ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„
    const newCurrency: UserCurrencyRecord = {
      userId,
      coins: 0,
      jade: 0,
      lastUpdated: new Date()
    };

    const id = await db.table('userCurrencies').add(newCurrency);
    return { ...newCurrency, id: id as number };
  }

  return currency;
}

/**
 * æ›´æ–°ç”¨æˆ·è´§å¸
 * @param userId ç”¨æˆ·ID
 * @param coins é‡‘å¸æ•°é‡å˜åŒ–ï¼ˆå¯ä»¥æ˜¯æ­£æ•°æˆ–è´Ÿæ•°ï¼‰
 * @param jade ç‰çŸ³æ•°é‡å˜åŒ–ï¼ˆå¯ä»¥æ˜¯æ­£æ•°æˆ–è´Ÿæ•°ï¼‰
 */
export async function updateUserCurrency(
  userId: string,
  coins: number = 0,
  jade: number = 0
): Promise<UserCurrencyRecord> {
  const currency = await getUserCurrency(userId);
  if (!currency) {
    throw new Error(`User currency not found for user ${userId}`);
  }

  const updatedCurrency: UserCurrencyRecord = {
    ...currency,
    coins: Math.max(0, currency.coins + coins),
    jade: Math.max(0, currency.jade + jade),
    lastUpdated: new Date()
  };

  // æ›´æ–°æ•°æ®åº“
  await db.table('userCurrencies').update(currency.id!, updatedCurrency);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('userCurrencies', 'update', updatedCurrency);

  return updatedCurrency;
}

/**
 * è´­ä¹°å•†åº—ç‰©å“
 * @param userId ç”¨æˆ·ID
 * @param storeItemId å•†åº—ç‰©å“ID
 */
export async function purchaseStoreItem(
  userId: string,
  storeItemId: number
): Promise<PurchaseRecord> {
  // è·å–å•†åº—ç‰©å“
  const storeItem = await getStoreItem(storeItemId);
  if (!storeItem) {
    throw new Error(`Store item with id ${storeItemId} not found`);
  }

  // æ£€æŸ¥ç‰©å“æ˜¯å¦å¯ç”¨
  if (!storeItem.isAvailable) {
    throw new Error(`Store item with id ${storeItemId} is not available`);
  }

  // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„åº“å­˜
  if (storeItem.limitedQuantity && storeItem.remainingQuantity !== undefined && storeItem.remainingQuantity <= 0) {
    throw new Error(`Store item with id ${storeItemId} is out of stock`);
  }

  // è·å–ç”¨æˆ·è´§å¸
  const currency = await getUserCurrency(userId);
  if (!currency) {
    throw new Error(`User currency not found for user ${userId}`);
  }

  // è®¡ç®—ä»·æ ¼
  const price = storeItem.isOnSale && storeItem.salePrice !== undefined ? storeItem.salePrice : storeItem.price;

  // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰è¶³å¤Ÿçš„è´§å¸
  if (storeItem.priceType === PriceType.COINS && currency.coins < price) {
    throw new Error('Not enough coins');
  }

  if (storeItem.priceType === PriceType.JADE && currency.jade < price) {
    throw new Error('Not enough jade');
  }

  // æ‰£é™¤è´§å¸
  if (storeItem.priceType === PriceType.COINS) {
    await updateUserCurrency(userId, -price, 0);
  } else if (storeItem.priceType === PriceType.JADE) {
    await updateUserCurrency(userId, 0, -price);
  }

  // æ›´æ–°åº“å­˜
  if (storeItem.limitedQuantity && storeItem.remainingQuantity !== undefined) {
    await db.table('storeItems').update(storeItemId, {
      ...storeItem,
      remainingQuantity: storeItem.remainingQuantity - 1,
      updatedAt: new Date()
    });
  }

  // åˆ›å»ºè´­ä¹°è®°å½•
  const purchase: PurchaseRecord = {
    userId,
    storeItemId,
    price,
    priceType: storeItem.priceType,
    purchaseDate: new Date(),
    isRefunded: false
  };

  // æ·»åŠ åˆ°æ•°æ®åº“
  const id = await db.table('purchases').add(purchase);
  const createdPurchase = { ...purchase, id: id as number };

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('purchases', 'create', createdPurchase);

  // æ·»åŠ ç‰©å“åˆ°ç”¨æˆ·åº“å­˜
  await addItem({
    type: storeItem.type,
    rarity: storeItem.rarity,
    quantity: 1,
    obtainedAt: new Date()
  });

  return createdPurchase;
}

/**
 * è·å–ç”¨æˆ·çš„VIPè®¢é˜…
 * @param userId ç”¨æˆ·ID
 */
export async function getUserVipSubscription(userId: string): Promise<VipSubscriptionRecord | null> {
  return db.table('vipSubscriptions')
    .where('userId')
    .equals(userId)
    .and(sub => sub.isActive)
    .first();
}

/**
 * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ˜¯VIP
 * @param userId ç”¨æˆ·ID
 */
export async function isUserVip(userId: string): Promise<boolean> {
  const subscription = await getUserVipSubscription(userId);
  if (!subscription) {
    return false;
  }

  // æ£€æŸ¥è®¢é˜…æ˜¯å¦è¿‡æœŸ
  if (subscription.endDate && new Date(subscription.endDate) < new Date()) {
    // æ›´æ–°è®¢é˜…çŠ¶æ€
    await db.table('vipSubscriptions').update(subscription.id!, {
      ...subscription,
      isActive: false,
      updatedAt: new Date()
    });
    return false;
  }

  return true;
}

/**
 * æ¿€æ´»VIPè®¢é˜…
 * @param userId ç”¨æˆ·ID
 * @param tier VIPç­‰çº§
 * @param durationDays è®¢é˜…æ—¶é•¿ï¼ˆå¤©ï¼‰
 * @param paymentMethod æ”¯ä»˜æ–¹å¼
 * @param transactionId äº¤æ˜“ID
 */
export async function activateVipSubscription(
  userId: string,
  tier: number,
  durationDays: number,
  paymentMethod: string,
  transactionId?: string
): Promise<VipSubscriptionRecord> {
  // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç»æœ‰VIPè®¢é˜…
  const existingSubscription = await getUserVipSubscription(userId);

  const now = new Date();
  const endDate = new Date(now);
  endDate.setDate(endDate.getDate() + durationDays);

  if (existingSubscription) {
    // å¦‚æœå·²ç»æœ‰è®¢é˜…ï¼Œå»¶é•¿è®¢é˜…æ—¶é—´
    const updatedSubscription: VipSubscriptionRecord = {
      ...existingSubscription,
      tier: Math.max(existingSubscription.tier, tier), // ä½¿ç”¨æ›´é«˜çš„ç­‰çº§
      endDate: existingSubscription.endDate && new Date(existingSubscription.endDate) > now
        ? new Date(new Date(existingSubscription.endDate).getTime() + durationDays * 24 * 60 * 60 * 1000)
        : endDate,
      isActive: true,
      updatedAt: now
    };

    // æ›´æ–°æ•°æ®åº“
    await db.table('vipSubscriptions').update(existingSubscription.id!, updatedSubscription);

    // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
    await addSyncItem('vipSubscriptions', 'update', updatedSubscription);

    return updatedSubscription;
  } else {
    // åˆ›å»ºæ–°çš„è®¢é˜…
    const newSubscription: VipSubscriptionRecord = {
      userId,
      tier,
      startDate: now,
      endDate,
      isActive: true,
      autoRenew: false,
      paymentMethod,
      transactionId,
      createdAt: now,
      updatedAt: now
    };

    // æ·»åŠ åˆ°æ•°æ®åº“
    const id = await db.table('vipSubscriptions').add(newSubscription);
    const createdSubscription = { ...newSubscription, id: id as number };

    // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
    await addSyncItem('vipSubscriptions', 'create', createdSubscription);

    return createdSubscription;
  }
}
</file>

<file path="src/services/subtaskService.ts">
// src/services/subtaskService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { TaskRecord, TaskStatus, updateTask } from './taskService';

// å­ä»»åŠ¡è®°å½•ç±»å‹
export interface SubtaskRecord {
  id?: number;
  parentTaskId: number;
  title: string;
  description?: string;
  status: TaskStatus;
  order: number;
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
}

/**
 * åˆ›å»ºå­ä»»åŠ¡
 * @param subtask å­ä»»åŠ¡æ•°æ®
 */
export async function createSubtask(
  subtask: Omit<SubtaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status' | 'order'>
): Promise<SubtaskRecord> {
  // è·å–çˆ¶ä»»åŠ¡
  const parentTask = await db.table('tasks').get(subtask.parentTaskId);
  if (!parentTask) {
    throw new Error(`Parent task with id ${subtask.parentTaskId} not found`);
  }

  // è·å–å½“å‰å­ä»»åŠ¡æ•°é‡ï¼Œç”¨äºè®¾ç½®é¡ºåº
  const existingSubtasks = await getSubtasks(subtask.parentTaskId);
  const order = existingSubtasks.length;

  const now = new Date();
  const newSubtask: SubtaskRecord = {
    ...subtask,
    status: TaskStatus.TODO,
    order,
    createdAt: now,
    updatedAt: now
  };

  // æ·»åŠ å­ä»»åŠ¡åˆ°æ•°æ®åº“
  const id = await db.table('subtasks').add(newSubtask);
  const createdSubtask = { ...newSubtask, id: id as number };

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('subtasks', 'create', createdSubtask);

  return createdSubtask;
}

/**
 * è·å–ä»»åŠ¡çš„æ‰€æœ‰å­ä»»åŠ¡
 * @param parentTaskId çˆ¶ä»»åŠ¡ID
 */
export async function getSubtasks(parentTaskId: number): Promise<SubtaskRecord[]> {
  return db.table('subtasks')
    .where('parentTaskId')
    .equals(parentTaskId)
    .sortBy('order');
}

/**
 * æ›´æ–°å­ä»»åŠ¡
 * @param id å­ä»»åŠ¡ID
 * @param updates æ›´æ–°æ•°æ®
 */
export async function updateSubtask(
  id: number,
  updates: Partial<Omit<SubtaskRecord, 'id' | 'parentTaskId' | 'createdAt'>>
): Promise<SubtaskRecord> {
  const subtask = await db.table('subtasks').get(id);
  if (!subtask) {
    throw new Error(`Subtask with id ${id} not found`);
  }

  const updatedSubtask = {
    ...subtask,
    ...updates,
    updatedAt: new Date()
  };

  // æ›´æ–°æ•°æ®åº“
  await db.table('subtasks').update(id, updatedSubtask);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('subtasks', 'update', updatedSubtask);

  // å¦‚æœçŠ¶æ€å˜ä¸ºå·²å®Œæˆï¼Œæ›´æ–°å®Œæˆæ—¶é—´
  if (updates.status === TaskStatus.COMPLETED && !updatedSubtask.completedAt) {
    updatedSubtask.completedAt = new Date();
    await db.table('subtasks').update(id, { completedAt: updatedSubtask.completedAt });
  }

  // æ›´æ–°çˆ¶ä»»åŠ¡è¿›åº¦
  await updateParentTaskProgress(subtask.parentTaskId);

  return updatedSubtask;
}

/**
 * å®Œæˆå­ä»»åŠ¡
 * @param id å­ä»»åŠ¡ID
 */
export async function completeSubtask(id: number): Promise<SubtaskRecord> {
  return updateSubtask(id, {
    status: TaskStatus.COMPLETED,
    completedAt: new Date()
  });
}

/**
 * åˆ é™¤å­ä»»åŠ¡
 * @param id å­ä»»åŠ¡ID
 */
export async function deleteSubtask(id: number): Promise<void> {
  const subtask = await db.table('subtasks').get(id);
  if (!subtask) {
    throw new Error(`Subtask with id ${id} not found`);
  }

  // åˆ é™¤å­ä»»åŠ¡
  await db.table('subtasks').delete(id);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('subtasks', 'delete', { id });

  // æ›´æ–°çˆ¶ä»»åŠ¡è¿›åº¦
  await updateParentTaskProgress(subtask.parentTaskId);

  // é‡æ–°æ’åºå‰©ä½™å­ä»»åŠ¡
  const remainingSubtasks = await getSubtasks(subtask.parentTaskId);
  for (let i = 0; i < remainingSubtasks.length; i++) {
    if (remainingSubtasks[i].order !== i) {
      await updateSubtask(remainingSubtasks[i].id!, { order: i });
    }
  }
}

/**
 * æ›´æ–°å­ä»»åŠ¡é¡ºåº
 * @param id å­ä»»åŠ¡ID
 * @param newOrder æ–°é¡ºåº
 */
export async function updateSubtaskOrder(id: number, newOrder: number): Promise<void> {
  const subtask = await db.table('subtasks').get(id);
  if (!subtask) {
    throw new Error(`Subtask with id ${id} not found`);
  }

  const oldOrder = subtask.order;
  if (oldOrder === newOrder) {
    return; // é¡ºåºæ²¡æœ‰å˜åŒ–
  }

  // è·å–æ‰€æœ‰åŒçº§å­ä»»åŠ¡
  const siblingSubtasks = await getSubtasks(subtask.parentTaskId);

  // æ›´æ–°å—å½±å“çš„å­ä»»åŠ¡é¡ºåº
  for (const sibling of siblingSubtasks) {
    if (sibling.id === id) {
      // æ›´æ–°å½“å‰å­ä»»åŠ¡çš„é¡ºåº
      await updateSubtask(id, { order: newOrder });
    } else if (
      (oldOrder < newOrder && sibling.order > oldOrder && sibling.order <= newOrder) ||
      (oldOrder > newOrder && sibling.order >= newOrder && sibling.order < oldOrder)
    ) {
      // æ›´æ–°å—å½±å“çš„å…¶ä»–å­ä»»åŠ¡é¡ºåº
      const newSiblingOrder = oldOrder < newOrder
        ? sibling.order - 1 // å‘ä¸Šç§»åŠ¨æ—¶ï¼Œä¸­é—´çš„å­ä»»åŠ¡é¡ºåºå‡1
        : sibling.order + 1; // å‘ä¸‹ç§»åŠ¨æ—¶ï¼Œä¸­é—´çš„å­ä»»åŠ¡é¡ºåºåŠ 1
      await updateSubtask(sibling.id!, { order: newSiblingOrder });
    }
  }
}

/**
 * æ›´æ–°çˆ¶ä»»åŠ¡è¿›åº¦
 * @param parentTaskId çˆ¶ä»»åŠ¡ID
 */
export async function updateParentTaskProgress(parentTaskId: number): Promise<void> {
  const subtasks = await getSubtasks(parentTaskId);
  if (subtasks.length === 0) {
    return;
  }

  // è®¡ç®—å®Œæˆçš„å­ä»»åŠ¡æ•°é‡
  const completedCount = subtasks.filter(
    subtask => subtask.status === TaskStatus.COMPLETED
  ).length;

  // è®¡ç®—è¿›åº¦ç™¾åˆ†æ¯”
  const progressPercentage = Math.round((completedCount / subtasks.length) * 100);

  // å¦‚æœæ‰€æœ‰å­ä»»åŠ¡éƒ½å®Œæˆï¼Œå°†çˆ¶ä»»åŠ¡æ ‡è®°ä¸ºå·²å®Œæˆ
  if (completedCount === subtasks.length) {
    await updateTask(parentTaskId, {
      status: TaskStatus.COMPLETED,
      completedAt: new Date()
    });
  } else if (completedCount > 0) {
    // å¦‚æœæœ‰éƒ¨åˆ†å­ä»»åŠ¡å®Œæˆï¼Œå°†çˆ¶ä»»åŠ¡æ ‡è®°ä¸ºè¿›è¡Œä¸­
    await updateTask(parentTaskId, {
      status: TaskStatus.IN_PROGRESS
    });
  }
}

/**
 * å°†ä»»åŠ¡è½¬æ¢ä¸ºå¸¦æœ‰å­ä»»åŠ¡çš„ä»»åŠ¡
 * @param taskId ä»»åŠ¡ID
 * @param subtaskTitles å­ä»»åŠ¡æ ‡é¢˜åˆ—è¡¨
 */
export async function convertTaskToParentTask(
  taskId: number,
  subtaskTitles: string[]
): Promise<SubtaskRecord[]> {
  const task = await db.table('tasks').get(taskId);
  if (!task) {
    throw new Error(`Task with id ${taskId} not found`);
  }

  const createdSubtasks: SubtaskRecord[] = [];

  // åˆ›å»ºå­ä»»åŠ¡
  for (let i = 0; i < subtaskTitles.length; i++) {
    const subtask = await createSubtask({
      parentTaskId: taskId,
      title: subtaskTitles[i]
    });
    createdSubtasks.push(subtask);
  }

  // å°†çˆ¶ä»»åŠ¡çŠ¶æ€æ›´æ–°ä¸ºè¿›è¡Œä¸­
  await updateTask(taskId, {
    status: TaskStatus.IN_PROGRESS
  });

  return createdSubtasks;
}

/**
 * æ£€æŸ¥ä»»åŠ¡æ˜¯å¦æœ‰å­ä»»åŠ¡
 * @param taskId ä»»åŠ¡ID
 */
export async function hasSubtasks(taskId: number): Promise<boolean> {
  const count = await db.table('subtasks')
    .where('parentTaskId')
    .equals(taskId)
    .count();
  return count > 0;
}
</file>

<file path="src/services/taskReminderService.ts">
// src/services/taskReminderService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { TaskRecord, getTask, getAllTasks, TaskStatus } from './taskService';

// ä»»åŠ¡æé†’è®°å½•ç±»å‹
export interface TaskReminderRecord {
  id?: number;
  taskId: number;
  userId: string;
  reminderTime: Date;
  isViewed: boolean;
  isCompleted: boolean;
  createdAt: Date;
  message?: string;
}

// æé†’ç±»å‹
export enum ReminderType {
  DUE_SOON = 'due_soon',      // å³å°†åˆ°æœŸ
  OVERDUE = 'overdue',        // å·²è¿‡æœŸ
  SCHEDULED = 'scheduled',    // è®¡åˆ’æé†’
  CUSTOM = 'custom'           // è‡ªå®šä¹‰æé†’
}

/**
 * åˆ›å»ºä»»åŠ¡æé†’
 * @param taskId ä»»åŠ¡ID
 * @param reminderTime æé†’æ—¶é—´
 * @param message è‡ªå®šä¹‰æ¶ˆæ¯ï¼ˆå¯é€‰ï¼‰
 */
export async function createTaskReminder(
  taskId: number,
  reminderTime: Date,
  message?: string
): Promise<TaskReminderRecord> {
  const now = new Date();

  // è·å–å½“å‰ç”¨æˆ·IDï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥ä»ç”¨æˆ·ä¼šè¯ä¸­è·å–ï¼‰
  const userId = 'current-user';

  const reminder: TaskReminderRecord = {
    taskId,
    userId,
    reminderTime,
    isViewed: false,
    isCompleted: false,
    createdAt: now,
    message
  };

  // æ·»åŠ åˆ°æ•°æ®åº“
  const id = await db.table('taskReminders').add(reminder);
  const createdReminder = { ...reminder, id: id as number };

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('taskReminders', 'create', createdReminder);

  return createdReminder;
}

/**
 * è·å–ä»»åŠ¡çš„æé†’
 * @param taskId ä»»åŠ¡ID
 */
export async function getTaskReminders(taskId: number): Promise<TaskReminderRecord[]> {
  return db.table('taskReminders')
    .where('taskId')
    .equals(taskId)
    .toArray();
}

/**
 * è·å–ç”¨æˆ·çš„æœªæŸ¥çœ‹æé†’
 * @param userId ç”¨æˆ·ID
 */
export async function getUnviewedReminders(userId: string): Promise<TaskReminderRecord[]> {
  return db.table('taskReminders')
    .where('userId')
    .equals(userId)
    .and(reminder => !reminder.isViewed)
    .toArray();
}

/**
 * è·å–ç”¨æˆ·çš„æ´»è·ƒæé†’ï¼ˆæœªæŸ¥çœ‹ä¸”æœªå®Œæˆï¼‰
 * @param userId ç”¨æˆ·ID
 */
export async function getActiveReminders(userId: string): Promise<TaskReminderRecord[]> {
  return db.table('taskReminders')
    .where('userId')
    .equals(userId)
    .and(reminder => !reminder.isViewed && !reminder.isCompleted)
    .toArray();
}

/**
 * æ ‡è®°æé†’ä¸ºå·²æŸ¥çœ‹
 * @param id æé†’ID
 */
export async function markReminderAsViewed(id: number): Promise<TaskReminderRecord> {
  const reminder = await db.table('taskReminders').get(id);
  if (!reminder) {
    throw new Error(`Reminder with id ${id} not found`);
  }

  const updatedReminder = {
    ...reminder,
    isViewed: true
  };

  // æ›´æ–°æ•°æ®åº“
  await db.table('taskReminders').update(id, updatedReminder);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('taskReminders', 'update', updatedReminder);

  return updatedReminder;
}

/**
 * æ ‡è®°æé†’ä¸ºå·²å®Œæˆ
 * @param id æé†’ID
 */
export async function markReminderAsCompleted(id: number): Promise<TaskReminderRecord> {
  const reminder = await db.table('taskReminders').get(id);
  if (!reminder) {
    throw new Error(`Reminder with id ${id} not found`);
  }

  const updatedReminder = {
    ...reminder,
    isViewed: true,
    isCompleted: true
  };

  // æ›´æ–°æ•°æ®åº“
  await db.table('taskReminders').update(id, updatedReminder);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('taskReminders', 'update', updatedReminder);

  return updatedReminder;
}

/**
 * åˆ é™¤æé†’
 * @param id æé†’ID
 */
export async function deleteReminder(id: number): Promise<void> {
  // æ£€æŸ¥æé†’æ˜¯å¦å­˜åœ¨
  const reminder = await db.table('taskReminders').get(id);
  if (!reminder) {
    throw new Error(`Reminder with id ${id} not found`);
  }

  // ä»æ•°æ®åº“ä¸­åˆ é™¤
  await db.table('taskReminders').delete(id);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('taskReminders', 'delete', { id });
}

/**
 * ä¸ºå³å°†åˆ°æœŸçš„ä»»åŠ¡åˆ›å»ºæé†’
 * æ£€æŸ¥æœªå®Œæˆçš„ä»»åŠ¡ï¼Œå¦‚æœä»»åŠ¡å³å°†åˆ°æœŸï¼ˆ24å°æ—¶å†…ï¼‰ï¼Œåˆ›å»ºæé†’
 */
export async function checkDueSoonTasks(): Promise<void> {
  // è·å–å½“å‰ç”¨æˆ·IDï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥ä»ç”¨æˆ·ä¼šè¯ä¸­è·å–ï¼‰
  const userId = 'current-user';

  // è·å–æ‰€æœ‰æœªå®Œæˆçš„ä»»åŠ¡
  const tasks = await getAllTasks({ status: TaskStatus.TODO });

  // å½“å‰æ—¶é—´
  const now = new Date();

  // 24å°æ—¶å
  const tomorrow = new Date(now);
  tomorrow.setHours(tomorrow.getHours() + 24);

  // æ£€æŸ¥æ¯ä¸ªä»»åŠ¡
  for (const task of tasks) {
    // å¦‚æœä»»åŠ¡æœ‰æˆªæ­¢æ—¥æœŸä¸”åœ¨24å°æ—¶å†…
    if (task.dueDate && new Date(task.dueDate) <= tomorrow && new Date(task.dueDate) > now) {
      // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰æé†’
      const reminders = await getTaskReminders(task.id!);
      const hasDueSoonReminder = reminders.some(r =>
        r.message?.includes('å³å°†åˆ°æœŸ') ||
        (r.reminderTime >= now && r.reminderTime <= tomorrow)
      );

      // å¦‚æœæ²¡æœ‰æé†’ï¼Œåˆ›å»ºä¸€ä¸ª
      if (!hasDueSoonReminder) {
        await createTaskReminder(
          task.id!,
          new Date(task.dueDate),
          `ä»»åŠ¡"${task.title}"å³å°†åˆ°æœŸï¼Œè¯·å°½å¿«å®Œæˆã€‚`
        );
      }
    }
  }
}

/**
 * ä¸ºå·²è¿‡æœŸçš„ä»»åŠ¡åˆ›å»ºæé†’
 * æ£€æŸ¥æœªå®Œæˆçš„ä»»åŠ¡ï¼Œå¦‚æœä»»åŠ¡å·²è¿‡æœŸï¼Œåˆ›å»ºæé†’
 */
export async function checkOverdueTasks(): Promise<void> {
  // è·å–å½“å‰ç”¨æˆ·IDï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥ä»ç”¨æˆ·ä¼šè¯ä¸­è·å–ï¼‰
  const userId = 'current-user';

  // è·å–æ‰€æœ‰æœªå®Œæˆçš„ä»»åŠ¡
  const tasks = await getAllTasks({ status: TaskStatus.TODO });

  // å½“å‰æ—¶é—´
  const now = new Date();

  // æ£€æŸ¥æ¯ä¸ªä»»åŠ¡
  for (const task of tasks) {
    // å¦‚æœä»»åŠ¡æœ‰æˆªæ­¢æ—¥æœŸä¸”å·²è¿‡æœŸ
    if (task.dueDate && new Date(task.dueDate) < now) {
      // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰æé†’
      const reminders = await getTaskReminders(task.id!);
      const hasOverdueReminder = reminders.some(r =>
        r.message?.includes('å·²è¿‡æœŸ') &&
        new Date(r.createdAt) > new Date(task.dueDate!)
      );

      // å¦‚æœæ²¡æœ‰æé†’ï¼Œåˆ›å»ºä¸€ä¸ª
      if (!hasOverdueReminder) {
        await createTaskReminder(
          task.id!,
          now,
          `ä»»åŠ¡"${task.title}"å·²è¿‡æœŸï¼Œè¯·åŠæ—¶å¤„ç†ã€‚`
        );
      }
    }
  }
}

/**
 * ä¸ºè®¡åˆ’ä»»åŠ¡åˆ›å»ºæé†’
 * @param taskId ä»»åŠ¡ID
 * @param reminderTime æé†’æ—¶é—´
 */
export async function scheduleTaskReminder(
  taskId: number,
  reminderTime: Date
): Promise<TaskReminderRecord> {
  // è·å–ä»»åŠ¡
  const task = await getTask(taskId);
  if (!task) {
    throw new Error(`Task with id ${taskId} not found`);
  }

  // åˆ›å»ºæé†’
  return createTaskReminder(
    taskId,
    reminderTime,
    `è®¡åˆ’æé†’ï¼šä»»åŠ¡"${task.title}"éœ€è¦å¤„ç†ã€‚`
  );
}

/**
 * åˆ›å»ºè‡ªå®šä¹‰æé†’
 * @param taskId ä»»åŠ¡ID
 * @param reminderTime æé†’æ—¶é—´
 * @param message è‡ªå®šä¹‰æ¶ˆæ¯
 */
export async function createCustomReminder(
  taskId: number,
  reminderTime: Date,
  message: string
): Promise<TaskReminderRecord> {
  return createTaskReminder(taskId, reminderTime, message);
}
</file>

<file path="src/services/timelyRewardService.ts">
// src/services/timelyRewardService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import { generateRewards, RewardRecord, RewardRarity } from './rewardService';
import { TaskRecord, TaskStatus } from './taskService';

// åŠæ—¶å¥–åŠ±çŠ¶æ€æšä¸¾
export enum TimelyRewardStatus {
  ACTIVE = 'active',         // æ´»è·ƒä¸­
  COMPLETED = 'completed',   // å·²å®Œæˆ
  EXPIRED = 'expired',       // å·²è¿‡æœŸ
  UPCOMING = 'upcoming'      // å³å°†å¼€å§‹
}

// åŠæ—¶å¥–åŠ±ç±»å‹æšä¸¾
export enum TimelyRewardType {
  DAILY = 'daily',           // æ¯æ—¥å¥–åŠ±
  MORNING = 'morning',       // æ—©èµ·é¸Ÿå¥–åŠ±
  STREAK = 'streak',         // è¿ç»­å®Œæˆå¥–åŠ±
  SPECIAL = 'special'        // ç‰¹æ®Šå¥–åŠ±
}

// åŠæ—¶å¥–åŠ±è®°å½•ç±»å‹
export interface TimelyRewardRecord {
  id?: number;               // å¥–åŠ±ID
  title: string;             // å¥–åŠ±æ ‡é¢˜
  description: string;       // å¥–åŠ±æè¿°
  type: TimelyRewardType;    // å¥–åŠ±ç±»å‹
  status: TimelyRewardStatus; // å¥–åŠ±çŠ¶æ€
  progress: number;          // è¿›åº¦ï¼ˆ0-100ï¼‰
  startTime: Date;           // å¼€å§‹æ—¶é—´
  endTime: Date;             // ç»“æŸæ—¶é—´
  completedTime?: Date;      // å®Œæˆæ—¶é—´
  luckyPoints: number;       // å¹¸è¿ç‚¹æ•°
  taskIds?: number[];        // å…³è”çš„ä»»åŠ¡IDåˆ—è¡¨
  rewardIds?: number[];      // å¥–åŠ±IDåˆ—è¡¨
  iconPath: string;          // å›¾æ ‡è·¯å¾„
  createdAt: Date;           // åˆ›å»ºæ—¶é—´
  updatedAt: Date;           // æ›´æ–°æ—¶é—´
}

// å¹¸è¿ç‚¹è®°å½•ç±»å‹
export interface LuckyPointRecord {
  id?: number;               // è®°å½•ID
  userId: string;            // ç”¨æˆ·ID
  amount: number;            // ç‚¹æ•°æ•°é‡
  source: string;            // æ¥æº
  timestamp: Date;           // æ—¶é—´æˆ³
  expiryDate?: Date;         // è¿‡æœŸæ—¥æœŸ
  isSpent: boolean;          // æ˜¯å¦å·²ä½¿ç”¨
  createdAt: Date;           // åˆ›å»ºæ—¶é—´
}

// å¹¸è¿æŠ½å¥–è®°å½•ç±»å‹
export interface LuckyDrawRecord {
  id?: number;               // è®°å½•ID
  userId: string;            // ç”¨æˆ·ID
  pointsSpent: number;       // ä½¿ç”¨çš„ç‚¹æ•°
  rewards: RewardRecord[];   // è·å¾—çš„å¥–åŠ±
  timestamp: Date;           // æ—¶é—´æˆ³
  createdAt: Date;           // åˆ›å»ºæ—¶é—´
}

// å¥–å“å±‚çº§
export enum PrizeLevel {
  COMMON = 'common',         // æ™®é€š
  UNCOMMON = 'uncommon',     // ä¸å¸¸è§
  RARE = 'rare',             // ç¨€æœ‰
  EPIC = 'epic',             // å²è¯—
  LEGENDARY = 'legendary'    // ä¼ è¯´
}

// å¥–å“å±‚çº§æ¦‚ç‡é…ç½®
const PRIZE_LEVEL_PROBABILITIES = {
  [PrizeLevel.COMMON]: 0.6,      // 60%
  [PrizeLevel.UNCOMMON]: 0.25,   // 25%
  [PrizeLevel.RARE]: 0.1,        // 10%
  [PrizeLevel.EPIC]: 0.04,       // 4%
  [PrizeLevel.LEGENDARY]: 0.01   // 1%
};

// å¥–å“å±‚çº§å¯¹åº”çš„å¥–åŠ±ç¨€æœ‰åº¦
const PRIZE_LEVEL_TO_RARITY: Record<PrizeLevel, string> = {
  [PrizeLevel.COMMON]: 'common',
  [PrizeLevel.UNCOMMON]: 'uncommon',
  [PrizeLevel.RARE]: 'rare',
  [PrizeLevel.EPIC]: 'epic',
  [PrizeLevel.LEGENDARY]: 'legendary'
};

/**
 * åˆå§‹åŒ–åŠæ—¶å¥–åŠ±ç³»ç»Ÿ
 */
export async function initializeTimelyRewards(): Promise<void> {
  // æ£€æŸ¥æ˜¯å¦å·²æœ‰åŠæ—¶å¥–åŠ±
  const count = await db.table('timelyRewards').count();

  if (count === 0) {
    // åˆ›å»ºé»˜è®¤çš„åŠæ—¶å¥–åŠ±
    await createDailyTimelyReward();
    await createMorningTimelyReward();
  }
}

/**
 * åˆ›å»ºæ¯æ—¥åŠæ—¶å¥–åŠ±
 */
async function createDailyTimelyReward(): Promise<TimelyRewardRecord> {
  const now = new Date();
  const startTime = new Date(now);
  startTime.setHours(9, 0, 0, 0); // æ¯å¤©9ç‚¹å¼€å§‹

  const endTime = new Date(now);
  endTime.setHours(21, 0, 0, 0); // æ¯å¤©21ç‚¹ç»“æŸ

  // å¦‚æœå½“å‰æ—¶é—´å·²ç»è¶…è¿‡ä»Šå¤©çš„ç»“æŸæ—¶é—´ï¼Œåˆ™è®¾ç½®ä¸ºæ˜å¤©
  if (now > endTime) {
    startTime.setDate(startTime.getDate() + 1);
    endTime.setDate(endTime.getDate() + 1);
  }

  const dailyReward: TimelyRewardRecord = {
    title: 'æ¯æ—¥åŠæ—¶å®Œæˆ',
    description: 'åœ¨è§„å®šæ—¶é—´å†…å®Œæˆä»»åŠ¡ï¼Œè·å¾—é¢å¤–å¥–åŠ±',
    type: TimelyRewardType.DAILY,
    status: TimelyRewardStatus.ACTIVE,
    progress: 0,
    startTime,
    endTime,
    luckyPoints: 10,
    iconPath: '/assets/rewards/daily-reward.svg',
    createdAt: now,
    updatedAt: now
  };

  const id = await db.table('timelyRewards').add(dailyReward);
  const newReward = { ...dailyReward, id: id as number };

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('timelyRewards', 'create', newReward);

  return newReward;
}

/**
 * åˆ›å»ºæ—©èµ·é¸ŸåŠæ—¶å¥–åŠ±
 */
async function createMorningTimelyReward(): Promise<TimelyRewardRecord> {
  const now = new Date();
  const startTime = new Date(now);
  startTime.setHours(5, 0, 0, 0); // æ¯å¤©5ç‚¹å¼€å§‹

  const endTime = new Date(now);
  endTime.setHours(9, 0, 0, 0); // æ¯å¤©9ç‚¹ç»“æŸ

  // å¦‚æœå½“å‰æ—¶é—´å·²ç»è¶…è¿‡ä»Šå¤©çš„ç»“æŸæ—¶é—´ï¼Œåˆ™è®¾ç½®ä¸ºæ˜å¤©
  if (now > endTime) {
    startTime.setDate(startTime.getDate() + 1);
    endTime.setDate(endTime.getDate() + 1);
  }

  const morningReward: TimelyRewardRecord = {
    title: 'æ—©èµ·é¸Ÿå¥–åŠ±',
    description: 'æ—©èµ·å®Œæˆä»»åŠ¡ï¼Œè·å¾—é¢å¤–å¥–åŠ±',
    type: TimelyRewardType.MORNING,
    status: TimelyRewardStatus.ACTIVE,
    progress: 0,
    startTime,
    endTime,
    luckyPoints: 15,
    iconPath: '/assets/rewards/morning-reward.svg',
    createdAt: now,
    updatedAt: now
  };

  const id = await db.table('timelyRewards').add(morningReward);
  const newReward = { ...morningReward, id: id as number };

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('timelyRewards', 'create', newReward);

  return newReward;
}

/**
 * è·å–æ‰€æœ‰åŠæ—¶å¥–åŠ±
 * @param filter è¿‡æ»¤æ¡ä»¶
 */
export async function getAllTimelyRewards(filter?: {
  status?: TimelyRewardStatus;
  type?: TimelyRewardType;
}): Promise<TimelyRewardRecord[]> {
  let collection = db.table('timelyRewards').toCollection();

  if (filter) {
    if (filter.status) {
      collection = collection.filter(reward => reward.status === filter.status);
    }
    if (filter.type) {
      collection = collection.filter(reward => reward.type === filter.type);
    }
  }

  return collection.toArray();
}

/**
 * è·å–å•ä¸ªåŠæ—¶å¥–åŠ±
 * @param id å¥–åŠ±ID
 */
export async function getTimelyReward(id: number): Promise<TimelyRewardRecord | undefined> {
  return db.table('timelyRewards').get(id);
}

/**
 * æ›´æ–°åŠæ—¶å¥–åŠ±è¿›åº¦
 * @param id å¥–åŠ±ID
 * @param progress è¿›åº¦å€¼ï¼ˆ0-100ï¼‰
 */
export async function updateTimelyRewardProgress(id: number, progress: number): Promise<TimelyRewardRecord> {
  const reward = await db.table('timelyRewards').get(id);

  if (!reward) {
    throw new Error(`Timely reward with id ${id} not found`);
  }

  // ç¡®ä¿è¿›åº¦åœ¨0-100èŒƒå›´å†…
  const validProgress = Math.max(0, Math.min(100, progress));

  // å¦‚æœè¿›åº¦è¾¾åˆ°100%ï¼Œå°†çŠ¶æ€æ›´æ–°ä¸ºå·²å®Œæˆ
  let status = reward.status;
  let completedTime = reward.completedTime;

  if (validProgress >= 100 && status !== TimelyRewardStatus.COMPLETED) {
    status = TimelyRewardStatus.COMPLETED;
    completedTime = new Date();
  }

  const updatedReward = {
    ...reward,
    progress: validProgress,
    status,
    completedTime,
    updatedAt: new Date()
  };

  await db.table('timelyRewards').update(id, updatedReward);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('timelyRewards', 'update', updatedReward);

  return updatedReward;
}

/**
 * å®ŒæˆåŠæ—¶å¥–åŠ±
 * @param id å¥–åŠ±ID
 */
export async function completeTimelyReward(id: number): Promise<RewardRecord[]> {
  const reward = await db.table('timelyRewards').get(id);

  if (!reward) {
    throw new Error(`Timely reward with id ${id} not found`);
  }

  if (reward.status === TimelyRewardStatus.COMPLETED) {
    throw new Error(`Timely reward with id ${id} is already completed`);
  }

  // æ£€æŸ¥æ˜¯å¦åœ¨æœ‰æ•ˆæ—¶é—´èŒƒå›´å†…
  const now = new Date();
  if (now < reward.startTime || now > reward.endTime) {
    throw new Error(`Timely reward with id ${id} is not active`);
  }

  // æ›´æ–°å¥–åŠ±çŠ¶æ€
  const updatedReward = {
    ...reward,
    status: TimelyRewardStatus.COMPLETED,
    progress: 100,
    completedTime: now,
    updatedAt: now
  };

  await db.table('timelyRewards').update(id, updatedReward);

  // ç”Ÿæˆå¥–åŠ±
  const rewards = await generateRewards(2, 'uncommon' as RewardRarity);

  // æ·»åŠ å¹¸è¿ç‚¹
  await addLuckyPoints(reward.luckyPoints, `å®ŒæˆåŠæ—¶å¥–åŠ±: ${reward.title}`);

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('timelyRewards', 'update', updatedReward);

  return rewards;
}

/**
 * æ·»åŠ å¹¸è¿ç‚¹
 * @param amount ç‚¹æ•°æ•°é‡
 * @param source æ¥æº
 */
export async function addLuckyPoints(amount: number, source: string): Promise<LuckyPointRecord> {
  const now = new Date();

  // è®¾ç½®è¿‡æœŸæ—¥æœŸä¸º30å¤©å
  const expiryDate = new Date(now);
  expiryDate.setDate(expiryDate.getDate() + 30);

  const luckyPoint: LuckyPointRecord = {
    userId: 'current-user', // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥æ˜¯å½“å‰ç”¨æˆ·çš„ID
    amount,
    source,
    timestamp: now,
    expiryDate,
    isSpent: false,
    createdAt: now
  };

  const id = await db.table('luckyPoints').add(luckyPoint);
  const newLuckyPoint = { ...luckyPoint, id: id as number };

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('luckyPoints', 'create', newLuckyPoint);

  return newLuckyPoint;
}

/**
 * è·å–ç”¨æˆ·çš„å¹¸è¿ç‚¹æ€»æ•°
 */
export async function getLuckyPointsTotal(): Promise<number> {
  const points = await db.table('luckyPoints')
    .where('userId')
    .equals('current-user')
    .and(point => !point.isSpent)
    .and(point => !point.expiryDate || point.expiryDate > new Date())
    .toArray();

  return points.reduce((total, point) => total + point.amount, 0);
}

/**
 * è¿›è¡Œå¹¸è¿æŠ½å¥–
 * @param pointsToSpend è¦ä½¿ç”¨çš„ç‚¹æ•°
 */
export async function performLuckyDraw(pointsToSpend: number): Promise<LuckyDrawRecord> {
  // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰è¶³å¤Ÿçš„ç‚¹æ•°
  const totalPoints = await getLuckyPointsTotal();
  if (totalPoints < pointsToSpend) {
    throw new Error(`Not enough lucky points. Required: ${pointsToSpend}, Available: ${totalPoints}`);
  }

  // ç¡®å®šå¥–å“å±‚çº§
  const prizeLevel = determinePrizeLevel();

  // ç”Ÿæˆå¥–åŠ±
  const rarityString = PRIZE_LEVEL_TO_RARITY[prizeLevel];
  const rarity = rarityString as RewardRarity;
  const rewards = await generateRewards(1, rarity);

  // ä½¿ç”¨å¹¸è¿ç‚¹
  await spendLuckyPoints(pointsToSpend);

  const now = new Date();
  const luckyDraw: LuckyDrawRecord = {
    userId: 'current-user',
    pointsSpent: pointsToSpend,
    rewards,
    timestamp: now,
    createdAt: now
  };

  const id = await db.table('luckyDraws').add(luckyDraw);
  const newLuckyDraw = { ...luckyDraw, id: id as number };

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('luckyDraws', 'create', newLuckyDraw);

  return newLuckyDraw;
}

/**
 * ä½¿ç”¨å¹¸è¿ç‚¹
 * @param amount è¦ä½¿ç”¨çš„ç‚¹æ•°æ•°é‡
 */
async function spendLuckyPoints(amount: number): Promise<void> {
  // è·å–æœªä½¿ç”¨çš„å¹¸è¿ç‚¹
  const points = await db.table('luckyPoints')
    .where('userId')
    .equals('current-user')
    .and(point => !point.isSpent)
    .and(point => !point.expiryDate || point.expiryDate > new Date())
    .sortBy('expiryDate'); // å…ˆä½¿ç”¨å¿«è¿‡æœŸçš„ç‚¹æ•°

  let remainingAmount = amount;

  for (const point of points) {
    if (remainingAmount <= 0) break;

    if (point.amount <= remainingAmount) {
      // å¦‚æœå½“å‰ç‚¹æ•°è®°å½•å°äºç­‰äºå‰©ä½™éœ€è¦ä½¿ç”¨çš„ç‚¹æ•°ï¼Œåˆ™å…¨éƒ¨ä½¿ç”¨
      await db.table('luckyPoints').update(point.id!, { isSpent: true });
      await addSyncItem('luckyPoints', 'update', { ...point, isSpent: true });
      remainingAmount -= point.amount;
    } else {
      // å¦‚æœå½“å‰ç‚¹æ•°è®°å½•å¤§äºå‰©ä½™éœ€è¦ä½¿ç”¨çš„ç‚¹æ•°ï¼Œåˆ™æ‹†åˆ†è®°å½•
      await db.table('luckyPoints').update(point.id!, { amount: point.amount - remainingAmount });
      await addSyncItem('luckyPoints', 'update', { ...point, amount: point.amount - remainingAmount });

      // åˆ›å»ºä¸€ä¸ªæ–°çš„å·²ä½¿ç”¨è®°å½•
      const spentPoint: LuckyPointRecord = {
        userId: point.userId,
        amount: remainingAmount,
        source: point.source,
        timestamp: point.timestamp,
        expiryDate: point.expiryDate,
        isSpent: true,
        createdAt: new Date()
      };

      await db.table('luckyPoints').add(spentPoint);
      await addSyncItem('luckyPoints', 'create', spentPoint);

      remainingAmount = 0;
    }
  }

  if (remainingAmount > 0) {
    throw new Error(`Not enough lucky points. Required: ${amount}, Used: ${amount - remainingAmount}`);
  }
}

/**
 * ç¡®å®šå¥–å“å±‚çº§
 */
function determinePrizeLevel(): PrizeLevel {
  const random = Math.random();
  let cumulativeProbability = 0;

  for (const [level, probability] of Object.entries(PRIZE_LEVEL_PROBABILITIES)) {
    cumulativeProbability += probability;
    if (random <= cumulativeProbability) {
      return level as PrizeLevel;
    }
  }

  return PrizeLevel.COMMON; // é»˜è®¤è¿”å›æ™®é€šå±‚çº§
}

/**
 * æ£€æŸ¥ä»»åŠ¡æ˜¯å¦åœ¨åŠæ—¶å¥–åŠ±æ—¶é—´çª—å£å†…
 * @param task ä»»åŠ¡
 */
export async function checkTaskForTimelyReward(task: TaskRecord): Promise<TimelyRewardRecord | null> {
  if (task.status !== TaskStatus.COMPLETED) {
    return null;
  }

  const now = new Date();

  // è·å–æ´»è·ƒçš„åŠæ—¶å¥–åŠ±
  const activeRewards = await db.table('timelyRewards')
    .where('status')
    .equals(TimelyRewardStatus.ACTIVE)
    .toArray();

  // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦åœ¨ä»»ä½•åŠæ—¶å¥–åŠ±çš„æ—¶é—´çª—å£å†…
  for (const reward of activeRewards) {
    if (now >= reward.startTime && now <= reward.endTime) {
      // æ›´æ–°åŠæ—¶å¥–åŠ±è¿›åº¦
      const updatedReward = await updateTimelyRewardProgress(
        reward.id!,
        reward.progress + 20 // æ¯å®Œæˆä¸€ä¸ªä»»åŠ¡å¢åŠ 20%çš„è¿›åº¦
      );

      return updatedReward;
    }
  }

  return null;
}

/**
 * æ›´æ–°åŠæ—¶å¥–åŠ±çŠ¶æ€
 * æ£€æŸ¥æ‰€æœ‰åŠæ—¶å¥–åŠ±ï¼Œæ›´æ–°å®ƒä»¬çš„çŠ¶æ€ï¼ˆè¿‡æœŸã€å³å°†å¼€å§‹ç­‰ï¼‰
 */
export async function updateTimelyRewardsStatus(): Promise<void> {
  const now = new Date();

  // è·å–æ‰€æœ‰åŠæ—¶å¥–åŠ±
  const rewards = await db.table('timelyRewards').toArray();

  for (const reward of rewards) {
    let newStatus = reward.status;

    // å¦‚æœå·²ç»å®Œæˆï¼Œåˆ™è·³è¿‡
    if (reward.status === TimelyRewardStatus.COMPLETED) {
      continue;
    }

    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (now > reward.endTime) {
      newStatus = TimelyRewardStatus.EXPIRED;
    }
    // æ£€æŸ¥æ˜¯å¦æ´»è·ƒ
    else if (now >= reward.startTime && now <= reward.endTime) {
      newStatus = TimelyRewardStatus.ACTIVE;
    }
    // æ£€æŸ¥æ˜¯å¦å³å°†å¼€å§‹
    else if (now < reward.startTime) {
      newStatus = TimelyRewardStatus.UPCOMING;
    }

    // å¦‚æœçŠ¶æ€æœ‰å˜åŒ–ï¼Œåˆ™æ›´æ–°
    if (newStatus !== reward.status) {
      const updatedReward = {
        ...reward,
        status: newStatus,
        updatedAt: now
      };

      await db.table('timelyRewards').update(reward.id!, updatedReward);
      await addSyncItem('timelyRewards', 'update', updatedReward);
    }
  }
}
</file>

<file path="src/types/dataRefresh.ts">
// src/types/dataRefresh.ts

/**
 * æ•°æ®åˆ·æ–°äº‹ä»¶ç±»å‹
 */
export interface DataRefreshEvent {
  table: string;
  data?: any;
}
</file>

<file path="src/utils/animation.ts">
// src/utils/animation.ts
import { Variants } from 'framer-motion';

/**
 * æ·¡å…¥åŠ¨ç”»å˜ä½“
 */
export const fadeIn: Variants = {
  hidden: { opacity: 0 },
  visible: { 
    opacity: 1,
    transition: { duration: 0.5 }
  },
  exit: { 
    opacity: 0,
    transition: { duration: 0.3 }
  }
};

/**
 * ä»ä¸‹æ–¹æ»‘å…¥åŠ¨ç”»å˜ä½“
 */
export const slideUp: Variants = {
  hidden: { 
    opacity: 0, 
    y: 20 
  },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: { 
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  },
  exit: { 
    opacity: 0, 
    y: 20,
    transition: { duration: 0.2 }
  }
};

/**
 * ä»å·¦ä¾§æ»‘å…¥åŠ¨ç”»å˜ä½“
 */
export const slideInLeft: Variants = {
  hidden: { 
    opacity: 0, 
    x: -50 
  },
  visible: { 
    opacity: 1, 
    x: 0,
    transition: { 
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  },
  exit: { 
    opacity: 0, 
    x: -50,
    transition: { duration: 0.2 }
  }
};

/**
 * ä»å³ä¾§æ»‘å…¥åŠ¨ç”»å˜ä½“
 */
export const slideInRight: Variants = {
  hidden: { 
    opacity: 0, 
    x: 50 
  },
  visible: { 
    opacity: 1, 
    x: 0,
    transition: { 
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  },
  exit: { 
    opacity: 0, 
    x: 50,
    transition: { duration: 0.2 }
  }
};

/**
 * ç¼©æ”¾åŠ¨ç”»å˜ä½“
 */
export const scale: Variants = {
  hidden: { 
    opacity: 0, 
    scale: 0.8 
  },
  visible: { 
    opacity: 1, 
    scale: 1,
    transition: { 
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  },
  exit: { 
    opacity: 0, 
    scale: 0.8,
    transition: { duration: 0.2 }
  }
};

/**
 * å¼¹è·³åŠ¨ç”»å˜ä½“
 */
export const bounce: Variants = {
  hidden: { 
    opacity: 0, 
    y: 50,
    scale: 0.9
  },
  visible: { 
    opacity: 1, 
    y: 0,
    scale: 1,
    transition: { 
      type: 'spring', 
      stiffness: 400, 
      damping: 10 
    }
  },
  exit: { 
    opacity: 0, 
    y: 20,
    transition: { duration: 0.2 }
  }
};

/**
 * æ°´å¢¨æ•ˆæœåŠ¨ç”»å˜ä½“
 */
export const inkSplash: Variants = {
  hidden: { 
    opacity: 0, 
    scale: 0.1,
    filter: 'blur(10px)'
  },
  visible: { 
    opacity: 1, 
    scale: 1,
    filter: 'blur(0px)',
    transition: { 
      duration: 0.5,
      ease: [0.25, 0.1, 0.25, 1]
    }
  },
  exit: { 
    opacity: 0, 
    scale: 1.2,
    filter: 'blur(10px)',
    transition: { duration: 0.3 }
  }
};

/**
 * ç«¹å¶æ‘‡æ‘†åŠ¨ç”»å˜ä½“
 */
export const bambooSway: Variants = {
  hidden: { 
    opacity: 0, 
    rotate: -5,
    y: 20
  },
  visible: { 
    opacity: 1, 
    rotate: 0,
    y: 0,
    transition: { 
      type: 'spring', 
      stiffness: 100, 
      damping: 10 
    }
  },
  exit: { 
    opacity: 0, 
    rotate: 5,
    y: -20,
    transition: { duration: 0.3 }
  }
};

/**
 * é‡‘å…‰é—ªçƒåŠ¨ç”»å˜ä½“
 */
export const goldenGlow: Variants = {
  hidden: { 
    opacity: 0, 
    filter: 'brightness(0.8) saturate(0.8)'
  },
  visible: { 
    opacity: 1, 
    filter: 'brightness(1.2) saturate(1.2)',
    transition: { 
      duration: 0.5,
      ease: [0.25, 0.1, 0.25, 1]
    }
  },
  exit: { 
    opacity: 0, 
    filter: 'brightness(1.5) saturate(1.5)',
    transition: { duration: 0.3 }
  }
};

/**
 * åˆ—è¡¨é¡¹åŠ¨ç”»å˜ä½“ï¼ˆç”¨äºåˆ—è¡¨ä¸­çš„é¡¹ç›®ï¼Œå¸¦æœ‰äº¤é”™æ•ˆæœï¼‰
 */
export const listItem: Variants = {
  hidden: { 
    opacity: 0, 
    y: 20 
  },
  visible: (i: number) => ({ 
    opacity: 1, 
    y: 0,
    transition: { 
      delay: i * 0.1,
      type: 'spring', 
      stiffness: 300, 
      damping: 24 
    }
  }),
  exit: { 
    opacity: 0, 
    y: 20,
    transition: { duration: 0.2 }
  }
};

/**
 * é¡µé¢è¿‡æ¸¡åŠ¨ç”»å˜ä½“
 */
export const pageTransition: Variants = {
  hidden: { 
    opacity: 0, 
    y: 20 
  },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: { 
      duration: 0.5,
      ease: [0.25, 0.1, 0.25, 1]
    }
  },
  exit: { 
    opacity: 0, 
    y: -20,
    transition: { duration: 0.3 }
  }
};

/**
 * åˆ›å»ºå¸¦æœ‰å»¶è¿Ÿçš„å®¹å™¨åŠ¨ç”»å˜ä½“
 * @param staggerChildren å­å…ƒç´ ä¹‹é—´çš„å»¶è¿Ÿæ—¶é—´
 * @param delayChildren æ‰€æœ‰å­å…ƒç´ çš„åˆå§‹å»¶è¿Ÿ
 */
export const createContainerVariants = (
  staggerChildren = 0.1, 
  delayChildren = 0
): Variants => ({
  hidden: { opacity: 0 },
  visible: { 
    opacity: 1,
    transition: { 
      staggerChildren,
      delayChildren
    }
  },
  exit: { 
    opacity: 0,
    transition: { 
      staggerChildren: 0.05,
      staggerDirection: -1
    }
  }
});
</file>

<file path="src/utils/dateUtils.ts">
// src/utils/dateUtils.ts

/**
 * æ ¼å¼åŒ–æ—¥æœŸä¸ºæ˜“è¯»çš„å­—ç¬¦ä¸²ï¼ˆä¸åŒ…å«æ—¶é—´ï¼‰
 * @param dateString æ—¥æœŸå­—ç¬¦ä¸²æˆ–Dateå¯¹è±¡
 * @returns æ ¼å¼åŒ–åçš„æ—¥æœŸå­—ç¬¦ä¸²
 */
export function formatDate(dateString: string | Date): string {
  return formatTime(dateString, false);
}

/**
 * æ ¼å¼åŒ–æ—¥æœŸæ—¶é—´ä¸ºæ˜“è¯»çš„å­—ç¬¦ä¸²
 * @param dateString æ—¥æœŸå­—ç¬¦ä¸²æˆ–Dateå¯¹è±¡
 * @param includeTime æ˜¯å¦åŒ…å«æ—¶é—´éƒ¨åˆ†
 * @returns æ ¼å¼åŒ–åçš„æ—¥æœŸæ—¶é—´å­—ç¬¦ä¸²
 */
export function formatTime(dateString: string | Date, includeTime: boolean = true): string {
  if (!dateString) return '';

  const date = typeof dateString === 'string' ? new Date(dateString) : dateString;

  // æ£€æŸ¥æ—¥æœŸæ˜¯å¦æœ‰æ•ˆ
  if (isNaN(date.getTime())) {
    return 'Invalid Date';
  }

  // æ ¼å¼åŒ–æ—¥æœŸéƒ¨åˆ†
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');

  const dateFormatted = `${year}-${month}-${day}`;

  // å¦‚æœä¸éœ€è¦æ—¶é—´éƒ¨åˆ†ï¼Œç›´æ¥è¿”å›æ—¥æœŸ
  if (!includeTime) {
    return dateFormatted;
  }

  // æ ¼å¼åŒ–æ—¶é—´éƒ¨åˆ†
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');

  return `${dateFormatted} ${hours}:${minutes}`;
}

/**
 * è®¡ç®—ä¸¤ä¸ªæ—¥æœŸä¹‹é—´çš„å¤©æ•°å·®
 * @param date1 ç¬¬ä¸€ä¸ªæ—¥æœŸ
 * @param date2 ç¬¬äºŒä¸ªæ—¥æœŸï¼Œé»˜è®¤ä¸ºå½“å‰æ—¥æœŸ
 * @returns å¤©æ•°å·®
 */
export function daysBetween(date1: Date | string, date2: Date | string = new Date()): number {
  const d1 = typeof date1 === 'string' ? new Date(date1) : date1;
  const d2 = typeof date2 === 'string' ? new Date(date2) : date2;

  // å°†æ—¶é—´éƒ¨åˆ†è®¾ç½®ä¸º0ï¼Œåªæ¯”è¾ƒæ—¥æœŸéƒ¨åˆ†
  d1.setHours(0, 0, 0, 0);
  d2.setHours(0, 0, 0, 0);

  // è®¡ç®—æ¯«ç§’å·®å¹¶è½¬æ¢ä¸ºå¤©æ•°
  const diffTime = Math.abs(d2.getTime() - d1.getTime());
  const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

  return diffDays;
}

/**
 * æ£€æŸ¥æ—¥æœŸæ˜¯å¦æ˜¯ä»Šå¤©
 * @param date è¦æ£€æŸ¥çš„æ—¥æœŸ
 * @returns æ˜¯å¦æ˜¯ä»Šå¤©
 */
export function isToday(date: Date | string): boolean {
  const today = new Date();
  const checkDate = typeof date === 'string' ? new Date(date) : date;

  return (
    checkDate.getDate() === today.getDate() &&
    checkDate.getMonth() === today.getMonth() &&
    checkDate.getFullYear() === today.getFullYear()
  );
}

/**
 * è·å–ç›¸å¯¹æ—¶é—´æè¿°ï¼ˆä¾‹å¦‚ï¼šåˆšåˆšã€5åˆ†é’Ÿå‰ã€1å°æ—¶å‰ç­‰ï¼‰
 * @param date æ—¥æœŸ
 * @returns ç›¸å¯¹æ—¶é—´æè¿°
 */
export function getRelativeTimeDescription(date: Date | string): string {
  const now = new Date();
  const targetDate = typeof date === 'string' ? new Date(date) : date;

  const diffMs = now.getTime() - targetDate.getTime();
  const diffSecs = Math.floor(diffMs / 1000);
  const diffMins = Math.floor(diffSecs / 60);
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);

  if (diffSecs < 60) {
    return 'åˆšåˆš';
  } else if (diffMins < 60) {
    return `${diffMins}åˆ†é’Ÿå‰`;
  } else if (diffHours < 24) {
    return `${diffHours}å°æ—¶å‰`;
  } else if (diffDays < 30) {
    return `${diffDays}å¤©å‰`;
  } else {
    return formatTime(targetDate, false);
  }
}
</file>

<file path="src/utils/sound.ts">
// src/utils/sound.ts
/**
 * å£°éŸ³å·¥å…·ç±»
 * ç”¨äºæ’­æ”¾æ¸¸æˆä¸­çš„å„ç§éŸ³æ•ˆ
 */

// éŸ³æ•ˆç±»å‹æšä¸¾
export enum SoundType {
  // å¥–åŠ±éŸ³æ•ˆ
  REWARD_COMMON = 'reward_common',
  REWARD_UNCOMMON = 'reward_uncommon',
  REWARD_RARE = 'reward_rare',
  REWARD_EPIC = 'reward_epic',
  REWARD_LEGENDARY = 'reward_legendary',

  // ä»»åŠ¡ç›¸å…³éŸ³æ•ˆ
  TASK_COMPLETE = 'task_complete',
  TASK_COMPLETE_HIGH = 'task_complete_high',
  TASK_COMPLETE_MAIN = 'task_complete_main',
  TASK_FAILED = 'task_failed',
  TASK_CREATED = 'task_created',

  // æŒ‘æˆ˜ç›¸å…³éŸ³æ•ˆ
  CHALLENGE_COMPLETE = 'challenge_complete',
  CHALLENGE_COMPLETE_EPIC = 'challenge_complete_epic',
  CHALLENGE_COMPLETE_LEGENDARY = 'challenge_complete_legendary',
  CHALLENGE_FAILED = 'challenge_failed',
  CHALLENGE_UNLOCKED = 'challenge_unlocked',

  // ç³»ç»ŸéŸ³æ•ˆ
  LEVEL_UP = 'level_up',
  ABILITY_UNLOCKED = 'ability_unlocked',
  ABILITY_ACTIVATED = 'ability_activated',
  BUTTON_CLICK = 'button_click',
  ERROR = 'error',
  SUCCESS = 'success',
  NOTIFICATION = 'notification'
}

// éŸ³æ•ˆæ–‡ä»¶è·¯å¾„æ˜ å°„
const soundPaths: Record<SoundType, string> = {
  // å¥–åŠ±éŸ³æ•ˆ
  [SoundType.REWARD_COMMON]: '/assets/sounds/reward_common.mp3',
  [SoundType.REWARD_UNCOMMON]: '/assets/sounds/reward_uncommon.mp3',
  [SoundType.REWARD_RARE]: '/assets/sounds/reward_rare.mp3',
  [SoundType.REWARD_EPIC]: '/assets/sounds/reward_epic.mp3',
  [SoundType.REWARD_LEGENDARY]: '/assets/sounds/reward_legendary.mp3',

  // ä»»åŠ¡ç›¸å…³éŸ³æ•ˆ
  [SoundType.TASK_COMPLETE]: '/assets/sounds/task_complete.mp3',
  [SoundType.TASK_COMPLETE_HIGH]: '/assets/sounds/task_complete_high.mp3',
  [SoundType.TASK_COMPLETE_MAIN]: '/assets/sounds/task_complete_main.mp3',
  [SoundType.TASK_FAILED]: '/assets/sounds/task_failed.mp3',
  [SoundType.TASK_CREATED]: '/assets/sounds/task_created.mp3',

  // æŒ‘æˆ˜ç›¸å…³éŸ³æ•ˆ
  [SoundType.CHALLENGE_COMPLETE]: '/assets/sounds/challenge_complete.mp3',
  [SoundType.CHALLENGE_COMPLETE_EPIC]: '/assets/sounds/challenge_complete_epic.mp3',
  [SoundType.CHALLENGE_COMPLETE_LEGENDARY]: '/assets/sounds/challenge_complete_legendary.mp3',
  [SoundType.CHALLENGE_FAILED]: '/assets/sounds/challenge_failed.mp3',
  [SoundType.CHALLENGE_UNLOCKED]: '/assets/sounds/challenge_unlocked.mp3',

  // ç³»ç»ŸéŸ³æ•ˆ
  [SoundType.LEVEL_UP]: '/assets/sounds/level_up.mp3',
  [SoundType.ABILITY_UNLOCKED]: '/assets/sounds/ability_unlocked.mp3',
  [SoundType.ABILITY_ACTIVATED]: '/assets/sounds/ability_activated.mp3',
  [SoundType.BUTTON_CLICK]: '/assets/sounds/button_click.mp3',
  [SoundType.ERROR]: '/assets/sounds/error.mp3',
  [SoundType.SUCCESS]: '/assets/sounds/success.mp3',
  [SoundType.NOTIFICATION]: '/assets/sounds/notification.mp3'
};

// éŸ³é¢‘å¯¹è±¡ç¼“å­˜
const audioCache: Record<string, HTMLAudioElement> = {};

/**
 * æ’­æ”¾éŸ³æ•ˆ
 * @param type éŸ³æ•ˆç±»å‹
 * @param volume éŸ³é‡ï¼ˆ0-1ï¼‰
 * @returns æ˜¯å¦æˆåŠŸæ’­æ”¾
 */
export function playSound(type: SoundType, volume: number = 0.5): boolean {
  try {
    const soundPath = soundPaths[type];

    // æ£€æŸ¥éŸ³é¢‘æ˜¯å¦å·²ç¼“å­˜
    if (!audioCache[soundPath]) {
      audioCache[soundPath] = new Audio(soundPath);
    }

    const audio = audioCache[soundPath];

    // è®¾ç½®éŸ³é‡
    audio.volume = Math.max(0, Math.min(1, volume));

    // é‡ç½®æ’­æ”¾ä½ç½®
    audio.currentTime = 0;

    // æ’­æ”¾éŸ³æ•ˆ
    audio.play().catch(error => {
      console.warn(`Failed to play sound: ${error.message}`);
      return false;
    });

    return true;
  } catch (error) {
    console.error('Error playing sound:', error);
    return false;
  }
}

/**
 * æ ¹æ®å¥–åŠ±ç¨€æœ‰åº¦æ’­æ”¾å¯¹åº”éŸ³æ•ˆ
 * @param rarity å¥–åŠ±ç¨€æœ‰åº¦
 * @param volume éŸ³é‡ï¼ˆ0-1ï¼‰
 * @returns æ˜¯å¦æˆåŠŸæ’­æ”¾
 */
export function playRewardSound(rarity: string, volume: number = 0.5): boolean {
  switch (rarity) {
    case 'common':
      return playSound(SoundType.REWARD_COMMON, volume);
    case 'uncommon':
      return playSound(SoundType.REWARD_UNCOMMON, volume);
    case 'rare':
      return playSound(SoundType.REWARD_RARE, volume);
    case 'epic':
      return playSound(SoundType.REWARD_EPIC, volume);
    case 'legendary':
      return playSound(SoundType.REWARD_LEGENDARY, volume);
    default:
      return playSound(SoundType.REWARD_COMMON, volume);
  }
}

/**
 * æ ¹æ®ä»»åŠ¡ç±»å‹å’Œä¼˜å…ˆçº§æ’­æ”¾å¯¹åº”éŸ³æ•ˆ
 * @param taskType ä»»åŠ¡ç±»å‹
 * @param taskPriority ä»»åŠ¡ä¼˜å…ˆçº§
 * @param volume éŸ³é‡ï¼ˆ0-1ï¼‰
 * @returns æ˜¯å¦æˆåŠŸæ’­æ”¾
 */
export function playTaskCompletionSound(taskType: string, taskPriority: string, volume: number = 0.5): boolean {
  // ä¸»çº¿ä»»åŠ¡
  if (taskType === 'main') {
    return playSound(SoundType.TASK_COMPLETE_MAIN, volume);
  }

  // é«˜ä¼˜å…ˆçº§ä»»åŠ¡
  if (taskPriority === 'high') {
    return playSound(SoundType.TASK_COMPLETE_HIGH, volume);
  }

  // é»˜è®¤ä»»åŠ¡å®ŒæˆéŸ³æ•ˆ
  return playSound(SoundType.TASK_COMPLETE, volume);
}

/**
 * æ ¹æ®æŒ‘æˆ˜éš¾åº¦æ’­æ”¾å¯¹åº”éŸ³æ•ˆ
 * @param difficulty æŒ‘æˆ˜éš¾åº¦
 * @param volume éŸ³é‡ï¼ˆ0-1ï¼‰
 * @returns æ˜¯å¦æˆåŠŸæ’­æ”¾
 */
export function playChallengeCompletionSound(difficulty: string, volume: number = 0.5): boolean {
  switch (difficulty) {
    case 'expert':
    case 'legendary':
      return playSound(SoundType.CHALLENGE_COMPLETE_LEGENDARY, volume);
    case 'hard':
    case 'epic':
      return playSound(SoundType.CHALLENGE_COMPLETE_EPIC, volume);
    default:
      return playSound(SoundType.CHALLENGE_COMPLETE, volume);
  }
}

/**
 * é¢„åŠ è½½æ‰€æœ‰éŸ³æ•ˆ
 * åœ¨æ¸¸æˆå¯åŠ¨æ—¶è°ƒç”¨ï¼Œæå‰åŠ è½½æ‰€æœ‰éŸ³æ•ˆæ–‡ä»¶
 */
export function preloadAllSounds(): void {
  Object.values(SoundType).forEach(type => {
    const soundPath = soundPaths[type as SoundType];
    if (!audioCache[soundPath]) {
      audioCache[soundPath] = new Audio(soundPath);
      // åªåŠ è½½å…ƒæ•°æ®ï¼Œä¸æ’­æ”¾
      audioCache[soundPath].preload = 'metadata';
      audioCache[soundPath].load();
    }
  });
}

/**
 * è®¾ç½®å…¨å±€éŸ³é‡
 * @param volume éŸ³é‡ï¼ˆ0-1ï¼‰
 */
export function setGlobalVolume(volume: number): void {
  const normalizedVolume = Math.max(0, Math.min(1, volume));
  Object.values(audioCache).forEach(audio => {
    audio.volume = normalizedVolume;
  });
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src", "vite.config.ts"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})
</file>

<file path="src/App.tsx">
// src/App.tsx
import React, { useEffect } from 'react';
import { BrowserRouter } from 'react-router-dom';
import { QueryClientProvider } from '@tanstack/react-query';
// import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { LanguageProvider } from '@/context/LanguageProvider';
import { PandaStateProvider } from '@/context/PandaStateProvider';
import { DataRefreshProvider } from '@/context/DataRefreshProvider';
import { populateDB, db } from '@/db';
import AppShell from '@/components/layout/AppShell';
import AppRouter from '@/router';
import { initializeDataSync } from '@/services/dataSyncService';
import { initializeTimelyRewards, updateTimelyRewardsStatus } from '@/services/timelyRewardService';
import { queryClient } from '@/services/queryClient';

const App: React.FC = () => {
  useEffect(() => {
    // åˆå§‹åŒ–å’Œå¡«å……æ•°æ®åº“
    const initDB = async () => {
      try {
        // Populate Dexie DB on app start for development
        if (import.meta.env.DEV) { // Vite specific dev check
          await populateDB();
        }

        // åˆå§‹åŒ–æ•°æ®åŒæ­¥æœåŠ¡
        setTimeout(() => {
          try {
            initializeDataSync({
              autoSyncInterval: 30000, // 30ç§’
              maxRetryCount: 5,
              batchSize: 20
            });

            // ç¡®ä¿æ•°æ®åº“è¡¨å·²åˆ›å»º
            try {
              // æ£€æŸ¥åŠæ—¶å¥–åŠ±è¡¨æ˜¯å¦å­˜åœ¨
              db.table('timelyRewards').count().then(count => {
                console.log(`TimelyRewards table exists with ${count} records`);

                // åˆå§‹åŒ–åŠæ—¶å¥–åŠ±ç³»ç»Ÿ
                initializeTimelyRewards().then(() => {
                  console.log("Timely rewards initialized successfully");

                  // æ›´æ–°åŠæ—¶å¥–åŠ±çŠ¶æ€
                  updateTimelyRewardsStatus().then(() => {
                    console.log("Timely rewards status updated successfully");
                  }).catch(err => {
                    console.error("Failed to update timely rewards status:", err);
                  });
                }).catch(err => {
                  console.error("Failed to initialize timely rewards:", err);
                });
              }).catch(err => {
                console.error("Failed to access timelyRewards table:", err);
              });
            } catch (err) {
              console.error("Error during timely rewards initialization:", err);
            }
          } catch (syncErr) {
            console.error("Failed to initialize data sync service:", syncErr);
          }
        }, 2000); // å»¶è¿Ÿ2ç§’åˆå§‹åŒ–åŒæ­¥æœåŠ¡ï¼Œç¡®ä¿æ•°æ®åº“å·²ç»å‡†å¤‡å¥½
      } catch (err) {
        console.error("Failed to initialize database:", err);
      }
    };

    initDB();

    // ç›‘å¬åœ¨çº¿çŠ¶æ€å˜åŒ–
    const handleOnline = () => {
      console.log('App is online, triggering sync');
      import('@/services/dataSyncService').then(({ syncPendingItems }) => {
        syncPendingItems().catch(err => {
          console.error('Sync failed:', err);
        });
      }).catch(err => {
        console.error('Failed to import dataSyncService:', err);
      });
    };

    window.addEventListener('online', handleOnline);

    return () => {
      window.removeEventListener('online', handleOnline);

      // åœæ­¢è‡ªåŠ¨åŒæ­¥
      import('@/services/dataSyncService').then(({ stopAutoSync }) => {
        stopAutoSync();
      }).catch(err => {
        console.error('Failed to import dataSyncService for cleanup:', err);
      });
    };
  }, []);

  return (
    <QueryClientProvider client={queryClient}>
      <LanguageProvider>
        <DataRefreshProvider>
          <PandaStateProvider>
            <BrowserRouter>
              <AppShell> {/* AppShell fetches global layout labels and provides overall structure */}
                <AppRouter /> {/* AppRouter handles page-specific content and routing */}
              </AppShell>
            </BrowserRouter>
          </PandaStateProvider>
        </DataRefreshProvider>
      </LanguageProvider>
      {/* <ReactQueryDevtools initialIsOpen={false} /> */}
    </QueryClientProvider>
  );
};
export default App;
</file>

<file path="src/components/animation/AnimatedTaskCard.tsx">
// src/components/animation/AnimatedTaskCard.tsx
import React, { forwardRef } from 'react';
import { motion } from 'framer-motion';
import TaskCard from '@/components/game/TaskCard';
import { TaskRecord } from '@/services/taskService';
import { listItem } from '@/utils/animation';

interface AnimatedTaskCardProps {
  task: TaskRecord;
  onComplete?: (taskId: number) => void;
  onEdit?: (taskId: number) => void;
  onDelete?: (taskId: number) => void;
  index?: number;
  className?: string;
}

/**
 * åŠ¨ç”»ä»»åŠ¡å¡ç‰‡ç»„ä»¶ï¼Œä¸ºTaskCardç»„ä»¶æ·»åŠ åŠ¨ç”»æ•ˆæœ
 * 
 * @param task - ä»»åŠ¡æ•°æ®
 * @param onComplete - å®Œæˆä»»åŠ¡å›è°ƒ
 * @param onEdit - ç¼–è¾‘ä»»åŠ¡å›è°ƒ
 * @param onDelete - åˆ é™¤ä»»åŠ¡å›è°ƒ
 * @param index - ç´¢å¼•ï¼Œç”¨äºè®¡ç®—åŠ¨ç”»å»¶è¿Ÿ
 * @param className - CSSç±»å
 */
const AnimatedTaskCard = forwardRef<HTMLDivElement, AnimatedTaskCardProps>(({
  task,
  onComplete,
  onEdit,
  onDelete,
  index = 0,
  className = ''
}, ref) => {
  return (
    <motion.div
      ref={ref}
      variants={listItem}
      initial="hidden"
      animate="visible"
      exit="exit"
      custom={index}
      layout
      layoutId={`task-${task.id}`}
      whileHover={{ 
        y: -5, 
        boxShadow: '0 10px 20px rgba(0, 0, 0, 0.1)',
        transition: { duration: 0.2 }
      }}
    >
      <TaskCard
        task={task}
        onComplete={onComplete}
        onEdit={onEdit}
        onDelete={onDelete}
        className={className}
      />
    </motion.div>
  );
});

AnimatedTaskCard.displayName = 'AnimatedTaskCard';

export default AnimatedTaskCard;
</file>

<file path="src/components/animation/AnimatedTaskList.tsx">
// src/components/animation/AnimatedTaskList.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { AnimatePresence } from 'framer-motion';
import {
  TaskRecord,
  TaskStatus,
  TaskPriority,
  TaskType,
  getAllTasks,
  completeTask,
  deleteTask
} from '@/services/taskService';

// æ‰©å±•Windowæ¥å£ï¼Œæ·»åŠ å…¨å±€å›è°ƒå‡½æ•°
declare global {
  interface Window {
    handleCompletionAnimationEnd?: () => void;
  }
}
import { RewardRecord } from '@/services/rewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import { TimelyRewardRecord } from '@/services/timelyRewardService';
import AnimatedContainer from './AnimatedContainer';
import AnimatedTaskCard from './AnimatedTaskCard';
import AnimatedButton from './AnimatedButton';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import RewardModal from '@/components/game/RewardModal';
import TimelyRewardCard from '@/components/game/TimelyRewardCard';
import { useComponentLabels } from '@/hooks/useComponentLabels';
import TaskCompletionAnimation from './TaskCompletionAnimation';
import { createContainerVariants } from '@/utils/animation';

interface AnimatedTaskListProps {
  onEditTask: (taskId: number) => void;
  filter?: {
    status?: TaskStatus;
    categoryId?: number;
    type?: TaskType;
    priority?: TaskPriority;
  };
  refreshTrigger?: number;
}

/**
 * åŠ¨ç”»ä»»åŠ¡åˆ—è¡¨ç»„ä»¶ï¼Œä¸ºä»»åŠ¡åˆ—è¡¨æ·»åŠ åŠ¨ç”»æ•ˆæœ
 *
 * @param onEditTask - ç¼–è¾‘ä»»åŠ¡å›è°ƒ
 * @param filter - è¿‡æ»¤æ¡ä»¶
 * @param refreshTrigger - åˆ·æ–°è§¦å‘å™¨
 */
const AnimatedTaskList: React.FC<AnimatedTaskListProps> = ({
  onEditTask,
  filter,
  refreshTrigger = 0
}) => {
  const [tasks, setTasks] = useState<TaskRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [showRewardModal, setShowRewardModal] = useState(false);
  const [timelyReward, setTimelyReward] = useState<TimelyRewardRecord | null>(null);
  const [showTimelyReward, setShowTimelyReward] = useState(false);
  const [completedTask, setCompletedTask] = useState<TaskRecord | null>(null);
  const [showCompletionAnimation, setShowCompletionAnimation] = useState(false);

  // Get localized labels
  const { labels } = useComponentLabels();

  // åŠ è½½ä»»åŠ¡
  const loadTasks = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const taskList = await getAllTasks(filter);
      setTasks(taskList);
    } catch (err) {
      console.error('Failed to load tasks:', err);
      setError(labels?.error?.loadingError || 'Failed to load tasks, please try again');
    } finally {
      setIsLoading(false);
    }
  }, [filter]);

  // åˆå§‹åŠ è½½å’Œåˆ·æ–°è§¦å‘å™¨å˜åŒ–æ—¶åŠ è½½ä»»åŠ¡
  useEffect(() => {
    loadTasks();
  }, [loadTasks, refreshTrigger]);

  // å®šä¹‰ä»»åŠ¡æ•°æ®æ›´æ–°å¤„ç†å‡½æ•° - ä½¿ç”¨ useRef æ¥é¿å…ä¾èµ–å˜åŒ–
  const filterRef = React.useRef(filter);
  const loadTasksRef = React.useRef(loadTasks);

  // æ›´æ–° refs å½“ä¾èµ–å˜åŒ–æ—¶
  React.useEffect(() => {
    filterRef.current = filter;
    loadTasksRef.current = loadTasks;
  }, [filter, loadTasks]);

  // ä½¿ç”¨ç¨³å®šçš„å›è°ƒå‡½æ•°ï¼Œä¸ä¾èµ–äº filter æˆ– loadTasks
  const handleTaskDataUpdate = useCallback((taskData: any) => {
    // ä½¿ç”¨ ref å€¼è€Œä¸æ˜¯ç›´æ¥ä¾èµ–
    const currentFilter = filterRef.current;
    const currentLoadTasks = loadTasksRef.current;

    // å¦‚æœæœ‰ç‰¹å®šä»»åŠ¡æ•°æ®ï¼Œåˆ™æ›´æ–°è¯¥ä»»åŠ¡
    if (taskData && taskData.id) {
      setTasks(prevTasks => {
        // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å·²å­˜åœ¨
        const taskExists = prevTasks.some(task => task.id === taskData.id);

        if (taskExists) {
          // æ›´æ–°ç°æœ‰ä»»åŠ¡
          return prevTasks.map(task =>
            task.id === taskData.id ? { ...task, ...taskData } : task
          );
        } else {
          // æ·»åŠ æ–°ä»»åŠ¡ï¼ˆå¦‚æœç¬¦åˆè¿‡æ»¤æ¡ä»¶ï¼‰
          if (!currentFilter ||
              ((!currentFilter.status || taskData.status === currentFilter.status) &&
               (!currentFilter.categoryId || taskData.categoryId === currentFilter.categoryId) &&
               (!currentFilter.type || taskData.type === currentFilter.type) &&
               (!currentFilter.priority || taskData.priority === currentFilter.priority))) {
            return [...prevTasks, taskData];
          }
          return prevTasks;
        }
      });
    } else {
      // å¦‚æœæ²¡æœ‰ç‰¹å®šä»»åŠ¡æ•°æ®ï¼Œåˆ™é‡æ–°åŠ è½½æ‰€æœ‰ä»»åŠ¡
      currentLoadTasks();
    }
  }, [/* æ²¡æœ‰ä¾èµ–é¡¹ï¼Œä½¿ç”¨ ref æ¥è·å–æœ€æ–°å€¼ */]);

  // Use useRegisterTableRefresh hook to listen for task table changes
  // Call the hook at the top level. It will manage its own lifecycle.
  useRegisterTableRefresh('tasks', handleTaskDataUpdate);
  // console.log('AnimatedTaskList: Registered table refresh for tasks'); // Optional: for debugging

  // å¤„ç†å®Œæˆä»»åŠ¡
  const handleCompleteTask = async (taskId: number) => {
    try {
      setIsLoading(true);

      // è·å–è¦å®Œæˆçš„ä»»åŠ¡
      const taskToComplete = tasks.find(task => task.id === taskId);
      if (!taskToComplete) {
        throw new Error(labels?.error?.taskNotFound || 'Task not found');
      }

      // å…ˆæ˜¾ç¤ºä»»åŠ¡å®ŒæˆåŠ¨ç”»
      setCompletedTask(taskToComplete);
      setShowCompletionAnimation(true);

      // å®Œæˆä»»åŠ¡å¹¶è·å–å¥–åŠ±
      const result = await completeTask(taskId);

      // ä¸éœ€è¦æ‰‹åŠ¨æ›´æ–°ä»»åŠ¡åˆ—è¡¨ï¼Œæ•°æ®åŒæ­¥æœåŠ¡ä¼šè‡ªåŠ¨è§¦å‘æ›´æ–°
      // ä½†ä¸ºäº†UIç«‹å³å“åº”ï¼Œæˆ‘ä»¬ä»ç„¶æ›´æ–°æœ¬åœ°çŠ¶æ€
      setTasks(prevTasks =>
        prevTasks.map(task =>
          task.id === taskId
            ? { ...task, status: TaskStatus.COMPLETED, completedAt: new Date() }
            : task
        )
      );

      // åŠ¨ç”»å®Œæˆåæ˜¾ç¤ºå¥–åŠ±
      const handleCompletionAnimationEnd = () => {
        setShowCompletionAnimation(false);

        // æ˜¾ç¤ºå¥–åŠ±
        if (result.rewards && result.rewards.length > 0) {
          setTimeout(() => {
            setRewards(result.rewards);
            setShowRewardModal(true);
          }, 300);
        }

        // å¦‚æœæœ‰åŠæ—¶å¥–åŠ±ï¼Œæ˜¾ç¤ºåŠæ—¶å¥–åŠ±
        if (result.timelyReward) {
          setTimelyReward(result.timelyReward);

          // å»¶è¿Ÿæ˜¾ç¤ºåŠæ—¶å¥–åŠ±ï¼Œå…ˆæ˜¾ç¤ºä»»åŠ¡å¥–åŠ±
          if (result.rewards && result.rewards.length > 0) {
            setTimeout(() => {
              setShowTimelyReward(true);
            }, 1000);
          } else {
            setTimeout(() => {
              setShowTimelyReward(true);
            }, 500);
          }
        }
      };

      // å¦‚æœåŠ¨ç”»å·²ç»å®Œæˆï¼Œç›´æ¥æ˜¾ç¤ºå¥–åŠ±
      if (!showCompletionAnimation) {
        handleCompletionAnimationEnd();
      } else {
        // å¦åˆ™ç­‰å¾…åŠ¨ç”»å®Œæˆ
        window.handleCompletionAnimationEnd = handleCompletionAnimationEnd;
      }
    } catch (err) {
      console.error('Failed to complete task:', err);
      setError(labels?.error?.completeTaskError || 'Failed to complete task, please try again');
      setShowCompletionAnimation(false);
    } finally {
      setIsLoading(false);
    }
  };

  // å¤„ç†åˆ é™¤ä»»åŠ¡
  const handleDeleteTask = async (taskId: number) => {
    if (!window.confirm(labels?.deleteConfirmation || 'Are you sure you want to delete this task?')) {
      return;
    }

    try {
      setIsLoading(true);
      await deleteTask(taskId);

      // ä¸éœ€è¦æ‰‹åŠ¨æ›´æ–°ä»»åŠ¡åˆ—è¡¨ï¼Œæ•°æ®åŒæ­¥æœåŠ¡ä¼šè‡ªåŠ¨è§¦å‘æ›´æ–°
      // ä½†ä¸ºäº†UIç«‹å³å“åº”ï¼Œæˆ‘ä»¬ä»ç„¶æ›´æ–°æœ¬åœ°çŠ¶æ€
      setTasks(prevTasks => prevTasks.filter(task => task.id !== taskId));
    } catch (err) {
      console.error('Failed to delete task:', err);
      setError(labels?.error?.deleteTaskError || 'Failed to delete task, please try again');
    } finally {
      setIsLoading(false);
    }
  };

  // æŒ‰ä¼˜å…ˆçº§æ’åºä»»åŠ¡
  const sortedTasks = [...tasks].sort((a, b) => {
    // é¦–å…ˆæŒ‰çŠ¶æ€æ’åºï¼ˆæœªå®Œæˆçš„åœ¨å‰ï¼‰
    if (a.status !== b.status) {
      if (a.status === TaskStatus.COMPLETED) return 1;
      if (b.status === TaskStatus.COMPLETED) return -1;
    }

    // ç„¶åæŒ‰ä¼˜å…ˆçº§æ’åº
    const priorityOrder = {
      [TaskPriority.HIGH]: 0,
      [TaskPriority.MEDIUM]: 1,
      [TaskPriority.LOW]: 2
    };

    return priorityOrder[a.priority] - priorityOrder[b.priority];
  });

  if (isLoading && tasks.length === 0) {
    return <LoadingSpinner variant="jade" text={labels?.loading?.data || "Loading tasks..."} />;
  }

  if (error) {
    return (
      <div className="task-list-error">
        <p>{error}</p>
        <AnimatedButton variant="jade" onClick={() => window.location.reload()}>
          {labels?.button?.retry || "Retry"}
        </AnimatedButton>
      </div>
    );
  }

  if (tasks.length === 0) {
    return (
      <AnimatedContainer
        variants={createContainerVariants(0.1, 0.2)}
        className="task-list-empty"
      >
        <p>{labels?.emptyState?.noItems || "No tasks available"}</p>
      </AnimatedContainer>
    );
  }

  // å…³é—­å¥–åŠ±æ¨¡æ€æ¡†
  const handleCloseRewardModal = () => {
    setShowRewardModal(false);
    setRewards([]);

    // å¦‚æœæœ‰åŠæ—¶å¥–åŠ±ï¼Œæ˜¾ç¤ºåŠæ—¶å¥–åŠ±
    if (timelyReward && !showTimelyReward) {
      setTimeout(() => {
        setShowTimelyReward(true);
      }, 500);
    }
  };

  // å…³é—­åŠæ—¶å¥–åŠ±
  const handleCloseTimelyReward = () => {
    setShowTimelyReward(false);
    setTimelyReward(null);
  };

  return (
    <div className="task-list">
      {isLoading && (
        <div className="task-list-loading-overlay">
          <LoadingSpinner variant="jade" />
        </div>
      )}

      <AnimatedContainer
        variants={createContainerVariants(0.05, 0)}
      >
        <AnimatePresence mode="popLayout">
          {sortedTasks.map((task, index) => (
            <AnimatedTaskCard
              key={task.id}
              task={task}
              index={index}
              onComplete={handleCompleteTask}
              onEdit={onEditTask}
              onDelete={handleDeleteTask}
            />
          ))}
        </AnimatePresence>
      </AnimatedContainer>

      {/* å¥–åŠ±æ¨¡æ€æ¡† */}
      {showRewardModal && (
        <RewardModal
          isOpen={showRewardModal}
          onClose={handleCloseRewardModal}
          rewards={rewards}
        />
      )}

      {/* Timely reward modal */}
      {showTimelyReward && timelyReward && (
        <div className="timely-reward-modal">
          <div className="timely-reward-modal-backdrop" onClick={handleCloseTimelyReward}></div>
          <div className="timely-reward-modal-content">
            <h3 className="timely-reward-modal-title">{labels?.taskReminder?.title || "Timely Reward"}</h3>
            <p className="timely-reward-modal-description">
              {labels?.timelyRewardCongrats || "Congratulations! You completed the task in time and earned a timely reward!"}
            </p>
            <TimelyRewardCard
              reward={timelyReward}
              onComplete={() => {}}
              labels={labels?.taskReminder}
            />
            <div className="timely-reward-modal-actions">
              <AnimatedButton onClick={handleCloseTimelyReward}>
                {labels?.modal?.close || "Close"}
              </AnimatedButton>
            </div>
          </div>
        </div>
      )}

      {/* ä»»åŠ¡å®ŒæˆåŠ¨ç”» */}
      {showCompletionAnimation && completedTask && (
        <TaskCompletionAnimation
          task={completedTask}
          style={completedTask.priority === TaskPriority.HIGH ? 'fireworks' :
                 completedTask.type === TaskType.MAIN ? 'stars' : 'confetti'}
          onAnimationComplete={() => {
            setShowCompletionAnimation(false);
            // è°ƒç”¨å…¨å±€å›è°ƒå‡½æ•°ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (window.handleCompletionAnimationEnd) {
              window.handleCompletionAnimationEnd();
              delete window.handleCompletionAnimationEnd;
            }
          }}
        />
      )}
    </div>
  );
};

export default AnimatedTaskList;
</file>

<file path="src/components/animation/RewardAnimation.tsx">
// src/components/animation/RewardAnimation.tsx
import React, { useEffect, useState } from 'react';
import { motion, Variants, AnimatePresence } from 'framer-motion';
import { RewardType, RewardRarity } from '@/services/rewardService';
import { playRewardSound } from '@/utils/sound';

interface RewardAnimationProps {
  type: RewardType;
  rarity: RewardRarity;
  iconPath: string;
  amount?: number;
  size?: number;
  onAnimationComplete?: () => void;
  animationStyle?: 'default' | 'burst' | 'float' | 'spin' | 'pulse';
  playSound?: boolean;
  soundVolume?: number;
}

/**
 * å¥–åŠ±åŠ¨ç”»ç»„ä»¶
 * æ˜¾ç¤ºå¥–åŠ±è·å–çš„åŠ¨ç”»æ•ˆæœ
 *
 * @param type - å¥–åŠ±ç±»å‹
 * @param rarity - å¥–åŠ±ç¨€æœ‰åº¦
 * @param iconPath - å›¾æ ‡è·¯å¾„
 * @param amount - å¥–åŠ±æ•°é‡
 * @param size - å›¾æ ‡å¤§å°
 * @param onAnimationComplete - åŠ¨ç”»å®Œæˆå›è°ƒ
 */
const RewardAnimation: React.FC<RewardAnimationProps> = ({
  type,
  rarity,
  iconPath,
  amount = 1,
  size = 100,
  onAnimationComplete,
  animationStyle = 'default',
  playSound = true,
  soundVolume = 0.5
}) => {
  // åŠ¨ç”»å®ŒæˆçŠ¶æ€
  const [isAnimationComplete, setIsAnimationComplete] = useState(false);

  // æ’­æ”¾éŸ³æ•ˆ
  useEffect(() => {
    if (playSound) {
      playRewardSound(rarity, soundVolume);
    }
  }, [playSound, rarity, soundVolume]);
  // æ ¹æ®ç¨€æœ‰åº¦è·å–å…‰æ™•é¢œè‰²
  const getGlowColor = (rarity: RewardRarity): string => {
    switch (rarity) {
      case RewardRarity.COMMON:
        return 'rgba(255, 255, 255, 0.7)';
      case RewardRarity.UNCOMMON:
        return 'rgba(75, 175, 80, 0.7)';
      case RewardRarity.RARE:
        return 'rgba(33, 150, 243, 0.7)';
      case RewardRarity.EPIC:
        return 'rgba(156, 39, 176, 0.7)';
      case RewardRarity.LEGENDARY:
        return 'rgba(255, 193, 7, 0.7)';
      default:
        return 'rgba(255, 255, 255, 0.7)';
    }
  };

  // æ ¹æ®ç¨€æœ‰åº¦è·å–ç²’å­æ•°é‡
  const getParticleCount = (rarity: RewardRarity): number => {
    switch (rarity) {
      case RewardRarity.COMMON:
        return 5;
      case RewardRarity.UNCOMMON:
        return 10;
      case RewardRarity.RARE:
        return 15;
      case RewardRarity.EPIC:
        return 20;
      case RewardRarity.LEGENDARY:
        return 25;
      default:
        return 5;
    }
  };

  // è·å–å›¾æ ‡åŠ¨ç”»å˜ä½“
  const getIconVariants = (): Variants => {
    // é»˜è®¤åŠ¨ç”»
    const defaultVariants: Variants = {
      hidden: {
        scale: 0,
        opacity: 0,
        rotate: -180
      },
      visible: {
        scale: 1,
        opacity: 1,
        rotate: 0,
        transition: {
          type: 'spring',
          damping: 10,
          stiffness: 100,
          duration: 0.8
        }
      },
      exit: {
        scale: 0,
        opacity: 0,
        transition: {
          duration: 0.3
        }
      }
    };

    // çˆ†å‘åŠ¨ç”»
    const burstVariants: Variants = {
      hidden: {
        scale: 0,
        opacity: 0,
      },
      visible: {
        scale: [0, 1.5, 1],
        opacity: [0, 1, 1],
        transition: {
          times: [0, 0.6, 1],
          duration: 1,
          ease: "easeOut"
        }
      },
      exit: {
        scale: [1, 1.2, 0],
        opacity: [1, 1, 0],
        transition: {
          duration: 0.5
        }
      }
    };

    // æµ®åŠ¨åŠ¨ç”»
    const floatVariants: Variants = {
      hidden: {
        y: 50,
        opacity: 0,
      },
      visible: {
        y: [50, -10, 0],
        opacity: [0, 1, 1],
        transition: {
          times: [0, 0.6, 1],
          duration: 1.2,
          ease: "easeOut"
        }
      },
      exit: {
        y: -50,
        opacity: 0,
        transition: {
          duration: 0.5
        }
      }
    };

    // æ—‹è½¬åŠ¨ç”»
    const spinVariants: Variants = {
      hidden: {
        scale: 0,
        opacity: 0,
        rotate: 0
      },
      visible: {
        scale: 1,
        opacity: 1,
        rotate: 360 * 2,
        transition: {
          duration: 1.2,
          ease: "easeOut"
        }
      },
      exit: {
        scale: 0,
        opacity: 0,
        rotate: 180,
        transition: {
          duration: 0.5
        }
      }
    };

    // è„‰å†²åŠ¨ç”»
    const pulseVariants: Variants = {
      hidden: {
        scale: 0.8,
        opacity: 0,
      },
      visible: {
        scale: [0.8, 1.1, 1, 1.05, 1],
        opacity: 1,
        transition: {
          times: [0, 0.3, 0.5, 0.8, 1],
          duration: 1,
          ease: "easeInOut",
          repeat: 0
        }
      },
      exit: {
        scale: 0.8,
        opacity: 0,
        transition: {
          duration: 0.3
        }
      }
    };

    // æ ¹æ®åŠ¨ç”»æ ·å¼è¿”å›å¯¹åº”çš„å˜ä½“
    switch (animationStyle) {
      case 'burst':
        return burstVariants;
      case 'float':
        return floatVariants;
      case 'spin':
        return spinVariants;
      case 'pulse':
        return pulseVariants;
      default:
        return defaultVariants;
    }
  };

  // è·å–å½“å‰åŠ¨ç”»å˜ä½“
  const iconVariants = getIconVariants();

  // æ•°é‡åŠ¨ç”»å˜ä½“
  const amountVariants: Variants = {
    hidden: {
      opacity: 0,
      y: 20
    },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        delay: 0.3,
        duration: 0.5
      }
    },
    exit: {
      opacity: 0,
      y: -20,
      transition: {
        duration: 0.2
      }
    }
  };

  // å…‰æ™•åŠ¨ç”»å˜ä½“
  const getGlowVariants = (): Variants => {
    // é»˜è®¤å…‰æ™•åŠ¨ç”»
    const defaultGlowVariants: Variants = {
      hidden: {
        scale: 0.5,
        opacity: 0
      },
      visible: {
        scale: [0.5, 1.2, 1],
        opacity: [0, 0.8, 0.5],
        transition: {
          times: [0, 0.5, 1],
          duration: 1
        }
      }
    };

    // ç¨€æœ‰å’Œå²è¯—å…‰æ™•åŠ¨ç”»ï¼ˆæ›´å¼ºçƒˆçš„è„‰å†²ï¼‰
    const rareGlowVariants: Variants = {
      hidden: {
        scale: 0.5,
        opacity: 0
      },
      visible: {
        scale: [0.5, 1.3, 0.9, 1.1, 1],
        opacity: [0, 0.9, 0.7, 0.8, 0.6],
        transition: {
          times: [0, 0.3, 0.5, 0.7, 1],
          duration: 1.5,
          repeat: Infinity,
          repeatType: "reverse"
        }
      }
    };

    // ä¼ è¯´å…‰æ™•åŠ¨ç”»ï¼ˆå½©è™¹è‰²å˜åŒ–ï¼‰
    const legendaryGlowVariants: Variants = {
      hidden: {
        scale: 0.5,
        opacity: 0
      },
      visible: {
        scale: [0.8, 1.2, 1, 1.1, 0.9, 1],
        opacity: [0.3, 0.8, 0.6, 0.7, 0.5, 0.6],
        transition: {
          times: [0, 0.2, 0.4, 0.6, 0.8, 1],
          duration: 3,
          repeat: Infinity,
          repeatType: "loop"
        }
      }
    };

    // æ ¹æ®ç¨€æœ‰åº¦è¿”å›å¯¹åº”çš„å…‰æ™•åŠ¨ç”»
    if (rarity === RewardRarity.LEGENDARY) {
      return legendaryGlowVariants;
    } else if (rarity === RewardRarity.EPIC || rarity === RewardRarity.RARE) {
      return rareGlowVariants;
    } else {
      return defaultGlowVariants;
    }
  };

  const glowVariants = getGlowVariants();

  // ç”Ÿæˆéšæœºç²’å­
  const renderParticles = () => {
    const particleCount = getParticleCount(rarity);
    const particles = [];

    // æ ¹æ®ç¨€æœ‰åº¦å’ŒåŠ¨ç”»æ ·å¼è°ƒæ•´ç²’å­æ•ˆæœ
    const getParticleStyle = () => {
      // é»˜è®¤ç²’å­æ ·å¼
      if (animationStyle === 'default' || animationStyle === 'pulse') {
        // æ ‡å‡†æ”¾å°„çŠ¶ç²’å­
        for (let i = 0; i < particleCount; i++) {
          const angle = (i / particleCount) * 360;
          const distance = Math.random() * 50 + 50;
          const delay = Math.random() * 0.3;
          const duration = Math.random() * 0.5 + 0.5;
          const size = Math.random() * 6 + 4;

          particles.push(
            <motion.div
              key={`standard-${i}`}
              style={{
                position: 'absolute',
                width: size,
                height: size,
                borderRadius: '50%',
                backgroundColor: getGlowColor(rarity),
                top: '50%',
                left: '50%',
                margin: `-${size / 2}px 0 0 -${size / 2}px`
              }}
              initial={{
                x: 0,
                y: 0,
                opacity: 0
              }}
              animate={{
                x: Math.cos(angle * Math.PI / 180) * distance,
                y: Math.sin(angle * Math.PI / 180) * distance,
                opacity: [0, 1, 0],
                scale: [1, 1.5, 0.5]
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'easeOut'
              }}
            />
          );
        }
      }

      // çˆ†å‘å¼ç²’å­ - æ›´å¤šã€æ›´å¿«çš„ç²’å­
      if (animationStyle === 'burst') {
        for (let i = 0; i < particleCount * 1.5; i++) {
          const angle = Math.random() * 360;
          const distance = Math.random() * 80 + 40;
          const delay = Math.random() * 0.2;
          const duration = Math.random() * 0.4 + 0.3;
          const size = Math.random() * 5 + 3;

          particles.push(
            <motion.div
              key={`burst-${i}`}
              style={{
                position: 'absolute',
                width: size,
                height: size,
                borderRadius: '50%',
                backgroundColor: getGlowColor(rarity),
                top: '50%',
                left: '50%',
                margin: `-${size / 2}px 0 0 -${size / 2}px`
              }}
              initial={{
                x: 0,
                y: 0,
                opacity: 0
              }}
              animate={{
                x: Math.cos(angle * Math.PI / 180) * distance,
                y: Math.sin(angle * Math.PI / 180) * distance,
                opacity: [0, 1, 0],
                scale: [1, 2, 0]
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'easeOut'
              }}
            />
          );
        }
      }

      // æµ®åŠ¨ç²’å­ - ä¸Šå‡çš„ç²’å­
      if (animationStyle === 'float') {
        for (let i = 0; i < particleCount; i++) {
          const xOffset = (Math.random() - 0.5) * 80;
          const yDistance = -1 * (Math.random() * 60 + 40);
          const delay = Math.random() * 0.5;
          const duration = Math.random() * 1 + 1;
          const size = Math.random() * 6 + 3;

          particles.push(
            <motion.div
              key={`float-${i}`}
              style={{
                position: 'absolute',
                width: size,
                height: size,
                borderRadius: '50%',
                backgroundColor: getGlowColor(rarity),
                top: '50%',
                left: '50%',
                margin: `-${size / 2}px 0 0 -${size / 2}px`
              }}
              initial={{
                x: xOffset / 3,
                y: 10,
                opacity: 0
              }}
              animate={{
                x: xOffset,
                y: yDistance,
                opacity: [0, 0.8, 0],
                scale: [0.8, 1.2, 0.5]
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'easeOut'
              }}
            />
          );
        }
      }

      // æ—‹è½¬ç²’å­ - å›´ç»•ä¸­å¿ƒæ—‹è½¬
      if (animationStyle === 'spin') {
        for (let i = 0; i < particleCount; i++) {
          const radius = Math.random() * 30 + 30;
          const startAngle = Math.random() * 360;
          const duration = Math.random() * 2 + 2;
          const delay = Math.random() * 0.3;
          const size = Math.random() * 5 + 3;

          particles.push(
            <motion.div
              key={`spin-${i}`}
              style={{
                position: 'absolute',
                width: size,
                height: size,
                borderRadius: '50%',
                backgroundColor: getGlowColor(rarity),
                top: '50%',
                left: '50%',
                margin: `-${size / 2}px 0 0 -${size / 2}px`
              }}
              initial={{
                opacity: 0,
                x: Math.cos(startAngle * Math.PI / 180) * radius,
                y: Math.sin(startAngle * Math.PI / 180) * radius,
              }}
              animate={{
                opacity: [0, 0.8, 0.8, 0],
                x: [
                  Math.cos(startAngle * Math.PI / 180) * radius,
                  Math.cos((startAngle + 120) * Math.PI / 180) * radius,
                  Math.cos((startAngle + 240) * Math.PI / 180) * radius,
                  Math.cos((startAngle + 360) * Math.PI / 180) * radius
                ],
                y: [
                  Math.sin(startAngle * Math.PI / 180) * radius,
                  Math.sin((startAngle + 120) * Math.PI / 180) * radius,
                  Math.sin((startAngle + 240) * Math.PI / 180) * radius,
                  Math.sin((startAngle + 360) * Math.PI / 180) * radius
                ]
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'linear',
                times: [0, 0.33, 0.66, 1]
              }}
            />
          );
        }
      }

      // ä¼ è¯´çº§ç‰¹æ•ˆ - é¢å¤–çš„æ˜Ÿæ˜Ÿç²’å­
      if (rarity === RewardRarity.LEGENDARY) {
        // æ·»åŠ æ˜Ÿå½¢ç²’å­
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * 360;
          const distance = Math.random() * 30 + 60;
          const delay = Math.random() * 0.5 + 0.5;
          const duration = Math.random() * 1.5 + 1.5;

          particles.push(
            <motion.div
              key={`star-${i}`}
              style={{
                position: 'absolute',
                width: 10,
                height: 10,
                top: '50%',
                left: '50%',
                margin: '-5px 0 0 -5px',
                clipPath: 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
                backgroundColor: '#FFD700',
                boxShadow: '0 0 10px #FFD700'
              }}
              initial={{
                x: 0,
                y: 0,
                scale: 0,
                opacity: 0,
                rotate: 0
              }}
              animate={{
                x: Math.cos(angle * Math.PI / 180) * distance,
                y: Math.sin(angle * Math.PI / 180) * distance,
                scale: [0, 1.5, 1, 1.2, 0],
                opacity: [0, 1, 1, 0.8, 0],
                rotate: 360
              }}
              transition={{
                duration: duration,
                delay: delay,
                ease: 'easeInOut',
                times: [0, 0.2, 0.4, 0.8, 1]
              }}
            />
          );
        }
      }
    };

    // ç”Ÿæˆç²’å­
    getParticleStyle();

    return particles;
  };

  // å¤„ç†åŠ¨ç”»å®Œæˆ
  const handleAnimationComplete = () => {
    setIsAnimationComplete(true);
    if (onAnimationComplete) {
      onAnimationComplete();
    }
  };

  // è·å–ä¼ è¯´çº§å¥–åŠ±çš„å½©è™¹è¾¹æ¡†
  const getLegendaryBorder = () => {
    if (rarity === RewardRarity.LEGENDARY) {
      return (
        <motion.div
          style={{
            position: 'absolute',
            width: '110%',
            height: '110%',
            borderRadius: '50%',
            border: '3px solid transparent',
            backgroundImage: 'linear-gradient(white, white), linear-gradient(to right, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff)',
            backgroundOrigin: 'border-box',
            backgroundClip: 'content-box, border-box',
            top: '-5%',
            left: '-5%'
          }}
          animate={{
            rotate: [0, 360],
          }}
          transition={{
            duration: 8,
            repeat: Infinity,
            ease: 'linear'
          }}
        />
      );
    }
    return null;
  };

  // è·å–ç¨€æœ‰çº§å¥–åŠ±çš„ç‰¹æ®Šè¾¹æ¡†
  const getRareBorder = () => {
    if (rarity === RewardRarity.RARE || rarity === RewardRarity.EPIC) {
      return (
        <motion.div
          style={{
            position: 'absolute',
            width: '110%',
            height: '110%',
            borderRadius: '50%',
            border: '2px solid',
            borderColor: rarity === RewardRarity.RARE ? '#0088ff' : '#a335ee',
            top: '-5%',
            left: '-5%'
          }}
          animate={{
            boxShadow: [
              `0 0 5px ${rarity === RewardRarity.RARE ? '#0088ff' : '#a335ee'}`,
              `0 0 15px ${rarity === RewardRarity.RARE ? '#0088ff' : '#a335ee'}`,
              `0 0 5px ${rarity === RewardRarity.RARE ? '#0088ff' : '#a335ee'}`
            ]
          }}
          transition={{
            duration: 2,
            repeat: Infinity,
            ease: 'easeInOut'
          }}
        />
      );
    }
    return null;
  };

  return (
    <div
      style={{
        position: 'relative',
        width: size,
        height: size,
        margin: '0 auto'
      }}
    >
      {/* ç‰¹æ®Šè¾¹æ¡†æ•ˆæœ */}
      {getLegendaryBorder()}
      {getRareBorder()}

      {/* å…‰æ™•æ•ˆæœ */}
      <motion.div
        style={{
          position: 'absolute',
          width: '100%',
          height: '100%',
          borderRadius: '50%',
          backgroundColor: getGlowColor(rarity),
          top: 0,
          left: 0
        }}
        variants={glowVariants}
        initial="hidden"
        animate="visible"
      />

      {/* ç²’å­æ•ˆæœ */}
      <AnimatePresence>
        {!isAnimationComplete && renderParticles()}
      </AnimatePresence>

      {/* å¥–åŠ±å›¾æ ‡ */}
      <motion.div
        style={{
          position: 'relative',
          width: '100%',
          height: '100%',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          zIndex: 2
        }}
        variants={iconVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
        onAnimationComplete={handleAnimationComplete}
      >
        <img
          src={iconPath}
          alt={`${type} reward`}
          style={{
            width: '80%',
            height: '80%',
            objectFit: 'contain',
            filter: rarity === RewardRarity.LEGENDARY
              ? 'drop-shadow(0 0 5px gold)'
              : rarity === RewardRarity.EPIC
                ? 'drop-shadow(0 0 3px purple)'
                : rarity === RewardRarity.RARE
                  ? 'drop-shadow(0 0 3px blue)'
                  : 'none'
          }}
          onError={(e) => {
            // å›¾æ ‡åŠ è½½å¤±è´¥æ—¶ä½¿ç”¨é»˜è®¤å›¾æ ‡
            const target = e.target as HTMLImageElement;
            target.onerror = null; // é˜²æ­¢æ— é™å¾ªç¯
            target.src = type === RewardType.EXPERIENCE
              ? '/assets/rewards/experience.svg'
              : type === RewardType.COIN
                ? '/assets/rewards/coin.svg'
                : '/assets/rewards/item_common.svg';
          }}
        />
      </motion.div>

      {/* æ•°é‡æ˜¾ç¤º */}
      {amount > 1 && (
        <motion.div
          style={{
            position: 'absolute',
            bottom: -10,
            right: -10,
            backgroundColor: 'var(--imperial-gold)',
            color: 'white',
            borderRadius: '50%',
            width: 30,
            height: 30,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            fontWeight: 'bold',
            fontSize: '0.9rem',
            boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)',
            zIndex: 3
          }}
          variants={amountVariants}
          initial="hidden"
          animate="visible"
          exit="exit"
        >
          {amount}
        </motion.div>
      )}

      {/* ç¨€æœ‰åº¦æŒ‡ç¤ºå™¨ - åªå¯¹ç¨€æœ‰åŠä»¥ä¸Šæ˜¾ç¤º */}
      {(rarity === RewardRarity.RARE || rarity === RewardRarity.EPIC || rarity === RewardRarity.LEGENDARY) && (
        <motion.div
          style={{
            position: 'absolute',
            top: -15,
            left: '50%',
            transform: 'translateX(-50%)',
            backgroundColor: rarity === RewardRarity.LEGENDARY
              ? '#FFD700'
              : rarity === RewardRarity.EPIC
                ? '#a335ee'
                : '#0088ff',
            color: 'white',
            borderRadius: '4px',
            padding: '2px 6px',
            fontSize: '0.7rem',
            fontWeight: 'bold',
            boxShadow: `0 0 5px ${
              rarity === RewardRarity.LEGENDARY
                ? '#FFD700'
                : rarity === RewardRarity.EPIC
                  ? '#a335ee'
                  : '#0088ff'
            }`,
            zIndex: 3
          }}
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.5, duration: 0.3 }}
        >
          {rarity === RewardRarity.LEGENDARY
            ? 'ä¼ è¯´'
            : rarity === RewardRarity.EPIC
              ? 'å²è¯—'
              : 'ç¨€æœ‰'}
        </motion.div>
      )}
    </div>
  );
};

export default RewardAnimation;
</file>

<file path="src/components/game/AbilityList.tsx">
// src/components/game/AbilityList.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import AbilityCard from './AbilityCard';
import { PandaAbilityRecord, AbilityType } from '@/services/pandaAbilityService';
import ScrollDialog from './ScrollDialog';
import { AbilityCardLabels, AbilityDetailLabels, AbilityFilterLabels } from '@/types';

interface AbilityListProps {
  abilities: PandaAbilityRecord[];
  unlockedAbilities: PandaAbilityRecord[];
  onActivateAbility: (abilityId: number) => Promise<void>;
  pandaLevel: number;
  labels?: {
    filters?: AbilityFilterLabels;
    card?: AbilityCardLabels;
    detail?: AbilityDetailLabels;
    noAbilitiesMessage?: string;
  };
}

/**
 * Panda ability list component
 * Displays all panda abilities and allows activation of unlocked abilities
 *
 * @param abilities - List of all abilities
 * @param unlockedAbilities - List of unlocked abilities
 * @param onActivateAbility - Callback function to activate an ability
 * @param pandaLevel - Current panda level
 * @param labels - Localized labels for the component
 */
const AbilityList: React.FC<AbilityListProps> = ({
  abilities,
  unlockedAbilities,
  onActivateAbility,
  pandaLevel,
  labels
}) => {
  const [activeFilter, setActiveFilter] = useState<string>('all');
  const [selectedAbility, setSelectedAbility] = useState<PandaAbilityRecord | null>(null);
  const [isDetailModalOpen, setIsDetailModalOpen] = useState(false);

  // Filter abilities based on selected filter
  const filteredAbilities = abilities.filter(ability => {
    if (activeFilter === 'all') {
      return true;
    }
    if (activeFilter === 'unlocked') {
      return unlockedAbilities.some(unlocked => unlocked.id === ability.id);
    }
    if (activeFilter === 'locked') {
      return !unlockedAbilities.some(unlocked => unlocked.id === ability.id);
    }
    if (activeFilter === 'passive') {
      return ability.type === AbilityType.PASSIVE;
    }
    if (activeFilter === 'active') {
      return ability.type === AbilityType.ACTIVE;
    }
    if (activeFilter === 'ultimate') {
      return ability.type === AbilityType.ULTIMATE;
    }
    return true;
  });

  // Check if ability is unlocked
  const isAbilityUnlocked = (ability: PandaAbilityRecord): boolean => {
    return unlockedAbilities.some(unlocked => unlocked.id === ability.id);
  };

  // Handle ability activation
  const handleActivateAbility = async (abilityId: number) => {
    await onActivateAbility(abilityId);
  };

  // Open ability detail modal
  const openAbilityDetail = (ability: PandaAbilityRecord) => {
    setSelectedAbility(ability);
    setIsDetailModalOpen(true);
  };

  // Close ability detail modal
  const closeAbilityDetail = () => {
    setIsDetailModalOpen(false);
    setSelectedAbility(null);
  };

  return (
    <div className="ability-list-container">
      <div className="filter-section">
        <h3 className="filter-title">{labels?.filters?.statusLabel || 'Status'}</h3>
        <div className="ability-filters">
          <button
            className={`filter-button ${activeFilter === 'all' ? 'active' : ''}`}
            onClick={() => setActiveFilter('all')}
          >
            {labels?.filters?.allLabel || 'All'}
          </button>
          <button
            className={`filter-button ${activeFilter === 'unlocked' ? 'active' : ''}`}
            onClick={() => setActiveFilter('unlocked')}
          >
            {labels?.filters?.unlockedLabel || 'Unlocked'}
          </button>
          <button
            className={`filter-button ${activeFilter === 'locked' ? 'active' : ''}`}
            onClick={() => setActiveFilter('locked')}
          >
            {labels?.filters?.lockedLabel || 'Locked'}
          </button>
          <button
            className={`filter-button ${activeFilter === 'passive' ? 'active' : ''}`}
            onClick={() => setActiveFilter('passive')}
          >
            {labels?.filters?.passiveLabel || 'Passive'}
          </button>
          <button
            className={`filter-button ${activeFilter === 'active' ? 'active' : ''}`}
            onClick={() => setActiveFilter('active')}
          >
            {labels?.filters?.activeLabel || 'Active'}
          </button>
          <button
            className={`filter-button ${activeFilter === 'ultimate' ? 'active' : ''}`}
            onClick={() => setActiveFilter('ultimate')}
          >
            {labels?.filters?.ultimateLabel || 'Ultimate'}
          </button>
        </div>
      </div>

      <div className="abilities-grid">
        <AnimatePresence>
          {filteredAbilities.map(ability => (
            <motion.div
              key={ability.id}
              layout
              initial={{ opacity: 0, scale: 0.8 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.8 }}
              transition={{ duration: 0.3 }}
              onClick={() => openAbilityDetail(ability)}
            >
              <AbilityCard
                ability={ability}
                isUnlocked={isAbilityUnlocked(ability)}
                onActivate={() => ability.id && handleActivateAbility(ability.id)}
                labels={labels?.card}
              />
            </motion.div>
          ))}
        </AnimatePresence>
      </div>

      {filteredAbilities.length === 0 && (
        <div className="no-abilities">
          <p>{labels?.noAbilitiesMessage || 'No abilities match the current filter'}</p>
        </div>
      )}

      {/* Ability detail modal */}
      <ScrollDialog
        isOpen={isDetailModalOpen}
        onClose={closeAbilityDetail}
        title={selectedAbility?.name || labels?.detail?.title || 'Ability Details'}
      >
        {selectedAbility && (
          <div className="ability-detail">
            <div className="ability-detail-icon">
              <img
                src={selectedAbility.iconPath}
                alt={selectedAbility.name}
                onError={(e) => {
                  const target = e.target as HTMLImageElement;
                  target.onerror = null;
                  target.src = '/assets/abilities/default-ability.svg';
                }}
              />
            </div>

            <div className="ability-detail-info">
              <p className="ability-detail-description">
                {selectedAbility.description}
              </p>

              <div className="ability-detail-meta">
                <div className="meta-item">
                  <span className="meta-label">{labels?.detail?.typeLabel || 'Type'}:</span>
                  <span className="meta-value">
                    {selectedAbility.type === AbilityType.PASSIVE
                      ? (labels?.card?.typePassive || 'Passive')
                      : selectedAbility.type === AbilityType.ACTIVE
                        ? (labels?.card?.typeActive || 'Active')
                        : (labels?.card?.typeUltimate || 'Ultimate')}
                  </span>
                </div>

                <div className="meta-item">
                  <span className="meta-label">{labels?.detail?.effectLabel || 'Effect Value'}:</span>
                  <span className="meta-value">{selectedAbility.effectValue * 100}%</span>
                </div>

                {selectedAbility.cooldownMinutes && (
                  <div className="meta-item">
                    <span className="meta-label">{labels?.detail?.cooldownLabel || 'Cooldown'}:</span>
                    <span className="meta-value">{selectedAbility.cooldownMinutes} {labels?.card?.minutesUnit || 'minutes'}</span>
                  </div>
                )}

                <div className="meta-item">
                  <span className="meta-label">{labels?.detail?.requiredLevelLabel || 'Required Level'}:</span>
                  <span className="meta-value">
                    {selectedAbility.requiredLevel}
                    {pandaLevel < selectedAbility.requiredLevel &&
                      ` (${labels?.detail?.levelsNeededText || 'Need'} ${selectedAbility.requiredLevel - pandaLevel} ${labels?.detail?.levelsNeededText ? '' : 'more'})`}
                  </span>
                </div>
              </div>

              {isAbilityUnlocked(selectedAbility) && selectedAbility.type !== AbilityType.PASSIVE && (
                <div className="ability-detail-actions">
                  <button
                    className="activate-detail-button"
                    onClick={() => {
                      selectedAbility.id && handleActivateAbility(selectedAbility.id);
                      closeAbilityDetail();
                    }}
                    disabled={selectedAbility.isActive}
                  >
                    {selectedAbility.isActive
                      ? (labels?.detail?.alreadyActivatedText || 'Already Activated')
                      : (labels?.detail?.activateButtonText || 'Activate Ability')}
                  </button>
                </div>
              )}
            </div>
          </div>
        )}
      </ScrollDialog>
    </div>
  );
};

export default AbilityList;
</file>

<file path="src/components/game/LuckyDraw.tsx">
// src/components/game/LuckyDraw.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  getLuckyPointsTotal,
  performLuckyDraw,
  PrizeLevel
} from '@/services/timelyRewardService';
import { RewardRecord } from '@/services/rewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import LuckyPointsDisplay from './LuckyPointsDisplay';
import RewardAnimation from '@/components/animation/RewardAnimation';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { getLocalizedLabel, getLocalizedLabels } from '@/utils/localization';

interface LuckyDrawProps {
  onClose?: () => void;
  onRewardEarned?: (rewards: RewardRecord[]) => void;
}

/**
 * å¹¸è¿æŠ½å¥–ç»„ä»¶
 * å…è®¸ç”¨æˆ·ä½¿ç”¨å¹¸è¿ç‚¹è¿›è¡ŒæŠ½å¥–
 */
const LuckyDraw: React.FC<LuckyDrawProps> = ({ onClose, onRewardEarned }) => {
  const [points, setPoints] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [isDrawing, setIsDrawing] = useState(false);
  const [rewards, setRewards] = useState<RewardRecord[]>([]);
  const [showRewards, setShowRewards] = useState(false);
  const [selectedPoints, setSelectedPoints] = useState(10); // é»˜è®¤ä½¿ç”¨10ç‚¹
  const [error, setError] = useState<string | null>(null);
  const [labels, setLabels] = useState({
    title: 'Lucky Draw',
    basicDrawLabel: 'Basic Draw',
    basicDrawDescription: 'Chance to get common rewards',
    premiumDrawLabel: 'Premium Draw',
    premiumDrawDescription: 'Higher chance to get rare rewards',
    deluxeDrawLabel: 'Deluxe Draw',
    deluxeDrawDescription: 'Highest chance to get epic and legendary rewards',
    notEnoughPointsError: 'Not enough lucky points',
    loadPointsError: 'Failed to load lucky points, please try again',
    drawError: 'Failed to perform lucky draw, please try again',
    continueDrawingButton: 'Continue Drawing',
    closeButton: 'Close',
    drawingButton: 'Drawing...',
    drawButton: 'Draw'
  });

  // æŠ½å¥–é€‰é¡¹
  const drawOptions = [
    { points: 10, label: labels.basicDrawLabel, description: labels.basicDrawDescription },
    { points: 30, label: labels.premiumDrawLabel, description: labels.premiumDrawDescription },
    { points: 50, label: labels.deluxeDrawLabel, description: labels.deluxeDrawDescription }
  ];

  // åŠ è½½æœ¬åœ°åŒ–æ ‡ç­¾
  useEffect(() => {
    const loadLocalizedLabels = async () => {
      const languageCode = localStorage.getItem('language') || 'en';
      const localizedLabels = await getLocalizedLabels('luckyDraw', languageCode);

      if (Object.keys(localizedLabels).length > 0) {
        setLabels(prev => ({
          ...prev,
          ...localizedLabels
        }));
      }
    };

    loadLocalizedLabels();
  }, []);

  // åŠ è½½å¹¸è¿ç‚¹æ•°é‡
  const loadPoints = async () => {
    try {
      setIsLoading(true);
      const total = await getLuckyPointsTotal();
      setPoints(total);
    } catch (err) {
      console.error('Failed to load lucky points:', err);
      setError(labels.loadPointsError);
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadPoints();
  }, []);

  // å®šä¹‰å¹¸è¿ç‚¹æ•°æ®æ›´æ–°å¤„ç†å‡½æ•°
  const handleLuckyPointsUpdate = useCallback(() => {
    loadPoints();
  }, [loadPoints]);

  // ä½¿ç”¨ useRegisterTableRefresh hook ç›‘å¬å¹¸è¿ç‚¹è¡¨çš„å˜åŒ–
  useRegisterTableRefresh('luckyPoints', handleLuckyPointsUpdate);

  // å¤„ç†æŠ½å¥–
  const handleDraw = async () => {
    if (points < selectedPoints) {
      setError(labels.notEnoughPointsError);
      return;
    }

    try {
      setIsDrawing(true);
      setError(null);

      // æ‰§è¡ŒæŠ½å¥–
      const result = await performLuckyDraw(selectedPoints);

      // æ›´æ–°å¹¸è¿ç‚¹
      setPoints(prev => prev - selectedPoints);

      // è®¾ç½®å¥–åŠ±
      setRewards(result.rewards);

      // æ˜¾ç¤ºå¥–åŠ±åŠ¨ç”»
      setTimeout(() => {
        setShowRewards(true);
      }, 1000);

      // é€šçŸ¥çˆ¶ç»„ä»¶
      if (onRewardEarned) {
        onRewardEarned(result.rewards);
      }
    } catch (err) {
      console.error('Failed to perform lucky draw:', err);
      setError(labels.drawError);
    } finally {
      setIsDrawing(false);
    }
  };

  // å¤„ç†å…³é—­
  const handleClose = () => {
    if (onClose) {
      onClose();
    }
  };

  // å¤„ç†é€‰æ‹©æŠ½å¥–é€‰é¡¹
  const handleSelectOption = (points: number) => {
    setSelectedPoints(points);
  };

  // å¤„ç†ç»§ç»­æŠ½å¥–
  const handleContinue = () => {
    setShowRewards(false);
    setRewards([]);
  };

  return (
    <div className="lucky-draw-container">
      <div className="lucky-draw-header">
        <h2 className="lucky-draw-title">{labels.title}</h2>
        <LuckyPointsDisplay variant="large" />
      </div>

      {isLoading ? (
        <LoadingSpinner />
      ) : showRewards ? (
        <div className="lucky-draw-results">
          <RewardAnimation rewards={rewards} />
          <div className="lucky-draw-actions">
            <Button onClick={handleContinue}>{labels.continueDrawingButton}</Button>
            <Button onClick={handleClose}>{labels.closeButton}</Button>
          </div>
        </div>
      ) : (
        <>
          <div className="lucky-draw-options">
            <AnimatePresence>
              {drawOptions.map(option => (
                <motion.div
                  key={option.points}
                  className={`draw-option ${selectedPoints === option.points ? 'selected' : ''} ${points < option.points ? 'disabled' : ''}`}
                  onClick={() => handleSelectOption(option.points)}
                  whileHover={{ scale: points >= option.points ? 1.05 : 1 }}
                  whileTap={{ scale: points >= option.points ? 0.95 : 1 }}
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -20 }}
                  transition={{ duration: 0.3 }}
                >
                  <div className="draw-option-header">
                    <div className="draw-option-points">
                      <span className="lucky-points-icon">ğŸ€</span>
                      <span>{option.points}</span>
                    </div>
                    <h3 className="draw-option-label">{option.label}</h3>
                  </div>
                  <p className="draw-option-description">{option.description}</p>
                  {points < option.points && (
                    <div className="draw-option-insufficient">{labels.notEnoughPointsError}</div>
                  )}
                </motion.div>
              ))}
            </AnimatePresence>
          </div>

          {error && (
            <div className="error-message">{error}</div>
          )}

          <div className="lucky-draw-actions">
            <Button
              onClick={handleDraw}
              disabled={isDrawing || points < selectedPoints}
              className="draw-button"
            >
              {isDrawing ? labels.drawingButton : labels.drawButton}
            </Button>
            <Button onClick={handleClose}>{labels.closeButton}</Button>
          </div>
        </>
      )}
    </div>
  );
};

export default LuckyDraw;
</file>

<file path="src/components/game/LuckyPointsDisplay.tsx">
// src/components/game/LuckyPointsDisplay.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { getLuckyPointsTotal } from '@/services/timelyRewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import { getLocalizedLabel } from '@/utils/localization';

interface LuckyPointsDisplayProps {
  onClick?: () => void;
  variant?: 'default' | 'compact' | 'large';
}

/**
 * å¹¸è¿ç‚¹æ˜¾ç¤ºç»„ä»¶
 * æ˜¾ç¤ºç”¨æˆ·å½“å‰çš„å¹¸è¿ç‚¹æ•°é‡
 */
const LuckyPointsDisplay: React.FC<LuckyPointsDisplayProps> = ({
  onClick,
  variant = 'default'
}) => {
  const [points, setPoints] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [isAnimating, setIsAnimating] = useState(false);
  const [labels, setLabels] = useState<{
    label: string;
    loadingText: string;
  }>({
    label: 'Lucky Points',
    loadingText: 'Loading...'
  });

  // åŠ è½½å¹¸è¿ç‚¹æ•°é‡
  const loadPoints = async () => {
    try {
      setIsLoading(true);
      const total = await getLuckyPointsTotal();
      setPoints(total);
    } catch (err) {
      console.error('Failed to load lucky points:', err);
    } finally {
      setIsLoading(false);
    }
  };

  // åŠ è½½æœ¬åœ°åŒ–æ ‡ç­¾
  useEffect(() => {
    const loadLabels = async () => {
      const languageCode = localStorage.getItem('language') || 'en';
      const labelText = await getLocalizedLabel('luckyPointsDisplay', 'label', languageCode);
      const loadingText = await getLocalizedLabel('luckyPointsDisplay', 'loadingText', languageCode);

      setLabels({
        label: labelText || 'Lucky Points',
        loadingText: loadingText || 'Loading...'
      });
    };

    loadLabels();
  }, []);

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadPoints();
  }, []);

  // å®šä¹‰å¹¸è¿ç‚¹æ•°æ®æ›´æ–°å¤„ç†å‡½æ•°
  const handleLuckyPointsUpdate = useCallback(() => {
    loadPoints();
    setIsAnimating(true);

    // åŠ¨ç”»ç»“æŸåé‡ç½®çŠ¶æ€
    setTimeout(() => {
      setIsAnimating(false);
    }, 1000);
  }, [loadPoints]);

  // ä½¿ç”¨ useRegisterTableRefresh hook ç›‘å¬å¹¸è¿ç‚¹è¡¨çš„å˜åŒ–
  useRegisterTableRefresh('luckyPoints', handleLuckyPointsUpdate);

  // å¤„ç†ç‚¹å‡»äº‹ä»¶
  const handleClick = () => {
    if (onClick) {
      onClick();
    }
  };

  // è·å–å˜ä½“ç±»å
  const getVariantClass = () => {
    switch (variant) {
      case 'compact':
        return 'lucky-points-compact';
      case 'large':
        return 'lucky-points-large';
      default:
        return 'lucky-points-default';
    }
  };

  return (
    <motion.div
      className={`lucky-points-display ${getVariantClass()} ${isAnimating ? 'animating' : ''}`}
      onClick={handleClick}
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
    >
      <div className="lucky-points-icon">ğŸ€</div>
      <AnimatePresence mode="wait">
        <motion.div
          key={points}
          className="lucky-points-value"
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: 10 }}
          transition={{ duration: 0.3 }}
        >
          {isLoading ? (
            <span className="loading-dots">{labels.loadingText}</span>
          ) : (
            <span>{points}</span>
          )}
        </motion.div>
      </AnimatePresence>
      <div className="lucky-points-label">{labels.label}</div>
    </motion.div>
  );
};

export default LuckyPointsDisplay;
</file>

<file path="src/components/game/PandaAvatar.tsx">
// src/components/game/PandaAvatar.tsx
import React, { useState, useEffect } from 'react';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import {
  getEquippedAccessories,
  PandaAccessoryRecord,
  PandaAccessoryType,
  getActiveEnvironment,
  PandaEnvironmentRecord
} from '@/services/pandaCustomizationService';

// ç†ŠçŒ«çŠ¶æ€ç±»å‹
export type PandaMood = 'normal' | 'happy' | 'focused' | 'tired';

// ç†ŠçŒ«èƒ½é‡çº§åˆ«
export type EnergyLevel = 'high' | 'medium' | 'low';

interface PandaAvatarProps {
  mood?: PandaMood;
  energy?: EnergyLevel;
  size?: number;
  onClick?: () => void;
  className?: string;
  animate?: boolean;
  showAccessories?: boolean;
  showEnvironment?: boolean;
}

/**
 * ç†ŠçŒ«å¤´åƒç»„ä»¶ï¼Œæ˜¾ç¤ºä¸åŒæƒ…ç»ªå’Œèƒ½é‡çŠ¶æ€çš„ç†ŠçŒ«
 *
 * @param mood - ç†ŠçŒ«çš„æƒ…ç»ªçŠ¶æ€ï¼šnormal(æ­£å¸¸), happy(å¼€å¿ƒ), focused(ä¸“æ³¨), tired(ç–²æƒ«)
 * @param energy - ç†ŠçŒ«çš„èƒ½é‡çº§åˆ«ï¼šhigh(é«˜), medium(ä¸­), low(ä½)
 * @param size - å¤´åƒå¤§å°ï¼Œé»˜è®¤ä¸º120px
 * @param onClick - ç‚¹å‡»å¤´åƒæ—¶çš„å›è°ƒå‡½æ•°
 * @param className - é¢å¤–çš„CSSç±»å
 * @param animate - æ˜¯å¦å¯ç”¨åŠ¨ç”»æ•ˆæœ
 * @param showAccessories - æ˜¯å¦æ˜¾ç¤ºè£…é¥°ï¼Œé»˜è®¤ä¸ºtrue
 * @param showEnvironment - æ˜¯å¦æ˜¾ç¤ºç¯å¢ƒï¼Œé»˜è®¤ä¸ºfalse
 */
const PandaAvatar: React.FC<PandaAvatarProps> = ({
  mood = 'normal',
  energy = 'medium',
  size = 120,
  onClick,
  className = '',
  animate = true,
  showAccessories = true,
  showEnvironment = false
}) => {
  const [isAnimating, setIsAnimating] = useState(false);
  const [accessories, setAccessories] = useState<PandaAccessoryRecord[]>([]);
  const [environment, setEnvironment] = useState<PandaEnvironmentRecord | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // åŠ è½½è£…é¥°å’Œç¯å¢ƒ
  const loadCustomizations = async () => {
    try {
      setIsLoading(true);

      // åŠ è½½è£…é¥°
      if (showAccessories) {
        const equippedAccessories = await getEquippedAccessories();
        setAccessories(equippedAccessories);
      }

      // åŠ è½½ç¯å¢ƒ
      if (showEnvironment) {
        const activeEnvironment = await getActiveEnvironment();
        if (activeEnvironment) {
          setEnvironment(activeEnvironment);
        }
      }
    } catch (err) {
      console.error('Failed to load customizations:', err);
    } finally {
      setIsLoading(false);
    }
  };

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadCustomizations();
  }, [showAccessories, showEnvironment]);

  // æ³¨å†Œæ•°æ®åˆ·æ–°ç›‘å¬
  useRegisterTableRefresh('pandaAccessories', loadCustomizations);
  useRegisterTableRefresh('pandaEnvironments', loadCustomizations);

  // æ ¹æ®æƒ…ç»ªçŠ¶æ€è·å–å¯¹åº”çš„SVGå›¾åƒè·¯å¾„
  const getPandaImage = (pandaMood: PandaMood) => {
    switch (pandaMood) {
      case 'happy':
        return '/assets/panda-happy.svg';
      case 'focused':
        return '/assets/panda-focused.svg';
      case 'tired':
        return '/assets/panda-tired.svg';
      case 'normal':
      default:
        return '/assets/panda-normal.svg';
    }
  };

  // æ ¹æ®èƒ½é‡çº§åˆ«è·å–å¯¹åº”çš„æ ·å¼
  const getEnergyStyle = (level: EnergyLevel) => {
    switch (level) {
      case 'high':
        return { filter: 'brightness(1.2) saturate(1.2)', transform: 'scale(1.05)' };
      case 'low':
        return { filter: 'brightness(0.9) saturate(0.8)', transform: 'scale(0.95)' };
      case 'medium':
      default:
        return { filter: 'brightness(1) saturate(1)', transform: 'scale(1)' };
    }
  };

  // å¤„ç†ç‚¹å‡»äº‹ä»¶
  const handleClick = () => {
    if (onClick) {
      onClick();
    }

    if (animate) {
      setIsAnimating(true);
      setTimeout(() => setIsAnimating(false), 500);
    }
  };

  // åŠ¨ç”»æ•ˆæœ
  useEffect(() => {
    if (animate && isAnimating) {
      // åŠ¨ç”»é€»è¾‘å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ 
    }
  }, [animate, isAnimating]);

  // è·å–è£…é¥°çš„z-index
  const getAccessoryZIndex = (type: PandaAccessoryType): number => {
    switch (type) {
      case PandaAccessoryType.BACKGROUND:
        return -1;
      case PandaAccessoryType.FRAME:
        return 1;
      case PandaAccessoryType.HAT:
        return 2;
      case PandaAccessoryType.GLASSES:
        return 3;
      case PandaAccessoryType.SCARF:
        return 4;
      case PandaAccessoryType.PENDANT:
        return 5;
      case PandaAccessoryType.EFFECT:
        return 10;
      default:
        return 0;
    }
  };

  // ç»„åˆæ ·å¼
  const energyStyle = getEnergyStyle(energy);
  const animationStyle = isAnimating ? { animation: 'panda-bounce 0.5s ease' } : {};
  const combinedStyle = {
    width: `${size}px`,
    height: `${size}px`,
    cursor: onClick ? 'pointer' : 'default',
    transition: 'all 0.3s ease',
    ...energyStyle,
    ...animationStyle
  };

  // ç¯å¢ƒæ ·å¼
  const environmentStyle = showEnvironment && environment ? {
    backgroundImage: `url(${environment.backgroundPath})`,
    backgroundSize: 'cover',
    backgroundPosition: 'center',
    borderRadius: '8px',
    padding: '10px'
  } : {};

  return (
    <div
      className={`panda-environment ${className}`}
      style={environmentStyle}
    >
      <div
        className={`panda-avatar ${className}`}
        style={combinedStyle}
        onClick={handleClick}
      >
        {/* èƒŒæ™¯è£…é¥° */}
        {showAccessories && accessories.filter(a => a.type === PandaAccessoryType.BACKGROUND).map(accessory => (
          <img
            key={accessory.id}
            src={accessory.imagePath}
            alt={accessory.name}
            style={{
              position: 'absolute',
              width: '100%',
              height: '100%',
              zIndex: getAccessoryZIndex(accessory.type)
            }}
          />
        ))}

        {/* ç†ŠçŒ«åŸºç¡€å›¾åƒ */}
        <img
          src={getPandaImage(mood)}
          alt={`Panda in ${mood} mood`}
          style={{ width: '100%', height: '100%', position: 'relative', zIndex: 0 }}
        />

        {/* å…¶ä»–è£…é¥° */}
        {showAccessories && accessories.filter(a => a.type !== PandaAccessoryType.BACKGROUND).map(accessory => (
          <img
            key={accessory.id}
            src={accessory.imagePath}
            alt={accessory.name}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',
              zIndex: getAccessoryZIndex(accessory.type),
              pointerEvents: 'none'
            }}
          />
        ))}
      </div>

      {/* ç¯å¢ƒå‰æ™¯ */}
      {showEnvironment && environment && environment.foregroundPath && (
        <img
          src={environment.foregroundPath}
          alt={`${environment.name} foreground`}
          style={{
            position: 'absolute',
            bottom: 0,
            left: 0,
            width: '100%',
            zIndex: 20,
            pointerEvents: 'none'
          }}
        />
      )}
    </div>
  );
};

export default PandaAvatar;
</file>

<file path="src/components/game/RewardModal.tsx">
// src/components/game/RewardModal.tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ScrollDialog from './ScrollDialog';
import Button from '@/components/common/Button';
import RewardAnimation from '@/components/animation/RewardAnimation';
import { RewardRecord, markRewardsAsViewed } from '@/services/rewardService';
import { useTableRefresh } from '@/hooks/useDataRefresh';

interface RewardModalProps {
  isOpen: boolean;
  onClose: () => void;
  rewards: RewardRecord[];
}

/**
 * å¥–åŠ±å±•ç¤ºæ¨¡æ€æ¡†
 * ä»¥å·è½´é£æ ¼å±•ç¤ºä»»åŠ¡å®Œæˆåè·å¾—çš„å¥–åŠ±
 *
 * @param isOpen - æ§åˆ¶æ¨¡æ€æ¡†æ˜¯å¦æ˜¾ç¤º
 * @param onClose - å…³é—­æ¨¡æ€æ¡†çš„å›è°ƒå‡½æ•°
 * @param rewards - è¦å±•ç¤ºçš„å¥–åŠ±åˆ—è¡¨
 */
const RewardModal: React.FC<RewardModalProps> = ({
  isOpen,
  onClose,
  rewards
}) => {
  const [currentRewardIndex, setCurrentRewardIndex] = useState(0);
  const [showAll, setShowAll] = useState(false);
  const [animationComplete, setAnimationComplete] = useState(false);

  // å½“å‰å±•ç¤ºçš„å¥–åŠ±
  const currentReward = rewards[currentRewardIndex];

  // é‡ç½®çŠ¶æ€
  useEffect(() => {
    if (isOpen) {
      setCurrentRewardIndex(0);
      setShowAll(false);
      setAnimationComplete(false);
    }
  }, [isOpen]);

  // æ ‡è®°å¥–åŠ±ä¸ºå·²æŸ¥çœ‹
  useEffect(() => {
    if (!isOpen) return;

    const rewardIds = rewards
      .filter(reward => reward.id !== undefined)
      .map(reward => reward.id as number);

    if (rewardIds.length > 0) {
      markRewardsAsViewed(rewardIds);
    }
  }, [isOpen, rewards]);

  // å¤„ç†åŠ¨ç”»å®Œæˆ
  const handleAnimationComplete = () => {
    setAnimationComplete(true);
  };

  // æ˜¾ç¤ºä¸‹ä¸€ä¸ªå¥–åŠ±
  const handleNextReward = () => {
    if (currentRewardIndex < rewards.length - 1) {
      setCurrentRewardIndex(prev => prev + 1);
      setAnimationComplete(false);
    } else {
      setShowAll(true);
    }
  };

  // è·å–å¥–åŠ±ç¨€æœ‰åº¦çš„åç§°
  const getRarityName = (rarity: string): string => {
    switch (rarity) {
      case 'common': return 'Common';
      case 'uncommon': return 'Uncommon';
      case 'rare': return 'Rare';
      case 'epic': return 'Epic';
      case 'legendary': return 'Legendary';
      default: return 'Common';
    }
  };

  // è·å–å¥–åŠ±ç±»å‹çš„åç§°
  const getTypeName = (type: string): string => {
    switch (type) {
      case 'experience': return 'Experience';
      case 'coin': return 'Bamboo Coin';
      case 'item': return 'Item';
      case 'badge': return 'Badge';
      case 'ability': return 'Ability';
      default: return 'Reward';
    }
  };

  // æ ¹æ®ç¨€æœ‰åº¦è·å–åŠ¨ç”»æ ·å¼
  const getAnimationStyleForRarity = (rarity: string): 'default' | 'burst' | 'float' | 'spin' | 'pulse' => {
    switch (rarity) {
      case 'legendary': return 'burst';
      case 'epic': return 'spin';
      case 'rare': return 'pulse';
      case 'uncommon': return 'float';
      default: return 'default';
    }
  };

  // æ¸²æŸ“å•ä¸ªå¥–åŠ±å±•ç¤º
  const renderSingleReward = () => {
    // ç¡®ä¿æœ‰å¥–åŠ±å¯ä»¥æ˜¾ç¤º
    if (!rewards.length || !currentReward) {
      return (
        <div className="reward-showcase">
          <h3 className="reward-title">No Rewards</h3>
          <div className="reward-navigation">
            <Button variant="gold" onClick={onClose}>
              Close
            </Button>
          </div>
        </div>
      );
    }

    return (
      <div className="reward-showcase">
        <h3 className="reward-title">
          You got a {getTypeName(currentReward.type)} reward!
        </h3>

        <div className="reward-animation-container">
          <RewardAnimation
            type={currentReward.type}
            rarity={currentReward.rarity}
            iconPath={currentReward.iconPath}
            amount={currentReward.amount}
            size={120}
            onAnimationComplete={handleAnimationComplete}
            animationStyle={getAnimationStyleForRarity(currentReward.rarity)}
            playSound={true}
            soundVolume={0.6}
          />
        </div>

        <div className="reward-details">
          <h4>{currentReward.name}</h4>
          <p className="reward-rarity">
            {getRarityName(currentReward.rarity)}
          </p>
          <p className="reward-description">
            {currentReward.description}
          </p>
          {currentReward.amount > 1 && (
            <p className="reward-amount">
              Quantity: {currentReward.amount}
            </p>
          )}
        </div>

        <div className="reward-navigation">
          <AnimatePresence>
            {animationComplete && (
              <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                transition={{ duration: 0.3 }}
              >
                {currentRewardIndex < rewards.length - 1 ? (
                  <Button variant="jade" onClick={handleNextReward}>
                    Next Reward
                  </Button>
                ) : (
                  <Button variant="jade" onClick={() => setShowAll(true)}>
                    View All Rewards
                  </Button>
                )}
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      </div>
    );
  };

  // æ¸²æŸ“æ‰€æœ‰å¥–åŠ±åˆ—è¡¨
  const renderAllRewards = () => {
    // ç¡®ä¿æœ‰å¥–åŠ±å¯ä»¥æ˜¾ç¤º
    if (!rewards.length) {
      return (
        <div className="rewards-summary">
          <h3 className="rewards-summary-title">No Rewards</h3>
          <div className="rewards-summary-footer">
            <Button variant="gold" onClick={onClose}>
              Close
            </Button>
          </div>
        </div>
      );
    }

    return (
      <div className="rewards-summary">
        <h3 className="rewards-summary-title">
          Rewards Summary
        </h3>

        <div className="rewards-list">
          {rewards.map((reward, index) => (
            <div key={index} className="reward-item">
              <div className="reward-item-icon">
                <img
                  src={reward.iconPath}
                  alt={reward.name}
                  style={{ width: 40, height: 40 }}
                />
              </div>
              <div className="reward-item-details">
                <h4>{reward.name}</h4>
                <p className="reward-item-description">
                  {reward.description}
                </p>
              </div>
              <div className="reward-item-amount">
                {reward.amount > 0 && `x${reward.amount}`}
              </div>
            </div>
          ))}
        </div>

        <div className="rewards-summary-footer">
          <Button variant="gold" onClick={onClose}>
            Close
          </Button>
        </div>
      </div>
    );
  };

  return (
    <ScrollDialog
      isOpen={isOpen}
      onClose={onClose}
      title="Task Rewards"
      closeOnOutsideClick={false}
      closeOnEsc={false}
      showCloseButton={showAll}
      footer={null}
    >
      <div className="reward-modal-content">
        {!showAll ? renderSingleReward() : renderAllRewards()}
      </div>
    </ScrollDialog>
  );
};

export default RewardModal;
</file>

<file path="src/components/game/TaskCard.tsx">
// src/components/game/TaskCard.tsx
import React, { useState } from 'react';
import { TaskRecord, TaskPriority, TaskStatus, TaskType } from '@/services/taskService';
import { hasSubtasks } from '@/services/subtaskService';
import TaskDetailDialog from './TaskDetailDialog';

interface TaskCardProps {
  task: TaskRecord;
  onComplete?: (taskId: number) => void;
  onEdit?: (taskId: number) => void;
  onDelete?: (taskId: number) => void;
  onTaskUpdated?: () => void;
  className?: string;
}

/**
 * ä»»åŠ¡å¡ç‰‡ç»„ä»¶ï¼Œæ˜¾ç¤ºä»»åŠ¡ä¿¡æ¯å’Œæ“ä½œæŒ‰é’®
 */
const TaskCard: React.FC<TaskCardProps> = ({
  task,
  onComplete,
  onEdit,
  onDelete,
  onTaskUpdated,
  className = ''
}) => {
  const [showDetailDialog, setShowDetailDialog] = useState(false);
  const [hasSubtasksList, setHasSubtasksList] = useState(false);

  // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦æœ‰å­ä»»åŠ¡
  React.useEffect(() => {
    const checkSubtasks = async () => {
      if (task && task.id) {
        try {
          const hasSubtasksList = await hasSubtasks(task.id);
          setHasSubtasksList(hasSubtasksList);
        } catch (err) {
          console.error('Failed to check subtasks:', err);
        }
      }
    };

    checkSubtasks();
  }, [task]);
  // è·å–ä»»åŠ¡ä¼˜å…ˆçº§å¯¹åº”çš„æ ·å¼
  const getPriorityStyle = (priority: TaskPriority) => {
    switch (priority) {
      case TaskPriority.HIGH:
        return 'task-priority-high';
      case TaskPriority.MEDIUM:
        return 'task-priority-medium';
      case TaskPriority.LOW:
        return 'task-priority-low';
      default:
        return '';
    }
  };

  // è·å–ä»»åŠ¡ç±»å‹å¯¹åº”çš„æ ·å¼
  const getTypeStyle = (type: TaskType) => {
    switch (type) {
      case TaskType.MAIN:
        return 'task-type-main';
      case TaskType.DAILY:
        return 'task-type-daily';
      case TaskType.SIDE:
        return 'task-type-side';
      default:
        return '';
    }
  };

  // è·å–ä»»åŠ¡çŠ¶æ€å¯¹åº”çš„æ ·å¼
  const getStatusStyle = (status: TaskStatus) => {
    switch (status) {
      case TaskStatus.COMPLETED:
        return 'task-status-completed';
      case TaskStatus.IN_PROGRESS:
        return 'task-status-in-progress';
      case TaskStatus.TODO:
        return 'task-status-todo';
      case TaskStatus.ARCHIVED:
        return 'task-status-archived';
      default:
        return '';
    }
  };

  // æ ¼å¼åŒ–æ—¥æœŸæ˜¾ç¤º
  const formatDate = (date: Date | undefined) => {
    if (!date) return '';
    return new Date(date).toLocaleDateString();
  };

  // å¤„ç†å®Œæˆä»»åŠ¡
  const handleComplete = () => {
    if (onComplete && task.id) {
      onComplete(task.id);
    }
  };

  // å¤„ç†ç¼–è¾‘ä»»åŠ¡
  const handleEdit = () => {
    if (onEdit && task.id) {
      onEdit(task.id);
    }
  };

  // å¤„ç†åˆ é™¤ä»»åŠ¡
  const handleDelete = () => {
    if (onDelete && task.id) {
      onDelete(task.id);
    }
  };

  // å¤„ç†æŸ¥çœ‹è¯¦æƒ…
  const handleViewDetails = () => {
    setShowDetailDialog(true);
  };

  // å¤„ç†ä»»åŠ¡æ›´æ–°
  const handleTaskUpdated = () => {
    if (onTaskUpdated) {
      onTaskUpdated();
    }
  };

  return (
    <>
      <div
        className={`task-card ${getPriorityStyle(task.priority)} ${getStatusStyle(task.status)} ${className}`}
        onClick={handleViewDetails}
      >
        <div className="task-card-header">
          <div className={`task-type-badge ${getTypeStyle(task.type)}`}>
            {task.type.toUpperCase()}
          </div>
          <h3 className="task-title">{task.title}</h3>
          {hasSubtasksList && (
            <div className="subtasks-indicator ml-2" title="åŒ…å«å­ä»»åŠ¡">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
              </svg>
            </div>
          )}
        </div>

      {task.description && (
        <div className="task-description">
          {task.description}
        </div>
      )}

      <div className="task-meta">
        {task.dueDate && (
          <div className="task-due-date">
            <span>Due: {formatDate(task.dueDate)}</span>
          </div>
        )}

        {task.estimatedMinutes && (
          <div className="task-estimated-time">
            <span>Est: {task.estimatedMinutes} min</span>
          </div>
        )}
      </div>

      <div className="task-actions">
        {task.status !== TaskStatus.COMPLETED && (
          <button
            className="task-action-complete jade-button-small"
            onClick={handleComplete}
            aria-label="Complete task"
          >
            å®Œæˆ
          </button>
        )}

        <button
          className="task-action-edit"
          onClick={handleEdit}
          aria-label="Edit task"
        >
          ç¼–è¾‘
        </button>

        <button
          className="task-action-delete"
          onClick={handleDelete}
          aria-label="Delete task"
        >
          åˆ é™¤
        </button>
      </div>
      </div>

      {/* ä»»åŠ¡è¯¦æƒ…å¯¹è¯æ¡† */}
      {showDetailDialog && (
        <TaskDetailDialog
          isOpen={showDetailDialog}
          onClose={() => setShowDetailDialog(false)}
          task={task}
          onTaskUpdated={handleTaskUpdated}
        />
      )}
    </>
  );
};

export default TaskCard;
</file>

<file path="src/components/game/TaskList.tsx">
// src/components/game/TaskList.tsx
import React, { useState, useEffect } from 'react';
import {
  TaskRecord,
  TaskStatus,
  TaskPriority,
  TaskType,
  TaskCategoryRecord,
  getAllTasks,
  getAllTaskCategories,
  completeTask,
  deleteTask
} from '@/services/taskService';
import TaskCard from './TaskCard';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';

interface TaskListProps {
  onEditTask: (taskId: number) => void;
  filter?: {
    status?: TaskStatus;
    categoryId?: number;
    type?: TaskType;
    priority?: TaskPriority;
  };
  refreshTrigger?: number; // ç”¨äºè§¦å‘åˆ·æ–°çš„å€¼
}

/**
 * ä»»åŠ¡åˆ—è¡¨ç»„ä»¶ï¼Œæ˜¾ç¤ºä»»åŠ¡å¡ç‰‡åˆ—è¡¨
 */
const TaskList: React.FC<TaskListProps> = ({
  onEditTask,
  filter,
  refreshTrigger = 0
}) => {
  const [tasks, setTasks] = useState<TaskRecord[]>([]);
  const [categories, setCategories] = useState<Record<number, TaskCategoryRecord>>({});
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // åŠ è½½ä»»åŠ¡å’Œç±»åˆ«
  useEffect(() => {
    const loadData = async () => {
      try {
        setIsLoading(true);
        setError(null);

        // åŠ è½½ä»»åŠ¡
        const taskList = await getAllTasks(filter);
        setTasks(taskList);

        // åŠ è½½ç±»åˆ«
        const categoryList = await getAllTaskCategories();
        const categoryMap: Record<number, TaskCategoryRecord> = {};
        categoryList.forEach(category => {
          if (category.id) {
            categoryMap[category.id] = category;
          }
        });
        setCategories(categoryMap);
      } catch (err) {
        console.error('Failed to load tasks:', err);
        setError('åŠ è½½ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, [filter, refreshTrigger]);

  // å¤„ç†å®Œæˆä»»åŠ¡
  const handleCompleteTask = async (taskId: number) => {
    try {
      setIsLoading(true);
      await completeTask(taskId);

      // æ›´æ–°ä»»åŠ¡åˆ—è¡¨
      setTasks(prevTasks =>
        prevTasks.map(task =>
          task.id === taskId
            ? { ...task, status: TaskStatus.COMPLETED, completedAt: new Date() }
            : task
        )
      );
    } catch (err) {
      console.error('Failed to complete task:', err);
      setError('å®Œæˆä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // å¤„ç†åˆ é™¤ä»»åŠ¡
  const handleDeleteTask = async (taskId: number) => {
    if (!window.confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä»»åŠ¡å—ï¼Ÿ')) {
      return;
    }

    try {
      setIsLoading(true);
      await deleteTask(taskId);

      // æ›´æ–°ä»»åŠ¡åˆ—è¡¨
      setTasks(prevTasks => prevTasks.filter(task => task.id !== taskId));
    } catch (err) {
      console.error('Failed to delete task:', err);
      setError('åˆ é™¤ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsLoading(false);
    }
  };

  // è·å–ä»»åŠ¡ç±»åˆ«åç§°
  const getCategoryName = (categoryId: number) => {
    return categories[categoryId]?.name || 'æœªåˆ†ç±»';
  };

  // æŒ‰ä¼˜å…ˆçº§æ’åºä»»åŠ¡
  const sortedTasks = [...tasks].sort((a, b) => {
    // é¦–å…ˆæŒ‰çŠ¶æ€æ’åºï¼ˆæœªå®Œæˆçš„åœ¨å‰ï¼‰
    if (a.status !== b.status) {
      if (a.status === TaskStatus.COMPLETED) return 1;
      if (b.status === TaskStatus.COMPLETED) return -1;
    }

    // ç„¶åæŒ‰ä¼˜å…ˆçº§æ’åº
    const priorityOrder = {
      [TaskPriority.HIGH]: 0,
      [TaskPriority.MEDIUM]: 1,
      [TaskPriority.LOW]: 2
    };

    return priorityOrder[a.priority] - priorityOrder[b.priority];
  });

  if (isLoading && tasks.length === 0) {
    return <LoadingSpinner variant="jade" text="åŠ è½½ä»»åŠ¡ä¸­..." />;
  }

  if (error) {
    return (
      <div className="task-list-error">
        <p>{error}</p>
        <Button variant="jade" onClick={() => window.location.reload()}>
          é‡è¯•
        </Button>
      </div>
    );
  }

  if (tasks.length === 0) {
    return (
      <div className="task-list-empty">
        <p>æš‚æ— ä»»åŠ¡</p>
      </div>
    );
  }

  // å¤„ç†ä»»åŠ¡æ›´æ–°
  const handleTaskUpdated = async () => {
    try {
      setIsLoading(true);
      const taskList = await getAllTasks(filter);
      setTasks(taskList);
    } catch (err) {
      console.error('Failed to reload tasks:', err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="task-list">
      {isLoading && (
        <div className="task-list-loading-overlay">
          <LoadingSpinner variant="jade" />
        </div>
      )}

      {sortedTasks.map(task => (
        <TaskCard
          key={task.id}
          task={task}
          onComplete={handleCompleteTask}
          onEdit={onEditTask}
          onDelete={handleDeleteTask}
          onTaskUpdated={handleTaskUpdated}
        />
      ))}
    </div>
  );
};

export default TaskList;
</file>

<file path="src/components/game/TimelyRewardList.tsx">
// src/components/game/TimelyRewardList.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  TimelyRewardRecord,
  TimelyRewardStatus,
  TimelyRewardType,
  getAllTimelyRewards,
  completeTimelyReward,
  updateTimelyRewardsStatus
} from '@/services/timelyRewardService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import TimelyRewardCard from './TimelyRewardCard';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import RewardModal from '@/components/game/RewardModal';
import { RewardRecord } from '@/services/rewardService';
import ScrollDialog from './ScrollDialog';
import LuckyPointsDisplay from './LuckyPointsDisplay';
import { TimelyRewardCardLabels } from '@/types';

interface TimelyRewardListProps {
  filter?: {
    status?: TimelyRewardStatus;
    type?: TimelyRewardType;
  };
  onSelectReward?: (reward: TimelyRewardRecord) => void;
  labels?: TimelyRewardCardLabels;
}

/**
 * Timely reward list component
 * Displays a list of timely rewards with filtering and selection support
 */
const TimelyRewardList: React.FC<TimelyRewardListProps> = ({ filter, onSelectReward, labels }) => {
  // Add console log to check labels
  console.log('TimelyRewardList labels:', labels);
  const [rewards, setRewards] = useState<TimelyRewardRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [earnedRewards, setEarnedRewards] = useState<RewardRecord[]>([]);
  const [showRewardModal, setShowRewardModal] = useState(false);
  const [selectedReward, setSelectedReward] = useState<TimelyRewardRecord | null>(null);
  const [showRewardDetails, setShowRewardDetails] = useState(false);

  // åŠ è½½åŠæ—¶å¥–åŠ±
  const loadTimelyRewards = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      // æ›´æ–°åŠæ—¶å¥–åŠ±çŠ¶æ€
      await updateTimelyRewardsStatus();

      // è·å–åŠæ—¶å¥–åŠ±åˆ—è¡¨
      const rewardList = await getAllTimelyRewards(filter);
      setRewards(rewardList);
    } catch (err) {
      console.error('Failed to load timely rewards:', err);
      setError('Failed to load timely rewards, please try again');
    } finally {
      setIsLoading(false);
    }
  }, [filter]);

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadTimelyRewards();
  }, [loadTimelyRewards]);

  // å®šä¹‰å¥–åŠ±æ•°æ®æ›´æ–°å¤„ç†å‡½æ•°
  const handleRewardDataUpdate = useCallback((rewardData: any) => {
    // å¦‚æœæœ‰ç‰¹å®šå¥–åŠ±æ•°æ®ï¼Œåˆ™æ›´æ–°è¯¥å¥–åŠ±
    if (rewardData && rewardData.id) {
      setRewards(prevRewards => {
        // æ£€æŸ¥å¥–åŠ±æ˜¯å¦å·²å­˜åœ¨
        const rewardExists = prevRewards.some(reward => reward.id === rewardData.id);

        if (rewardExists) {
          // æ›´æ–°ç°æœ‰å¥–åŠ±
          return prevRewards.map(reward =>
            reward.id === rewardData.id ? { ...reward, ...rewardData } : reward
          );
        } else {
          // æ·»åŠ æ–°å¥–åŠ±ï¼ˆå¦‚æœç¬¦åˆè¿‡æ»¤æ¡ä»¶ï¼‰
          if (!filter ||
              ((!filter.status || rewardData.status === filter.status) &&
               (!filter.type || rewardData.type === filter.type))) {
            return [...prevRewards, rewardData];
          }
          return prevRewards;
        }
      });
    } else {
      // å¦‚æœæ²¡æœ‰ç‰¹å®šå¥–åŠ±æ•°æ®ï¼Œåˆ™é‡æ–°åŠ è½½æ‰€æœ‰å¥–åŠ±
      loadTimelyRewards();
    }
  }, [loadTimelyRewards, filter]);

  // ä½¿ç”¨ useRegisterTableRefresh hook ç›‘å¬åŠæ—¶å¥–åŠ±è¡¨çš„å˜åŒ–
  useRegisterTableRefresh('timelyRewards', handleRewardDataUpdate);

  // å¤„ç†é€‰æ‹©å¥–åŠ±
  const handleSelectReward = (reward: TimelyRewardRecord) => {
    setSelectedReward(reward);
    setShowRewardDetails(true);

    if (onSelectReward) {
      onSelectReward(reward);
    }
  };

  // Get type text for a reward with localization
  const getTypeTextForReward = (reward: TimelyRewardRecord) => {
    switch (reward.type) {
      case TimelyRewardType.DAILY:
        return labels?.typeDaily || 'Daily Reward';
      case TimelyRewardType.MORNING:
        return labels?.typeMorning || 'Early Bird Reward';
      case TimelyRewardType.STREAK:
        return labels?.typeStreak || 'Streak Reward';
      case TimelyRewardType.SPECIAL:
        return labels?.typeSpecial || 'Special Reward';
      default:
        return '';
    }
  };

  // Get status text for a reward with localization
  const getStatusTextForReward = (reward: TimelyRewardRecord) => {
    switch (reward.status) {
      case TimelyRewardStatus.ACTIVE:
        return labels?.statusActive || 'Active';
      case TimelyRewardStatus.COMPLETED:
        return labels?.statusCompleted || 'Completed';
      case TimelyRewardStatus.EXPIRED:
        return labels?.statusExpired || 'Expired';
      case TimelyRewardStatus.UPCOMING:
        return labels?.statusUpcoming || 'Upcoming';
      default:
        return '';
    }
  };

  // å¤„ç†å®Œæˆå¥–åŠ±
  const handleCompleteReward = async (rewardId: number) => {
    try {
      setIsLoading(true);

      // å®Œæˆå¥–åŠ±å¹¶è·å–å¥–åŠ±
      const rewards = await completeTimelyReward(rewardId);

      // æ›´æ–°å¥–åŠ±åˆ—è¡¨
      setRewards(prevRewards =>
        prevRewards.map(reward =>
          reward.id === rewardId
            ? {
                ...reward,
                status: TimelyRewardStatus.COMPLETED,
                progress: 100,
                completedTime: new Date()
              }
            : reward
        )
      );

      // æ˜¾ç¤ºå¥–åŠ±
      if (rewards && rewards.length > 0) {
        setEarnedRewards(rewards);
        setShowRewardModal(true);
      }
    } catch (err) {
      console.error('Failed to complete timely reward:', err);
      setError('Failed to complete timely reward, please try again');
    } finally {
      setIsLoading(false);
    }
  };

  // å…³é—­å¥–åŠ±æ¨¡æ€æ¡†
  const handleCloseRewardModal = () => {
    setShowRewardModal(false);
  };

  // å…³é—­å¥–åŠ±è¯¦æƒ…
  const handleCloseRewardDetails = () => {
    setShowRewardDetails(false);
    setSelectedReward(null);
  };

  // å¦‚æœæ­£åœ¨åŠ è½½ï¼Œæ˜¾ç¤ºåŠ è½½åŠ¨ç”»
  if (isLoading && rewards.length === 0) {
    return <LoadingSpinner />;
  }

  // å¦‚æœæœ‰é”™è¯¯ï¼Œæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
  if (error && rewards.length === 0) {
    return <div className="error-message">{error}</div>;
  }

  // å¦‚æœæ²¡æœ‰å¥–åŠ±ï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯
  if (rewards.length === 0) {
    return <div className="no-rewards-message">{labels?.noRewardsMessage || "No timely rewards available"}</div>;
  }

  return (
    <div className="timely-reward-list">
      <div className="lucky-points-container">
        <LuckyPointsDisplay />
      </div>

      <AnimatePresence>
        {rewards.map(reward => (
          <TimelyRewardCard
            key={reward.id}
            reward={reward}
            onClick={handleSelectReward}
            onComplete={handleCompleteReward}
            labels={labels}
          />
        ))}
      </AnimatePresence>

      {/* å¥–åŠ±æ¨¡æ€æ¡† */}
      {showRewardModal && (
        <RewardModal
          rewards={earnedRewards}
          onClose={handleCloseRewardModal}
        />
      )}

      {/* å¥–åŠ±è¯¦æƒ… */}
      {showRewardDetails && selectedReward && (
        <ScrollDialog
          title={selectedReward.title}
          onClose={handleCloseRewardDetails}
        >
          <div className="reward-details">
            <div className="reward-header">
              <img
                src={selectedReward.iconPath}
                alt={selectedReward.title}
                className="reward-icon-large"
              />
              <div className="reward-meta-details">
                <div className="reward-type">
                  {labels?.typeLabel || "Type"}: {getTypeTextForReward(selectedReward)}
                </div>
                <div className="reward-status">
                  {labels?.statusLabel || "Status"}: {getStatusTextForReward(selectedReward)}
                </div>
                <div className="reward-lucky-points">
                  {labels?.luckyPointsLabel || "Lucky Points"}: {selectedReward.luckyPoints}
                </div>
              </div>
            </div>

            <div className="reward-description-full">
              {selectedReward.description}
            </div>

            <div className="reward-progress-details">
              <h4>{labels?.progressLabel || "Progress"}: {selectedReward.progress}%</h4>
              <div className="progress-bar-container">
                <div
                  className="progress-bar-fill"
                  style={{ width: `${selectedReward.progress}%` }}
                ></div>
              </div>
            </div>

            <div className="reward-time-details">
              <div>{labels?.startTimeLabel || "Start Time"}: {new Date(selectedReward.startTime).toLocaleString()}</div>
              <div>{labels?.endTimeLabel || "End Time"}: {new Date(selectedReward.endTime).toLocaleString()}</div>
              {selectedReward.completedTime && (
                <div>{labels?.completedTimeLabel || "Completed Time"}: {new Date(selectedReward.completedTime).toLocaleString()}</div>
              )}
            </div>

            {selectedReward.status === TimelyRewardStatus.ACTIVE && (
              <button
                className="complete-reward-button-large"
                onClick={() => handleCompleteReward(selectedReward.id!)}
                disabled={selectedReward.progress < 100}
              >
                {selectedReward.progress >= 100
                  ? (labels?.claimRewardButton || 'Claim Reward')
                  : (labels?.continueEffortButton || 'Keep Going')}
              </button>
            )}
          </div>
        </ScrollDialog>
      )}
    </div>
  );
};

export default TimelyRewardList;
</file>

<file path="src/components/layout/AppShell.tsx">
// src/components/layout/AppShell.tsx
import React, { ReactNode } from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchGlobalLayoutView } from '@/services';
import Header from './Header';
import Navigation from './Navigation';
import LoadingSpinner from '../common/LoadingSpinner';
import ErrorDisplay from '../common/ErrorDisplay';
import ChineseDecoration from '../decoration/ChineseDecoration';
import SyncStatusIndicator from '../common/SyncStatusIndicator';
import type { GlobalLayoutLabelsBundle, ApiError } from '@/types';

interface AppShellProps { children: ReactNode; }

const AppShell: React.FC<AppShellProps> = ({ children }) => {
  const {
    labels: globalLabels, isPending, isError, error, isFetching, refetch
  } = useLocalizedView<null, GlobalLayoutLabelsBundle>(
    'globalLayoutViewContent', // Unique query key for this "view"
    fetchGlobalLayoutView
  );

  if (isPending && !globalLabels) {
    // Use a very generic loading text if global labels themselves are not available
    return <LoadingSpinner variant="jade" text={globalLabels?.loadingGeneric || "Initializing Application..."} />;
  }

  if (isError || !globalLabels) { // Critical error if global labels fail
    return (
      <div style={{ padding: '20px' }}>
        <ErrorDisplay
          error={error} // Error from the hook
          title={globalLabels?.appErrorHeading || "Application Shell Error"}
          messageTemplate={globalLabels?.appErrorGeneralMessage || "Core UI failed. Details: {message}"}
          onRetry={refetch}
          retryButtonText="Retry Loading Shell"
        />
      </div>
    );
  }

  return (
    <div className="app-shell">
      {/* Add Chinese pattern decorative elements */}
      <div className="chinese-pattern top"></div>

      {/* æ·»åŠ ä¸­å›½é£è£…é¥°å…ƒç´  */}
      <ChineseDecoration />

      <Header labels={globalLabels} isFetching={isFetching && !!globalLabels}/> {/* Pass fetching only if labels are loaded */}

      <main>{children}</main>

      {/* ç§»åŠ¨åº”ç”¨åº•éƒ¨å¯¼èˆª */}
      <Navigation labels={globalLabels} variant="bamboo" />

      {/* åŒæ­¥çŠ¶æ€æŒ‡ç¤ºå™¨ */}
      <SyncStatusIndicator variant="standard" showCount={true} showLabel={true} />

      <div className="chinese-pattern bottom"></div>
    </div>
  );
};
export default AppShell;
</file>

<file path="src/context/DataRefreshProvider.tsx">
// src/context/DataRefreshProvider.tsx
import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode, useMemo } from 'react';
import { DataRefreshEvent } from '@/types/dataRefresh';

// æ•°æ®åˆ·æ–°ä¸Šä¸‹æ–‡ç±»å‹
interface DataRefreshContextType {
  lastRefresh: Record<string, DataRefreshEvent | null>;
  refreshTable: (table: string, data?: any) => void;
  registerRefreshListener: (table: string, callback: (data?: any) => void) => () => void;
}

// åˆ›å»ºä¸Šä¸‹æ–‡
const DataRefreshContext = createContext<DataRefreshContextType | undefined>(undefined);

// Providerç»„ä»¶å±æ€§
interface DataRefreshProviderProps {
  children: ReactNode;
}

/**
 * æ•°æ®åˆ·æ–°Providerç»„ä»¶
 * æä¾›å…¨å±€æ•°æ®åˆ·æ–°ç®¡ç†åŠŸèƒ½
 */
export const DataRefreshProvider: React.FC<DataRefreshProviderProps> = ({ children }) => {
  const [lastRefresh, setLastRefresh] = useState<Record<string, DataRefreshEvent | null>>({});
  const [listeners, setListeners] = useState<Record<string, Set<(data?: any) => void>>>({});

  // ç›‘å¬æ•°æ®åˆ·æ–°äº‹ä»¶
  useEffect(() => {
    const handleDataRefresh = (event: Event) => {
      const customEvent = event as CustomEvent<DataRefreshEvent>;
      const { table, data } = customEvent.detail;

      // æ›´æ–°æœ€è¿‘ä¸€æ¬¡åˆ·æ–°çš„æ•°æ®
      setLastRefresh(prev => ({
        ...prev,
        [table]: { table, data }
      }));

      // é€šçŸ¥è¯¥è¡¨çš„æ‰€æœ‰ç›‘å¬å™¨
      if (listeners[table]) {
        listeners[table].forEach(callback => {
          try {
            callback(data);
          } catch (err) {
            console.error(`Error in refresh listener for table ${table}:`, err);
          }
        });
      }
    };

    // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
    window.addEventListener('dataRefresh', handleDataRefresh);

    // æ¸…ç†å‡½æ•°
    return () => {
      window.removeEventListener('dataRefresh', handleDataRefresh);
    };
  }, [listeners]);

  // åˆ·æ–°è¡¨æ•°æ®
  const refreshTable = useCallback((table: string, data?: any) => {
    const refreshEvent = new CustomEvent('dataRefresh', {
      detail: { table, data }
    });
    window.dispatchEvent(refreshEvent);
  }, []);

  // æ³¨å†Œåˆ·æ–°ç›‘å¬å™¨
  const registerRefreshListener = useCallback((table: string, callback: (data?: any) => void) => {
    setListeners(prev => {
      const tableListeners = prev[table] || new Set();
      tableListeners.add(callback);

      return {
        ...prev,
        [table]: tableListeners
      };
    });

    // è¿”å›å–æ¶ˆæ³¨å†Œçš„å‡½æ•°
    return () => {
      setListeners(prev => {
        const tableListeners = prev[table];
        if (tableListeners) {
          tableListeners.delete(callback);

          return {
            ...prev,
            [table]: tableListeners
          };
        }
        return prev;
      });
    };
  }, []);

  // æä¾›ä¸Šä¸‹æ–‡å€¼
  const contextValue: DataRefreshContextType = useMemo(() => ({
    lastRefresh,
    refreshTable,
    registerRefreshListener
  }), [lastRefresh, refreshTable, registerRefreshListener]);

  return (
    <DataRefreshContext.Provider value={contextValue}>
      {children}
    </DataRefreshContext.Provider>
  );
};

/**
 * ä½¿ç”¨æ•°æ®åˆ·æ–°çš„Hook
 * @returns æ•°æ®åˆ·æ–°ä¸Šä¸‹æ–‡
 */
export const useDataRefreshContext = (): DataRefreshContextType => {
  const context = useContext(DataRefreshContext);
  if (context === undefined) {
    throw new Error('useDataRefreshContext must be used within a DataRefreshProvider');
  }
  return context;
};
</file>

<file path="src/features/home/PandaSection.tsx">
// src/features/home/PandaSection.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import PandaAvatar from '@/components/game/PandaAvatar';
import { usePandaState } from '@/context/PandaStateProvider';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import AnimatedButton from '@/components/animation/AnimatedButton';
import GoldenGlow from '@/components/animation/GoldenGlow';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import PandaCustomizationPanel from '@/components/panda/PandaCustomizationPanel';
import PandaEnvironmentPanel from '@/components/panda/PandaEnvironmentPanel';
import { initializePandaCustomization } from '@/services/pandaCustomizationService';
import { playSound, SoundType } from '@/utils/sound';

interface PandaSectionLabels {
  sectionTitle?: string;
  levelLabel?: string;
  experienceLabel?: string;
  interactButtonText?: string;
  feedButtonText?: string;
  playButtonText?: string;
  trainButtonText?: string;
  customizeButtonText?: string;
  environmentButtonText?: string;
}

interface PandaSectionProps {
  labels?: PandaSectionLabels;
}

/**
 * ç†ŠçŒ«äº’åŠ¨åŒºåŸŸç»„ä»¶
 * æ˜¾ç¤ºç†ŠçŒ«å¤´åƒå’Œäº’åŠ¨æŒ‰é’®
 */
const PandaSection: React.FC<PandaSectionProps> = ({ labels }) => {
  const {
    pandaState,
    isLoading,
    setMood,
    addExperience
  } = usePandaState();

  const [interactionMode, setInteractionMode] = useState<'none' | 'feed' | 'play' | 'train'>('none');
  const [showCustomizationPanel, setShowCustomizationPanel] = useState(false);
  const [showEnvironmentPanel, setShowEnvironmentPanel] = useState(false);
  const [showAccessories, setShowAccessories] = useState(true);
  const [showEnvironment, setShowEnvironment] = useState(false);

  // åˆå§‹åŒ–ç†ŠçŒ«å®šåˆ¶ç³»ç»Ÿ
  useEffect(() => {
    const initialize = async () => {
      try {
        await initializePandaCustomization();
      } catch (err) {
        console.error('Failed to initialize panda customization:', err);
      }
    };

    initialize();
  }, []);

  // é»˜è®¤æ ‡ç­¾æ–‡æœ¬
  const defaultLabels: PandaSectionLabels = {
    sectionTitle: 'ç†ŠçŒ«ä¼™ä¼´',
    levelLabel: 'ç­‰çº§',
    experienceLabel: 'ç»éªŒ',
    interactButtonText: 'äº’åŠ¨',
    feedButtonText: 'å–‚é£Ÿ',
    playButtonText: 'ç©è€',
    trainButtonText: 'è®­ç»ƒ',
    customizeButtonText: 'è£…æ‰®',
    environmentButtonText: 'ç¯å¢ƒ'
  };

  // åˆå¹¶é»˜è®¤æ ‡ç­¾å’Œä¼ å…¥çš„æ ‡ç­¾
  const mergedLabels = { ...defaultLabels, ...labels };

  // å®šä¹‰ç†ŠçŒ«çŠ¶æ€æ›´æ–°å¤„ç†å‡½æ•°
  const handlePandaStateUpdate = useCallback(() => {
    // ç†ŠçŒ«çŠ¶æ€å·²ç»é€šè¿‡ usePandaState è·å–ï¼Œä¸éœ€è¦é¢å¤–å¤„ç†
    console.log('Panda state updated in PandaSection');
  }, []);

  // ä½¿ç”¨ useRegisterTableRefresh hook ç›‘å¬ç†ŠçŒ«çŠ¶æ€å˜åŒ–
  useRegisterTableRefresh('pandaState', handlePandaStateUpdate);

  // å¤„ç†äº’åŠ¨æŒ‰é’®ç‚¹å‡»
  const handleInteractClick = () => {
    if (interactionMode === 'none') {
      setInteractionMode('feed');
    } else {
      setInteractionMode('none');
    }
  };

  // å¤„ç†å–‚é£ŸæŒ‰é’®ç‚¹å‡»
  const handleFeedClick = async () => {
    await setMood('happy');
    await addExperience(10);
    setInteractionMode('none');
  };

  // å¤„ç†ç©è€æŒ‰é’®ç‚¹å‡»
  const handlePlayClick = async () => {
    await setMood('happy');
    await addExperience(15);
    setInteractionMode('none');
  };

  // å¤„ç†è®­ç»ƒæŒ‰é’®ç‚¹å‡»
  const handleTrainClick = async () => {
    await setMood('focused');
    await addExperience(20);
    setInteractionMode('none');
  };

  // å¤„ç†æ‰“å¼€è£…æ‰®é¢æ¿
  const handleOpenCustomizationPanel = () => {
    setShowCustomizationPanel(true);
    playSound(SoundType.BUTTON_CLICK, 0.3);
  };

  // å¤„ç†å…³é—­è£…æ‰®é¢æ¿
  const handleCloseCustomizationPanel = () => {
    setShowCustomizationPanel(false);
  };

  // å¤„ç†è£…æ‰®å˜åŒ–
  const handleCustomizationChanged = () => {
    playSound(SoundType.SUCCESS, 0.5);
  };

  // å¤„ç†æ‰“å¼€ç¯å¢ƒé¢æ¿
  const handleOpenEnvironmentPanel = () => {
    setShowEnvironmentPanel(true);
    playSound(SoundType.BUTTON_CLICK, 0.3);
  };

  // å¤„ç†å…³é—­ç¯å¢ƒé¢æ¿
  const handleCloseEnvironmentPanel = () => {
    setShowEnvironmentPanel(false);
  };

  // å¤„ç†ç¯å¢ƒå˜åŒ–
  const handleEnvironmentChanged = () => {
    setShowEnvironment(true);
    playSound(SoundType.SUCCESS, 0.5);
  };

  if (isLoading && !pandaState) {
    return <LoadingSpinner variant="jade" text="åŠ è½½ç†ŠçŒ«ä¸­..." />;
  }

  if (!pandaState) {
    return <div>æ— æ³•åŠ è½½ç†ŠçŒ«çŠ¶æ€</div>;
  }

  return (
    <motion.section
      className="panda-section"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
    >
      <motion.h3
        initial={{ opacity: 0, x: -20 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ delay: 0.2, duration: 0.5 }}
      >
        {mergedLabels.sectionTitle}
      </motion.h3>

      <div className="panda-container" style={{ textAlign: 'center', marginBottom: '20px' }}>
        <motion.div
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
        >
          {pandaState.level > 5 ? (
            <GoldenGlow intensity="medium">
              <PandaAvatar
                mood={pandaState.mood}
                energy={pandaState.energy}
                size={150}
                onClick={handleInteractClick}
                className={pandaState.mood}
                showAccessories={showAccessories}
                showEnvironment={showEnvironment}
              />
            </GoldenGlow>
          ) : (
            <PandaAvatar
              mood={pandaState.mood}
              energy={pandaState.energy}
              size={150}
              onClick={handleInteractClick}
              className={pandaState.mood}
              showAccessories={showAccessories}
              showEnvironment={showEnvironment}
            />
          )}
        </motion.div>

        <motion.div
          className="panda-stats"
          style={{ marginTop: '10px' }}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.3, duration: 0.5 }}
        >
          <p>
            <strong>{mergedLabels.levelLabel}:</strong> {pandaState.level} |
            <strong> {mergedLabels.experienceLabel}:</strong> {pandaState.experience}
          </p>
        </motion.div>
      </div>

      <AnimatePresence mode="wait">
        {interactionMode === 'none' ? (
          <motion.div
            key="interact"
            className="panda-actions"
            style={{ textAlign: 'center' }}
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            transition={{ duration: 0.3 }}
          >
            <div className="flex justify-center gap-2">
              <AnimatedButton
                variant="jade"
                onClick={handleInteractClick}
                disabled={isLoading}
              >
                {isLoading ? 'è¯·ç¨å€™...' : mergedLabels.interactButtonText}
              </AnimatedButton>

              <AnimatedButton
                variant="secondary"
                onClick={handleOpenCustomizationPanel}
                disabled={isLoading}
              >
                {mergedLabels.customizeButtonText}
              </AnimatedButton>

              <AnimatedButton
                variant="secondary"
                onClick={handleOpenEnvironmentPanel}
                disabled={isLoading}
              >
                {mergedLabels.environmentButtonText}
              </AnimatedButton>
            </div>
          </motion.div>
        ) : (
          <motion.div
            key="buttons"
            className="panda-interaction-buttons"
            style={{
              display: 'flex',
              justifyContent: 'space-around',
              marginTop: '10px'
            }}
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            transition={{ duration: 0.3 }}
          >
            <AnimatedButton
              variant="jade"
              onClick={handleFeedClick}
              disabled={isLoading}
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
            >
              {mergedLabels.feedButtonText}
            </AnimatedButton>

            <AnimatedButton
              variant="jade"
              onClick={handlePlayClick}
              disabled={isLoading}
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
            >
              {mergedLabels.playButtonText}
            </AnimatedButton>

            <AnimatedButton
              variant="jade"
              onClick={handleTrainClick}
              disabled={isLoading}
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
            >
              {mergedLabels.trainButtonText}
            </AnimatedButton>
          </motion.div>
        )}
      </AnimatePresence>

      {/* è£…æ‰®é¢æ¿ */}
      <PandaCustomizationPanel
        isOpen={showCustomizationPanel}
        onClose={handleCloseCustomizationPanel}
        onCustomizationChanged={handleCustomizationChanged}
      />

      {/* ç¯å¢ƒé¢æ¿ */}
      <PandaEnvironmentPanel
        isOpen={showEnvironmentPanel}
        onClose={handleCloseEnvironmentPanel}
        onEnvironmentChanged={handleEnvironmentChanged}
      />
    </motion.section>
  );
};

export default PandaSection;
</file>

<file path="src/features/tasks/TaskManager.tsx">
// src/features/tasks/TaskManager.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { AnimatePresence } from 'framer-motion';
import {
  TaskRecord,
  TaskStatus,
  TaskPriority,
  TaskType,
  createTask,
  updateTask,
  getAllTasks,
  initializeTaskCategories
} from '@/services/taskService';
import { useRegisterTableRefresh } from '@/hooks/useDataRefresh';
import TaskForm from '@/components/game/TaskForm';
import AnimatedTaskList from '@/components/animation/AnimatedTaskList';
import AnimatedButton from '@/components/animation/AnimatedButton';
import PageTransition from '@/components/animation/PageTransition';

interface TaskManagerLabels {
  sectionTitle?: string;
  createTaskButton?: string;
  filterAllLabel?: string;
  filterTodoLabel?: string;
  filterInProgressLabel?: string;
  filterCompletedLabel?: string;
  noTasksMessage?: string;
}

interface TaskManagerProps {
  labels?: TaskManagerLabels;
}

/**
 * ä»»åŠ¡ç®¡ç†å™¨ç»„ä»¶ï¼ŒåŒ…å«ä»»åŠ¡åˆ—è¡¨å’Œä»»åŠ¡è¡¨å•
 */
const TaskManager: React.FC<TaskManagerProps> = ({ labels }) => {
  const [showForm, setShowForm] = useState(false);
  const [editingTask, setEditingTask] = useState<TaskRecord | null>(null);
  const [statusFilter, setStatusFilter] = useState<TaskStatus | undefined>(undefined);
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  // é»˜è®¤æ ‡ç­¾
  const defaultLabels: TaskManagerLabels = {
    sectionTitle: 'ä»»åŠ¡ç®¡ç†',
    createTaskButton: 'åˆ›å»ºæ–°ä»»åŠ¡',
    filterAllLabel: 'å…¨éƒ¨',
    filterTodoLabel: 'å¾…åŠ',
    filterInProgressLabel: 'è¿›è¡Œä¸­',
    filterCompletedLabel: 'å·²å®Œæˆ',
    noTasksMessage: 'æš‚æ— ä»»åŠ¡'
  };

  // åˆå¹¶æ ‡ç­¾
  const mergedLabels = { ...defaultLabels, ...labels };

  // ä½¿ç”¨ useRef æ¥é¿å…ä¾èµ–å˜åŒ–
  const setRefreshTriggerRef = React.useRef(setRefreshTrigger);

  // æ›´æ–° ref å½“ä¾èµ–å˜åŒ–æ—¶
  React.useEffect(() => {
    setRefreshTriggerRef.current = setRefreshTrigger;
  }, [setRefreshTrigger]);

  // ä½¿ç”¨ç¨³å®šçš„å›è°ƒå‡½æ•°ï¼Œä¸ä¾èµ–äº setRefreshTrigger
  const handleDataRefresh = useCallback(() => {
    // åªéœ€è¦è§¦å‘åˆ·æ–°ï¼Œä¸éœ€è¦é‡æ–°è·å–æ‰€æœ‰æ•°æ®
    setRefreshTriggerRef.current(prev => prev + 1);
  }, []); // æ²¡æœ‰ä¾èµ–é¡¹ï¼Œä½¿ç”¨ ref æ¥è·å–æœ€æ–°å€¼

  // ä½¿ç”¨ useRegisterTableRefresh ç›‘å¬ 'tasks' è¡¨çš„æ•°æ®åˆ·æ–°
  useRegisterTableRefresh('tasks', handleDataRefresh);

  // åˆå§‹åŒ–ä»»åŠ¡ç±»åˆ«
  useEffect(() => {
    initializeTaskCategories();
  }, []);

  // å¤„ç†åˆ›å»ºä»»åŠ¡
  const handleCreateTask = async (taskData: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'>) => {
    try {
      await createTask(taskData);
      setShowForm(false);
      // ä¸éœ€è¦æ‰‹åŠ¨è§¦å‘åˆ·æ–°ï¼Œæ•°æ®åŒæ­¥æœåŠ¡ä¼šè‡ªåŠ¨è§¦å‘
    } catch (error) {
      console.error('Failed to create task:', error);
      alert('åˆ›å»ºä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };

  // å¤„ç†æ›´æ–°ä»»åŠ¡
  const handleUpdateTask = async (taskData: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'>) => {
    if (!editingTask?.id) return;

    try {
      await updateTask(editingTask.id, taskData);
      setEditingTask(null);
      setShowForm(false);
      // ä¸éœ€è¦æ‰‹åŠ¨è§¦å‘åˆ·æ–°ï¼Œæ•°æ®åŒæ­¥æœåŠ¡ä¼šè‡ªåŠ¨è§¦å‘
    } catch (error) {
      console.error('Failed to update task:', error);
      alert('æ›´æ–°ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };

  // å¤„ç†ç¼–è¾‘ä»»åŠ¡
  const handleEditTask = async (taskId: number) => {
    try {
      const tasks = await getAllTasks();
      const task = tasks.find(t => t.id === taskId);

      if (task) {
        setEditingTask(task);
        setShowForm(true);
      }
    } catch (error) {
      console.error('Failed to get task for editing:', error);
      alert('è·å–ä»»åŠ¡è¯¦æƒ…å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };

  // å¤„ç†å–æ¶ˆè¡¨å•
  const handleCancelForm = () => {
    setShowForm(false);
    setEditingTask(null);
  };

  return (
    <PageTransition className="task-manager">
      <div className="task-manager-header">
        <h2>{mergedLabels.sectionTitle}</h2>

        {!showForm && (
          <AnimatedButton
            variant="jade"
            onClick={() => setShowForm(true)}
          >
            {mergedLabels.createTaskButton}
          </AnimatedButton>
        )}
      </div>

      <AnimatePresence mode="wait">
        {showForm ? (
          <PageTransition key="task-form">
            <TaskForm
              initialTask={editingTask || {}}
              onSubmit={editingTask ? handleUpdateTask : handleCreateTask}
              onCancel={handleCancelForm}
            />
          </PageTransition>
        ) : (
          <PageTransition key="task-list">
            <div className="task-filter-tabs">
              <button
                className={statusFilter === undefined ? 'active' : ''}
                onClick={() => setStatusFilter(undefined)}
              >
                {mergedLabels.filterAllLabel}
              </button>
              <button
                className={statusFilter === TaskStatus.TODO ? 'active' : ''}
                onClick={() => setStatusFilter(TaskStatus.TODO)}
              >
                {mergedLabels.filterTodoLabel}
              </button>
              <button
                className={statusFilter === TaskStatus.IN_PROGRESS ? 'active' : ''}
                onClick={() => setStatusFilter(TaskStatus.IN_PROGRESS)}
              >
                {mergedLabels.filterInProgressLabel}
              </button>
              <button
                className={statusFilter === TaskStatus.COMPLETED ? 'active' : ''}
                onClick={() => setStatusFilter(TaskStatus.COMPLETED)}
              >
                {mergedLabels.filterCompletedLabel}
              </button>
            </div>

            <AnimatedTaskList
              onEditTask={handleEditTask}
              filter={{ status: statusFilter }}
              refreshTrigger={refreshTrigger}
            />
          </PageTransition>
        )}
      </AnimatePresence>
    </PageTransition>
  );
};

export default TaskManager;
</file>

<file path="src/game-theme.css">
/* src/game-theme.css */
/* åä¸½ç†ŠçŒ«ç«¹æ—ä¸»é¢˜ - PandaHabit åä¸½æ¸¸æˆé£æ ¼ */

/* å¯¼å…¥Googleå­—ä½“ */
@import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&family=Playfair+Display:wght@400;500;600;700&family=Fredoka+One&display=swap');
/* å¯¼å…¥ä¸­æ–‡å­—ä½“ - æ€æºå®‹ä½“ */
@import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700&display=swap');
/* å¯¼å…¥ä¸­æ–‡å­—ä½“ - æ€æºé»‘ä½“ */
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap');
/* å¯¼å…¥ä¸­æ–‡å­—ä½“ - ç«™é…·é«˜ç«¯é»‘ */
@import url('https://fonts.font.im/css?family=ZCOOL+QingKe+HuangYou');
/* å¯¼å…¥ä¸­æ–‡å­—ä½“ - ç«™é…·å¿«ä¹ä½“ */
@import url('https://fonts.font.im/css?family=ZCOOL+KuaiLe');
/* å¯¼å…¥ä¸­æ–‡å­—ä½“ - ç«™é…·æ–‡è‰ºä½“ */
@import url('https://fonts.font.im/css?family=ZCOOL+XiaoWei');
/* å¯¼å…¥ä¸­æ–‡å­—ä½“ - æ€æºé»‘ä½“ */
@import url('https://fonts.font.im/css?family=Ma+Shan+Zheng');

/* CSSå˜é‡ä¸»é¢˜é¢œè‰² */
:root {
  /* åä¸½è‰²å½©æ–¹æ¡ˆ */
  --royal-jade: #1A5F4A; /* çš‡å®¶ç¿¡ç¿ ç»¿ï¼šä»£è¡¨æˆé•¿ã€å®é™ä¸è‡ªç„¶ */
  --bamboo-green: #88B04B; /* å¯Œè´µç«¹ç»¿ï¼šè±¡å¾ç†ŠçŒ«çš„é£Ÿç‰©å’Œæ´»åŠ› */
  --snow-white: #F7F9F9; /* ç‘é›ªç™½ï¼šæä¾›è§†è§‰å‘¼å¸ç©ºé—´å’Œæ¸…æ™°åº¦ */
  --cinnabar-red: #D73E35; /* æœ±ç ‚çº¢ï¼šä¼ ç»Ÿä¸­å›½çº¢ï¼Œè±¡å¾å–œåº†ã€æ´»åŠ›ä¸å¥½è¿ */
  --imperial-gold: #D4AF37; /* åè´µé‡‘ï¼šçªå‡ºæˆå°±å’Œé«˜çº§å…ƒç´  */
  --porcelain-blue: #1A6DB0; /* é’èŠ±è“ï¼šä»£è¡¨æ°´åˆ†å’ŒæµåŠ¨ */
  --peony-pink: #F8C8DC; /* ç‰¡ä¸¹ç²‰ï¼šå¢æ·»æ¸©æš–å’Œæƒ…æ„Ÿè¿æ¥ */
  --rosewood-purple: #5D3954; /* ç´«æª€ç´«ï¼šå¢æ·»ç¥ç§˜æ„Ÿå’Œé«˜è´µæ„Ÿ */
  --ruyi-green: #2E8B57; /* å¦‚æ„ç»¿ï¼šè¡¨ç¤ºå®Œæˆå’Œç§¯ææˆæœ */
  --amber-yellow: #FFA500; /* ç¥ç€é»„ï¼šå¼•èµ·æ³¨æ„ä½†ä¸åˆºçœ¼ */
  --ink-gray: #8A8D91; /* å¢¨ç°ï¼šç”¨äºæ¬¡è¦æ–‡æœ¬å’Œéæ´»åŠ¨å…ƒç´  */

  /* åŠŸèƒ½è‰²å½© */
  --text-primary: var(--royal-jade);
  --text-secondary: var(--ink-gray);
  --text-light: var(--snow-white);
  --background-main: var(--snow-white);
  --background-panel: #FFFFFF;
  --border-color: var(--bamboo-green);
  --shadow-color: rgba(26, 95, 74, 0.2);
  --highlight-color: var(--imperial-gold);
  --accent-color: var(--cinnabar-red);

  /* ç»„ä»¶ç‰¹å®šé¢œè‰² */
  --primary-green: var(--bamboo-green);
  --deep-green: var(--royal-jade);
  --light-green: rgba(136, 176, 75, 0.2);
  --deep-night: #333333;
  --accent-jade: #00BFA5;
  --accent-gold: var(--imperial-gold);

  /* å­—ä½“è®¾ç½® */
  --font-main: 'Noto Sans SC', 'Quicksand', sans-serif;
  --font-accent: 'Noto Serif SC', 'Playfair Display', serif;
  --font-game: 'Fredoka One', cursive;
  --font-title: 'Ma Shan Zheng', cursive;
  --font-decorative: 'ZCOOL XiaoWei', serif;
  --font-fun: 'ZCOOL KuaiLe', cursive;
  --font-modern: 'ZCOOL QingKe HuangYou', sans-serif;

  /* é—´è· */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;

  /* åœ†è§’ */
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 16px;
  --radius-round: 50%;

  /* åŠ¨ç”»æ—¶é—´ */
  --timing-quick: 0.2s;
  --timing-medium: 0.4s;
  --timing-slow: 0.8s;

  /* ç‰¹æ•ˆ */
  --gold-gradient: linear-gradient(145deg, var(--imperial-gold), #FFA000);
  --jade-gradient: linear-gradient(145deg, var(--royal-jade), var(--bamboo-green));
  --red-gradient: linear-gradient(145deg, var(--cinnabar-red), #FF6B6B);
  --ink-animation: 0.8s ease-out;
}

/* åŸºç¡€æ ·å¼ - ç§»åŠ¨åº”ç”¨ */
body {
  font-family: var(--font-main);
  background-color: var(--background-main);
  background-image: url('/assets/bamboo-bg-pattern.svg');
  background-size: 200px;
  background-attachment: fixed;
  color: var(--text-primary);
  line-height: 1.6;
  margin: 0;
  padding: 0;
  position: relative;
  max-width: 100vw;
  overflow-x: hidden;
  -webkit-tap-highlight-color: transparent; /* ç§»é™¤ç§»åŠ¨ç«¯ç‚¹å‡»é«˜äº® */
  touch-action: manipulation; /* ä¼˜åŒ–è§¦æ‘¸æ“ä½œ */
}

/* æ·»åŠ æ°´å¢¨é£æ ¼èƒŒæ™¯è£…é¥° */
body::before {
  content: '';
  position: fixed;
  top: 0;
  right: 0;
  width: 300px;
  height: 300px;
  background-image: url('/assets/ink-splash.svg');
  background-size: contain;
  background-repeat: no-repeat;
  opacity: 0.1;
  z-index: -1;
  pointer-events: none;
}

body::after {
  content: '';
  position: fixed;
  bottom: 0;
  left: 0;
  width: 250px;
  height: 250px;
  background-image: url('/assets/bamboo-leaves.svg');
  background-size: contain;
  background-repeat: no-repeat;
  opacity: 0.1;
  z-index: -1;
  pointer-events: none;
}

#root {
  width: 100%;
  margin: 0 auto;
  padding: 0;
  position: relative;
  min-height: 100vh;
}

/* ä¸­å›½é£è£…é¥°å…ƒç´  */
.chinese-pattern {
  position: fixed;
  width: 100%;
  height: 8px;
  background-image: url('/assets/chinese-pattern.svg');
  background-repeat: repeat-x;
  background-size: auto 100%;
  opacity: 0.8;
  z-index: 50;
}

.chinese-pattern.top {
  top: 0;
  left: 0;
}

.chinese-pattern.bottom {
  bottom: 70px; /* ä¸ºåº•éƒ¨å¯¼èˆªç•™å‡ºç©ºé—´ */
  left: 0;
  transform: rotate(180deg);
}

/* é¡µé¢å®¹å™¨æ ·å¼ */
.page-container {
  padding: 10px 0;
  margin-top: 10px;
  width: 100%;
  box-sizing: border-box;
}

/* ä¸­å›½é£è£…é¥°å…ƒç´  - äº‘æœµ */
.chinese-cloud {
  position: fixed;
  width: 200px;
  height: 100px;
  background-image: url('/assets/chinese-cloud.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.2;
  z-index: -1;
  pointer-events: none;
}

.chinese-cloud.top-right {
  top: 50px;
  right: 20px;
  transform: scale(0.8);
}

.chinese-cloud.top-left {
  top: 100px;
  left: 10px;
  transform: scale(0.6) rotate(10deg);
}

/* ä¸­å›½é£è£…é¥°å…ƒç´  - ä¸­å›½ç»“ */
.chinese-knot {
  position: fixed;
  width: 100px;
  height: 150px;
  background-image: url('/assets/chinese-knot.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.7;
  z-index: 10;
  pointer-events: none;
}

.chinese-knot.top-right {
  top: 10px;
  right: 10px;
  transform: scale(0.5);
}

/* ä¸­å›½é£è£…é¥°å…ƒç´  - è·èŠ± */
.lotus-flower {
  position: fixed;
  width: 150px;
  height: 150px;
  background-image: url('/assets/lotus-flower.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.5;
  z-index: -1;
  pointer-events: none;
}

.lotus-flower.bottom-left {
  bottom: 80px;
  left: 10px;
  transform: scale(0.6);
}

/* ä¸­å›½é£è£…é¥°å…ƒç´  - ç¯ç¬¼ */
.chinese-lantern {
  position: fixed;
  width: 100px;
  height: 150px;
  background-image: url('/assets/chinese-lantern.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.8;
  z-index: 10;
  pointer-events: none;
}

.chinese-lantern.top-left {
  top: 10px;
  left: 10px;
  transform: scale(0.5);
}

/* ä¸­å›½é£è£…é¥°å…ƒç´  - å±±æ°´ç”» */
.mountain-landscape {
  position: fixed;
  width: 300px;
  height: 150px;
  background-image: url('/assets/mountain-landscape.svg');
  background-repeat: no-repeat;
  background-size: contain;
  opacity: 0.2;
  z-index: -2;
  pointer-events: none;
}

.mountain-landscape.bottom {
  bottom: 70px;
  left: 50%;
  transform: translateX(-50%) scale(1.5);
}

/* ç†ŠçŒ«å¤´åƒæ ·å¼ */
.panda-avatar {
  position: relative;
  border-radius: 50%;
  overflow: hidden;
  box-shadow: 0 4px 8px var(--shadow-color);
  margin: 0 auto;
}

.panda-avatar::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  border-radius: 50%;
  box-shadow: inset 0 -3px 6px rgba(0,0,0,0.2);
  pointer-events: none;
}

.panda-avatar:hover {
  transform: translateY(-5px) scale(1.05) !important;
  box-shadow: 0 8px 16px var(--shadow-color);
}

.panda-avatar:active {
  transform: translateY(2px) scale(0.98) !important;
  box-shadow: 0 2px 4px var(--shadow-color);
}

/* ç†ŠçŒ«åŠ¨ç”» */
@keyframes panda-bounce {
  0% { transform: translateY(0) scale(1); }
  50% { transform: translateY(-15px) scale(1.1); }
  100% { transform: translateY(0) scale(1); }
}

@keyframes panda-wiggle {
  0% { transform: rotate(0deg); }
  25% { transform: rotate(-5deg); }
  50% { transform: rotate(0deg); }
  75% { transform: rotate(5deg); }
  100% { transform: rotate(0deg); }
}

.panda-avatar.happy {
  animation: panda-wiggle 1s infinite;
}

.panda-avatar.tired {
  animation: panda-bounce 3s ease-in-out infinite;
}

/* ä»»åŠ¡å¡ç‰‡æ ·å¼ */
.task-card {
  background-color: var(--background-panel);
  border: 2px solid var(--primary-green);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  position: relative;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px var(--shadow-color);
}

.task-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 4px 8px var(--shadow-color);
}

.task-card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.task-title {
  margin: 0;
  font-size: 1.1rem;
  color: var(--text-primary);
}

.task-type-badge {
  font-size: 0.7rem;
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  font-weight: bold;
  color: white;
}

.task-type-main {
  background-color: var(--imperial-gold);
}

.task-type-daily {
  background-color: var(--bamboo-green);
}

.task-type-side {
  background-color: var(--ink-gray);
}

.task-description {
  margin-bottom: var(--spacing-sm);
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.task-meta {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  color: var(--text-secondary);
  margin-bottom: var(--spacing-sm);
}

.task-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-sm);
}

.task-action-complete,
.task-action-edit,
.task-action-delete {
  padding: 4px 8px;
  font-size: 0.8rem;
  border-radius: var(--radius-sm);
  cursor: pointer;
  border: none;
  transition: all 0.2s ease;
}

.task-action-complete {
  background-color: var(--bamboo-green);
  color: white;
}

.task-action-edit {
  background-color: var(--imperial-gold);
  color: white;
}

.task-action-delete {
  background-color: var(--cinnabar-red);
  color: white;
}

.task-priority-high {
  border-left: 4px solid var(--cinnabar-red);
}

.task-priority-medium {
  border-left: 4px solid var(--imperial-gold);
}

.task-priority-low {
  border-left: 4px solid var(--bamboo-green);
}

.task-status-completed {
  opacity: 0.7;
  background-color: rgba(136, 176, 75, 0.1);
}

.task-status-completed .task-title {
  text-decoration: line-through;
}

.task-status-in-progress {
  background-color: rgba(212, 175, 55, 0.1);
}

/* ä»»åŠ¡åˆ—è¡¨æ ·å¼ */
.task-list {
  position: relative;
  min-height: 100px;
}

.task-list-loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(255, 255, 255, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10;
}

.task-list-empty,
.task-list-error {
  text-align: center;
  padding: var(--spacing-lg);
  color: var(--text-secondary);
}

/* ä»»åŠ¡è¡¨å•æ ·å¼ */
.task-form {
  margin-bottom: var(--spacing-lg);
}

.form-group {
  margin-bottom: var(--spacing-md);
}

.form-group label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-weight: 500;
  color: var(--text-primary);
}

.form-group input,
.form-group select,
.form-group textarea {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  background-color: white;
  font-size: 1rem;
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
  outline: none;
  border-color: var(--primary-green);
  box-shadow: 0 0 0 2px rgba(136, 176, 75, 0.2);
}

.form-group input.error,
.form-group select.error {
  border-color: var(--cinnabar-red);
}

.error-message {
  color: var(--cinnabar-red);
  font-size: 0.8rem;
  margin-top: 4px;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-md);
  margin-top: var(--spacing-lg);
}

/* ä»»åŠ¡è¿‡æ»¤å™¨æ ·å¼ */
.task-filter-tabs {
  display: flex;
  margin-bottom: var(--spacing-md);
  border-bottom: 1px solid var(--border-color);
  overflow-x: auto;
}

.task-filter-tabs button {
  padding: 8px 16px;
  background: none;
  border: none;
  cursor: pointer;
  font-size: 0.9rem;
  color: var(--text-secondary);
  position: relative;
  white-space: nowrap;
}

.task-filter-tabs button.active {
  color: var(--text-primary);
  font-weight: 500;
}

.task-filter-tabs button.active::after {
  content: '';
  position: absolute;
  bottom: -1px;
  left: 0;
  right: 0;
  height: 2px;
  background-color: var(--primary-green);
}

/* ä»»åŠ¡ç®¡ç†å™¨æ ·å¼ */
.task-manager-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-md);
}

/* å°æŒ‰é’®æ ·å¼ */
.jade-button-small {
  background: linear-gradient(to bottom, var(--bamboo-green), var(--deep-green));
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: 4px 8px;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.jade-button-small:hover {
  background: linear-gradient(to bottom, var(--bamboo-green), var(--deep-green));
  filter: brightness(1.1);
  transform: translateY(-1px);
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
}

/* å­—ä½“æ’ç‰ˆ */
h1, h2, h3 {
  font-family: var(--font-accent);
  color: var(--royal-jade);
  margin-top: 0;
  position: relative;
}

h1 {
  font-family: var(--font-title);
  font-size: 2.2rem;
  text-shadow: 1px 1px 2px var(--shadow-color);
  background: linear-gradient(to right, var(--royal-jade), var(--bamboo-green));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  letter-spacing: 0.5px;
  padding-bottom: var(--spacing-md);
  position: relative;
}

h2 {
  font-family: var(--font-decorative);
  font-size: 1.8rem;
  letter-spacing: 1px;
}

h3 {
  font-family: var(--font-modern);
  font-size: 1.4rem;
}

/* æ·»åŠ ä¸­å›½é£è£…é¥°çº¿ */
h1::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100px;
  height: 3px;
  background: var(--gold-gradient);
  border-radius: var(--radius-sm);
}

/* æ¨¡æ€æ¡†æ ·å¼ */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: var(--spacing-md);
}

.modal-content {
  position: relative;
  max-width: 90%;
  max-height: 90vh;
  overflow-y: auto;
  z-index: 1001;
}

.modal-container {
  position: relative;
  background-color: var(--background-panel);
  border-radius: var(--radius-md);
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
  overflow: hidden;
}

/* å·è½´é£æ ¼æ¨¡æ€æ¡† */
.scroll-modal {
  background-color: #f8f0d8; /* å¤çº¸è‰² */
  border: none;
  box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
  position: relative;
  padding: var(--spacing-lg) var(--spacing-xl);
  color: var(--deep-night);
}

.scroll-modal::before,
.scroll-modal::after {
  content: '';
  position: absolute;
  left: 0;
  right: 0;
  height: 30px;
  background-image: url('/assets/scroll-edge.svg');
  background-repeat: repeat-x;
  background-size: auto 100%;
}

.scroll-modal::before {
  top: 0;
  transform: rotateX(180deg);
}

.scroll-modal::after {
  bottom: 0;
}

.scroll-modal-content {
  max-height: 70vh;
  overflow-y: auto;
  padding: var(--spacing-md) 0;
  background-image: url('/assets/paper-texture.svg');
  background-repeat: repeat;
  background-size: 200px;
  position: relative;
}

.scroll-modal-header {
  text-align: center;
  margin-bottom: var(--spacing-lg);
  position: relative;
}

.scroll-modal-title {
  font-family: var(--font-accent);
  font-size: 1.8rem;
  color: var(--cinnabar-red);
  margin: 0;
  padding-bottom: var(--spacing-md);
  position: relative;
  display: inline-block;
}

.scroll-modal-title::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 10%;
  right: 10%;
  height: 2px;
  background: var(--gold-gradient);
}

.scroll-modal-close {
  position: absolute;
  top: var(--spacing-md);
  right: var(--spacing-md);
  background: none;
  border: none;
  font-size: 1.5rem;
  color: var(--cinnabar-red);
  cursor: pointer;
  width: 30px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-round);
  transition: all 0.2s ease;
}

.scroll-modal-close:hover {
  background-color: rgba(215, 62, 53, 0.1);
  transform: rotate(90deg);
}

.scroll-modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-md);
  margin-top: var(--spacing-lg);
  padding-top: var(--spacing-md);
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

/* çª—æ£‚é£æ ¼æ¨¡æ€æ¡† */
.lattice-modal {
  background-color: var(--background-panel);
  border: 4px solid var(--imperial-gold);
  border-radius: var(--radius-md);
  position: relative;
  overflow: hidden;
}

.lattice-modal-header {
  background: var(--gold-gradient);
  color: var(--deep-night);
  padding: var(--spacing-md) var(--spacing-lg);
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
}

.lattice-modal-title {
  font-family: var(--font-accent);
  font-size: 1.5rem;
  margin: 0;
  text-align: center;
  position: relative;
}

.lattice-modal-close {
  position: absolute;
  top: 50%;
  right: var(--spacing-md);
  transform: translateY(-50%);
  background: none;
  border: none;
  color: var(--deep-night);
  cursor: pointer;
  width: 30px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-round);
  transition: all 0.2s ease;
}

.lattice-modal-close:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

.lattice-modal-content {
  padding: var(--spacing-lg);
  position: relative;
  max-height: 70vh;
  overflow-y: auto;
}

.lattice-modal-content::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: url('/assets/lattice-pattern.svg');
  background-repeat: repeat;
  background-size: 100px;
  opacity: 0.05;
  pointer-events: none;
  z-index: -1;
}

.lattice-modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-md);
  padding: var(--spacing-md) var(--spacing-lg);
  background-color: rgba(212, 175, 55, 0.1);
  border-top: 1px solid var(--imperial-gold);
}

/* å¥–åŠ±æ¨¡æ€æ¡†æ ·å¼ */
.reward-modal-content {
  padding: var(--spacing-md);
  text-align: center;
}

.reward-showcase {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--spacing-md);
}

.reward-title {
  font-family: var(--font-accent);
  font-size: 1.5rem;
  color: var(--cinnabar-red);
  margin-bottom: var(--spacing-lg);
  position: relative;
}

.reward-title::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 25%;
  right: 25%;
  height: 2px;
  background: var(--gold-gradient);
}

.reward-animation-container {
  margin: var(--spacing-lg) 0;
  height: 150px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.reward-details {
  margin: var(--spacing-md) 0;
  padding: var(--spacing-md);
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: var(--radius-md);
  max-width: 300px;
}

.reward-details h4 {
  font-family: var(--font-accent);
  font-size: 1.2rem;
  color: var(--deep-night);
  margin: 0 0 var(--spacing-sm) 0;
}

.reward-rarity {
  font-size: 0.9rem;
  color: var(--text-secondary);
  margin: 0 0 var(--spacing-sm) 0;
}

.reward-description {
  font-size: 1rem;
  margin: 0 0 var(--spacing-sm) 0;
}

.reward-amount {
  font-weight: bold;
  margin: var(--spacing-sm) 0 0 0;
}

.reward-navigation {
  margin-top: var(--spacing-lg);
  height: 50px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.rewards-summary {
  display: flex;
  flex-direction: column;
  width: 100%;
}

.rewards-summary-title {
  font-family: var(--font-accent);
  font-size: 1.5rem;
  color: var(--cinnabar-red);
  margin-bottom: var(--spacing-lg);
  position: relative;
  text-align: center;
}

.rewards-summary-title::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 25%;
  right: 25%;
  height: 2px;
  background: var(--gold-gradient);
}

.rewards-list {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
  margin: var(--spacing-md) 0;
  max-height: 300px;
  overflow-y: auto;
  padding: var(--spacing-sm);
}

.reward-item {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm);
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: var(--radius-md);
  transition: all 0.2s ease;
}

.reward-item:hover {
  background-color: rgba(255, 255, 255, 0.3);
  transform: translateY(-2px);
}

.reward-item-icon {
  margin-right: var(--spacing-md);
  display: flex;
  justify-content: center;
  align-items: center;
}

.reward-item-details {
  flex: 1;
  text-align: left;
}

.reward-item-details h4 {
  font-family: var(--font-accent);
  font-size: 1.1rem;
  color: var(--deep-night);
  margin: 0 0 var(--spacing-xs) 0;
}

.reward-item-description {
  font-size: 0.9rem;
  color: var(--text-secondary);
  margin: 0;
}

.reward-item-amount {
  font-weight: bold;
  font-size: 1.1rem;
  color: var(--imperial-gold);
  margin-left: var(--spacing-md);
}

.rewards-summary-footer {
  margin-top: var(--spacing-lg);
  display: flex;
  justify-content: center;
}

/* ç†ŠçŒ«èƒ½åŠ›æ ·å¼ */
.abilities-header {
  margin-bottom: var(--spacing-lg);
  padding-bottom: var(--spacing-md);
  border-bottom: 1px solid var(--border-color);
}

.panda-level-info {
  margin-bottom: var(--spacing-md);
}

.panda-level-info h3 {
  font-family: var(--font-accent);
  color: var(--imperial-gold);
  margin-bottom: var(--spacing-xs);
}

.abilities-description {
  color: var(--text-secondary);
  font-size: 0.95rem;
  line-height: 1.5;
}

.ability-filters {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-sm);
  margin-bottom: var(--spacing-md);
}

.filter-button {
  background-color: var(--background-panel);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  padding: var(--spacing-xs) var(--spacing-sm);
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.filter-button:hover {
  background-color: var(--background-hover);
}

.filter-button.active {
  background-color: var(--jade-green);
  color: white;
  border-color: var(--jade-green);
}

.abilities-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: var(--spacing-md);
  margin-top: var(--spacing-md);
}

.ability-card {
  background-color: var(--background-panel);
  border-radius: var(--radius-md);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
}

.ability-card:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  transform: translateY(-2px);
}

.ability-card.locked {
  opacity: 0.7;
  filter: grayscale(0.5);
}

.ability-card.passive-ability {
  border-left: 4px solid var(--jade-green);
}

.ability-card.active-ability {
  border-left: 4px solid var(--imperial-blue);
}

.ability-card.ultimate-ability {
  border-left: 4px solid var(--imperial-gold);
}

.ability-card-header {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm);
  background-color: rgba(0, 0, 0, 0.03);
  border-bottom: 1px solid var(--border-color);
}

.ability-icon {
  width: 50px;
  height: 50px;
  margin-right: var(--spacing-sm);
  display: flex;
  justify-content: center;
  align-items: center;
}

.ability-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.ability-info {
  flex: 1;
}

.ability-name {
  font-family: var(--font-accent);
  font-size: 1.1rem;
  margin: 0 0 var(--spacing-xs) 0;
}

.ability-meta {
  display: flex;
  gap: var(--spacing-sm);
  font-size: 0.8rem;
  color: var(--text-secondary);
}

.ability-type, .ability-rarity {
  background-color: rgba(0, 0, 0, 0.05);
  padding: 2px 6px;
  border-radius: var(--radius-sm);
}

.ability-card-body {
  padding: var(--spacing-sm);
}

.ability-description {
  font-size: 0.9rem;
  line-height: 1.5;
  margin-bottom: var(--spacing-sm);
}

.ability-unlock-info {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-size: 0.85rem;
  color: var(--text-secondary);
  margin-top: var(--spacing-sm);
}

.ability-lock-icon {
  font-size: 1rem;
}

.ability-cooldown {
  font-size: 0.85rem;
  color: var(--text-secondary);
  margin-top: var(--spacing-sm);
}

.cooldown-remaining {
  color: var(--cinnabar-red);
}

.ability-card-footer {
  padding: var(--spacing-sm);
  border-top: 1px solid var(--border-color);
  display: flex;
  justify-content: flex-end;
}

.activate-button {
  background-color: var(--imperial-blue);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: var(--spacing-xs) var(--spacing-md);
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.activate-button:hover {
  background-color: var(--imperial-blue-dark);
}

.activate-button.unavailable {
  background-color: var(--text-disabled);
  cursor: not-allowed;
}

.no-abilities {
  text-align: center;
  padding: var(--spacing-lg);
  color: var(--text-secondary);
}

/* èƒ½åŠ›è¯¦æƒ…æ ·å¼ */
.ability-detail {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--spacing-md);
}

.ability-detail-icon {
  width: 80px;
  height: 80px;
  margin-bottom: var(--spacing-md);
}

.ability-detail-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.ability-detail-info {
  width: 100%;
  text-align: center;
}

.ability-detail-description {
  font-size: 1rem;
  line-height: 1.6;
  margin-bottom: var(--spacing-md);
}

.ability-detail-meta {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--spacing-sm);
  margin-bottom: var(--spacing-md);
}

.meta-item {
  background-color: rgba(0, 0, 0, 0.03);
  padding: var(--spacing-sm);
  border-radius: var(--radius-sm);
  display: flex;
  flex-direction: column;
  align-items: center;
}

.meta-label {
  font-size: 0.8rem;
  color: var(--text-secondary);
  margin-bottom: var(--spacing-xs);
}

.meta-value {
  font-weight: bold;
  font-size: 0.95rem;
}

.ability-detail-actions {
  margin-top: var(--spacing-md);
}

.activate-detail-button {
  background-color: var(--imperial-blue);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: var(--spacing-sm) var(--spacing-lg);
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.activate-detail-button:hover {
  background-color: var(--imperial-blue-dark);
}

.activate-detail-button:disabled {
  background-color: var(--text-disabled);
  cursor: not-allowed;
}

/* èƒ½åŠ›è§£é”é€šçŸ¥æ ·å¼ */
.ability-unlock-content {
  padding: var(--spacing-md);
}

.ability-unlock-view {
  width: 100%;
  min-height: 300px;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.ability-unlock-single {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.ability-unlock-icon {
  width: 100px;
  height: 100px;
  margin-bottom: var(--spacing-md);
}

.ability-unlock-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.ability-unlock-title {
  font-family: var(--font-accent);
  font-size: 1.5rem;
  color: var(--imperial-gold);
  margin-bottom: var(--spacing-sm);
}

.ability-unlock-name {
  font-size: 1.2rem;
  margin-bottom: var(--spacing-md);
}

.ability-unlock-description {
  font-size: 1rem;
  line-height: 1.6;
  margin-bottom: var(--spacing-lg);
  max-width: 500px;
}

.ability-unlock-actions {
  margin-top: var(--spacing-md);
}

.ability-unlock-list {
  width: 100%;
  max-height: 300px;
  overflow-y: auto;
  margin: var(--spacing-md) 0;
}

.ability-unlock-item {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm);
  background-color: rgba(0, 0, 0, 0.03);
  border-radius: var(--radius-md);
  margin-bottom: var(--spacing-sm);
  transition: all 0.2s ease;
}

.ability-unlock-item:hover {
  background-color: rgba(0, 0, 0, 0.05);
}

.ability-unlock-item-icon {
  width: 40px;
  height: 40px;
  margin-right: var(--spacing-sm);
}

.ability-unlock-item-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.ability-unlock-item-info {
  flex: 1;
  text-align: left;
}

.ability-unlock-item-name {
  font-size: 1rem;
  margin: 0 0 var(--spacing-xs) 0;
}

.ability-unlock-item-description {
  font-size: 0.9rem;
  color: var(--text-secondary);
  margin: 0;
}

h2 {
  font-size: 1.8rem;
  margin-bottom: 0.8em;
  border-bottom: 2px solid var(--imperial-gold);
  padding-bottom: var(--spacing-sm);
  display: inline-block;
  position: relative;
}

/* æ·»åŠ ä¸­å›½é£è£…é¥°å…ƒç´  */
h2::before {
  content: 'â–';
  color: var(--cinnabar-red);
  position: absolute;
  left: -1.5rem;
  top: 0.2rem;
  font-size: 1rem;
}

h3 {
  font-size: 1.5rem;
  margin-bottom: 0.6em;
  color: var(--royal-jade);
  position: relative;
  padding-left: var(--spacing-md);
}

h3::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0.5rem;
  height: 1rem;
  width: 4px;
  background: var(--bamboo-green);
  border-radius: var(--radius-sm);
}

h4 {
  font-size: 1.2rem;
  margin-bottom: 0.5em;
  color: var(--ruyi-green);
  font-family: var(--font-main);
  font-weight: 600;
}

/* Bamboo Frame Container */
.bamboo-frame {
  background-color: var(--background-panel);
  border: 4px solid var(--primary-green);
  border-radius: var(--radius-md);
  box-shadow: 0 4px 12px var(--shadow-color);
  padding: var(--spacing-lg);
  position: relative;
  overflow: hidden;
  margin-bottom: var(--spacing-lg);
}

.bamboo-frame::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 12px;
  background: repeating-linear-gradient(
    to right,
    var(--primary-green),
    var(--primary-green) 20px,
    var(--deep-green) 20px,
    var(--deep-green) 30px
  );
  border-top-left-radius: var(--radius-md);
  border-top-right-radius: var(--radius-md);
}

.bamboo-frame::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 12px;
  background: repeating-linear-gradient(
    to right,
    var(--primary-green),
    var(--primary-green) 20px,
    var(--deep-green) 20px,
    var(--deep-green) 30px
  );
  border-bottom-left-radius: var(--radius-md);
  border-bottom-right-radius: var(--radius-md);
}

/* Jade Button */
.jade-button {
  background: linear-gradient(145deg, var(--accent-jade), var(--primary-green));
  color: white;
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-md) var(--spacing-lg);
  font-family: var(--font-main);
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(0, 191, 165, 0.3);
  transition: all var(--timing-quick) ease;
  position: relative;
  overflow: hidden;
}

.jade-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    rgba(255, 255, 255, 0) 0%,
    rgba(255, 255, 255, 0.2) 50%,
    rgba(255, 255, 255, 0) 100%
  );
  transition: left 0.8s ease;
}

.jade-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(0, 191, 165, 0.4);
}

.jade-button:hover::before {
  left: 100%;
}

.jade-button:active {
  transform: translateY(1px);
  box-shadow: 0 2px 4px rgba(0, 191, 165, 0.3);
}

.jade-button:disabled {
  background: #B0BEC5;
  cursor: not-allowed;
  box-shadow: none;
  transform: none;
}

/* Gold Button - for premium/special actions */
.gold-button {
  background: linear-gradient(145deg, var(--accent-gold), #FFA000);
  color: var(--deep-night);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-md) var(--spacing-lg);
  font-family: var(--font-main);
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(255, 215, 0, 0.3);
  transition: all var(--timing-quick) ease;
}

.gold-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(255, 215, 0, 0.4);
}

.gold-button:active {
  transform: translateY(1px);
  box-shadow: 0 2px 4px rgba(255, 215, 0, 0.3);
}

/* Navigation Bar - Mobile Style */
.bamboo-nav {
  display: flex;
  justify-content: space-around;
  background: linear-gradient(to right, var(--deep-green), var(--primary-green));
  padding: var(--spacing-md) var(--spacing-sm);
  box-shadow: 0 -2px 10px var(--shadow-color);
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 100;
}

.bamboo-nav a {
  color: white;
  text-decoration: none;
  padding: var(--spacing-md) var(--spacing-lg);
  border-radius: var(--radius-md);
  transition: all var(--timing-quick) ease;
  font-weight: 500;
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: 0.9rem;
}

.bamboo-nav a::before {
  content: 'â€¢';
  font-size: 1.5rem;
  margin-bottom: 4px;
}

.bamboo-nav a:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.bamboo-nav a.active {
  background-color: rgba(255, 255, 255, 0.2);
  box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
  font-weight: 700;
}

/* Add padding to main content to account for fixed navigation */
main {
  padding-bottom: 80px;
}

/* Loading Spinner - Jade Coin */
.jade-spinner {
  width: 50px;
  height: 50px;
  border-radius: var(--radius-round);
  border: 5px solid var(--accent-jade);
  border-top-color: var(--accent-gold);
  animation: spin 1s infinite linear;
  margin: var(--spacing-lg) auto;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Bamboo Progress Bar */
.bamboo-progress {
  height: 24px;
  background-color: var(--light-green);
  border-radius: var(--radius-lg);
  overflow: hidden;
  position: relative;
  margin: var(--spacing-md) 0;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
}

.bamboo-progress-fill {
  height: 100%;
  background: repeating-linear-gradient(
    45deg,
    var(--primary-green),
    var(--primary-green) 10px,
    var(--deep-green) 10px,
    var(--deep-green) 20px
  );
  border-radius: var(--radius-lg);
  transition: width var(--timing-medium) ease-out;
  position: relative;
}

.bamboo-progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  width: 10px;
  height: 100%;
  background-color: var(--accent-gold);
  border-top-right-radius: var(--radius-lg);
  border-bottom-right-radius: var(--radius-lg);
}

/* Task Item */
.task-item {
  background-color: white;
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  box-shadow: 0 2px 4px var(--shadow-color);
  display: flex;
  align-items: center;
  transition: transform var(--timing-quick) ease;
  border-left: 4px solid var(--primary-green);
}

.task-item:hover {
  transform: translateX(4px);
}

.task-item.completed {
  border-left-color: var(--accent-gold);
  background-color: rgba(255, 215, 0, 0.05);
}

.task-checkbox {
  width: 24px;
  height: 24px;
  border: 2px solid var(--primary-green);
  border-radius: var(--radius-sm);
  margin-right: var(--spacing-md);
  position: relative;
  cursor: pointer;
}

.task-checkbox.checked::after {
  content: 'âœ“';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: var(--accent-gold);
  font-weight: bold;
}

/* Footer */
footer {
  text-align: center;
  margin-top: var(--spacing-xl);
  padding: var(--spacing-lg);
  color: var(--text-secondary);
  font-size: 0.9rem;
  background: linear-gradient(to right, var(--deep-green), var(--primary-green));
  color: white;
  border-radius: var(--radius-lg) var(--radius-lg) 0 0;
}

/* æ•°æ®åŠ è½½å™¨æ ·å¼ */
.data-loader-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 200px;
  width: 100%;
}

.empty-state {
  text-align: center;
  padding: var(--spacing-lg);
  color: var(--text-secondary);
  font-style: italic;
}

/* åŒæ­¥çŠ¶æ€æŒ‡ç¤ºå™¨æ ·å¼ */
.sync-status-indicator {
  display: flex;
  align-items: center;
  padding: var(--spacing-xs) var(--spacing-sm);
  background-color: var(--background-panel);
  border-radius: var(--radius-full);
  box-shadow: var(--shadow-md);
  cursor: pointer;
  transition: all 0.2s ease;
  user-select: none;
  position: fixed;
  bottom: 80px;
  right: 20px;
  z-index: 100;
  border: 1px solid var(--border-color);
}

.sync-status-indicator:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.sync-status-indicator.minimal {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  justify-content: center;
  padding: 0;
}

.sync-status-indicator.detailed {
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--radius-md);
}

.sync-status-indicator.syncing {
  background-color: rgba(74, 144, 226, 0.1);
  border-color: var(--imperial-blue);
  animation: pulse 1.5s infinite;
}

.sync-status-indicator.success {
  background-color: rgba(136, 176, 75, 0.1);
  border-color: var(--jade-green);
}

.sync-status-indicator.error {
  background-color: rgba(215, 62, 53, 0.1);
  border-color: var(--cinnabar-red);
}

@keyframes pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(74, 144, 226, 0.4);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(74, 144, 226, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(74, 144, 226, 0);
  }
}

.sync-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  font-size: 1.2rem;
  margin-right: var(--spacing-xs);
}

.sync-status-indicator.minimal .sync-icon {
  margin-right: 0;
}

.sync-icon.syncing {
  color: var(--imperial-blue);
}

.sync-icon.success {
  color: var(--jade-green);
}

.sync-icon.error {
  color: var(--cinnabar-red);
}

.sync-icon.idle {
  color: var(--text-secondary);
}

.sync-label {
  font-size: 0.9rem;
  color: var(--text-primary);
  margin-right: var(--spacing-xs);
}

.sync-count {
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 20px;
  height: 20px;
  border-radius: var(--radius-full);
  background-color: var(--imperial-blue);
  color: white;
  font-size: 0.8rem;
  padding: 0 var(--spacing-xs);
}

/* åŠæ—¶å¥–åŠ±å¡ç‰‡ */
.timely-reward-card {
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border: 1px solid var(--border-color);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  box-shadow: var(--shadow-md);
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
}

.timely-reward-card:hover {
  transform: translateY(-3px);
  box-shadow: var(--shadow-lg);
}

.reward-card-header {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.reward-icon {
  width: 48px;
  height: 48px;
  border-radius: var(--radius-round);
  overflow: hidden;
  margin-right: var(--spacing-md);
  background-color: var(--background-panel-dark);
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid var(--border-color);
}

.reward-icon img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.reward-title-section {
  flex: 1;
}

.reward-title {
  margin: 0 0 var(--spacing-xs) 0;
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--text-primary);
}

.reward-meta {
  display: flex;
  gap: var(--spacing-sm);
}

.reward-type,
.reward-status {
  font-size: 0.8rem;
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  background-color: var(--background-panel-dark);
}

.reward-card-body {
  margin-bottom: var(--spacing-md);
}

.reward-description {
  margin: 0 0 var(--spacing-md) 0;
  font-size: 0.9rem;
  color: var(--text-secondary);
  line-height: 1.4;
}

.reward-progress-section {
  margin-top: var(--spacing-md);
}

.reward-time-info {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  color: var(--text-tertiary);
  margin-top: var(--spacing-xs);
}

.reward-card-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.reward-points {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-size: 0.9rem;
  color: var(--imperial-gold);
  font-weight: 600;
}

.lucky-points-icon {
  font-size: 1.2rem;
}

.complete-reward-button {
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-xs) var(--spacing-md);
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.complete-reward-button:disabled {
  background: linear-gradient(145deg, var(--background-panel-dark), var(--background-panel));
  color: var(--text-tertiary);
  cursor: not-allowed;
}

.reward-completed-info {
  font-size: 0.8rem;
  color: var(--jade-green);
  font-weight: 600;
}

/* å¥–åŠ±çŠ¶æ€æ ·å¼ */
.reward-active {
  border-left: 4px solid var(--imperial-blue);
}

.reward-completed {
  border-left: 4px solid var(--jade-green);
}

.reward-expired {
  border-left: 4px solid var(--cinnabar-red);
  opacity: 0.7;
}

.reward-upcoming {
  border-left: 4px solid var(--imperial-gold);
}

/* åŠæ—¶å¥–åŠ±åˆ—è¡¨ */
.timely-reward-list {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

/* å¹¸è¿ç‚¹æ˜¾ç¤º */
.lucky-points-display {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-sm) var(--spacing-md);
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border-radius: var(--radius-full);
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
  cursor: pointer;
  transition: all 0.2s ease;
}

.lucky-points-display:hover {
  box-shadow: var(--shadow-md);
}

.lucky-points-display.animating {
  animation: pulse 1s;
}

.lucky-points-icon {
  font-size: 1.2rem;
  color: var(--imperial-gold);
}

.lucky-points-value {
  font-weight: 600;
  color: var(--imperial-gold);
}

.lucky-points-label {
  font-size: 0.8rem;
  color: var(--text-secondary);
}

.lucky-points-compact {
  padding: var(--spacing-xs);
}

.lucky-points-large {
  padding: var(--spacing-md);
  font-size: 1.2rem;
}

.lucky-points-container {
  display: flex;
  justify-content: flex-end;
  margin-bottom: var(--spacing-md);
}

/* å¹¸è¿æŠ½å¥– */
.lucky-draw-container {
  padding: var(--spacing-md);
}

.lucky-draw-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-lg);
}

.lucky-draw-title {
  margin: 0;
  font-size: 1.5rem;
  color: var(--text-primary);
}

.lucky-draw-options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-lg);
}

.draw-option {
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border: 1px solid var(--border-color);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  box-shadow: var(--shadow-sm);
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.draw-option.selected {
  border: 2px solid var(--imperial-gold);
  box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
}

.draw-option.disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

.draw-option-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.draw-option-points {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-weight: 600;
  color: var(--imperial-gold);
}

.draw-option-label {
  margin: 0;
  font-size: 1.1rem;
  color: var(--text-primary);
}

.draw-option-description {
  margin: 0;
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.draw-option-insufficient {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: var(--spacing-xs);
  background-color: rgba(215, 62, 53, 0.8);
  color: white;
  font-size: 0.8rem;
  text-align: center;
}

.lucky-draw-actions {
  display: flex;
  justify-content: center;
  gap: var(--spacing-md);
  margin-top: var(--spacing-lg);
}

.draw-button {
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-sm) var(--spacing-lg);
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.draw-button:disabled {
  background: linear-gradient(145deg, var(--background-panel-dark), var(--background-panel));
  color: var(--text-tertiary);
  cursor: not-allowed;
}

.lucky-draw-results {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--spacing-lg);
}

/* åŠæ—¶å¥–åŠ±é¡µé¢ */
.timely-rewards-page {
  padding: var(--spacing-md);
}

.lucky-draw-button {
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-sm) var(--spacing-md);
  font-size: 0.9rem;
  font-weight: 600;
}

.lucky-draw-dialog {
  max-width: 800px;
}

/* åŠæ—¶å¥–åŠ±æ¨¡æ€æ¡† */
.timely-reward-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.timely-reward-modal-backdrop {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(5px);
}

.timely-reward-modal-content {
  position: relative;
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border: 2px solid var(--imperial-gold);
  border-radius: var(--radius-md);
  padding: var(--spacing-lg);
  max-width: 90%;
  width: 500px;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: var(--shadow-lg), 0 0 20px rgba(212, 175, 55, 0.3);
  animation: scale-in 0.3s ease-out;
}

.timely-reward-modal-title {
  margin: 0 0 var(--spacing-md) 0;
  font-size: 1.5rem;
  color: var(--imperial-gold);
  text-align: center;
  text-shadow: 0 0 5px rgba(212, 175, 55, 0.5);
}

.timely-reward-modal-description {
  margin: 0 0 var(--spacing-md) 0;
  font-size: 1rem;
  color: var(--text-secondary);
  text-align: center;
}

.timely-reward-modal-actions {
  display: flex;
  justify-content: center;
  margin-top: var(--spacing-md);
}

@keyframes scale-in {
  0% {
    transform: scale(0.8);
    opacity: 0;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

/* æŒ‘æˆ˜å¡ç‰‡ */
.challenge-card {
  background: linear-gradient(145deg, var(--background-panel), var(--background-panel-light));
  border: 1px solid var(--border-color);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  box-shadow: var(--shadow-md);
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
}

.challenge-card:hover {
  transform: translateY(-3px);
  box-shadow: var(--shadow-lg);
}

.challenge-card-header {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.challenge-icon {
  width: 48px;
  height: 48px;
  border-radius: var(--radius-round);
  overflow: hidden;
  margin-right: var(--spacing-md);
  background-color: var(--background-panel-dark);
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid var(--border-color);
}

.challenge-icon img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.challenge-title-section {
  flex: 1;
}

.challenge-title {
  margin: 0 0 var(--spacing-xs) 0;
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--text-primary);
}

.challenge-meta {
  display: flex;
  gap: var(--spacing-sm);
}

.challenge-difficulty,
.challenge-status {
  font-size: 0.8rem;
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  background-color: var(--background-panel-dark);
}

.challenge-card-body {
  margin-bottom: var(--spacing-md);
}

.challenge-description {
  margin: 0 0 var(--spacing-md) 0;
  font-size: 0.9rem;
  color: var(--text-secondary);
  line-height: 1.4;
}

.challenge-progress-section {
  margin-top: var(--spacing-md);
}

.challenge-dates {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  color: var(--text-tertiary);
  margin-top: var(--spacing-xs);
}

.challenge-card-footer {
  display: flex;
  justify-content: flex-end;
}

.complete-challenge-button {
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-xs) var(--spacing-md);
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.complete-challenge-button:disabled {
  background: linear-gradient(145deg, var(--background-panel-dark), var(--background-panel));
  color: var(--text-tertiary);
  cursor: not-allowed;
}

.challenge-completed-info {
  font-size: 0.8rem;
  color: var(--jade-green);
  font-weight: 600;
}

/* æŒ‘æˆ˜çŠ¶æ€æ ·å¼ */
.challenge-active {
  border-left: 4px solid var(--imperial-blue);
}

.challenge-completed {
  border-left: 4px solid var(--jade-green);
}

.challenge-expired {
  border-left: 4px solid var(--cinnabar-red);
  opacity: 0.7;
}

.challenge-upcoming {
  border-left: 4px solid var(--imperial-gold);
}

/* æŒ‘æˆ˜éš¾åº¦æ ·å¼ */
.difficulty-easy {
  color: var(--jade-green);
}

.difficulty-medium {
  color: var(--imperial-blue);
}

.difficulty-hard {
  color: var(--imperial-gold);
}

.difficulty-expert {
  color: var(--cinnabar-red);
}

/* æŒ‘æˆ˜åˆ—è¡¨ */
.challenge-list {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

/* æŒ‘æˆ˜é¡µé¢ */
.challenges-page {
  padding: var(--spacing-md);
}

.page-header {
  position: relative;
  margin-bottom: var(--spacing-md);
  display: flex;
  align-items: center;
  justify-content: center;
}

.page-title {
  font-family: var(--font-accent);
  font-size: 1.8rem;
  color: var(--deep-green);
  text-align: center;
}

/* ç”Ÿæˆæµ‹è¯•æ•°æ®æŒ‰é’® */
.generate-test-data-button {
  background-color: var(--imperial-gold);
  color: white;
  border: none;
  border-radius: var(--radius-md);
  padding: 8px 16px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.3s ease;
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
}

.generate-test-data-button:hover {
  background-color: #FFA000;
  transform: translateY(-50%) translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.generate-test-data-button:disabled {
  background-color: var(--ink-gray);
  cursor: not-allowed;
  transform: translateY(-50%);
  box-shadow: none;
}

.filter-section {
  margin-bottom: var(--spacing-lg);
  background-color: var(--background-panel-light);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  box-shadow: var(--shadow-sm);
}

.filter-group {
  margin-bottom: var(--spacing-md);
}

.filter-title {
  margin: 0 0 var(--spacing-xs) 0;
  font-size: 1rem;
  font-weight: 600;
  color: var(--text-primary);
}

.filter-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-xs);
}

.filter-actions {
  display: flex;
  justify-content: flex-end;
  margin-top: var(--spacing-md);
}

.clear-filters-button {
  font-size: 0.9rem;
}

/* æŒ‘æˆ˜è¯¦æƒ… */
.challenge-details {
  padding: var(--spacing-md);
}

.challenge-header {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-md);
}

.challenge-icon-large {
  width: 64px;
  height: 64px;
  border-radius: var(--radius-md);
  margin-right: var(--spacing-md);
  border: 2px solid var(--border-color);
}

.challenge-meta-details {
  flex: 1;
}

.challenge-description-full {
  margin-bottom: var(--spacing-md);
  line-height: 1.6;
}

.challenge-progress-details {
  margin-bottom: var(--spacing-md);
}

.progress-bar-container {
  height: 12px;
  background-color: var(--background-panel-dark);
  border-radius: var(--radius-full);
  overflow: hidden;
}

.progress-bar-fill {
  height: 100%;
  background: linear-gradient(to right, var(--jade-green), var(--imperial-blue));
  border-radius: var(--radius-full);
}

.challenge-dates-details {
  margin-bottom: var(--spacing-md);
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.complete-challenge-button-large {
  width: 100%;
  background: linear-gradient(145deg, var(--imperial-gold), var(--accent-gold));
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-top: var(--spacing-md);
}

/* åŠæ—¶å¥–åŠ±å¡ç‰‡ */
.timely-reward-card {
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  padding: 16px;
  margin-bottom: 16px;
  transition: all 0.3s ease;
  border-left: 4px solid #ccc;
  overflow: hidden;
  position: relative;
}

.timely-reward-card:hover {
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
  transform: translateY(-2px);
}

/* çŠ¶æ€æ ·å¼ */
.timely-reward-card.reward-active {
  border-left-color: var(--bamboo-green);
}

.timely-reward-card.reward-completed {
  border-left-color: var(--rosewood-purple);
}

.timely-reward-card.reward-expired {
  border-left-color: var(--ink-gray);
  opacity: 0.8;
}

.timely-reward-card.reward-upcoming {
  border-left-color: var(--porcelain-blue);
}

/* å¡ç‰‡å¤´éƒ¨ */
.reward-card-header {
  display: flex;
  align-items: center;
  margin-bottom: 12px;
}

.reward-icon {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  overflow: hidden;
  margin-right: 12px;
  background-color: #f5f5f5;
  display: flex;
  align-items: center;
  justify-content: center;
}

.reward-icon img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.reward-title-section {
  flex: 1;
}

.reward-title {
  margin: 0 0 4px 0;
  font-size: 18px;
  font-weight: 600;
}

.reward-meta {
  display: flex;
  align-items: center;
  font-size: 12px;
  color: var(--text-secondary);
}

.reward-type {
  margin-right: 8px;
  padding: 2px 6px;
  background-color: #f5f5f5;
  border-radius: 4px;
}

.reward-status {
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: 500;
}

.reward-status.reward-active {
  background-color: rgba(136, 176, 75, 0.1);
  color: var(--bamboo-green);
}

.reward-status.reward-completed {
  background-color: rgba(93, 57, 84, 0.1);
  color: var(--rosewood-purple);
}

.reward-status.reward-expired {
  background-color: rgba(138, 141, 145, 0.1);
  color: var(--ink-gray);
}

.reward-status.reward-upcoming {
  background-color: rgba(26, 109, 176, 0.1);
  color: var(--porcelain-blue);
}

/* å¡ç‰‡å†…å®¹ */
.reward-card-body {
  margin-bottom: 12px;
}

.reward-description {
  margin: 0 0 12px 0;
  font-size: 14px;
  color: var(--text-secondary);
  line-height: 1.5;
}

.reward-progress-section {
  margin-bottom: 8px;
}

.reward-time-info {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: var(--text-secondary);
  margin-top: 4px;
}

/* å¡ç‰‡åº•éƒ¨ */
.reward-card-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 8px;
  border-top: 1px solid #f0f0f0;
}

.reward-points {
  display: flex;
  align-items: center;
  font-size: 14px;
  font-weight: 500;
}

.lucky-points-icon {
  margin-right: 4px;
}

.lucky-points-value {
  color: var(--amber-yellow);
}

.complete-reward-button {
  padding: 6px 12px;
  background-color: var(--bamboo-green);
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.complete-reward-button:hover:not(:disabled) {
  background-color: var(--royal-jade);
}

.complete-reward-button:disabled {
  background-color: #e0e0e0;
  color: var(--ink-gray);
  cursor: not-allowed;
}

.reward-completed-info {
  font-size: 12px;
  color: var(--rosewood-purple);
}

/* åŠ¨ç”»æ•ˆæœ */
@keyframes glow {
  0% {
    box-shadow: 0 0 5px rgba(136, 176, 75, 0.5);
  }
  50% {
    box-shadow: 0 0 15px rgba(136, 176, 75, 0.8);
  }
  100% {
    box-shadow: 0 0 5px rgba(136, 176, 75, 0.5);
  }
}

.timely-reward-card.reward-active:hover {
  animation: glow 2s infinite;
}
</file>

<file path="src/hooks/useDataRefresh.ts">
// src/hooks/useDataRefresh.ts
import { useEffect, useState, useCallback, useRef } from 'react';
import { useDataRefreshContext } from '@/context/DataRefreshProvider';
import { DataRefreshEvent } from '@/types/dataRefresh';

/**
 * è‡ªå®šä¹‰ Hookï¼Œç”¨äºç›‘å¬æ•°æ®åˆ·æ–°äº‹ä»¶
 *
 * @param tables è¦ç›‘å¬çš„è¡¨åæ•°ç»„
 * @param callback æ•°æ®åˆ·æ–°æ—¶çš„å›è°ƒå‡½æ•°
 * @returns æœ€è¿‘ä¸€æ¬¡åˆ·æ–°çš„æ•°æ®
 */
export function useDataRefresh(
  tables: string[],
  callback?: (event: DataRefreshEvent) => void
): DataRefreshEvent | null {
  const [lastRefresh, setLastRefresh] = useState<DataRefreshEvent | null>(null);
  const { registerRefreshListener } = useDataRefreshContext();

  useEffect(() => {
    // ä¸ºæ¯ä¸ªè¡¨æ³¨å†Œç›‘å¬å™¨
    const unregisterFunctions = tables.map(table => {
      return registerRefreshListener(table, (data) => {
        const event = { table, data };
        setLastRefresh(event);

        if (callback) {
          callback(event);
        }
      });
    });

    // æ¸…ç†å‡½æ•°
    return () => {
      unregisterFunctions.forEach(unregister => unregister());
    };
  }, [tables, callback, registerRefreshListener]);

  return lastRefresh;
}

/**
 * è‡ªå®šä¹‰ Hookï¼Œç”¨äºç›‘å¬ç‰¹å®šè¡¨çš„æ•°æ®åˆ·æ–°äº‹ä»¶
 *
 * @param table è¦ç›‘å¬çš„è¡¨å
 * @param callback æ•°æ®åˆ·æ–°æ—¶çš„å›è°ƒå‡½æ•°
 * @returns æœ€è¿‘ä¸€æ¬¡åˆ·æ–°çš„æ•°æ®
 */
export function useTableRefresh(
  table: string,
  callback?: (data: any) => void
): any | null {
  const [lastData, setLastData] = useState<any | null>(null);
  const { registerRefreshListener } = useDataRefreshContext();

  useEffect(() => {
    // æ³¨å†Œè¡¨ç›‘å¬å™¨
    const unregister = registerRefreshListener(table, (data) => {
      setLastData(data);

      if (callback) {
        callback(data);
      }
    });

    // æ¸…ç†å‡½æ•°
    return unregister;
  }, [table, callback, registerRefreshListener]);

  return lastData;
}

/**
 * è‡ªå®šä¹‰ Hookï¼Œç”¨äºæ³¨å†Œè¡¨æ•°æ®åˆ·æ–°ç›‘å¬å™¨
 *
 * @param table è¦ç›‘å¬çš„è¡¨å
 * @param callback æ•°æ®åˆ·æ–°æ—¶çš„å›è°ƒå‡½æ•°
 * @returns å–æ¶ˆæ³¨å†Œçš„å‡½æ•°
 */
export function useRegisterTableRefresh(
  table: string,
  callback: (data: any) => void
): () => void {
  const { registerRefreshListener } = useDataRefreshContext();
  const callbackRef = useRef(callback);
  const unregisterFuncRef = useRef<(() => void) | null>(null);

  // Update callbackRef when the callback prop changes
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  // Effect for registering and unregistering the listener
  useEffect(() => {
    // Define a stable callback function that always uses the latest callback from ref
    const stableCallback = (data: any) => {
      callbackRef.current(data);
    };

    // Register the listener
    const unregister = registerRefreshListener(table, stableCallback);
    unregisterFuncRef.current = unregister; // Store the unregister function

    // Cleanup function: This is called when the component unmounts or dependencies change
    return () => {
      unregister();
      unregisterFuncRef.current = null; // Clear the ref after unregistering
    };
  }, [table, registerRefreshListener]); // Dependencies: re-run if table or registerRefreshListener changes

  // Return a memoized function that the caller can use to manually unregister.
  // This function is stable and safe to call multiple times (will only unregister once).
  const manualUnregister = useCallback(() => {
    if (unregisterFuncRef.current) {
      unregisterFuncRef.current();
      unregisterFuncRef.current = null; // Ensure it's only called once via this manual path
    }
  }, []); // This useCallback has no dependencies, so manualUnregister is stable.

  return manualUnregister;
}

/**
 * æ‰‹åŠ¨è§¦å‘æ•°æ®åˆ·æ–°äº‹ä»¶
 * æ³¨æ„ï¼šæ­¤å‡½æ•°å¿…é¡»åœ¨Reactç»„ä»¶å†…éƒ¨ä½¿ç”¨
 *
 * @param table è¡¨å
 * @param data æ•°æ®
 */
export function useDataRefreshTrigger() {
  const { refreshTable } = useDataRefreshContext();

  return (table: string, data?: any): void => {
    refreshTable(table, data);
  };
}

/**
 * ç›´æ¥è§¦å‘æ•°æ®åˆ·æ–°äº‹ä»¶ï¼ˆä¸ä½¿ç”¨hookï¼Œå¯ä»¥åœ¨ä»»ä½•åœ°æ–¹è°ƒç”¨ï¼‰
 *
 * @param table è¡¨å
 * @param data æ•°æ®
 */
export function triggerDataRefresh(table: string, data?: any): void {
  const refreshEvent = new CustomEvent('dataRefresh', {
    detail: { table, data }
  });
  window.dispatchEvent(refreshEvent);
}
</file>

<file path="src/index.css">
/* åŸºæœ¬æ ·å¼å·²ç§»è‡³game-theme.css */

/* é¡µé¢å†…å®¹æ ·å¼ */

.page-content, section.page-content { /* Allow section to also use page-content style */
  background-color: transparent;
  padding: 15px;
  margin-bottom: 20px;
  width: 100%;
  box-sizing: border-box;
}
section + section { margin-top: 25px; }


hr {
  border: 0;
  height: 1px;
  background-color: rgba(136, 176, 75, 0.3); /* ä½¿ç”¨ç«¹ç»¿è‰² */
  margin: 25px 0;
}

ul {
  list-style-type: disc;
  padding-left: 20px;
}
li { margin-bottom: 5px; }


/* Common Components */
.button-common {
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1em;
  font-weight: 500;
  transition: background-color 0.2s, opacity 0.2s;
  margin-right: 10px; /* Default spacing for buttons */
}
.button-common:last-child { margin-right: 0; }

.button-common:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.button-primary {
  background-color: #3498db;
  color: white;
}
.button-primary:hover:not(:disabled) {
  background-color: #2980b9;
}
.button-secondary {
  background-color: #95a5a6;
  color: white;
}
.button-secondary:hover:not(:disabled) {
  background-color: #7f8c8d;
}


select {
  padding: 10px;
  border-radius: 4px;
  border: 1px solid #bdc3c7;
  margin-right: 10px;
  font-size: 1em;
  background-color: white;
}

.loading-spinner-overlay {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  min-height: 100px;
}
.loading-spinner {
  border: 4px solid #ecf0f1; /* Light grey */
  border-top: 4px solid #3498db; /* Blue */
  border-radius: 50%;
  width: 30px;
  height: 30px;
  animation: spin 0.8s linear infinite;
}
.loading-spinner-text { margin-top: 10px; font-style: italic; color: #555; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.error-container {
  border: 1px solid #e74c3c; /* Red */
  padding: 15px;
  border-radius: 5px;
  background-color: #fdedec; /* Light red */
  margin-bottom: 15px;
}
.error-container h3 { color: #c0392b; margin-bottom: 8px;}
.error-text { color: #c0392b; }
.error-code-text { font-size: 0.85em; color: #7f8c8d; margin-top: 5px; }
</file>

<file path="src/pages/AbilitiesPage.tsx">
// src/pages/AbilitiesPage.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { usePandaState } from '@/context/PandaStateProvider';
import AbilityList from '@/components/game/AbilityList';
import AbilityUnlockNotification from '@/components/game/AbilityUnlockNotification';
import PageTransition from '@/components/animation/PageTransition';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { PandaAbilityRecord } from '@/services/pandaAbilityService';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchAbilitiesPageView } from '@/services';
import { AbilitiesPageViewLabelsBundle } from '@/types';

/**
 * Panda Abilities Page
 * Displays all panda abilities and allows activation of unlocked abilities
 */
const AbilitiesPage: React.FC = () => {
  const {
    pandaState,
    abilities,
    unlockedAbilities,
    isLoading: isPandaLoading,
    activateAbility,
    checkNewAbilities
  } = usePandaState();

  const [newlyUnlockedAbilities, setNewlyUnlockedAbilities] = useState<PandaAbilityRecord[]>([]);
  const [showUnlockNotification, setShowUnlockNotification] = useState(false);

  // è·å–æœ¬åœ°åŒ–æ ‡ç­¾
  const {
    labels: pageLabels,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<null, AbilitiesPageViewLabelsBundle>(
    'abilitiesPageViewContent',
    fetchAbilitiesPageView
  );

  // åˆå¹¶åŠ è½½çŠ¶æ€
  const isLoading = isPandaLoading || isPending;

  // æ£€æŸ¥æ–°è§£é”çš„èƒ½åŠ›
  useEffect(() => {
    const checkForNewAbilities = async () => {
      const newAbilities = await checkNewAbilities();
      if (newAbilities.length > 0) {
        setNewlyUnlockedAbilities(newAbilities);
        setShowUnlockNotification(true);
      }
    };

    checkForNewAbilities();
  }, [checkNewAbilities]);

  // å…³é—­è§£é”é€šçŸ¥
  const handleCloseUnlockNotification = () => {
    setShowUnlockNotification(false);
    setNewlyUnlockedAbilities([]);
  };

  // æ¿€æ´»èƒ½åŠ›
  const handleActivateAbility = async (abilityId: number) => {
    await activateAbility(abilityId);
  };

  // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
  if (isError) {
    return (
      <PageTransition>
        <div className="page-content">
          <ErrorDisplay
            error={error}
            title={pageLabels?.errorTitle || "Failed to Load Abilities"}
            messageTemplate={pageLabels?.errorMessage || "Unable to load ability data: {message}"}
            onRetry={refetch}
            retryButtonText={pageLabels?.retryButtonText || "Retry"}
          />
        </div>
      </PageTransition>
    );
  }

  return (
    <PageTransition>
      <div className="page-content">
        <div className="bamboo-frame">
          <h2>{pageLabels?.pageTitle || "Panda Abilities"}</h2>

          {isLoading ? (
            <div className="loading-container">
              <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "Loading abilities..."} />
            </div>
          ) : (
            <>
              <div className="abilities-header">
                <motion.div
                  className="panda-level-info"
                  initial={{ opacity: 0, y: -20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.5 }}
                >
                  <h3>{pageLabels?.pandaLevelLabel || "Panda Level"}: {pandaState?.level || 1}</h3>
                  <p>{pageLabels?.unlockedAbilitiesLabel || "Unlocked Abilities"}: {unlockedAbilities.length} / {abilities.length}</p>
                </motion.div>

                <motion.div
                  className="abilities-description"
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.5, delay: 0.2 }}
                >
                  <p>
                    {pageLabels?.abilitiesDescription ||
                      "Panda abilities help you complete tasks more efficiently and earn more rewards. As your panda levels up, you'll unlock more powerful abilities."}
                  </p>
                </motion.div>
              </div>

              <AbilityList
                abilities={abilities}
                unlockedAbilities={unlockedAbilities}
                onActivateAbility={handleActivateAbility}
                pandaLevel={pandaState?.level || 1}
                labels={{
                  filters: pageLabels?.filters,
                  card: pageLabels?.abilityCard,
                  detail: pageLabels?.abilityDetail,
                  noAbilitiesMessage: pageLabels?.noAbilitiesMessage
                }}
              />
            </>
          )}
        </div>

        {/* Ability unlock notification */}
        {showUnlockNotification && (
          <AbilityUnlockNotification
            newlyUnlockedAbilities={newlyUnlockedAbilities}
            onClose={handleCloseUnlockNotification}
            labels={pageLabels?.abilityUnlockNotification}
          />
        )}
      </div>
    </PageTransition>
  );
};

export default AbilitiesPage;
</file>

<file path="src/pages/ChallengesPage.tsx">
// src/pages/ChallengesPage.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import {
  ChallengeStatus,
  ChallengeType,
  ChallengeDifficulty,
  initializeChallengeCategories,
  generateTestChallengeData
} from '@/services/challengeService';
import ChallengeList from '@/components/game/ChallengeList';
import PageTransition from '@/components/animation/PageTransition';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import AnimatedButton from '@/components/animation/AnimatedButton';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { fetchChallengesPageView } from '@/services';
import type { ChallengesPageViewLabelsBundle } from '@/types';

/**
 * Challenges Page
 * Displays challenge list and filter options
 */
const ChallengesPage: React.FC = () => {
  const [filter, setFilter] = useState<{
    status?: ChallengeStatus;
    type?: ChallengeType;
    difficulty?: ChallengeDifficulty;
  }>({
    status: ChallengeStatus.ACTIVE
  });

  const [isGeneratingData, setIsGeneratingData] = useState(false);

  const {
    labels: pageLabels,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<null, ChallengesPageViewLabelsBundle>(
    'challengesPageViewContent',
    fetchChallengesPageView
  );

  // Initialize challenge categories
  useEffect(() => {
    initializeChallengeCategories();
  }, []);

  // Handle status filter
  const handleStatusFilter = (status?: ChallengeStatus) => {
    setFilter(prev => ({ ...prev, status }));
  };

  // Handle type filter
  const handleTypeFilter = (type?: ChallengeType) => {
    setFilter(prev => ({ ...prev, type }));
  };

  // Handle difficulty filter
  const handleDifficultyFilter = (difficulty?: ChallengeDifficulty) => {
    setFilter(prev => ({ ...prev, difficulty }));
  };

  // Clear all filters
  const clearAllFilters = () => {
    setFilter({});
  };

  // Generate test data
  const handleGenerateTestData = async () => {
    try {
      setIsGeneratingData(true);
      await generateTestChallengeData();
      // Refresh the page to show new data
      window.location.reload();
    } catch (error) {
      console.error('Error generating test data:', error);
    } finally {
      setIsGeneratingData(false);
    }
  };

  // Show loading state
  if (isPending) {
    return (
      <PageTransition>
        <div className="challenges-page">
          <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "Loading challenges..."} />
        </div>
      </PageTransition>
    );
  }

  // Show error state
  if (isError) {
    return (
      <PageTransition>
        <div className="challenges-page">
          <ErrorDisplay
            error={error}
            title={pageLabels?.errorTitle || "Challenge Page Error"}
            messageTemplate={pageLabels?.errorMessage || "Failed to load challenges: {message}"}
            onRetry={refetch}
            retryButtonText={pageLabels?.retryButtonText || "Retry"}
          />
        </div>
      </PageTransition>
    );
  }

  return (
    <PageTransition>
      <motion.div
        className="challenges-page"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
      >
        <div className="page-header">
          <h1 className="page-title">{pageLabels?.pageTitle || 'Challenges'}</h1>
          <button
            className="generate-test-data-button"
            onClick={handleGenerateTestData}
            disabled={isGeneratingData}
          >
            {isGeneratingData ? 'Generating...' : 'Generate Test Data'}
          </button>
        </div>

        <div className="filter-section">
          <div className="filter-group">
            <h3 className="filter-title">{pageLabels?.statusFilterLabel || 'Status'}</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleStatusFilter(undefined)}
                className={!filter.status ? 'active' : ''}
              >
                {pageLabels?.filters?.allLabel || 'All'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(ChallengeStatus.ACTIVE)}
                className={filter.status === ChallengeStatus.ACTIVE ? 'active' : ''}
              >
                {pageLabels?.filters?.activeLabel || 'Active'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(ChallengeStatus.COMPLETED)}
                className={filter.status === ChallengeStatus.COMPLETED ? 'active' : ''}
              >
                {pageLabels?.filters?.completedLabel || 'Completed'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(ChallengeStatus.UPCOMING)}
                className={filter.status === ChallengeStatus.UPCOMING ? 'active' : ''}
              >
                {pageLabels?.filters?.upcomingLabel || 'Upcoming'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-group">
            <h3 className="filter-title">{pageLabels?.typeFilterLabel || 'Type'}</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleTypeFilter(undefined)}
                className={!filter.type ? 'active' : ''}
              >
                {pageLabels?.filters?.typeAllLabel || 'All'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(ChallengeType.DAILY)}
                className={filter.type === ChallengeType.DAILY ? 'active' : ''}
              >
                {pageLabels?.filters?.typeDailyLabel || 'Daily'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(ChallengeType.WEEKLY)}
                className={filter.type === ChallengeType.WEEKLY ? 'active' : ''}
              >
                {pageLabels?.filters?.typeWeeklyLabel || 'Weekly'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(ChallengeType.EVENT)}
                className={filter.type === ChallengeType.EVENT ? 'active' : ''}
              >
                {pageLabels?.filters?.typeEventLabel || 'Event'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(ChallengeType.ONGOING)}
                className={filter.type === ChallengeType.ONGOING ? 'active' : ''}
              >
                {pageLabels?.filters?.typeOngoingLabel || 'Ongoing'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-group">
            <h3 className="filter-title">{pageLabels?.difficultyFilterLabel || 'Difficulty'}</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleDifficultyFilter(undefined)}
                className={!filter.difficulty ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyAllLabel || 'All'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleDifficultyFilter(ChallengeDifficulty.EASY)}
                className={filter.difficulty === ChallengeDifficulty.EASY ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyEasyLabel || 'Easy'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleDifficultyFilter(ChallengeDifficulty.MEDIUM)}
                className={filter.difficulty === ChallengeDifficulty.MEDIUM ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyMediumLabel || 'Medium'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleDifficultyFilter(ChallengeDifficulty.HARD)}
                className={filter.difficulty === ChallengeDifficulty.HARD ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyHardLabel || 'Hard'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleDifficultyFilter(ChallengeDifficulty.EXPERT)}
                className={filter.difficulty === ChallengeDifficulty.EXPERT ? 'active' : ''}
              >
                {pageLabels?.filters?.difficultyExpertLabel || 'Expert'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-actions">
            <AnimatedButton onClick={clearAllFilters} className="clear-filters-button">
              {pageLabels?.filters?.clearFiltersLabel || 'Clear All Filters'}
            </AnimatedButton>
          </div>
        </div>

        <div className="challenges-container">
          <ChallengeList
            filter={filter}
            labels={{
              ...pageLabels?.challengeCard,
              statusLabel: pageLabels?.statusFilterLabel,
              typeLabel: pageLabels?.typeFilterLabel,
              difficultyLabel: pageLabels?.difficultyFilterLabel,
              noItemsMessage: pageLabels?.noChallengesMessage
            }}
          />
        </div>
      </motion.div>
    </PageTransition>
  );
};

export default ChallengesPage;
</file>

<file path="src/pages/HomePage.tsx">
// src/pages/HomePage.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchHomePageView } from '@/services';
import WelcomeSection from '@/features/home/WelcomeSection';
import MoodsSection from '@/features/home/MoodsSection';
import PandaSection from '@/features/home/PandaSection';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import AnimatedButton from '@/components/animation/AnimatedButton';
import { pageTransition } from '@/utils/animation';
import { initializeGameData } from '@/services/gameInitService';
import type { HomePageViewDataPayload, HomePageViewLabelsBundle, ApiError } from '@/types';

const HomePage: React.FC = () => {
  const [isInitializing, setIsInitializing] = useState(false);

  const {
    data: pageData, labels: pageLabels, isPending, isError, error, refetch, isFetching
  } = useLocalizedView<HomePageViewDataPayload, HomePageViewLabelsBundle>(
    'homePageViewContent',
    fetchHomePageView
  );

  const handleInitializeGame = async () => {
    try {
      setIsInitializing(true);
      await initializeGameData();
      // Refresh the page to show new data
      window.location.reload();
    } catch (error) {
      console.error('Error initializing game data:', error);
      alert('Failed to initialize game data. Please try again.');
    } finally {
      setIsInitializing(false);
    }
  };

  if (isPending && !pageLabels) { // Full page initial load
    return <LoadingSpinner variant="jade" text="Loading Home Page Content..." />;
  }

  if (isError && !pageLabels) { // Critical: Page labels failed
    return (
      <div className="page-content">
        <ErrorDisplay error={error} title="Home Page Error" onRetry={refetch} />
      </div>
    );
  }

  // If labels are partially/fully loaded, but an error occurred or still pending data
  // We can render the page shell with what we have.
  const isLoadingData = isPending || (isFetching && !pageData); // True if data is still being fetched/refetched

  return (
    <motion.div
      className="page-container"
      variants={pageTransition}
      initial="hidden"
      animate="visible"
      exit="exit"
    >
      <div className="bamboo-frame"> {/* Wrap content in bamboo-frame */}
        <h2>{pageLabels?.pageTitle || "Dashboard"}</h2>

        <WelcomeSection labels={pageLabels?.welcomeSection} username={pageData?.username} />

        <PandaSection labels={pageLabels?.pandaSection} />

        <MoodsSection
          labels={pageLabels?.moodsSection}
          moods={pageData?.moods}
          onRefresh={refetch}
          isFetching={isFetching}
        />

        {/* Initialize Game Data Button */}
        <div className="init-game-container" style={{marginTop: '20px', textAlign: 'center'}}>
          <AnimatedButton
            variant="gold"
            onClick={handleInitializeGame}
            disabled={isInitializing}
            style={{marginTop: '20px'}}
          >
            {isInitializing ? 'Initializing...' : 'Initialize Game Data'}
          </AnimatedButton>
          <p className="text-sm text-gray-500 mt-2">
            This will create sample data for all game systems
          </p>
        </div>

        {/* Example of a page-level button using a page-level label with jade style */}
        {pageLabels?.someActionText && (
          <AnimatedButton
            variant="jade"
            onClick={() => alert('Action Confirmed!')}
            style={{marginTop: '20px'}}
          >
            {pageLabels.someActionText}
          </AnimatedButton>
        )}

        {/* Show specific data error if labels loaded but data part failed */}
        {isError && pageData === undefined && pageLabels && (
           <ErrorDisplay
              error={error}
              title={pageLabels.moodsSection?.sectionTitle || "Data Fetch Error"}
              messageTemplate="Could not load mood data. Details: {message}"
              onRetry={refetch}
           />
         )}
         {isLoadingData && pageLabels && ( // Show spinner for data if labels are present
             <LoadingSpinner variant="jade" text="Fetching latest data..." />
         )}
      </div>
    </motion.div>
  );
};
export default HomePage;
</file>

<file path="src/pages/SettingsPage.tsx">
// src/pages/SettingsPage.tsx
import React from 'react';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchSettingsPageView } from '@/services';
import LanguageSettingsSection from '@/features/settings/LanguageSettingsSection';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import PageTransition from '@/components/animation/PageTransition';
import DialogDemo from '@/components/game/DialogDemo';
import type { SettingsPageViewLabelsBundle, ApiError } from '@/types';

const SettingsPage: React.FC = () => {
  const {
    labels: pageLabels, isPending, isError, error, refetch, isFetching
  } = useLocalizedView<null, SettingsPageViewLabelsBundle>(
    'settingsPageViewContent',
    fetchSettingsPageView
  );

  if (isPending && !pageLabels) { // Full page initial load
    return <LoadingSpinner variant="jade" text="Loading Settings Page Content..." />;
  }

  if (isError || !pageLabels) { // Critical: Page labels failed
     return (
      <div className="page-content">
        <ErrorDisplay
          error={error}
          title={pageLabels?.pageTitle || "Settings Load Error"}
          messageTemplate="Could not load settings. Details: {message}"
          onRetry={refetch}
        />
      </div>
    );
  }

  return (
    <PageTransition>
      <div className="page-content"> {/* Use regular container first */}
        <div className="bamboo-frame"> {/* Wrap content in bamboo-frame */}
          <h2>{pageLabels.pageTitle || "Settings"}</h2>
          <LanguageSettingsSection
            labels={pageLabels.languageSection}
            isUpdatingPage={isFetching && !!pageLabels} // Page is fetching if labels are present but still fetching
          />

          {/* å¯¹è¯æ¡†æ¼”ç¤ºéƒ¨åˆ† */}
          <div style={{ marginTop: '30px', borderTop: '1px solid var(--border-color)', paddingTop: '20px' }}>
            <h3>UIç»„ä»¶æ¼”ç¤º</h3>
            <DialogDemo />
          </div>
        </div>
      </div>
    </PageTransition>
  );
};
export default SettingsPage;
</file>

<file path="src/pages/TasksPage.tsx">
// src/pages/TasksPage.tsx
import React, { useEffect } from 'react';
import { motion } from 'framer-motion';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import { fetchTasksPageView } from '@/services';
import TaskManager from '@/features/tasks/TaskManager';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { pageTransition } from '@/utils/animation';
import type { TasksPageViewLabelsBundle } from '@/types';
import TaskReminderNotification from '@/components/task/TaskReminderNotification';
import { checkDueSoonTasks, checkOverdueTasks } from '@/services/taskReminderService';

const TasksPage: React.FC = () => {
  const {
    labels: pageLabels, isPending, isError, error, refetch
  } = useLocalizedView<null, TasksPageViewLabelsBundle>(
    'tasksPageViewContent',
    fetchTasksPageView
  );

  // æ£€æŸ¥ä»»åŠ¡æé†’
  useEffect(() => {
    const checkReminders = async () => {
      try {
        // æ£€æŸ¥å³å°†åˆ°æœŸçš„ä»»åŠ¡
        await checkDueSoonTasks();

        // æ£€æŸ¥å·²è¿‡æœŸçš„ä»»åŠ¡
        await checkOverdueTasks();
      } catch (err) {
        console.error('Failed to check task reminders:', err);
      }
    };

    // ç«‹å³æ£€æŸ¥ä¸€æ¬¡
    checkReminders();

    // è®¾ç½®å®šæ—¶æ£€æŸ¥ï¼ˆæ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡ï¼‰
    const intervalId = setInterval(checkReminders, 60 * 60 * 1000);

    // æ¸…ç†å‡½æ•°
    return () => {
      clearInterval(intervalId);
    };
  }, []);

  if (isPending) { // å®Œæ•´é¡µé¢åˆå§‹åŠ è½½
    return <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "åŠ è½½ä»»åŠ¡é¡µé¢å†…å®¹..."} />;
  }

  if (isError) { // å…³é”®é”™è¯¯ï¼šé¡µé¢æ ‡ç­¾åŠ è½½å¤±è´¥
    return (
      <div className="page-content">
        <ErrorDisplay
          error={error}
          title={pageLabels?.errorTitle || "ä»»åŠ¡é¡µé¢é”™è¯¯"}
          messageTemplate={pageLabels?.errorMessage || "æ— æ³•åŠ è½½ä»»åŠ¡æ•°æ®: {message}"}
          onRetry={refetch}
          retryButtonText={pageLabels?.retryButtonText || "é‡è¯•"}
        />
      </div>
    );
  }

  return (
    <>
      <motion.div
        className="page-container"
        variants={pageTransition}
        initial="hidden"
        animate="visible"
        exit="exit"
      >
        <div className="bamboo-frame">
          <h2>{pageLabels?.pageTitle || "ä»»åŠ¡ç®¡ç†"}</h2>

          <TaskManager labels={pageLabels?.taskManager} />
        </div>
      </motion.div>

      {/* ä»»åŠ¡æé†’é€šçŸ¥ */}
      <TaskReminderNotification
        onTaskClick={(taskId) => {
          // è¿™é‡Œå¯ä»¥æ·»åŠ å¯¼èˆªåˆ°ä»»åŠ¡è¯¦æƒ…çš„é€»è¾‘
          console.log('Navigate to task:', taskId);
        }}
      />
    </>
  );
};

export default TasksPage;
</file>

<file path="src/pages/TimelyRewardsPage.tsx">
// src/pages/TimelyRewardsPage.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import {
  TimelyRewardStatus,
  TimelyRewardType,
  initializeTimelyRewards
} from '@/services/timelyRewardService';
import TimelyRewardList from '@/components/game/TimelyRewardList';
import LuckyDraw from '@/components/game/LuckyDraw';
import PageTransition from '@/components/animation/PageTransition';
import { useLocalizedView } from '@/hooks/useLocalizedView';
import AnimatedButton from '@/components/animation/AnimatedButton';
import ScrollDialog from '@/components/game/ScrollDialog';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorDisplay from '@/components/common/ErrorDisplay';
import { fetchTimelyRewardsPageView } from '@/services';
import type { TimelyRewardsPageViewLabelsBundle } from '@/types';

/**
 * Timely Rewards Page
 * Displays timely rewards list and lucky draw
 */
const TimelyRewardsPage: React.FC = () => {
  const [filter, setFilter] = useState<{
    status?: TimelyRewardStatus;
    type?: TimelyRewardType;
  }>({
    status: TimelyRewardStatus.ACTIVE
  });
  const [showLuckyDraw, setShowLuckyDraw] = useState(false);

  const {
    labels: pageLabels,
    isPending,
    isError,
    error,
    refetch
  } = useLocalizedView<null, TimelyRewardsPageViewLabelsBundle>(
    'timelyRewardsPageViewContent',
    fetchTimelyRewardsPageView
  );

  // Initialize timely rewards
  useEffect(() => {
    initializeTimelyRewards();
  }, []);

  // Handle status filter
  const handleStatusFilter = (status?: TimelyRewardStatus) => {
    setFilter(prev => ({ ...prev, status }));
  };

  // Handle type filter
  const handleTypeFilter = (type?: TimelyRewardType) => {
    setFilter(prev => ({ ...prev, type }));
  };

  // Clear all filters
  const clearAllFilters = () => {
    setFilter({});
  };

  // Open lucky draw
  const openLuckyDraw = () => {
    setShowLuckyDraw(true);
  };

  // Close lucky draw
  const closeLuckyDraw = () => {
    setShowLuckyDraw(false);
  };

  if (isPending && !pageLabels) { // Full page initial loading
    return <LoadingSpinner variant="jade" text={pageLabels?.loadingMessage || "Loading rewards..."} />;
  }

  if (isError && !pageLabels) { // Critical error: page labels failed to load
    return (
      <div className="page-content">
        <ErrorDisplay error={error} title={pageLabels?.errorTitle || "Timely Rewards Page Error"} onRetry={refetch} />
      </div>
    );
  }

  return (
    <PageTransition>
      <motion.div
        className="timely-rewards-page"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
      >
        <div className="page-header">
          <h1 className="page-title">{pageLabels?.pageTitle || 'Timely Rewards'}</h1>
          <AnimatedButton
            onClick={openLuckyDraw}
            className="lucky-draw-button"
          >
            {pageLabels?.luckyDraw?.buttonText || 'Lucky Draw'}
          </AnimatedButton>
        </div>

        <div className="filter-section">
          <div className="filter-group">
            <h3 className="filter-title">{pageLabels?.filters?.statusLabel || 'Status'}</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleStatusFilter(undefined)}
                className={!filter.status ? 'active' : ''}
              >
                {pageLabels?.filters?.allLabel || 'All'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(TimelyRewardStatus.ACTIVE)}
                className={filter.status === TimelyRewardStatus.ACTIVE ? 'active' : ''}
              >
                {pageLabels?.filters?.activeLabel || 'Active'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(TimelyRewardStatus.COMPLETED)}
                className={filter.status === TimelyRewardStatus.COMPLETED ? 'active' : ''}
              >
                {pageLabels?.filters?.completedLabel || 'Completed'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleStatusFilter(TimelyRewardStatus.UPCOMING)}
                className={filter.status === TimelyRewardStatus.UPCOMING ? 'active' : ''}
              >
                {pageLabels?.filters?.upcomingLabel || 'Upcoming'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-group">
            <h3 className="filter-title">{pageLabels?.filters?.typeLabel || 'Type'}</h3>
            <div className="filter-buttons">
              <AnimatedButton
                onClick={() => handleTypeFilter(undefined)}
                className={!filter.type ? 'active' : ''}
              >
                {pageLabels?.filters?.typeAllLabel || 'All'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(TimelyRewardType.DAILY)}
                className={filter.type === TimelyRewardType.DAILY ? 'active' : ''}
              >
                {pageLabels?.filters?.typeDailyLabel || 'Daily Reward'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(TimelyRewardType.MORNING)}
                className={filter.type === TimelyRewardType.MORNING ? 'active' : ''}
              >
                {pageLabels?.filters?.typeMorningLabel || 'Early Bird Reward'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(TimelyRewardType.STREAK)}
                className={filter.type === TimelyRewardType.STREAK ? 'active' : ''}
              >
                {pageLabels?.filters?.typeStreakLabel || 'Streak Reward'}
              </AnimatedButton>
              <AnimatedButton
                onClick={() => handleTypeFilter(TimelyRewardType.SPECIAL)}
                className={filter.type === TimelyRewardType.SPECIAL ? 'active' : ''}
              >
                {pageLabels?.filters?.typeSpecialLabel || 'Special Reward'}
              </AnimatedButton>
            </div>
          </div>

          <div className="filter-actions">
            <AnimatedButton onClick={clearAllFilters} className="clear-filters-button">
              {pageLabels?.filters?.clearFiltersLabel || 'Clear All Filters'}
            </AnimatedButton>
          </div>
        </div>

        <div className="rewards-container">
          <TimelyRewardList
            filter={filter}
            labels={pageLabels?.rewardCard}
          />
        </div>

        {/* Lucky Draw Modal */}
        {showLuckyDraw && (
          <ScrollDialog
            isOpen={showLuckyDraw}
            title={pageLabels?.luckyDraw?.title || 'Lucky Draw'}
            onClose={closeLuckyDraw}
          >
            <div className="lucky-draw-dialog">
              <LuckyDraw onClose={closeLuckyDraw} />
            </div>
          </ScrollDialog>
        )}
      </motion.div>
    </PageTransition>
  );
};

export default TimelyRewardsPage;
</file>

<file path="src/services/pandaStateService.ts">
// src/services/pandaStateService.ts
import { db } from '@/db';
import { addSyncItem } from './dataSyncService';
import type { PandaMood, EnergyLevel } from '@/components/game/PandaAvatar';

// ç†ŠçŒ«çŠ¶æ€è®°å½•ç±»å‹
export interface PandaStateRecord {
  id?: number;
  mood: PandaMood;
  energy: EnergyLevel;
  lastUpdated: Date;
  experience: number; // ç»éªŒå€¼
  level: number; // ç­‰çº§
}

// æ‰©å±•çš„ç†ŠçŒ«çŠ¶æ€ï¼ˆç”¨äºæ¸¸æˆåˆå§‹åŒ–ï¼‰
export interface PandaState extends Omit<PandaStateRecord, 'lastUpdated'> {
  name?: string;
  outfit?: string;
  accessories?: string[];
}

// é»˜è®¤ç†ŠçŒ«çŠ¶æ€
const DEFAULT_PANDA_STATE: PandaStateRecord = {
  mood: 'normal',
  energy: 'medium',
  lastUpdated: new Date(),
  experience: 0,
  level: 1
};


export async function getPandaMood(): Promise<PandaMood> {
  const pandaState = await getPandaState();
  return pandaState.mood;
}

/**
 * è·å–å½“å‰ç†ŠçŒ«çŠ¶æ€
 * å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºé»˜è®¤çŠ¶æ€
 */
export async function getPandaState(): Promise<PandaStateRecord> {
  // æ£€æŸ¥æ•°æ®åº“ä¸­æ˜¯å¦å·²æœ‰ç†ŠçŒ«çŠ¶æ€è®°å½•
  const pandaState = await db.table('pandaState').toArray();

  if (pandaState.length === 0) {
    // å¦‚æœæ²¡æœ‰è®°å½•ï¼Œåˆ›å»ºé»˜è®¤çŠ¶æ€
    const id = await db.table('pandaState').add(DEFAULT_PANDA_STATE);
    return { ...DEFAULT_PANDA_STATE, id };
  }

  return pandaState[0];
}

/**
 * æ›´æ–°ç†ŠçŒ«æƒ…ç»ªçŠ¶æ€
 * @param mood æ–°çš„æƒ…ç»ªçŠ¶æ€
 */
export async function updatePandaMood(mood: PandaMood): Promise<PandaStateRecord> {
  const currentState = await getPandaState();
  const updatedState = {
    ...currentState,
    mood,
    lastUpdated: new Date()
  };

  // æ›´æ–°æ•°æ®åº“
  await db.table('pandaState').update(currentState.id!, updatedState);

  // æ·»åŠ åŒæ­¥é¡¹ç›®
  await addSyncItem('pandaState', 'update', updatedState);

  return updatedState;
}

/**
 * æ›´æ–°ç†ŠçŒ«èƒ½é‡çº§åˆ«
 * @param energy æ–°çš„èƒ½é‡çº§åˆ«
 */
export async function updatePandaEnergy(energy: EnergyLevel): Promise<PandaStateRecord> {
  const currentState = await getPandaState();
  const updatedState = {
    ...currentState,
    energy,
    lastUpdated: new Date()
  };

  // æ›´æ–°æ•°æ®åº“
  await db.table('pandaState').update(currentState.id!, updatedState);

  // æ·»åŠ åŒæ­¥é¡¹ç›®
  await addSyncItem('pandaState', 'update', updatedState);

  return updatedState;
}

/**
 * å¢åŠ ç†ŠçŒ«ç»éªŒå€¼
 * @param amount å¢åŠ çš„ç»éªŒå€¼æ•°é‡
 */
export async function addPandaExperience(amount: number): Promise<PandaStateRecord> {
  const currentState = await getPandaState();
  const newExperience = currentState.experience + amount;

  // ç®€å•çš„ç­‰çº§è®¡ç®—é€»è¾‘ï¼šæ¯100ç‚¹ç»éªŒå‡ä¸€çº§
  const newLevel = Math.floor(newExperience / 100) + 1;

  const updatedState = {
    ...currentState,
    experience: newExperience,
    level: newLevel,
    lastUpdated: new Date()
  };

  // å¦‚æœå‡çº§äº†ï¼Œæ›´æ–°æƒ…ç»ªä¸ºå¼€å¿ƒ
  if (newLevel > currentState.level) {
    updatedState.mood = 'happy';
  }

  // æ›´æ–°æ•°æ®åº“
  await db.table('pandaState').update(currentState.id!, updatedState);

  // æ·»åŠ åŒæ­¥é¡¹ç›®
  await addSyncItem('pandaState', 'update', updatedState);

  return updatedState;
}

/**
 * é‡ç½®ç†ŠçŒ«çŠ¶æ€ï¼ˆç”¨äºæµ‹è¯•æˆ–é‡æ–°å¼€å§‹ï¼‰
 */
export async function resetPandaState(): Promise<PandaStateRecord> {
  const currentState = await getPandaState();
  const resetState = {
    ...DEFAULT_PANDA_STATE,
    id: currentState.id,
    lastUpdated: new Date()
  };

  // æ›´æ–°æ•°æ®åº“
  await db.table('pandaState').update(currentState.id!, resetState);

  // æ·»åŠ åŒæ­¥é¡¹ç›®
  await addSyncItem('pandaState', 'update', resetState);

  return resetState;
}

/**
 * æ›´æ–°ç†ŠçŒ«çŠ¶æ€ï¼ˆç”¨äºæ¸¸æˆåˆå§‹åŒ–ï¼‰
 * @param state æ–°çš„ç†ŠçŒ«çŠ¶æ€
 */
export async function updatePandaState(state: PandaState): Promise<PandaStateRecord> {
  const currentState = await getPandaState();

  // åˆ›å»ºæ›´æ–°åçš„çŠ¶æ€
  const updatedState = {
    ...currentState,
    mood: state.mood || currentState.mood,
    energy: typeof state.energy === 'number' ? state.energy : currentState.energy,
    experience: state.experience !== undefined ? state.experience : currentState.experience,
    level: state.level || currentState.level,
    lastUpdated: new Date()
  };

  // æ›´æ–°æ•°æ®åº“
  await db.table('pandaState').update(currentState.id!, updatedState);

  // æ·»åŠ åŒæ­¥é¡¹ç›®
  await addSyncItem('pandaState', 'update', updatedState);

  // å¦‚æœæä¾›äº†åç§°ã€è£…æ‰®æˆ–é…ä»¶ï¼Œå¯ä»¥åœ¨è¿™é‡Œå¤„ç†
  // è¿™é‡Œå‡è®¾æœ‰ä¸€ä¸ªå•ç‹¬çš„è¡¨æ¥å­˜å‚¨è¿™äº›ä¿¡æ¯
  if (state.name || state.outfit || state.accessories) {
    console.log('Additional panda customization:', {
      name: state.name,
      outfit: state.outfit,
      accessories: state.accessories
    });
    // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œå¯ä»¥æ›´æ–°ç›¸åº”çš„è¡¨
  }

  return updatedState;
}
</file>

<file path="src/services/rewardService.ts">
// src/services/rewardService.ts
import { db } from '@/db';
import { TaskType, TaskPriority, TaskRecord } from './taskService';
import { addSyncItem } from './dataSyncService';

// å¥–åŠ±ç±»å‹æšä¸¾
export enum RewardType {
  EXPERIENCE = 'experience',   // ç»éªŒå€¼
  COIN = 'coin',               // é‡‘å¸
  ITEM = 'item',               // ç‰©å“
  BADGE = 'badge',             // å¾½ç« 
  ABILITY = 'ability'          // ç†ŠçŒ«èƒ½åŠ›
}

// å¥–åŠ±ç¨€æœ‰åº¦æšä¸¾
export enum RewardRarity {
  COMMON = 'common',           // æ™®é€š
  UNCOMMON = 'uncommon',       // ä¸å¸¸è§
  RARE = 'rare',               // ç¨€æœ‰
  EPIC = 'epic',               // å²è¯—
  LEGENDARY = 'legendary'      // ä¼ è¯´
}

// å¥–åŠ±è®°å½•ç±»å‹
export interface RewardRecord {
  id?: number;
  type: RewardType;
  rarity: RewardRarity;
  amount: number;
  name: string;
  description: string;
  iconPath: string;
  taskId?: number;
  obtainedAt: Date;
  isNew: boolean;
  isViewed: boolean;
}

// ç‰©å“ç±»å‹æšä¸¾
export enum ItemType {
  FOOD = 'food',               // é£Ÿç‰©
  TOY = 'toy',                 // ç©å…·
  DECORATION = 'decoration',   // è£…é¥°
  SCROLL = 'scroll',           // å·è½´
  POTION = 'potion'            // è¯æ°´
}

// ç‰©å“è®°å½•ç±»å‹
export interface ItemRecord {
  id?: number;
  type: ItemType;
  name: string;
  description: string;
  rarity: RewardRarity;
  iconPath: string;
  quantity: number;
  isUsable: boolean;
  effectDescription?: string;
  obtainedAt: Date;
}

// å¾½ç« è®°å½•ç±»å‹
export interface BadgeRecord {
  id?: number;
  name: string;
  description: string;
  rarity: RewardRarity;
  iconPath: string;
  obtainedAt: Date;
  isEquipped: boolean;
}

// ç†ŠçŒ«èƒ½åŠ›è®°å½•ç±»å‹
export interface AbilityRecord {
  id?: number;
  name: string;
  description: string;
  rarity: RewardRarity;
  iconPath: string;
  obtainedAt: Date;
  isUnlocked: boolean;
  isActive: boolean;
  cooldownMinutes?: number;
  lastUsedAt?: Date;
}

/**
 * æ ¹æ®ä»»åŠ¡ç”Ÿæˆå¥–åŠ±
 * @param task å®Œæˆçš„ä»»åŠ¡
 * @returns ç”Ÿæˆçš„å¥–åŠ±
 */
export async function generateRewardsForTask(task: TaskRecord): Promise<RewardRecord[]> {
  const rewards: RewardRecord[] = [];
  const now = new Date();

  // åŸºç¡€ç»éªŒå€¼å¥–åŠ±ï¼ˆå·²åœ¨taskServiceä¸­å¤„ç†ï¼‰
  let experienceAmount = 10;

  // æ ¹æ®ä¼˜å…ˆçº§è°ƒæ•´ç»éªŒå€¼
  switch (task.priority) {
    case TaskPriority.HIGH:
      experienceAmount += 15;
      break;
    case TaskPriority.MEDIUM:
      experienceAmount += 10;
      break;
    case TaskPriority.LOW:
      experienceAmount += 5;
      break;
  }

  // æ ¹æ®ä»»åŠ¡ç±»å‹è°ƒæ•´ç»éªŒå€¼
  switch (task.type) {
    case TaskType.MAIN:
      experienceAmount += 20;
      break;
    case TaskType.DAILY:
      experienceAmount += 5;
      break;
    case TaskType.SIDE:
      experienceAmount += 10;
      break;
  }

  // æ·»åŠ ç»éªŒå€¼å¥–åŠ±
  rewards.push({
    type: RewardType.EXPERIENCE,
    rarity: RewardRarity.COMMON,
    amount: experienceAmount,
    name: 'ç»éªŒå€¼',
    description: 'å¢åŠ ç†ŠçŒ«çš„ç»éªŒå€¼',
    iconPath: '/assets/rewards/experience.svg',
    taskId: task.id,
    obtainedAt: now,
    isNew: true,
    isViewed: false
  });

  // æ·»åŠ é‡‘å¸å¥–åŠ±
  const coinAmount = calculateCoinReward(task);
  rewards.push({
    type: RewardType.COIN,
    rarity: RewardRarity.COMMON,
    amount: coinAmount,
    name: 'ç«¹å¸',
    description: 'å¯ç”¨äºè´­ä¹°ç‰©å“å’Œå‡çº§',
    iconPath: '/assets/rewards/coin.svg',
    taskId: task.id,
    obtainedAt: now,
    isNew: true,
    isViewed: false
  });

  // éšæœºç‰©å“å¥–åŠ±ï¼ˆæ¦‚ç‡æ€§ï¼‰
  if (shouldGetItemReward(task)) {
    const itemReward = generateRandomItemReward(task);
    rewards.push({
      ...itemReward,
      taskId: task.id,
      obtainedAt: now,
      isNew: true,
      isViewed: false
    });
  }

  // ä¿å­˜å¥–åŠ±è®°å½•
  await saveRewards(rewards);

  return rewards;
}

/**
 * è®¡ç®—é‡‘å¸å¥–åŠ±
 */
function calculateCoinReward(task: TaskRecord): number {
  let baseAmount = 5;

  // æ ¹æ®ä¼˜å…ˆçº§è°ƒæ•´é‡‘å¸æ•°é‡
  switch (task.priority) {
    case TaskPriority.HIGH:
      baseAmount += 15;
      break;
    case TaskPriority.MEDIUM:
      baseAmount += 10;
      break;
    case TaskPriority.LOW:
      baseAmount += 5;
      break;
  }

  // æ ¹æ®ä»»åŠ¡ç±»å‹è°ƒæ•´é‡‘å¸æ•°é‡
  switch (task.type) {
    case TaskType.MAIN:
      baseAmount += 20;
      break;
    case TaskType.DAILY:
      baseAmount += 5;
      break;
    case TaskType.SIDE:
      baseAmount += 10;
      break;
  }

  // æ·»åŠ éšæœºæ³¢åŠ¨ï¼ˆÂ±20%ï¼‰
  const randomFactor = 0.8 + Math.random() * 0.4; // 0.8 åˆ° 1.2 ä¹‹é—´
  return Math.round(baseAmount * randomFactor);
}

/**
 * åˆ¤æ–­æ˜¯å¦åº”è¯¥è·å¾—ç‰©å“å¥–åŠ±
 */
function shouldGetItemReward(task: TaskRecord): boolean {
  let chance = 0.1; // åŸºç¡€æ¦‚ç‡10%

  // æ ¹æ®ä¼˜å…ˆçº§è°ƒæ•´æ¦‚ç‡
  switch (task.priority) {
    case TaskPriority.HIGH:
      chance += 0.2;
      break;
    case TaskPriority.MEDIUM:
      chance += 0.1;
      break;
    case TaskPriority.LOW:
      chance += 0.05;
      break;
  }

  // æ ¹æ®ä»»åŠ¡ç±»å‹è°ƒæ•´æ¦‚ç‡
  switch (task.type) {
    case TaskType.MAIN:
      chance += 0.3;
      break;
    case TaskType.DAILY:
      chance += 0.05;
      break;
    case TaskType.SIDE:
      chance += 0.15;
      break;
  }

  return Math.random() < chance;
}

/**
 * ç”Ÿæˆéšæœºç‰©å“å¥–åŠ±
 */
function generateRandomItemReward(task: TaskRecord): RewardRecord {
  // éšæœºé€‰æ‹©ç‰©å“ç±»å‹
  const itemTypes = [
    { type: ItemType.FOOD, weight: 0.4 },
    { type: ItemType.TOY, weight: 0.3 },
    { type: ItemType.DECORATION, weight: 0.1 },
    { type: ItemType.SCROLL, weight: 0.1 },
    { type: ItemType.POTION, weight: 0.1 }
  ];

  // éšæœºé€‰æ‹©ç¨€æœ‰åº¦
  const rarityTypes = [
    { rarity: RewardRarity.COMMON, weight: 0.6 },
    { rarity: RewardRarity.UNCOMMON, weight: 0.25 },
    { rarity: RewardRarity.RARE, weight: 0.1 },
    { rarity: RewardRarity.EPIC, weight: 0.04 },
    { rarity: RewardRarity.LEGENDARY, weight: 0.01 }
  ];

  // æ ¹æ®æƒé‡éšæœºé€‰æ‹©ç‰©å“ç±»å‹
  const randomTypeObj = weightedRandom(itemTypes);
  const randomType = randomTypeObj.type;

  // æ ¹æ®æƒé‡éšæœºé€‰æ‹©ç¨€æœ‰åº¦
  const randomRarityObj = weightedRandom(rarityTypes);
  const randomRarity = randomRarityObj.rarity;

  // æ ¹æ®ç±»å‹å’Œç¨€æœ‰åº¦ç”Ÿæˆç‰©å“
  return generateItemByTypeAndRarity(randomType, randomRarity);
}

/**
 * æ ¹æ®æƒé‡éšæœºé€‰æ‹©
 */
function weightedRandom<T>(items: Array<T & { weight: number }>): T {
  const totalWeight = items.reduce((sum, item) => sum + item.weight, 0);
  let random = Math.random() * totalWeight;

  for (const item of items) {
    random -= item.weight;
    if (random <= 0) {
      return item;
    }
  }

  return items[0]; // é»˜è®¤è¿”å›ç¬¬ä¸€ä¸ª
}

/**
 * æ ¹æ®ç±»å‹å’Œç¨€æœ‰åº¦ç”Ÿæˆç‰©å“
 */
function generateItemByTypeAndRarity(itemType: ItemType, rarity: RewardRarity): RewardRecord {
  // è¿™é‡Œå¯ä»¥æ ¹æ®ç±»å‹å’Œç¨€æœ‰åº¦ä»é¢„å®šä¹‰çš„ç‰©å“åˆ—è¡¨ä¸­é€‰æ‹©
  // ç®€åŒ–ç‰ˆæœ¬ï¼Œç›´æ¥ç”Ÿæˆ
  const itemNames: Record<ItemType, string[]> = {
    [ItemType.FOOD]: ['ç«¹ç¬‹', 'ç«¹å¶', 'ç«¹èŠ½', 'ç«¹æœ', 'ç«¹ç³–'],
    [ItemType.TOY]: ['ç«¹çƒ', 'ç«¹ç¯', 'ç«¹å“‘é“ƒ', 'ç«¹æ‘‡é“ƒ', 'ç«¹é™€èº'],
    [ItemType.DECORATION]: ['ç«¹å¸½', 'ç«¹å›´å·¾', 'ç«¹çœ¼é•œ', 'ç«¹é¡¹é“¾', 'ç«¹æ‰‹é•¯'],
    [ItemType.SCROLL]: ['åˆçº§å·è½´', 'ä¸­çº§å·è½´', 'é«˜çº§å·è½´', 'å¤§å¸ˆå·è½´', 'å®—å¸ˆå·è½´'],
    [ItemType.POTION]: ['å°å‹è¯æ°´', 'ä¸­å‹è¯æ°´', 'å¤§å‹è¯æ°´', 'ç‰¹æ•ˆè¯æ°´', 'ç¥å¥‡è¯æ°´']
  };

  const rarityDescriptions: Record<RewardRarity, string> = {
    [RewardRarity.COMMON]: 'æ™®é€š',
    [RewardRarity.UNCOMMON]: 'ä¸å¸¸è§',
    [RewardRarity.RARE]: 'ç¨€æœ‰',
    [RewardRarity.EPIC]: 'å²è¯—',
    [RewardRarity.LEGENDARY]: 'ä¼ è¯´'
  };

  // éšæœºé€‰æ‹©ç‰©å“åç§°
  const names = itemNames[itemType];
  const name = names[Math.floor(Math.random() * names.length)];

  // ç”Ÿæˆç‰©å“æè¿°
  const description = `${rarityDescriptions[rarity]}çš„${name}`;

  // ç”Ÿæˆå›¾æ ‡è·¯å¾„
  const iconPath = `/assets/rewards/${itemType.toLowerCase()}_${rarity.toLowerCase()}.svg`;

  return {
    type: RewardType.ITEM,
    rarity,
    amount: 1,
    name,
    description,
    iconPath,
    obtainedAt: new Date(),
    isNew: true,
    isViewed: false
  };
}

/**
 * ä¿å­˜å¥–åŠ±è®°å½•
 */
async function saveRewards(rewards: RewardRecord[]): Promise<void> {
  await db.table('rewards').bulkAdd(rewards);
}

/**
 * è·å–æœªæŸ¥çœ‹çš„å¥–åŠ±
 */
export async function getUnviewedRewards(): Promise<RewardRecord[]> {
  return db.table('rewards')
    .filter(reward => reward.isViewed === false)
    .toArray();
}

/**
 * æ ‡è®°å¥–åŠ±ä¸ºå·²æŸ¥çœ‹
 */
export async function markRewardsAsViewed(rewardIds: number[]): Promise<void> {
  await Promise.all(
    rewardIds.map(id =>
      db.table('rewards')
        .update(id, { isViewed: true, isNew: false })
    )
  );
}

/**
 * è·å–ç©å®¶çš„é‡‘å¸æ•°é‡
 */
export async function getPlayerCoins(): Promise<number> {
  const coinRewards = await db.table('rewards')
    .where('type')
    .equals(RewardType.COIN)
    .toArray();

  return coinRewards.reduce((total, reward) => total + reward.amount, 0);
}

/**
 * æ·»åŠ ç‰©å“åˆ°ç”¨æˆ·åº“å­˜
 * @param item ç‰©å“æ•°æ®
 */
export async function addItem(item: Omit<ItemRecord, 'id'>): Promise<ItemRecord> {
  const id = await db.table('items').add(item);
  const newItem = { ...item, id: id as number };

  // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
  await addSyncItem('items', 'create', newItem);

  return newItem;
}

/**
 * ç”ŸæˆæŒ‡å®šæ•°é‡å’Œç¨€æœ‰åº¦çš„å¥–åŠ±
 * @param count å¥–åŠ±æ•°é‡
 * @param rarity å¥–åŠ±ç¨€æœ‰åº¦
 * @returns ç”Ÿæˆçš„å¥–åŠ±åˆ—è¡¨
 */
export async function generateRewards(count: number, rarity: RewardRarity): Promise<RewardRecord[]> {
  const rewards: RewardRecord[] = [];
  const now = new Date();

  for (let i = 0; i < count; i++) {
    // éšæœºé€‰æ‹©ç‰©å“ç±»å‹
    const itemTypes = [
      { type: ItemType.FOOD, weight: 0.4 },
      { type: ItemType.TOY, weight: 0.3 },
      { type: ItemType.DECORATION, weight: 0.1 },
      { type: ItemType.SCROLL, weight: 0.1 },
      { type: ItemType.POTION, weight: 0.1 }
    ];

    // æ ¹æ®æƒé‡éšæœºé€‰æ‹©ç‰©å“ç±»å‹
    const randomTypeObj = weightedRandom(itemTypes);
    const randomType = randomTypeObj.type;

    // ç”Ÿæˆç‰©å“
    const reward = generateItemByTypeAndRarity(randomType, rarity);

    rewards.push({
      ...reward,
      obtainedAt: now,
      isNew: true,
      isViewed: false
    });
  }

  // ä¿å­˜å¥–åŠ±è®°å½•
  await saveRewards(rewards);

  return rewards;
}

/**
 * ä¸ºæŒ‘æˆ˜ç”Ÿæˆå¥–åŠ±
 * @param challenge å®Œæˆçš„æŒ‘æˆ˜
 * @returns ç”Ÿæˆçš„å¥–åŠ±åˆ—è¡¨
 */
export async function generateRewardsForChallenge(challenge: any): Promise<RewardRecord[]> {
  // æ ¹æ®æŒ‘æˆ˜éš¾åº¦å†³å®šå¥–åŠ±ç¨€æœ‰åº¦
  let rarity = RewardRarity.COMMON;

  if (challenge.difficulty === 'hard') {
    rarity = RewardRarity.RARE;
  } else if (challenge.difficulty === 'medium') {
    rarity = RewardRarity.UNCOMMON;
  } else if (challenge.difficulty === 'expert') {
    rarity = RewardRarity.EPIC;
  }

  // ç”Ÿæˆ2-4ä¸ªå¥–åŠ±
  const count = 2 + Math.floor(Math.random() * 3);

  return generateRewards(count, rarity);
}
</file>

<file path="src/services/taskService.ts">
// src/services/taskService.ts
import { db } from '@/db';
import { addPandaExperience, updatePandaMood } from './pandaStateService';
import { generateRewardsForTask, RewardRecord } from './rewardService';
import { addSyncItem } from './dataSyncService';
import { checkTaskForTimelyReward, TimelyRewardRecord } from './timelyRewardService';

// ä»»åŠ¡çŠ¶æ€æšä¸¾
export enum TaskStatus {
  TODO = 'todo',
  IN_PROGRESS = 'in_progress',
  COMPLETED = 'completed',
  ARCHIVED = 'archived'
}

// ä»»åŠ¡ä¼˜å…ˆçº§æšä¸¾
export enum TaskPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high'
}

// ä»»åŠ¡ç±»å‹æšä¸¾
export enum TaskType {
  DAILY = 'daily',    // æ—¥å¸¸ä»»åŠ¡
  MAIN = 'main',      // ä¸»çº¿ä»»åŠ¡
  SIDE = 'side'       // æ”¯çº¿ä»»åŠ¡
}

// ä»»åŠ¡ç±»åˆ«æšä¸¾
export enum TaskCategory {
  WORK = 'work',
  PERSONAL = 'personal',
  HEALTH = 'health',
  LEARNING = 'learning',
  ERRANDS = 'errands'
}

// ä»»åŠ¡è®°å½•ç±»å‹
export interface TaskRecord {
  id?: number;
  title: string;
  description?: string;
  categoryId: number;
  type: TaskType;
  priority: TaskPriority;
  status: TaskStatus;
  dueDate?: Date;
  reminderTime?: Date;
  estimatedMinutes?: number;
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
  repeatPattern?: string; // ä¾‹å¦‚: "daily", "weekly:1,3,5", "monthly:15"
  tags?: string[];
}

// ä»»åŠ¡ç±»åˆ«è®°å½•ç±»å‹
export interface TaskCategoryRecord {
  id?: number;
  name: string;
  description?: string;
  color: string;
  icon?: string;
  isDefault: boolean;
  createdAt: Date;
}

// ä»»åŠ¡å®Œæˆè®°å½•ç±»å‹
export interface TaskCompletionRecord {
  id?: number;
  taskId: number;
  completedAt: Date;
  experienceGained: number;
  notes?: string;
}

// é»˜è®¤ä»»åŠ¡ç±»åˆ«
const DEFAULT_CATEGORIES: Omit<TaskCategoryRecord, 'id'>[] = [
  {
    name: 'Work',
    description: 'Work related tasks',
    color: '#4A6FA5',
    icon: 'briefcase',
    isDefault: true,
    createdAt: new Date()
  },
  {
    name: 'Personal',
    description: 'Personal tasks',
    color: '#6B8F71',
    icon: 'user',
    isDefault: true,
    createdAt: new Date()
  },
  {
    name: 'Health',
    description: 'Health and fitness tasks',
    color: '#D98580',
    icon: 'heart',
    isDefault: true,
    createdAt: new Date()
  },
  {
    name: 'Learning',
    description: 'Learning and education tasks',
    color: '#B4A7D6',
    icon: 'book',
    isDefault: true,
    createdAt: new Date()
  }
];

/**
 * åˆå§‹åŒ–ä»»åŠ¡ç±»åˆ«
 * å¦‚æœæ²¡æœ‰ä»»åŠ¡ç±»åˆ«ï¼Œåˆ™åˆ›å»ºé»˜è®¤ç±»åˆ«
 */
export async function initializeTaskCategories(): Promise<void> {
  const count = await db.taskCategories.count();
  if (count === 0) {
    console.log('Initializing default task categories...');
    await db.taskCategories.bulkAdd(DEFAULT_CATEGORIES);
  }
}

/**
 * è·å–æ‰€æœ‰ä»»åŠ¡ç±»åˆ«
 */
export async function getAllTaskCategories(): Promise<TaskCategoryRecord[]> {
  return db.taskCategories.toArray();
}

/**
 * åˆ›å»ºæ–°çš„ä»»åŠ¡ç±»åˆ«
 */
export async function createTaskCategory(category: Omit<TaskCategoryRecord, 'id' | 'createdAt'>): Promise<number> {
  const newCategory = {
    ...category,
    createdAt: new Date()
  };
  return db.taskCategories.add(newCategory);
}

/**
 * è·å–å•ä¸ªä»»åŠ¡
 * @param id ä»»åŠ¡ID
 */
export async function getTask(id: number): Promise<TaskRecord | undefined> {
  return db.tasks.get(id);
}

/**
 * è·å–æ‰€æœ‰ä»»åŠ¡
 * @param filter å¯é€‰çš„è¿‡æ»¤æ¡ä»¶
 */
export async function getAllTasks(filter?: {
  status?: TaskStatus;
  categoryId?: number;
  type?: TaskType;
  priority?: TaskPriority;
}): Promise<TaskRecord[]> {
  let query = db.tasks.toCollection();

  if (filter) {
    if (filter.status) {
      query = query.filter(task => task.status === filter.status);
    }
    if (filter.categoryId) {
      query = query.filter(task => task.categoryId === filter.categoryId);
    }
    if (filter.type) {
      query = query.filter(task => task.type === filter.type);
    }
    if (filter.priority) {
      query = query.filter(task => task.priority === filter.priority);
    }
  }

  return query.toArray();
}

/**
 * åˆ›å»ºæ–°ä»»åŠ¡
 */
export async function createTask(task: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'>): Promise<number> {
  const now = new Date();
  const newTask = {
    ...task,
    status: TaskStatus.TODO,
    createdAt: now,
    updatedAt: now
  };

  // æ·»åŠ ä»»åŠ¡åˆ°æ•°æ®åº“
  const id = await db.tasks.add(newTask);

  // æ·»åŠ åŒæ­¥é¡¹ç›®
  await addSyncItem('tasks', 'create', { ...newTask, id });

  return id;
}

/**
 * æ›´æ–°ä»»åŠ¡
 */
export async function updateTask(id: number, updates: Partial<Omit<TaskRecord, 'id' | 'createdAt'>>): Promise<void> {
  const task = await db.tasks.get(id);
  if (!task) {
    throw new Error(`Task with id ${id} not found`);
  }

  const updatedTask = {
    ...task,
    ...updates,
    updatedAt: new Date()
  };

  // æ›´æ–°æ•°æ®åº“
  await db.tasks.update(id, updatedTask);

  // æ·»åŠ åŒæ­¥é¡¹ç›®
  await addSyncItem('tasks', 'update', updatedTask);
}

/**
 * å®Œæˆä»»åŠ¡
 * æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºå·²å®Œæˆï¼Œåˆ›å»ºå®Œæˆè®°å½•ï¼Œç”Ÿæˆå¥–åŠ±ï¼Œå¹¶å¢åŠ ç†ŠçŒ«ç»éªŒå€¼
 * @returns ç”Ÿæˆçš„å¥–åŠ±åˆ—è¡¨å’ŒåŠæ—¶å¥–åŠ±ï¼ˆå¦‚æœæœ‰ï¼‰
 */
export async function completeTask(id: number, notes?: string): Promise<{
  rewards: RewardRecord[];
  timelyReward?: TimelyRewardRecord | null;
}> {
  const task = await db.tasks.get(id);
  if (!task) {
    throw new Error(`Task with id ${id} not found`);
  }

  const now = new Date();

  // è®¡ç®—è·å¾—çš„ç»éªŒå€¼ï¼ˆåŸºäºä»»åŠ¡ä¼˜å…ˆçº§å’Œç±»å‹ï¼‰
  let experienceGained = 10; // åŸºç¡€ç»éªŒå€¼

  // æ ¹æ®ä¼˜å…ˆçº§å¢åŠ ç»éªŒå€¼
  switch (task.priority) {
    case TaskPriority.HIGH:
      experienceGained += 15;
      break;
    case TaskPriority.MEDIUM:
      experienceGained += 10;
      break;
    case TaskPriority.LOW:
      experienceGained += 5;
      break;
  }

  // æ ¹æ®ä»»åŠ¡ç±»å‹å¢åŠ ç»éªŒå€¼
  switch (task.type) {
    case TaskType.MAIN:
      experienceGained += 20;
      break;
    case TaskType.DAILY:
      experienceGained += 5;
      break;
    case TaskType.SIDE:
      experienceGained += 10;
      break;
  }

  // æ›´æ–°ä»»åŠ¡çŠ¶æ€
  await updateTask(id, {
    status: TaskStatus.COMPLETED,
    completedAt: now
  });

  // åˆ›å»ºå®Œæˆè®°å½•
  await db.taskCompletions.add({
    taskId: id,
    completedAt: now,
    experienceGained,
    notes
  });

  // å¢åŠ ç†ŠçŒ«ç»éªŒå€¼
  await addPandaExperience(experienceGained);

  // æ›´æ–°ç†ŠçŒ«å¿ƒæƒ…ä¸ºå¼€å¿ƒ
  await updatePandaMood('happy');

  // ç”Ÿæˆä»»åŠ¡å¥–åŠ±
  const rewards = await generateRewardsForTask(task);

  // æ£€æŸ¥æ˜¯å¦ç¬¦åˆåŠæ—¶å¥–åŠ±æ¡ä»¶
  const timelyReward = await checkTaskForTimelyReward({
    ...task,
    status: TaskStatus.COMPLETED,
    completedAt: now
  });

  return {
    rewards,
    timelyReward
  };
}

/**
 * è·å–ä»»åŠ¡ç»Ÿè®¡ä¿¡æ¯
 */
export async function getTaskStats(): Promise<{
  total: number;
  completed: number;
  inProgress: number;
  todo: number;
  byCategory: Record<number, number>;
  byPriority: Record<TaskPriority, number>;
}> {
  const tasks = await db.tasks.toArray();

  const stats = {
    total: tasks.length,
    completed: tasks.filter(t => t.status === TaskStatus.COMPLETED).length,
    inProgress: tasks.filter(t => t.status === TaskStatus.IN_PROGRESS).length,
    todo: tasks.filter(t => t.status === TaskStatus.TODO).length,
    byCategory: {} as Record<number, number>,
    byPriority: {
      [TaskPriority.LOW]: 0,
      [TaskPriority.MEDIUM]: 0,
      [TaskPriority.HIGH]: 0
    }
  };

  // æŒ‰ç±»åˆ«ç»Ÿè®¡
  tasks.forEach(task => {
    if (!stats.byCategory[task.categoryId]) {
      stats.byCategory[task.categoryId] = 0;
    }
    stats.byCategory[task.categoryId]++;

    // æŒ‰ä¼˜å…ˆçº§ç»Ÿè®¡
    stats.byPriority[task.priority]++;
  });

  return stats;
}

/**
 * è·å–ä»»åŠ¡å®Œæˆå†å²
 */
export async function getTaskCompletionHistory(): Promise<TaskCompletionRecord[]> {
  return db.taskCompletions.toArray();
}

/**
 * è·å–ä»Šæ—¥å¾…åŠä»»åŠ¡
 */
export async function getTodayTasks(): Promise<TaskRecord[]> {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);

  return db.tasks
    .where('dueDate')
    .between(today, tomorrow, true, false)
    .and(task => task.status !== TaskStatus.COMPLETED && task.status !== TaskStatus.ARCHIVED)
    .toArray();
}

/**
 * è·å–é€¾æœŸä»»åŠ¡
 */
export async function getOverdueTasks(): Promise<TaskRecord[]> {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  return db.tasks
    .where('dueDate')
    .below(today)
    .and(task => task.status !== TaskStatus.COMPLETED && task.status !== TaskStatus.ARCHIVED)
    .toArray();
}

/**
 * åˆ é™¤ä»»åŠ¡
 */
export async function deleteTask(id: number): Promise<void> {
  const task = await db.tasks.get(id);
  if (!task) {
    throw new Error(`Task with id ${id} not found`);
  }

  // ä»æ•°æ®åº“ä¸­åˆ é™¤
  await db.tasks.delete(id);

  // æ·»åŠ åŒæ­¥é¡¹ç›®
  await addSyncItem('tasks', 'delete', task);
}

/**
 * å½’æ¡£ä»»åŠ¡
 */
export async function archiveTask(id: number): Promise<void> {
  await updateTask(id, { status: TaskStatus.ARCHIVED });
}
</file>

<file path="development-tasks-updated.md">
# PandaHabit å¼€å‘ä»»åŠ¡æ–‡æ¡£ï¼šåä¸½æ¸¸æˆé£æ ¼å®ç°

## 1. é¡¹ç›®è®¾ç½®

### 1.1 ç¯å¢ƒé…ç½®
- [x] è®¾ç½®å¼€å‘ç¯å¢ƒï¼ˆä½¿ç”¨Viteï¼‰
- [ ] è®¾ç½®æµ‹è¯•å’Œç”Ÿäº§ç¯å¢ƒ
- [ ] ä¸ºä¸åŒéƒ¨ç½²é˜¶æ®µé…ç½®ç¯å¢ƒå˜é‡
- [ ] è®¾ç½®CI/CDç®¡é“ï¼Œç”¨äºè‡ªåŠ¨æµ‹è¯•å’Œéƒ¨ç½²
- [x] é…ç½®ä»£ç æ£€æŸ¥å’Œæ ¼å¼åŒ–å·¥å…·ï¼ˆESLintå·²é…ç½®ï¼‰
- [x] è®¾ç½®åä¸½æ¸¸æˆé£æ ¼çš„è®¾è®¡ç³»ç»Ÿå’Œç»„ä»¶åº“ï¼ˆå·²å®ç°åŸºæœ¬ä¸»é¢˜å’Œç§»åŠ¨åº”ç”¨å¸ƒå±€ï¼‰

### 1.2 ä¾èµ–ç®¡ç†
- [x] å®‰è£…å’Œé…ç½®æ‰€éœ€ä¾èµ–ï¼š
  - [x] Reactå’ŒReact DOM
  - [x] TypeScript
  - [x] React Routerç”¨äºå¯¼èˆª
  - [x] Dexie.jsç”¨äºæœ¬åœ°æ•°æ®åº“
  - [x] React Queryç”¨äºæ•°æ®è·å–
  - [ ] åŠ¨ç”»åº“ï¼ˆFramer Motionæˆ–React Springï¼‰ç”¨äºåä¸½åŠ¨æ•ˆ
  - [ğŸ”„] ä¸­æ–‡å­—ä½“åº“ï¼ˆå·²æ·»åŠ Google Fontsï¼Œä½†éœ€è¦æ·»åŠ æ›´å¤šä¸­æ–‡å­—ä½“ï¼‰
  - [ ] ç²’å­æ•ˆæœåº“ï¼ˆç”¨äºåä¸½ç‰¹æ•ˆï¼‰
- [x] ä½¿ç”¨npmè®¾ç½®åŒ…ç®¡ç†
- [ ] ä¸ºç”Ÿäº§æ„å»ºé…ç½®ä¾èµ–ä¼˜åŒ–
- [ ] é›†æˆä¸­å›½é£ç´ æåº“å’Œå›¾æ ‡ç³»ç»Ÿ

### 1.3 é¡¹ç›®ç»“æ„ç»„ç»‡
- [x] æŒ‰ç…§ç°æœ‰æ¶æ„æ¨¡å¼ç»„ç»‡é¡¹ç›®
- [ ] ä¸ºæ¸¸æˆç‰¹å®šç»„ä»¶åˆ›å»ºä¸“ç”¨ç›®å½•
- [x] è®¾ç½®èµ„äº§ç®¡ç†ç»“æ„ï¼Œç”¨äºå›¾åƒã€åŠ¨ç”»å’Œå£°éŸ³ï¼ˆå·²åˆ›å»ºpublic/assetsç›®å½•å’ŒSVGèµ„æºï¼‰
- [x] å»ºç«‹æ ·å¼ç»„ç»‡ï¼ˆä½¿ç”¨CSSæ–‡ä»¶ï¼‰
- [x] é…ç½®TypeScriptè·¯å¾„ä»¥å®ç°æ¸…æ™°å¯¼å…¥ï¼ˆå·²é…ç½®@è·¯å¾„åˆ«åï¼‰
- [x] åˆ›å»ºåä¸½æ¸¸æˆé£æ ¼çš„ä¸»é¢˜æ–‡ä»¶å’Œå˜é‡ï¼ˆå·²å®Œå–„game-theme.cssï¼Œæ·»åŠ äº†ä¸­å›½é£å…ƒç´ ï¼‰

## 2. æ ¸å¿ƒåŸºç¡€è®¾æ–½å¼€å‘

### 2.1 æ•°æ®åº“æ¶æ„å®ç°
- [âœ…] æ‰©å±•ç°æœ‰Dexie.jsæ¶æ„ï¼ŒåŒ…æ‹¬ï¼š
  - [x] åŸºæœ¬UIæ ‡ç­¾æ•°æ®ï¼ˆå·²å®ç°UILabelRecordï¼‰
  - [x] ç”¨æˆ·é…ç½®æ–‡ä»¶å’Œè¿›åº¦æ•°æ®ï¼ˆå·²å®ç°PandaStateRecordï¼‰
  - [x] ç†ŠçŒ«çŠ¶æ€å’Œå®šåˆ¶æ•°æ®ï¼ˆå·²å®ç°PandaStateRecordå’ŒPandaAbilityRecordï¼‰
  - [x] ä»»åŠ¡å’ŒæŒ‘æˆ˜æ•°æ®ï¼ˆå·²å®ç°TaskRecordå’ŒTaskCompletionRecordï¼‰
  - [x] èµ„æºå’Œåº“å­˜æ•°æ®ï¼ˆå·²å®ç°RewardRecordå’ŒItemRecordï¼‰
  - [x] æˆå°±å’Œé‡Œç¨‹ç¢‘æ•°æ®ï¼ˆå·²å®ç°BadgeRecordï¼‰
- [x] å®ç°åŸºæœ¬æ•°æ®å¡«å……ç­–ç•¥ï¼ˆå·²å®ç°populateDBå‡½æ•°ï¼‰
- [x] å®ç°æ•°æ®è¿ç§»ç­–ç•¥ä»¥è¿›è¡Œæ›´æ–°ï¼ˆå·²å®ç°æ•°æ®åº“ç‰ˆæœ¬å‡çº§ï¼‰
- [x] åˆ›å»ºæ•°æ®éªŒè¯å®ç”¨ç¨‹åºï¼ˆå·²å®ç°å„ç§æœåŠ¡ä¸­çš„éªŒè¯é€»è¾‘ï¼‰
- [x] è®¾ç½®æ•°æ®å¤‡ä»½å’ŒåŒæ­¥æœºåˆ¶ï¼ˆå·²å®ç°dataSyncServiceï¼‰

### 2.2 APIç«¯ç‚¹å®ç°
- [âœ…] å®ç°æ¨¡æ‹ŸAPIæœåŠ¡ï¼š
  - [x] åˆ›å»ºåŸºæœ¬æœåŠ¡å±‚ç»“æ„ï¼ˆå·²å®ç°localizedContentServiceï¼‰
  - [ğŸ”„] ç”¨æˆ·è®¤è¯å’Œé…ç½®æ–‡ä»¶ç®¡ç†
  - [x] ç†ŠçŒ«çŠ¶æ€å’Œäº’åŠ¨ï¼ˆå·²å®ç°pandaStateServiceï¼‰
  - [x] ä»»åŠ¡ç®¡ç†å’Œå®Œæˆï¼ˆå·²å®ç°taskServiceï¼‰
  - [x] æŒ‘æˆ˜è·Ÿè¸ªå’Œå¥–åŠ±ï¼ˆå·²å®ç°rewardServiceï¼‰
  - [x] åŠæ—¶å¥–åŠ±å’Œå¹¸è¿æŠ½å¥–ï¼ˆå·²å®ç°rewardServiceä¸­çš„éšæœºå¥–åŠ±ç”Ÿæˆï¼‰
  - [x] ç†ŠçŒ«èƒ½åŠ›ç³»ç»Ÿï¼ˆå·²å®ç°pandaAbilityServiceï¼‰
- [x] åˆ›å»ºå…·æœ‰åŸºæœ¬é”™è¯¯å¤„ç†çš„APIæœåŠ¡å±‚
- [x] å®ç°åŸºæœ¬è¯·æ±‚ç¼“å­˜ï¼ˆé€šè¿‡React Queryï¼‰
- [x] ä¸ºå¼€å‘å’Œæµ‹è¯•è®¾ç½®æ¨¡æ‹ŸAPIï¼ˆä½¿ç”¨Dexie.jsï¼‰
- [x] å®ç°æ•°æ®åŒæ­¥æœºåˆ¶ï¼ˆå·²å®ç°dataSyncServiceï¼‰

### 2.3 è®¤è¯ç³»ç»Ÿ
- [ ] å®ç°ç”¨æˆ·æ³¨å†Œå’Œç™»å½•æµç¨‹
- [ ] è®¾ç½®å®‰å…¨çš„åŸºäºä»¤ç‰Œçš„è®¤è¯
- [ ] åˆ›å»ºè´¦æˆ·ç®¡ç†åŠŸèƒ½
- [ ] å®ç°ç¤¾äº¤ç™»å½•é€‰é¡¹ï¼ˆå¦‚éœ€è¦ï¼‰
- [ ] è®¾ç½®å¯†ç æ¢å¤æœºåˆ¶
- [ ] é…ç½®éšç§å’Œæ•°æ®ä¿æŠ¤åŠŸèƒ½

### 2.4 å›½é™…åŒ–ç³»ç»Ÿ
- [x] å®ç°åŸºæœ¬i18nç³»ç»Ÿï¼ˆå·²å®ç°LanguageProviderï¼‰
- [ğŸ”„] æ‰©å±•ç°æœ‰i18nç³»ç»Ÿä»¥æ”¯æŒæ¸¸æˆç‰¹å®šå†…å®¹
- [x] ä¸ºåŸºæœ¬æ”¯æŒçš„è¯­è¨€åˆ›å»ºç¿»è¯‘æ–‡ä»¶ï¼ˆè‹±æ–‡å’Œä¸­æ–‡ï¼‰
- [x] å®ç°åŸºäºè¯­è¨€é€‰æ‹©çš„åŠ¨æ€å†…å®¹åŠ è½½ï¼ˆé€šè¿‡useLocalizedViewé’©å­ï¼‰
- [ ] è®¾ç½®æ›´å®Œå–„çš„ç¿»è¯‘ç®¡ç†å·¥ä½œæµç¨‹
- [ ] ç¡®ä¿æ­£ç¡®å¤„ç†RTLè¯­è¨€ï¼ˆå¦‚æ”¯æŒï¼‰
- [ ] ä¸ºæ—¥æœŸã€æ•°å­—å’Œè´§å¸å®ç°ç‰¹å®šäºè¯­è¨€çš„æ ¼å¼åŒ–
- [ ] ç¡®ä¿åä¸½æ¸¸æˆé£æ ¼å…ƒç´ åœ¨æ‰€æœ‰è¯­è¨€ä¸­ä¿æŒä¸€è‡´

## 3. UIç»„ä»¶å¼€å‘

### 3.1 é€šç”¨ç»„ä»¶
- [x] è®¾è®¡å¹¶å®ç°åä¸½ç‰ˆæœ¬çš„ï¼š
  - [x] æŒ‰é’®ï¼ˆå·²å®ç°åŸºæœ¬æŒ‰é’®å’Œæ¸¸æˆé£æ ¼çš„jade-buttonã€gold-buttonï¼‰
  - [ ] è¾“å…¥å­—æ®µå’Œè¡¨å•å…ƒç´ ï¼Œæ·»åŠ æ°´å¢¨åŠ¨æ•ˆå’Œä¼ ç»Ÿçº¹é¥°
  - [x] å¡ç‰‡å’Œå®¹å™¨ï¼ˆå·²å®ç°bamboo-frameæ ·å¼ï¼‰
  - [x] æ¨¡æ€æ¡†å’Œå¯¹è¯æ¡†ç»„ä»¶ï¼Œè®¾è®¡ä¸ºå¤ä»£å·è½´æˆ–çª—æ£‚æ ·å¼
  - [x] åŠ è½½å™¨å’Œè¿›åº¦æŒ‡ç¤ºå™¨ï¼ˆå·²å®ç°jade-spinnerå’Œbamboo-progressï¼‰
  - [ ] å·¥å…·æç¤ºå’Œå¼¹å‡ºæ¡†ï¼Œæ·»åŠ äº‘çº¹è£…é¥°å’Œä¼˜é›…è¿‡æ¸¡
- [ ] åˆ›å»ºå…¨é¢çš„ç»„ä»¶åº“ï¼Œå¹¶é™„å¸¦æ–‡æ¡£
- [x] ä¸ºæ‰€æœ‰ç»„ä»¶å®ç°å“åº”å¼è¡Œä¸ºï¼ˆå·²é’ˆå¯¹ç§»åŠ¨è®¾å¤‡ä¼˜åŒ–ï¼‰
- [x] æ·»åŠ åŠ¨ç”»å’Œè¿‡æ¸¡æ•ˆæœï¼ˆå·²ä½¿ç”¨Framer Motionå®ç°ï¼‰
- [x] å®ç°ä¸­å›½é£ç‰¹æ•ˆç³»ç»Ÿï¼ˆå·²å®ç°æ°´å¢¨ã€é‡‘å…‰ã€ç«¹å¶ç­‰ç‰¹æ•ˆï¼‰

### 3.2 å¸ƒå±€ç»„ä»¶
- [x] å®ç°åŸºæœ¬AppShellç»„ä»¶
- [x] ä½¿ç”¨åä¸½é£æ ¼å¢å¼ºAppShellï¼ˆå·²æ·»åŠ ä¸­å›½é£è£…é¥°å…ƒç´ ï¼‰
- [x] åˆ›å»ºåŸºæœ¬Headerç»„ä»¶
- [x] å¢å¼ºHeaderç»„ä»¶ï¼ˆå·²é’ˆå¯¹ç§»åŠ¨åº”ç”¨ä¼˜åŒ–ï¼Œç§»é™¤äº†é¡¶éƒ¨æ ‡é¢˜ï¼‰
- [x] è®¾è®¡Navigationç»„ä»¶ï¼ˆå·²å®ç°ç§»åŠ¨åº”ç”¨é£æ ¼çš„åº•éƒ¨å¯¼èˆªæ ï¼‰
- [x] å¼€å‘åŸºæœ¬é¡µé¢å¸ƒå±€æ¨¡æ¿
- [x] å®ç°é’ˆå¯¹ä¸åŒå±å¹•å°ºå¯¸çš„å“åº”å¼å¸ƒå±€è°ƒæ•´ï¼ˆå·²é’ˆå¯¹ç§»åŠ¨è®¾å¤‡ä¼˜åŒ–ï¼‰
- [x] åˆ›å»ºå¸ƒå±€çŠ¶æ€ä¹‹é—´çš„è¿‡æ¸¡æ•ˆæœï¼ˆå·²ä½¿ç”¨Framer Motionå®ç°é¡µé¢è¿‡æ¸¡ï¼‰
- [x] æ·»åŠ ä¸­å›½é£èƒŒæ™¯å’Œè£…é¥°å…ƒç´ ï¼ˆå·²æ·»åŠ ä¸­å›½é£è¾¹æ¡†å’Œè£…é¥°ï¼‰

### 3.3 ç‰¹å®šåŠŸèƒ½ç»„ä»¶
- [x] å¼€å‘PandaAvatarç»„ä»¶ï¼Œå…·æœ‰ä¸åŒçŠ¶æ€å’ŒåŠ¨ç”»ï¼ˆå·²å®ç°åŸºæœ¬ç†ŠçŒ«å¤´åƒç»„ä»¶ï¼‰
- [x] åˆ›å»ºTaskCardç»„ä»¶ï¼ˆå·²å®ç°å¸¦åŠ¨ç”»æ•ˆæœçš„ä»»åŠ¡å¡ç‰‡ï¼‰
- [âœ…] å®ç°ChallengeCardç»„ä»¶ï¼Œå…·æœ‰è¿›åº¦è·Ÿè¸ªï¼ˆå·²å®ç°æŒ‘æˆ˜å¡ç‰‡å’Œåˆ—è¡¨ç»„ä»¶ï¼‰
- [ ] è®¾è®¡å„ç§èµ„æºç±»å‹çš„ResourceDisplayç»„ä»¶
- [ ] å¼€å‘ä¸åŒå¥–åŠ±åœºæ™¯çš„RewardAnimationç»„ä»¶
- [ ] åˆ›å»ºå…·æœ‰å¼•äººå…¥èƒœåŠ¨ç”»çš„LuckyDrawç»„ä»¶
- [ ] å®ç°å…·æœ‰æ”¯æŒæ€§UIçš„ReflectionModuleç»„ä»¶
- [x] ä¸ºæ‰€æœ‰ç»„ä»¶æ·»åŠ åä¸½çš„ä¸­å›½é£è§†è§‰å…ƒç´ å’ŒåŠ¨æ•ˆï¼ˆå·²æ·»åŠ æ°´å¢¨ã€é‡‘å…‰ç­‰ç‰¹æ•ˆï¼‰

## 4. åŠŸèƒ½å®ç°

### 4.1 ç†ŠçŒ«ä¼™ä¼´ç³»ç»Ÿ
- [x] å®ç°ç†ŠçŒ«çŠ¶æ€ç®¡ç†ï¼ˆæƒ…ç»ªã€æˆé•¿ã€èƒ½é‡ï¼‰ï¼ˆå·²å®ç°PandaStateProviderï¼‰
- [x] åˆ›å»ºç†ŠçŒ«äº’åŠ¨æœºåˆ¶ï¼ˆå–‚é£Ÿã€ç©è€ã€è®­ç»ƒï¼‰ï¼ˆå·²å®ç°åŸºæœ¬äº’åŠ¨åŠŸèƒ½ï¼‰
- [x] å¼€å‘ç†ŠçŒ«å®šåˆ¶ç³»ç»Ÿï¼ŒåŒ…æ‹¬ä¼ ç»Ÿä¸­å›½é£è£…é¥°å…ƒç´ ï¼ˆå·²å®ç°PandaCustomizationPanelç»„ä»¶å’Œè£…é¥°ç³»ç»Ÿï¼‰
- [x] å®ç°ç†ŠçŒ«æˆé•¿å’Œè¿›åŒ–é€»è¾‘ï¼ˆå·²å®ç°åŸºæœ¬ç»éªŒå’Œç­‰çº§ç³»ç»Ÿï¼‰
- [x] åˆ›å»ºç†ŠçŒ«èƒ½åŠ›è§£é”ç³»ç»Ÿï¼ˆå·²å®ç°èƒ½åŠ›è§£é”å’Œæ¿€æ´»åŠŸèƒ½ï¼‰
- [x] å¼€å‘ç†ŠçŒ«åŠ¨ç”»æ§åˆ¶å™¨ï¼Œç”¨äºä¸åŒçŠ¶æ€å’ŒåŠ¨ä½œï¼ˆå·²å®ç°åŸºæœ¬çŠ¶æ€åŠ¨ç”»ï¼‰
- [x] å®ç°ç¯å¢ƒå®šåˆ¶å’Œäº’åŠ¨ï¼Œèå…¥ä¸­å›½å›­æ—å…ƒç´ ï¼ˆå·²å®ç°PandaEnvironmentPanelç»„ä»¶å’Œç¯å¢ƒç³»ç»Ÿï¼‰

### 4.2 ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ
- [x] å®ç°ä»»åŠ¡åˆ›å»ºå’Œç¼–è¾‘åŠŸèƒ½ï¼ˆå·²å®ç°TaskFormç»„ä»¶ï¼‰
- [x] åˆ›å»ºä»»åŠ¡åˆ†ç±»ï¼ˆæ—¥å¸¸ã€ä¸»çº¿ã€æ”¯çº¿ï¼‰ï¼ˆå·²å®ç°TaskTypeæšä¸¾å’Œç±»åˆ«ç³»ç»Ÿï¼‰
- [x] å¼€å‘ä»»åŠ¡è°ƒåº¦å’Œé‡å¤é€»è¾‘ï¼ˆå·²å®ç°åŸºæœ¬ä»»åŠ¡ç®¡ç†ï¼‰
- [x] å®ç°ä»»åŠ¡å®Œæˆå’ŒéªŒè¯ï¼ˆå·²å®ç°completeTaskåŠŸèƒ½ï¼‰
- [âœ…] åˆ›å»ºä»»åŠ¡æé†’ç³»ç»Ÿï¼Œä½¿ç”¨ç†ŠçŒ«ä¿¡ä½¿ä¸»é¢˜ï¼ˆå·²å®ç°TaskReminderServiceå’Œç›¸å…³ç»„ä»¶ï¼‰
- [âœ…] å¼€å‘å¤æ‚ç›®æ ‡çš„ä»»åŠ¡åˆ†è§£ï¼ˆå·²å®ç°SubtaskServiceå’Œå­ä»»åŠ¡ç®¡ç†ï¼‰
- [x] å®ç°ä»»åŠ¡è¿‡æ»¤å’Œæ’åºï¼ˆå·²å®ç°åŸºæœ¬è¿‡æ»¤åŠŸèƒ½ï¼‰
- [x] æ·»åŠ åä¸½çš„ä»»åŠ¡å®ŒæˆåŠ¨ç”»å’Œç‰¹æ•ˆï¼ˆå·²å®ç°ä»»åŠ¡å®Œæˆå¥–åŠ±ç³»ç»Ÿï¼‰

### 4.3 æŒ‘æˆ˜ç³»ç»Ÿ
- [âœ…] åˆ›å»ºæŒ‘æˆ˜å®šä¹‰å’Œç®¡ç†ï¼ˆå·²å®ç°æŒ‘æˆ˜æ•°æ®æ¨¡å‹å’ŒæœåŠ¡ï¼‰
- [âœ…] å®ç°æŒ‘æˆ˜ç±»å‹ï¼ˆæ—¥å¸¸ã€æ¯å‘¨ã€æ´»åŠ¨ã€æŒç»­ï¼‰ï¼ˆå·²å®ç°ChallengeTypeæšä¸¾ï¼‰
- [âœ…] å¼€å‘æŒ‘æˆ˜ç”Ÿå‘½å‘¨æœŸå’Œè¿›åº¦è·Ÿè¸ªï¼ˆå·²å®ç°æŒ‘æˆ˜çŠ¶æ€å’Œè¿›åº¦ç®¡ç†ï¼‰
- [âœ…] åˆ›å»ºä¸æ—¥å¸¸ä»»åŠ¡çš„å­ä»»åŠ¡é›†æˆï¼ˆå·²å®ç°SubtaskListç»„ä»¶å’ŒTaskDetailDialogï¼‰
- [âœ…] å®ç°æŒ‘æˆ˜å¥–åŠ±å’Œå®Œæˆé€»è¾‘ï¼ˆå·²å®ç°completeChallengeåŠŸèƒ½ï¼‰
- [âœ…] å¼€å‘æŒ‘æˆ˜å‘ç°å’Œæ¨èç³»ç»Ÿï¼ˆå·²å®ç°ChallengeDiscoveryServiceå’Œç›¸å…³ç»„ä»¶ï¼‰
- [âœ…] åˆ›å»ºåˆä½œç¤¾äº¤æŒ‘æˆ˜ï¼ˆå·²å®ç°SocialChallengeServiceå’Œç›¸å…³ç»„ä»¶ï¼‰
- [âœ…] è®¾è®¡åä¸½çš„æŒ‘æˆ˜åœ°å›¾å’Œè¿›åº¦å¯è§†åŒ–ï¼ˆå·²å®ç°æŒ‘æˆ˜å¡ç‰‡å’Œè¿‡æ»¤ç•Œé¢ï¼‰

### 4.4 åŠæ—¶å¥–åŠ±ç³»ç»Ÿ
- [âœ…] å®ç°ç¬¦åˆæ¡ä»¶ä»»åŠ¡çš„æ—¶é—´çª—å£è·Ÿè¸ªï¼ˆå·²å®ç°timelyRewardServiceï¼‰
- [âœ…] åˆ›å»ºåŠæ—¶æ€§è¿›åº¦æ¡ç³»ç»Ÿï¼Œè®¾è®¡ä¸ºåä¸½å·è½´ï¼ˆå·²å®ç°TimelyRewardCardç»„ä»¶ï¼‰
- [âœ…] å¼€å‘å¹¸è¿ç‚¹ç´¯ç§¯å’Œç®¡ç†ï¼ˆå·²å®ç°LuckyPointsDisplayç»„ä»¶ï¼‰
- [âœ…] å®ç°å¸¦æœ‰å¥–å“å±‚çº§çš„å¹¸è¿æŠ½å¥–æœºåˆ¶ï¼ˆå·²å®ç°LuckyDrawç»„ä»¶ï¼‰
- [âœ…] åˆ›å»ºå¥–åŠ±åˆ†é…å’Œåº“å­˜ç®¡ç†ï¼ˆå·²å®ç°å¥–åŠ±ç”Ÿæˆå’Œåˆ†å‘é€»è¾‘ï¼‰
- [âœ…] å¼€å‘åŠæ—¶å®Œæˆçš„è§†è§‰åé¦ˆï¼ˆå·²å®ç°åŠæ—¶å¥–åŠ±æ¨¡æ€æ¡†ï¼‰
- [âœ…] å®ç°"æ—©èµ·é¸Ÿ"å¥–åŠ±æœºåˆ¶ï¼ˆå·²å®ç°æ—©èµ·é¸Ÿå¥–åŠ±ç±»å‹ï¼‰
- [âœ…] æ·»åŠ åä¸½çš„æŠ½å¥–åŠ¨ç”»å’Œå¥–åŠ±å±•ç¤ºæ•ˆæœï¼ˆå·²å®ç°æŠ½å¥–åŠ¨ç”»å’Œç‰¹æ•ˆï¼‰

### 4.5 åæ€æ¨¡å—
- [âœ…] åˆ›å»ºåæ€æœºä¼šçš„è§¦å‘æ£€æµ‹ï¼ˆå·²å®ç°ReflectionTriggerTypeå’Œè§¦å‘æ£€æµ‹æœºåˆ¶ï¼‰
- [âœ…] å®ç°æ¸©å’Œã€éåˆ¤æ–­æ€§çš„å¯¹è¯ç³»ç»Ÿï¼ˆå·²å®ç°EnhancedReflectionModuleç»„ä»¶ï¼‰
- [âœ…] å¼€å‘ç”¨æˆ·è¾“å…¥æ”¶é›†å’Œå¤„ç†ï¼ˆå·²å®ç°åæ€è¾“å…¥å’Œæ ‡ç­¾ç³»ç»Ÿï¼‰
- [âœ…] åˆ›å»ºæ”¯æŒæ€§åé¦ˆç”Ÿæˆï¼ˆå·²å®ç°åŸºäºåæ€å†…å®¹çš„æ”¯æŒæ€§åé¦ˆï¼‰
- [âœ…] å®ç°å¯è¡Œå»ºè®®ç³»ç»Ÿï¼ˆå·²å®ç°åŸºäºåæ€å†…å®¹å’Œæ ‡ç­¾çš„å»ºè®®è¡ŒåŠ¨ï¼‰
- [âœ…] å¼€å‘æƒ…ç»ªè·Ÿè¸ªå’Œæ¨¡å¼è¯†åˆ«ï¼ˆå·²å®ç°MoodTrackerç»„ä»¶å’Œæƒ…ç»ªè®°å½•ï¼‰
- [âœ…] åˆ›å»ºè‡ªæˆ‘åŒæƒ…å¼ºåŒ–æœºåˆ¶ï¼ˆå·²å®ç°æ¸©å’Œè¯­è¨€å’Œæ”¯æŒæ€§åé¦ˆï¼‰
- [âœ…] è®¾è®¡é™å¿ƒèŒ¶å®¤ç¯å¢ƒå’Œç›¸å…³è§†è§‰æ•ˆæœï¼ˆå·²å®ç°TeaRoomPageé¡µé¢ï¼‰

### 4.6 å•†åº—å’Œè´§å¸åŒ–
- [âœ…] å®ç°å¸¦æœ‰ç‰©å“ç±»åˆ«çš„å•†åº—ç•Œé¢ï¼ˆå·²å®ç°StorePageå’ŒStoreCategoryListç»„ä»¶ï¼‰
- [âœ…] åˆ›å»ºç‰©å“é¢„è§ˆå’Œè´­ä¹°æµç¨‹ï¼ˆå·²å®ç°StoreItemCardå’ŒStoreItemPreviewç»„ä»¶ï¼‰
- [âœ…] å¼€å‘VIPè®¢é˜…ç®¡ç†ï¼ˆå·²å®ç°VipSubscriptionCardç»„ä»¶å’Œç›¸å…³æœåŠ¡ï¼‰
- [âœ…] å®ç°åº”ç”¨å†…è´­ä¹°é›†æˆï¼ˆå·²å®ç°åŸºæœ¬è´­ä¹°æµç¨‹ï¼‰
- [âœ…] åˆ›å»ºVIPç¦åˆ©æ¿€æ´»å’Œè·Ÿè¸ªï¼ˆå·²å®ç°VIPè®¢é˜…å’Œç¦åˆ©ç³»ç»Ÿï¼‰
- [âœ…] å¼€å‘ä¿ƒé”€åŠŸèƒ½ï¼ˆå·²å®ç°é”€å”®å’Œé™æ—¶ç‰©å“åŠŸèƒ½ï¼‰
- [âœ…] å®ç°æ”¶æ®éªŒè¯å’Œè´­ä¹°æ¢å¤ï¼ˆå·²å®ç°åŸºæœ¬è´­ä¹°è®°å½•ç³»ç»Ÿï¼‰
- [âœ…] è®¾è®¡åä¸½çš„å•†åº—ç¯å¢ƒå’Œè´­ä¹°åŠ¨ç”»ï¼ˆå·²å®ç°åŠ¨ç”»æ•ˆæœå’Œè§†è§‰è®¾è®¡ï¼‰

### 4.7 å›¾ç‰‡ç´ æ
ç”Ÿæˆcsvç®¡ç†æ‰€æœ‰é¡µé¢çš„spirateã€iconã€å›¾ç‰‡ã€æ¨¡å‹ç­‰ç´ æï¼ŒåŒ…å«é¡µé¢åç§°ã€ç´ ææ–‡ä»¶åç§°ï¼Œè·¯å¾„ï¼Œå¤§å°ï¼Œç”Ÿæˆç´ æå›¾ç‰‡/iconç­‰çš„æç¤ºè¯ã€‚

## 5. é›†æˆå’Œæµ‹è¯•

### 5.1 ç»„ä»¶é›†æˆ
- [âœ…] å°†UIç»„ä»¶ä¸æ•°æ®æœåŠ¡é›†æˆï¼ˆå·²å®ç°DataLoaderç»„ä»¶å’Œæ•°æ®åŒæ­¥æœåŠ¡ï¼‰
- [âœ…] è¿æ¥åŠŸèƒ½ç³»ç»Ÿä»¥åˆ›å»ºè¿è´¯çš„æ¸¸æˆå¾ªç¯ï¼ˆå·²è¿æ¥ä»»åŠ¡ç³»ç»Ÿã€å¥–åŠ±ç³»ç»Ÿå’Œç†ŠçŒ«ä¼™ä¼´ç³»ç»Ÿï¼‰
- [âœ…] å®ç°åŠŸèƒ½ä¹‹é—´çš„çŠ¶æ€åŒæ­¥ï¼ˆå·²å®ç°dataSyncServiceå’ŒçŠ¶æ€åŒæ­¥æœºåˆ¶ï¼‰
- [âœ…] å®ç°æ•°æ®åŒæ­¥åçš„å±€éƒ¨UIæ›´æ–°ï¼ˆå·²å®ç°useDataRefresh Hookå’Œäº‹ä»¶é©±åŠ¨çš„UIæ›´æ–°ï¼‰
- [x] åˆ›å»ºä¸åŒåº”ç”¨éƒ¨åˆ†ä¹‹é—´çš„æµç•…è¿‡æ¸¡ï¼ˆå·²ä½¿ç”¨Framer Motionå®ç°é¡µé¢è¿‡æ¸¡ï¼‰
- [âœ…] å¼€å‘é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶ï¼ˆå·²å®ç°é”™è¯¯å¤„ç†å’ŒåŒæ­¥æ¢å¤æœºåˆ¶ï¼‰
- [x] å®ç°åŠ è½½çŠ¶æ€å’Œå ä½ç¬¦ï¼ˆå·²å®ç°LoadingSpinnerç»„ä»¶ï¼‰
- [x] ç¡®ä¿åä¸½è§†è§‰é£æ ¼åœ¨æ‰€æœ‰é›†æˆç‚¹ä¿æŒä¸€è‡´ï¼ˆå·²å®ç°ç»Ÿä¸€çš„æ¸¸æˆé£æ ¼ï¼‰

### 5.2 ç«¯åˆ°ç«¯æµ‹è¯•
- [ ] ä¸ºå…³é”®ç”¨æˆ·æ—…ç¨‹åˆ›å»ºå…¨é¢çš„æµ‹è¯•å¥—ä»¶
- [ ] å®ç°æ ¸å¿ƒåŠŸèƒ½çš„è‡ªåŠ¨åŒ–æµ‹è¯•
- [ ] å¼€å‘UIç»„ä»¶çš„è§†è§‰å›å½’æµ‹è¯•
- [ ] åˆ›å»ºæ€§èƒ½åŸºå‡†å’Œæµ‹è¯•
- [ ] å®ç°è·¨æµè§ˆå™¨å’Œè·¨è®¾å¤‡æµ‹è¯•
- [ ] å¼€å‘å¯è®¿é—®æ€§æµ‹è¯•ç¨‹åº
- [ ] æµ‹è¯•åä¸½åŠ¨ç”»å’Œç‰¹æ•ˆçš„æ€§èƒ½å½±å“

### 5.3 æ€§èƒ½ä¼˜åŒ–
- [x] å®ç°ä»£ç åˆ†å‰²å’Œå»¶è¿ŸåŠ è½½ï¼ˆå·²é€šè¿‡React.lazyå®ç°ï¼‰
- [âœ…] ä¼˜åŒ–èµ„äº§åŠ è½½å’Œç¼“å­˜ï¼ˆå·²ä¼˜åŒ–SVGèµ„æºå’Œå®ç°æ•°æ®ç¼“å­˜ï¼‰
- [x] å®ç°é«˜æ•ˆæ¸²æŸ“ç­–ç•¥ï¼ˆå·²ä½¿ç”¨Framer Motionçš„æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§ï¼‰
- [ ] åˆ›å»ºæ€§èƒ½ç›‘æ§å·¥å…·
- [âœ…] ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢å’Œæ•°æ®ç®¡ç†ï¼ˆå·²å®ç°é«˜æ•ˆçš„æ•°æ®åº“æŸ¥è¯¢å’ŒåŒæ­¥æœºåˆ¶ï¼‰
- [âœ…] å®ç°å†…å­˜ç®¡ç†æœ€ä½³å®è·µï¼ˆå·²å®ç°æ•°æ®ç¼“å­˜å’Œå†…å­˜ç®¡ç†ï¼‰
- [x] ä¼˜åŒ–åä¸½è§†è§‰æ•ˆæœå’ŒåŠ¨ç”»çš„æ€§èƒ½ï¼ˆå·²ä½¿ç”¨Framer Motionçš„æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§ï¼‰

### 5.4 ç”¨æˆ·éªŒæ”¶æµ‹è¯•
- [ ] åˆ›å»ºbetaæµ‹è¯•è®¡åˆ’
- [ ] å¼€å‘åé¦ˆæ”¶é›†æœºåˆ¶
- [ ] å®ç°ç”¨æˆ·è¡Œä¸ºè·Ÿè¸ªåˆ†æ
- [ ] åˆ›å»ºåŠŸèƒ½ä¼˜åŒ–çš„A/Bæµ‹è¯•æ¡†æ¶
- [ ] å¼€å‘ç”¨æˆ·æ»¡æ„åº¦æµ‹é‡
- [ ] å®ç°åŸºäºåé¦ˆçš„è¿­ä»£æ”¹è¿›è¿‡ç¨‹
- [ ] æ”¶é›†åä¸½æ¸¸æˆé£æ ¼çš„ç”¨æˆ·ä½“éªŒåé¦ˆ

## 6. éƒ¨ç½²å’Œç»´æŠ¤

### 6.1 éƒ¨ç½²ç­–ç•¥
- [x] ä¸ºç”Ÿäº§åˆ›å»ºæ„å»ºä¼˜åŒ–ï¼ˆå·²å®ç°Viteæ„å»ºé…ç½®ï¼‰
- [ ] å®ç°æ¸è¿›å¼æ¨å‡ºç­–ç•¥
- [ ] å¼€å‘åŠŸèƒ½æ ‡è®°ï¼Œç”¨äºå—æ§å‘å¸ƒ
- [ ] åˆ›å»ºå…³é”®é—®é¢˜çš„å›æ»šæœºåˆ¶
- [ ] å®ç°ç›‘æ§å’Œè­¦æŠ¥ç³»ç»Ÿ
- [ ] å¼€å‘è‡ªåŠ¨éƒ¨ç½²éªŒè¯
- [x] ç¡®ä¿åä¸½è§†è§‰èµ„äº§çš„é«˜æ•ˆäº¤ä»˜ï¼ˆå·²ä¼˜åŒ–SVGèµ„æºå’ŒåŠ¨ç”»æ€§èƒ½ï¼‰

### 6.2 ç›‘æ§å’Œåˆ†æ
- [ ] å®ç°é”™è¯¯è·Ÿè¸ªå’ŒæŠ¥å‘Š
- [ ] åˆ›å»ºæ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿
- [ ] å¼€å‘ç”¨æˆ·å‚ä¸åº¦åˆ†æ
- [ ] å®ç°è½¬åŒ–å’Œç•™å­˜è·Ÿè¸ª
- [ ] åˆ›å»ºåŠŸèƒ½ä½¿ç”¨åˆ†æ
- [ ] å¼€å‘è´§å¸åŒ–æ€§èƒ½æŒ‡æ ‡
- [ ] ç›‘æ§åä¸½æ¸¸æˆå…ƒç´ çš„ç”¨æˆ·äº’åŠ¨æ•°æ®

### 6.3 æ›´æ–°è®¡åˆ’
- [ ] åˆ›å»ºå†…å®¹æ›´æ–°ç®¡é“
- [ ] å®ç°å­£èŠ‚æ€§æ´»åŠ¨æ¡†æ¶
- [ ] å¼€å‘åŠŸèƒ½æ‰©å±•è·¯çº¿å›¾
- [ ] åˆ›å»ºæ›´æ–°çš„ç”¨æˆ·æ²Ÿé€šæ¸ é“
- [ ] å®ç°åŸºäºåé¦ˆçš„ä¼˜å…ˆçº§æ’åº
- [ ] å¼€å‘é•¿æœŸå¯æŒç»­æ€§è§„åˆ’
- [ ] è§„åˆ’åä¸½æ¸¸æˆé£æ ¼çš„å­£èŠ‚æ€§æ›´æ–°å’Œä¸»é¢˜æ´»åŠ¨

## 7. æŠ€æœ¯å€ºåŠ¡å’Œæ–‡æ¡£

### 7.1 ä»£ç è´¨é‡å’Œç»´æŠ¤
- [x] å®ç°ä»£ç æ–‡æ¡£ï¼ˆå·²ä¸ºæ‰€æœ‰ç»„ä»¶æ·»åŠ è¯¦ç»†æ³¨é‡Šï¼‰
- [ ] åˆ›å»ºæ¶æ„å†³ç­–è®°å½•
- [x] å¼€å‘ç¼–ç æ ‡å‡†å’Œæœ€ä½³å®è·µï¼ˆå·²é…ç½®ESLintè§„åˆ™å’ŒTypeScriptç±»å‹æ£€æŸ¥ï¼‰
- [ ] å®ç°å®šæœŸä»£ç å®¡æŸ¥æµç¨‹
- [ ] åˆ›å»ºæŠ€æœ¯å€ºåŠ¡è·Ÿè¸ªå’Œè§£å†³è®¡åˆ’
- [ ] å¼€å‘çŸ¥è¯†å…±äº«æœºåˆ¶
- [ğŸ”„] å»ºç«‹åä¸½æ¸¸æˆé£æ ¼å®ç°çš„è®¾è®¡è§„èŒƒï¼ˆå·²åˆ›å»ºåŸºæœ¬è®¾è®¡è§„èŒƒï¼‰

### 7.2 ç”¨æˆ·æ–‡æ¡£
- [ ] åˆ›å»ºåº”ç”¨å†…æ•™ç¨‹å’Œå¸®åŠ©ç³»ç»Ÿ
- [ ] å¼€å‘ç”¨æˆ·æŒ‡å—å’Œå¸¸è§é—®é¢˜è§£ç­”
- [ ] å®ç°ä¸Šä¸‹æ–‡å¸®åŠ©å’Œå·¥å…·æç¤º
- [ ] åˆ›å»ºå…¥èŒææ–™
- [ ] å¼€å‘æ•…éšœæ’é™¤æŒ‡å—
- [ ] å®ç°åé¦ˆå’Œæ”¯æŒæ¸ é“
- [ ] æä¾›åä¸½æ¸¸æˆé£æ ¼å…ƒç´ çš„è§£é‡Šå’ŒèƒŒæ™¯æ•…äº‹

### 7.3 å¼€å‘è€…æ–‡æ¡£
- [x] åˆ›å»ºé¡¹ç›®æ–‡æ¡£ï¼ˆå·²å®ç°è¯¦ç»†çš„READMEå’Œä»»åŠ¡è¿›åº¦æ–‡æ¡£ï¼‰
- [ğŸ”„] åˆ›å»ºå…¨é¢çš„APIæ–‡æ¡£ï¼ˆå·²ä¸ºä¸»è¦æœåŠ¡æ·»åŠ æ–‡æ¡£ï¼‰
- [ğŸ”„] å¼€å‘ç»„ä»¶åº“æ–‡æ¡£ï¼ˆå·²ä¸ºä¸»è¦ç»„ä»¶æ·»åŠ æ–‡æ¡£ï¼‰
- [âœ…] å®ç°ç³»ç»Ÿæ¶æ„æ–‡æ¡£ï¼ˆå·²åˆ›å»ºæ•°æ®åŒæ­¥ä¸å±€éƒ¨åˆ·æ–°æ¶æ„æ–‡æ¡£ï¼‰
- [x] åˆ›å»ºå¼€å‘ç¯å¢ƒè®¾ç½®æŒ‡å—ï¼ˆå·²åœ¨READMEä¸­æä¾›ï¼‰
- [ ] å¼€å‘è´¡çŒ®æŒ‡å—
- [ ] å®ç°ç‰ˆæœ¬æ§åˆ¶å’Œåˆ†æ”¯ç­–ç•¥æ–‡æ¡£
- [ğŸ”„] æä¾›åä¸½æ¸¸æˆé£æ ¼è®¾è®¡ç³»ç»Ÿçš„è¯¦ç»†è¯´æ˜ï¼ˆå·²åœ¨game-theme.cssä¸­æä¾›åŸºæœ¬è¯´æ˜ï¼‰

## 8. æœªæ¥è€ƒè™‘

### 8.1 é«˜çº§åŠŸèƒ½
- [ ] è§„åˆ’é«˜çº§ç†ŠçŒ«äº’åŠ¨å’Œè¿·ä½ æ¸¸æˆ
- [ ] å¼€å‘å¤æ‚çš„ä¹ æƒ¯åˆ†æå’Œè§è§£
- [ ] åˆ›å»ºæ›´æ·±å…¥çš„ç¤¾äº¤åŠŸèƒ½å’Œè´£ä»»å°ç»„
- [ ] è§„åˆ’å¯ç©¿æˆ´è®¾å¤‡é›†æˆ
- [ ] å¼€å‘æ‰©å±•çš„å¼•å¯¼ç»ƒä¹ 
- [ ] åˆ›å»ºä¸»é¢˜å­£èŠ‚æ€§æ´»åŠ¨æ¡†æ¶
- [ ] è®¾è®¡æ›´å¤šåä¸½çš„æ¸¸æˆåŒ–å…ƒç´ å’Œäº’åŠ¨ä½“éªŒ

### 8.2 å¹³å°æ‰©å±•
- [ ] è§„åˆ’ç½‘é¡µç‰ˆå¼€å‘
- [ ] è€ƒè™‘æ¡Œé¢åº”ç”¨å¯èƒ½æ€§
- [ ] è¯„ä¼°æ™ºèƒ½æ‰‹è¡¨ä¼´ä¾£åº”ç”¨
- [ ] ç ”ç©¶è¯­éŸ³åŠ©æ‰‹é›†æˆ
- [ ] è€ƒè™‘ç”¨äºç†ŠçŒ«äº’åŠ¨çš„AR/VRä½“éªŒ
- [ ] è¯„ä¼°è·¨å¹³å°åŒæ­¥
- [ ] æ¢ç´¢ä¸­å›½ç‰¹è‰²å¹³å°çš„é›†æˆï¼ˆå¦‚å¾®ä¿¡å°ç¨‹åºï¼‰

### 8.3 ä¸šåŠ¡å‘å±•
- [ ] åˆ›å»ºåˆä½œä¼™ä¼´å…³ç³»å’Œåä½œæ¡†æ¶
- [ ] å¼€å‘å†…å®¹åˆ›å»ºè€…è®¡åˆ’
- [ ] è§„åˆ’æœ¬åœ°åŒ–åˆ°å…¶ä»–å¸‚åœº
- [ ] ç ”ç©¶ä¼ä¸š/ç»„ç»‡ç‰ˆæœ¬
- [ ] å¼€å‘å“ç‰Œæ‰©å±•æœºä¼š
- [ ] åˆ›å»ºé•¿æœŸå¯æŒç»­æ€§æ¨¡å‹
- [ ] æ¢ç´¢ä¸ä¸­å›½ä¼ ç»Ÿæ–‡åŒ–å“ç‰Œçš„åˆä½œæœºä¼š

## 9. è¿›åº¦æ€»ç»“

### 9.1 å·²å®Œæˆé¡¹ç›®ï¼ˆâœ“ï¼‰
- åŸºæœ¬é¡¹ç›®è®¾ç½®ï¼ˆViteã€Reactã€TypeScriptï¼‰
- åŸºæœ¬ä¾èµ–å®‰è£…ï¼ˆReact Routerã€Dexie.jsã€React Queryï¼‰
- åŸºæœ¬é¡¹ç›®ç»“æ„ç»„ç»‡
- åŸºæœ¬å›½é™…åŒ–ç³»ç»Ÿå®ç°
- åŸºæœ¬æ•°æ®åº“ç»“æ„å’Œå¡«å……ç­–ç•¥
- åä¸½æ¸¸æˆé£æ ¼çš„UIç»„ä»¶ï¼ˆæŒ‰é’®ã€åŠ è½½å™¨ã€å¡ç‰‡ç­‰ï¼‰
- åŸºæœ¬è·¯ç”±ç³»ç»Ÿ
- ç§»åŠ¨åº”ç”¨å¸ƒå±€ä¼˜åŒ–ï¼ˆåº•éƒ¨å¯¼èˆªã€å“åº”å¼è®¾è®¡ï¼‰
- ä¸­å›½é£è§†è§‰å…ƒç´ é›†æˆï¼ˆè£…é¥°ã€è¾¹æ¡†ã€SVGèµ„æºï¼‰
- æ¸¸æˆé£æ ¼çš„ä¸»é¢˜ç³»ç»Ÿï¼ˆé¢œè‰²ã€å­—ä½“ã€é—´è·ç­‰ï¼‰
- ç†ŠçŒ«ä¼™ä¼´ç³»ç»Ÿçš„åŸºæœ¬åŠŸèƒ½ï¼ˆPandaAvatarç»„ä»¶ã€çŠ¶æ€ç®¡ç†ã€äº’åŠ¨æœºåˆ¶ï¼‰
- ä»»åŠ¡ç®¡ç†ç³»ç»Ÿçš„æ ¸å¿ƒåŠŸèƒ½ï¼ˆä»»åŠ¡åˆ›å»ºã€ç¼–è¾‘ã€å®Œæˆã€åˆ†ç±»ã€è¿‡æ»¤ï¼‰
- åŠ¨ç”»ç³»ç»Ÿé›†æˆï¼ˆFramer Motionï¼‰
- ä¸­å›½é£ç‰¹æ•ˆç»„ä»¶ï¼ˆæ°´å¢¨ã€é‡‘å…‰ã€ç«¹å¶ç­‰ï¼‰
- é¡µé¢è¿‡æ¸¡åŠ¨ç”»
- æ•°æ®æœåŠ¡ä¸UIç»„ä»¶çš„é›†æˆï¼ˆDataLoaderç»„ä»¶ã€æ•°æ®åŒæ­¥æœåŠ¡ï¼‰
- ç†ŠçŒ«èƒ½åŠ›è§£é”ç³»ç»Ÿï¼ˆèƒ½åŠ›å®šä¹‰ã€è§£é”å’Œæ¿€æ´»åŠŸèƒ½ï¼‰
- ä»»åŠ¡å®Œæˆå¥–åŠ±ç³»ç»Ÿï¼ˆå¥–åŠ±ç”Ÿæˆå’Œå±•ç¤ºï¼‰
- æ•°æ®åŒæ­¥åçš„å±€éƒ¨UIæ›´æ–°ï¼ˆuseDataRefresh Hookå’Œäº‹ä»¶é©±åŠ¨çš„UIæ›´æ–°ï¼‰
- æŒ‘æˆ˜ç³»ç»Ÿçš„åŸºæœ¬åŠŸèƒ½ï¼ˆæŒ‘æˆ˜å®šä¹‰ã€è¿‡æ»¤ã€å®Œæˆå’Œå¥–åŠ±ï¼‰
- åŠæ—¶å¥–åŠ±ç³»ç»Ÿï¼ˆæ—¶é—´çª—å£å†…å®Œæˆä»»åŠ¡è·å¾—é¢å¤–å¥–åŠ±ï¼‰
- å¹¸è¿ç‚¹å’Œå¹¸è¿æŠ½å¥–ç³»ç»Ÿï¼ˆç´¯ç§¯å¹¸è¿ç‚¹è¿›è¡ŒæŠ½å¥–ï¼‰
- åæ€æ¨¡å—ç³»ç»Ÿï¼ˆæƒ…ç»ªè¿½è¸ªã€åæ€è§¦å‘ã€æ”¯æŒæ€§åé¦ˆã€é™å¿ƒèŒ¶å®¤ï¼‰
- ç¤¾äº¤æŒ‘æˆ˜ç³»ç»Ÿï¼ˆåˆä½œæŒ‘æˆ˜ã€æŒ‘æˆ˜å‘ç°å’Œæ¨èï¼‰
- å­ä»»åŠ¡ç³»ç»Ÿï¼ˆä»»åŠ¡åˆ†è§£ã€å­ä»»åŠ¡ç®¡ç†ï¼‰
- ä»»åŠ¡æé†’ç³»ç»Ÿï¼ˆç†ŠçŒ«ä¿¡ä½¿ä¸»é¢˜ã€è‡ªåŠ¨æ£€æµ‹å’Œæé†’ï¼‰
- å•†åº—å’Œè´§å¸åŒ–ç³»ç»Ÿï¼ˆå•†åº—ç•Œé¢ã€ç‰©å“è´­ä¹°ã€VIPè®¢é˜…ï¼‰

### 9.2 è¿›è¡Œä¸­é¡¹ç›®ï¼ˆğŸ”„ï¼‰
- ç”¨æˆ·è®¤è¯å’Œé…ç½®æ–‡ä»¶ç®¡ç†

### 9.3 ä¸‹ä¸€æ­¥ä¼˜å…ˆäº‹é¡¹
1. âœ… å®ç°ç†ŠçŒ«ä¼™ä¼´ç³»ç»Ÿçš„åŸºæœ¬åŠŸèƒ½ï¼ˆPandaAvatarç»„ä»¶ï¼‰
2. âœ… å¼€å‘ä»»åŠ¡ç®¡ç†ç³»ç»Ÿçš„æ ¸å¿ƒåŠŸèƒ½ï¼ˆTaskManagerç»„ä»¶ï¼‰
3. âœ… æ·»åŠ åŠ¨ç”»åº“ï¼ˆFramer Motionï¼‰
4. âœ… å®ç°ä¸­å›½é£ç‰¹æ•ˆç³»ç»Ÿï¼ˆæ°´å¢¨ã€é‡‘å…‰ã€ç«¹å¶ç­‰ï¼‰
5. âœ… å¼€å‘æ¨¡æ€æ¡†å’Œå¯¹è¯æ¡†ç»„ä»¶ï¼ˆå¤ä»£å·è½´æˆ–çª—æ£‚æ ·å¼ï¼‰
6. âœ… å®ç°ä»»åŠ¡å®Œæˆå¥–åŠ±ç³»ç»Ÿ
7. âœ… å¼€å‘ç†ŠçŒ«èƒ½åŠ›è§£é”ç³»ç»Ÿ
8. âœ… æ·»åŠ æ›´å¤šä¸­æ–‡å­—ä½“å’Œè§†è§‰èµ„æº
9. âœ… å®ç°æ•°æ®åŒæ­¥åçš„å±€éƒ¨UIæ›´æ–°ï¼ˆuseDataRefresh Hookï¼‰
10. âœ… å¼€å‘æŒ‘æˆ˜ç³»ç»Ÿçš„åŸºæœ¬åŠŸèƒ½ï¼ˆæŒ‘æˆ˜å®šä¹‰ã€è¿‡æ»¤ã€å®Œæˆå’Œå¥–åŠ±ï¼‰
11. âœ… å®ç°åŠæ—¶å¥–åŠ±ç³»ç»Ÿï¼ˆå·²å®ç°åŠæ—¶å¥–åŠ±å’Œå¹¸è¿æŠ½å¥–åŠŸèƒ½ï¼‰
12. âœ… å¼€å‘åæ€æ¨¡å—ï¼ˆå·²å®ç°åæ€è§¦å‘ã€æƒ…ç»ªè¿½è¸ªå’Œé™å¿ƒèŒ¶å®¤ï¼‰
13. âœ… å®Œå–„ä»»åŠ¡ç®¡ç†ç³»ç»Ÿï¼ˆå·²å®ç°ä»»åŠ¡æé†’å’Œä»»åŠ¡åˆ†è§£åŠŸèƒ½ï¼‰
14. âœ… å¼€å‘å•†åº—å’Œè´§å¸åŒ–ç³»ç»Ÿï¼ˆå·²å®ç°å•†åº—ç•Œé¢ã€ç‰©å“è´­ä¹°å’ŒVIPè®¢é˜…ï¼‰
15. [ ] å¼€å‘è®¤è¯ç³»ç»Ÿï¼ˆç”¨æˆ·æ³¨å†Œã€ç™»å½•å’Œè´¦æˆ·ç®¡ç†ï¼‰
</file>

<file path="package.json">
{
  "name": "minimal-dexie-i18n-v3-final",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.32.0",
    "@types/node": "^22.15.17",
    "dexie": "^3.2.7",
    "framer-motion": "^12.11.0",
    "react": "^18.2.0",
    "react-beautiful-dnd": "^13.1.1",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.23.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@types/react-router-dom": "^5.3.3",
    "@typescript-eslint/eslint-plugin": "^7.2.0",
    "@typescript-eslint/parser": "^7.2.0",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "typescript": "^5.2.2",
    "vite": "^5.2.0"
  }
}
</file>

<file path="src/components/layout/Navigation.tsx">
// src/components/layout/Navigation.tsx
import React from 'react';
import { NavLink } from 'react-router-dom';
import type { GlobalLayoutLabelsBundle } from '@/types';

interface NavigationProps {
  labels: GlobalLayoutLabelsBundle | undefined;
  variant?: 'default' | 'bamboo';
}

/**
 * Navigation component with support for game-themed style
 *
 * @param labels - Text labels for navigation items
 * @param variant - 'default' or 'bamboo' (game-themed)
 */
const Navigation: React.FC<NavigationProps> = ({
  labels,
  variant = 'bamboo' // Default to bamboo style for game theme
}) => {
  // Provide fallbacks for label properties
  const navHomeText = labels?.navHome || "Home";
  const navTasksText = labels?.navTasks || "Tasks";
  const navAbilitiesText = labels?.navAbilities || "Abilities";
  const navChallengesText = labels?.navChallenges || "Challenges";
  const navRewardsText = labels?.navRewards || "Rewards";
  const navTeaRoomText = labels?.navTeaRoom || "Tea Room";
  const navStoreText = labels?.navStore || "Store";
  const navSettingsText = labels?.navSettings || "Settings";

  if (!labels) { // Can show a minimal loading state or just render with fallbacks
    return <nav className={variant === 'bamboo' ? 'bamboo-nav' : ''}>Loading navigation...</nav>;
  }

  const navClass = variant === 'bamboo' ? 'bamboo-nav' : '';

  return (
    <nav className={navClass}>
      <NavLink
        to="/"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navHomeText}
      </NavLink>
      <NavLink
        to="/tasks"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navTasksText}
      </NavLink>
      <NavLink
        to="/abilities"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navAbilitiesText}
      </NavLink>
      <NavLink
        to="/challenges"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navChallengesText}
      </NavLink>
      <NavLink
        to="/rewards"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navRewardsText}
      </NavLink>
      <NavLink
        to="/tearoom"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navTeaRoomText}
      </NavLink>
      <NavLink
        to="/store"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navStoreText}
      </NavLink>
      <NavLink
        to="/settings"
        className={({isActive}) => isActive ? 'active' : ''}
      >
        {navSettingsText}
      </NavLink>
    </nav>
  );
};

export default Navigation;
</file>

<file path="src/db.ts">
// src/db.ts
import Dexie, { Table } from 'dexie';
import type { UILabelRecord } from '@/types';
import type { PandaStateRecord } from '@/services/pandaStateService';
import type {
  TaskRecord,
  TaskCategoryRecord,
  TaskCompletionRecord
} from '@/services/taskService';
import type { RewardRecord, ItemRecord, BadgeRecord, AbilityRecord as RewardAbilityRecord } from '@/services/rewardService';
import type { PandaAbilityRecord } from '@/services/pandaAbilityService';
import type { SyncItem } from '@/services/dataSyncService';
import type { ChallengeRecord, ChallengeCompletionRecord } from '@/services/challengeService';
import type { TimelyRewardRecord, LuckyPointRecord, LuckyDrawRecord } from '@/services/timelyRewardService';
import type { SubtaskRecord } from '@/services/subtaskService';
import type { ChallengeDiscovery } from '@/services/challengeDiscoveryService';
import type { SocialChallengeRecord, SocialChallengeParticipation, SocialChallengeMilestone } from '@/services/socialChallengeService';
import type { ReflectionRecord, ReflectionTriggerRecord, MoodRecord } from '@/services/reflectionService';
import type { TaskReminderRecord } from '@/services/taskReminderService';
import type { StoreItemRecord, StoreCategoryRecord, PurchaseRecord, VipSubscriptionRecord, UserCurrencyRecord } from '@/services/storeService';
import type { PandaAccessoryRecord, PandaEnvironmentRecord } from '@/services/pandaCustomizationService';

export class AppDB extends Dexie {
  uiLabels!: Table<UILabelRecord, number>;
  pandaState!: Table<PandaStateRecord, number>;
  tasks!: Table<TaskRecord, number>;
  taskCategories!: Table<TaskCategoryRecord, number>;
  taskCompletions!: Table<TaskCompletionRecord, number>;
  subtasks!: Table<SubtaskRecord, number>;
  taskReminders!: Table<TaskReminderRecord, number>;
  rewards!: Table<RewardRecord, number>;
  items!: Table<ItemRecord, number>;
  badges!: Table<BadgeRecord, number>;
  abilities!: Table<PandaAbilityRecord, number>;
  rewardAbilities!: Table<RewardAbilityRecord, number>;
  pandaAccessories!: Table<PandaAccessoryRecord, number>;
  pandaEnvironments!: Table<PandaEnvironmentRecord, number>;
  syncQueue!: Table<SyncItem, string>;
  challenges!: Table<ChallengeRecord, number>;
  challengeCategories!: Table<any, number>;
  challengeCompletions!: Table<ChallengeCompletionRecord, number>;
  challengeDiscoveries!: Table<ChallengeDiscovery, number>;
  socialChallenges!: Table<SocialChallengeRecord, number>;
  socialChallengeParticipations!: Table<SocialChallengeParticipation, number>;
  socialChallengeMilestones!: Table<SocialChallengeMilestone, number>;
  reflections!: Table<ReflectionRecord, number>;
  reflectionTriggers!: Table<ReflectionTriggerRecord, number>;
  moods!: Table<MoodRecord, number>;
  storeItems!: Table<StoreItemRecord, number>;
  storeCategories!: Table<StoreCategoryRecord, number>;
  purchases!: Table<PurchaseRecord, number>;
  vipSubscriptions!: Table<VipSubscriptionRecord, number>;
  userCurrencies!: Table<UserCurrencyRecord, number>;
  timelyRewards!: Table<TimelyRewardRecord, number>;
  luckyPoints!: Table<LuckyPointRecord, number>;
  luckyDraws!: Table<LuckyDrawRecord, number>;

  constructor() {
    super('PandaHabitDB_V13'); // æ›´æ–°æ•°æ®åº“ç‰ˆæœ¬
    this.version(13).stores({
      uiLabels: '++id, scopeKey, labelKey, languageCode, &[scopeKey+labelKey+languageCode]',
      pandaState: '++id, mood, energy, lastUpdated, level',
      tasks: '++id, title, categoryId, priority, status, dueDate, createdAt',
      taskCategories: '++id, name, color, icon, isDefault',
      taskCompletions: '++id, taskId, completedAt, experienceGained',
      subtasks: '++id, parentTaskId, title, status, order, createdAt',
      taskReminders: '++id, taskId, userId, reminderTime, isViewed, isCompleted, createdAt',
      rewards: '++id, type, rarity, taskId, obtainedAt, isViewed',
      items: '++id, type, rarity, quantity, obtainedAt',
      badges: '++id, rarity, obtainedAt, isEquipped',
      abilities: '++id, name, type, effectType, requiredLevel, isUnlocked, isActive',
      rewardAbilities: '++id, rarity, obtainedAt, isUnlocked, isActive',
      pandaAccessories: '++id, name, type, isEquipped, isOwned, obtainedAt, rarity, themeType',
      pandaEnvironments: '++id, name, isActive, isOwned, obtainedAt, rarity, themeType',
      syncQueue: 'id, table, action, timestamp, status',
      challenges: '++id, title, type, difficulty, status, progress, startDate, endDate, createdAt',
      challengeCategories: '++id, name, description, iconPath',
      challengeCompletions: '++id, challengeId, userId, completedDate, createdAt',
      challengeDiscoveries: '++id, userId, challengeId, discoveredAt, isViewed, isAccepted, expiresAt',
      socialChallenges: '++id, title, type, difficulty, status, creatorId, isPublic, inviteCode, createdAt',
      socialChallengeParticipations: '++id, challengeId, userId, joinedAt, status, contribution',
      socialChallengeMilestones: '++id, challengeId, title, targetValue, currentValue, isCompleted, order',
      reflections: '++id, userId, taskId, mood, reflection, action, createdAt, isCompleted',
      reflectionTriggers: '++id, userId, type, createdAt, isViewed, isCompleted',
      moods: '++id, userId, mood, intensity, createdAt',
      storeItems: '++id, name, type, rarity, price, priceType, isAvailable, isFeatured, isOnSale, categoryId, createdAt',
      storeCategories: '++id, name, order, isVisible, createdAt',
      purchases: '++id, userId, storeItemId, price, priceType, purchaseDate, isRefunded',
      vipSubscriptions: '++id, userId, tier, startDate, endDate, isActive, createdAt',
      userCurrencies: '++id, userId, coins, jade, lastUpdated',
      timelyRewards: '++id, title, type, status, startTime, endTime, createdAt',
      luckyPoints: '++id, userId, amount, isSpent, expiryDate, createdAt',
      luckyDraws: '++id, userId, pointsSpent, timestamp, createdAt'
    });
  }
}
export const db = new AppDB();

let hasAttemptedPopulation = false;

export async function populateDB() {
  if (hasAttemptedPopulation) return;
  hasAttemptedPopulation = true;

  const count = await db.uiLabels.count();
  if (count > 0) { /* console.log("DB V3 already populated."); */ return; }
  console.log("Populating Final V3 Dexie DB...");

  const labels: UILabelRecord[] = [
    // GlobalLayout scope
    { scopeKey: 'globalLayout', labelKey: 'appTitle', languageCode: 'en', translatedText: 'App V3 - Consistent' },
    { scopeKey: 'globalLayout', labelKey: 'appTitle', languageCode: 'zh', translatedText: 'åº”ç”¨ V3 - ä¸€è‡´æ€§' },
    { scopeKey: 'globalLayout', labelKey: 'navHome', languageCode: 'en', translatedText: 'Home' },
    { scopeKey: 'globalLayout', labelKey: 'navHome', languageCode: 'zh', translatedText: 'ä¸»é¡µ' },
    { scopeKey: 'globalLayout', labelKey: 'navTasks', languageCode: 'en', translatedText: 'Tasks' },
    { scopeKey: 'globalLayout', labelKey: 'navTasks', languageCode: 'zh', translatedText: 'ä»»åŠ¡' },
    { scopeKey: 'globalLayout', labelKey: 'navSettings', languageCode: 'en', translatedText: 'Settings' },
    { scopeKey: 'globalLayout', labelKey: 'navSettings', languageCode: 'zh', translatedText: 'è®¾å®š' },
    { scopeKey: 'globalLayout', labelKey: 'footerText', languageCode: 'en', translatedText: 'Â© 2024 Final Demo App' },
    { scopeKey: 'globalLayout', labelKey: 'footerText', languageCode: 'zh', translatedText: 'Â© 2024 æœ€ç»ˆæ¼”ç¤ºåº”ç”¨' },
    { scopeKey: 'globalLayout', labelKey: 'loadingGeneric', languageCode: 'en', translatedText: 'Loading, one moment...' },
    { scopeKey: 'globalLayout', labelKey: 'loadingGeneric', languageCode: 'zh', translatedText: 'åŠ è½½ä¸­ï¼Œè¯·ç¨å€™...' },
    { scopeKey: 'globalLayout', labelKey: 'errorGeneric', languageCode: 'en', translatedText: 'An unexpected error occurred.' },
    { scopeKey: 'globalLayout', labelKey: 'errorGeneric', languageCode: 'zh', translatedText: 'å‘ç”Ÿäº†ä¸€ä¸ªæ„å¤–é”™è¯¯ã€‚' },

    // homeView scope
    { scopeKey: 'homeView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'My Dashboard' },
    { scopeKey: 'homeView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: 'æˆ‘çš„ä»ªè¡¨æ¿' },
    { scopeKey: 'homeView.welcomeSection', labelKey: 'welcomeMessage', languageCode: 'en', translatedText: 'Greetings, {user}! Have a productive day.' },
    { scopeKey: 'homeView.welcomeSection', labelKey: 'welcomeMessage', languageCode: 'zh', translatedText: 'ä½ å¥½ {user}ï¼Œç¥ä½ æ‹¥æœ‰é«˜æ•ˆçš„ä¸€å¤©ï¼' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Recent Mood Entries' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: 'è¿‘æœŸå¿ƒæƒ…è®°å½•' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'noMoodsMessage', languageCode: 'en', translatedText: 'No moods logged. Why not add one?' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'noMoodsMessage', languageCode: 'zh', translatedText: 'æš‚æ— å¿ƒæƒ…è®°å½•ã€‚è¦ä¸è¦æ·»åŠ ä¸€æ¡ï¼Ÿ' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'refreshButtonText', languageCode: 'en', translatedText: 'Refresh Moods' },
    { scopeKey: 'homeView.moodsSection', labelKey: 'refreshButtonText', languageCode: 'zh', translatedText: 'åˆ·æ–°å¿ƒæƒ…' },

    // ç†ŠçŒ«åŒºåŸŸæ ‡ç­¾
    { scopeKey: 'homeView.pandaSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Panda Companion' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: 'ç†ŠçŒ«ä¼™ä¼´' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'levelLabel', languageCode: 'en', translatedText: 'Level' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'levelLabel', languageCode: 'zh', translatedText: 'ç­‰çº§' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'experienceLabel', languageCode: 'en', translatedText: 'Experience' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'experienceLabel', languageCode: 'zh', translatedText: 'ç»éªŒ' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'interactButtonText', languageCode: 'en', translatedText: 'Interact' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'interactButtonText', languageCode: 'zh', translatedText: 'äº’åŠ¨' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'feedButtonText', languageCode: 'en', translatedText: 'Feed' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'feedButtonText', languageCode: 'zh', translatedText: 'å–‚é£Ÿ' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'playButtonText', languageCode: 'en', translatedText: 'Play' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'playButtonText', languageCode: 'zh', translatedText: 'ç©è€' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'trainButtonText', languageCode: 'en', translatedText: 'Train' },
    { scopeKey: 'homeView.pandaSection', labelKey: 'trainButtonText', languageCode: 'zh', translatedText: 'è®­ç»ƒ' },

    { scopeKey: 'homeView', labelKey: 'someActionText', languageCode: 'en', translatedText: 'Perform Action' },
    { scopeKey: 'homeView', labelKey: 'someActionText', languageCode: 'zh', translatedText: 'æ‰§è¡Œæ“ä½œ' },

    // settingsView scope
    { scopeKey: 'settingsView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Configuration Panel' },
    { scopeKey: 'settingsView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: 'é…ç½®é¢æ¿' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'Display Language' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: 'æ˜¾ç¤ºè¯­è¨€' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'selectLanguagePrompt', languageCode: 'en', translatedText: 'Select your preferred language:' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'selectLanguagePrompt', languageCode: 'zh', translatedText: 'è¯·é€‰æ‹©æ‚¨çš„åå¥½è¯­è¨€ï¼š' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'currentLanguageIs', languageCode: 'en', translatedText: 'Currently using: {lang}' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'currentLanguageIs', languageCode: 'zh', translatedText: 'å½“å‰ä½¿ç”¨ï¼š{lang}' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameEn', languageCode: 'en', translatedText: 'English (US)' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameEn', languageCode: 'zh', translatedText: 'ç¾å¼è‹±è¯­' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameZh', languageCode: 'en', translatedText: 'Chinese (Simplified)' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'langNameZh', languageCode: 'zh', translatedText: 'ç®€ä½“ä¸­æ–‡' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'saveButtonText', languageCode: 'en', translatedText: 'Save Preferences' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'saveButtonText', languageCode: 'zh', translatedText: 'ä¿å­˜åå¥½' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'successMessage', languageCode: 'en', translatedText: 'Preferences have been updated!' },
    { scopeKey: 'settingsView.languageSection', labelKey: 'successMessage', languageCode: 'zh', translatedText: 'åå¥½è®¾ç½®å·²æ›´æ–°ï¼' },

    // tasksView scope
    { scopeKey: 'tasksView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Task Management' },
    { scopeKey: 'tasksView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: 'ä»»åŠ¡ç®¡ç†' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'sectionTitle', languageCode: 'en', translatedText: 'My Tasks' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'sectionTitle', languageCode: 'zh', translatedText: 'æˆ‘çš„ä»»åŠ¡' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'createTaskButton', languageCode: 'en', translatedText: 'Create New Task' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'createTaskButton', languageCode: 'zh', translatedText: 'åˆ›å»ºæ–°ä»»åŠ¡' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterAllLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterAllLabel', languageCode: 'zh', translatedText: 'å…¨éƒ¨' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterTodoLabel', languageCode: 'en', translatedText: 'To Do' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterTodoLabel', languageCode: 'zh', translatedText: 'å¾…åŠ' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterInProgressLabel', languageCode: 'en', translatedText: 'In Progress' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterInProgressLabel', languageCode: 'zh', translatedText: 'è¿›è¡Œä¸­' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterCompletedLabel', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'filterCompletedLabel', languageCode: 'zh', translatedText: 'å·²å®Œæˆ' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'noTasksMessage', languageCode: 'en', translatedText: 'No tasks found' },
    { scopeKey: 'tasksView.taskManager', labelKey: 'noTasksMessage', languageCode: 'zh', translatedText: 'æš‚æ— ä»»åŠ¡' },

    // challengesView scope
    { scopeKey: 'challengesView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Challenges' },
    { scopeKey: 'challengesView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: 'æŒ‘æˆ˜' },
    { scopeKey: 'challengesView', labelKey: 'statusFilterLabel', languageCode: 'en', translatedText: 'Status' },
    { scopeKey: 'challengesView', labelKey: 'statusFilterLabel', languageCode: 'zh', translatedText: 'çŠ¶æ€' },
    { scopeKey: 'challengesView', labelKey: 'typeFilterLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'challengesView', labelKey: 'typeFilterLabel', languageCode: 'zh', translatedText: 'ç±»å‹' },
    { scopeKey: 'challengesView', labelKey: 'difficultyFilterLabel', languageCode: 'en', translatedText: 'Difficulty' },
    { scopeKey: 'challengesView', labelKey: 'difficultyFilterLabel', languageCode: 'zh', translatedText: 'éš¾åº¦' },
    { scopeKey: 'challengesView', labelKey: 'filterAllLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'challengesView', labelKey: 'filterAllLabel', languageCode: 'zh', translatedText: 'å…¨éƒ¨' },
    { scopeKey: 'challengesView', labelKey: 'filterActiveLabel', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'challengesView', labelKey: 'filterActiveLabel', languageCode: 'zh', translatedText: 'è¿›è¡Œä¸­' },
    { scopeKey: 'challengesView', labelKey: 'filterCompletedLabel', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'challengesView', labelKey: 'filterCompletedLabel', languageCode: 'zh', translatedText: 'å·²å®Œæˆ' },
    { scopeKey: 'challengesView', labelKey: 'filterUpcomingLabel', languageCode: 'en', translatedText: 'Upcoming' },
    { scopeKey: 'challengesView', labelKey: 'filterUpcomingLabel', languageCode: 'zh', translatedText: 'å³å°†å¼€å§‹' },
    { scopeKey: 'challengesView', labelKey: 'clearFiltersButton', languageCode: 'en', translatedText: 'Clear All Filters' },
    { scopeKey: 'challengesView', labelKey: 'clearFiltersButton', languageCode: 'zh', translatedText: 'æ¸…é™¤æ‰€æœ‰è¿‡æ»¤å™¨' },
    { scopeKey: 'challengesView', labelKey: 'noChallengesMessage', languageCode: 'en', translatedText: 'No challenges found' },
    { scopeKey: 'challengesView', labelKey: 'noChallengesMessage', languageCode: 'zh', translatedText: 'æš‚æ— æŒ‘æˆ˜' },

    // æŒ‘æˆ˜é¡µé¢è¿‡æ»¤å™¨æ ‡ç­¾ - ç±»å‹
    { scopeKey: 'challengesView.filters', labelKey: 'typeAllLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeAllLabel', languageCode: 'zh', translatedText: 'å…¨éƒ¨' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeDailyLabel', languageCode: 'en', translatedText: 'Daily' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeDailyLabel', languageCode: 'zh', translatedText: 'æ¯æ—¥' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeWeeklyLabel', languageCode: 'en', translatedText: 'Weekly' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeWeeklyLabel', languageCode: 'zh', translatedText: 'æ¯å‘¨' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeEventLabel', languageCode: 'en', translatedText: 'Event' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeEventLabel', languageCode: 'zh', translatedText: 'æ´»åŠ¨' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeOngoingLabel', languageCode: 'en', translatedText: 'Ongoing' },
    { scopeKey: 'challengesView.filters', labelKey: 'typeOngoingLabel', languageCode: 'zh', translatedText: 'æŒç»­' },

    // æŒ‘æˆ˜é¡µé¢è¿‡æ»¤å™¨æ ‡ç­¾ - éš¾åº¦
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyAllLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyAllLabel', languageCode: 'zh', translatedText: 'å…¨éƒ¨' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyEasyLabel', languageCode: 'en', translatedText: 'Easy' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyEasyLabel', languageCode: 'zh', translatedText: 'ç®€å•' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyMediumLabel', languageCode: 'en', translatedText: 'Medium' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyMediumLabel', languageCode: 'zh', translatedText: 'ä¸­ç­‰' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyHardLabel', languageCode: 'en', translatedText: 'Hard' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyHardLabel', languageCode: 'zh', translatedText: 'å›°éš¾' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyExpertLabel', languageCode: 'en', translatedText: 'Expert' },
    { scopeKey: 'challengesView.filters', labelKey: 'difficultyExpertLabel', languageCode: 'zh', translatedText: 'ä¸“å®¶' },

    // æŒ‘æˆ˜é¡µé¢é”™è¯¯å’ŒåŠ è½½æ¶ˆæ¯
    { scopeKey: 'challengesView', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading challenges...' },
    { scopeKey: 'challengesView', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: 'åŠ è½½æŒ‘æˆ˜ä¸­...' },
    { scopeKey: 'challengesView', labelKey: 'errorTitle', languageCode: 'en', translatedText: 'Challenge Page Error' },
    { scopeKey: 'challengesView', labelKey: 'errorTitle', languageCode: 'zh', translatedText: 'æŒ‘æˆ˜é¡µé¢é”™è¯¯' },
    { scopeKey: 'challengesView', labelKey: 'errorMessage', languageCode: 'en', translatedText: 'Failed to load challenges: {message}' },
    { scopeKey: 'challengesView', labelKey: 'errorMessage', languageCode: 'zh', translatedText: 'åŠ è½½æŒ‘æˆ˜å¤±è´¥: {message}' },
    { scopeKey: 'challengesView', labelKey: 'retryButtonText', languageCode: 'en', translatedText: 'Retry' },
    { scopeKey: 'challengesView', labelKey: 'retryButtonText', languageCode: 'zh', translatedText: 'é‡è¯•' },

    // åŠæ—¶å¥–åŠ±é¡µé¢æ ‡ç­¾
    { scopeKey: 'timelyRewardsPageView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Timely Rewards' },
    { scopeKey: 'timelyRewardsPageView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: 'åŠæ—¶å¥–åŠ±' },
    { scopeKey: 'timelyRewardsPageView', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading rewards...' },
    { scopeKey: 'timelyRewardsPageView', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: 'åŠ è½½å¥–åŠ±ä¸­...' },
    { scopeKey: 'timelyRewardsPageView', labelKey: 'errorTitle', languageCode: 'en', translatedText: 'Timely Rewards Page Error' },
    { scopeKey: 'timelyRewardsPageView', labelKey: 'errorTitle', languageCode: 'zh', translatedText: 'åŠæ—¶å¥–åŠ±é¡µé¢é”™è¯¯' },

    // åŠæ—¶å¥–åŠ±é¡µé¢è¿‡æ»¤å™¨æ ‡ç­¾
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'statusLabel', languageCode: 'en', translatedText: 'Status' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'statusLabel', languageCode: 'zh', translatedText: 'çŠ¶æ€' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'allLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'allLabel', languageCode: 'zh', translatedText: 'å…¨éƒ¨' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'activeLabel', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'activeLabel', languageCode: 'zh', translatedText: 'è¿›è¡Œä¸­' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'completedLabel', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'completedLabel', languageCode: 'zh', translatedText: 'å·²å®Œæˆ' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'upcomingLabel', languageCode: 'en', translatedText: 'Upcoming' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'upcomingLabel', languageCode: 'zh', translatedText: 'å³å°†å¼€å§‹' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeLabel', languageCode: 'zh', translatedText: 'ç±»å‹' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeAllLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeAllLabel', languageCode: 'zh', translatedText: 'å…¨éƒ¨' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeDailyLabel', languageCode: 'en', translatedText: 'Daily Reward' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeDailyLabel', languageCode: 'zh', translatedText: 'æ¯æ—¥å¥–åŠ±' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeMorningLabel', languageCode: 'en', translatedText: 'Early Bird Reward' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeMorningLabel', languageCode: 'zh', translatedText: 'æ—©èµ·é¸Ÿå¥–åŠ±' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeStreakLabel', languageCode: 'en', translatedText: 'Streak Reward' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeStreakLabel', languageCode: 'zh', translatedText: 'è¿ç»­å®Œæˆå¥–åŠ±' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeSpecialLabel', languageCode: 'en', translatedText: 'Special Reward' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'typeSpecialLabel', languageCode: 'zh', translatedText: 'ç‰¹æ®Šå¥–åŠ±' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'clearFiltersLabel', languageCode: 'en', translatedText: 'Clear All Filters' },
    { scopeKey: 'timelyRewardsPageView.filters', labelKey: 'clearFiltersLabel', languageCode: 'zh', translatedText: 'æ¸…é™¤æ‰€æœ‰è¿‡æ»¤å™¨' },

    // åŠæ—¶å¥–åŠ±å¡ç‰‡æ ‡ç­¾
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeDaily', languageCode: 'en', translatedText: 'Daily Reward' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeDaily', languageCode: 'zh', translatedText: 'æ¯æ—¥å¥–åŠ±' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeMorning', languageCode: 'en', translatedText: 'Early Bird Reward' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeMorning', languageCode: 'zh', translatedText: 'æ—©èµ·é¸Ÿå¥–åŠ±' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeStreak', languageCode: 'en', translatedText: 'Streak Reward' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeStreak', languageCode: 'zh', translatedText: 'è¿ç»­å®Œæˆå¥–åŠ±' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeSpecial', languageCode: 'en', translatedText: 'Special Reward' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeSpecial', languageCode: 'zh', translatedText: 'ç‰¹æ®Šå¥–åŠ±' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusActive', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusActive', languageCode: 'zh', translatedText: 'è¿›è¡Œä¸­' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusCompleted', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusCompleted', languageCode: 'zh', translatedText: 'å·²å®Œæˆ' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusExpired', languageCode: 'en', translatedText: 'Expired' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusExpired', languageCode: 'zh', translatedText: 'å·²è¿‡æœŸ' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusUpcoming', languageCode: 'en', translatedText: 'Upcoming' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusUpcoming', languageCode: 'zh', translatedText: 'å³å°†å¼€å§‹' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'timeEnded', languageCode: 'en', translatedText: 'Ended' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'timeEnded', languageCode: 'zh', translatedText: 'å·²ç»“æŸ' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'hourUnit', languageCode: 'en', translatedText: 'h' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'hourUnit', languageCode: 'zh', translatedText: 'å°æ—¶' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'minuteUnit', languageCode: 'en', translatedText: 'm' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'minuteUnit', languageCode: 'zh', translatedText: 'åˆ†é’Ÿ' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'remainingTimeLabel', languageCode: 'en', translatedText: 'Remaining time' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'remainingTimeLabel', languageCode: 'zh', translatedText: 'å‰©ä½™æ—¶é—´' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'luckyPointsLabel', languageCode: 'en', translatedText: 'Lucky Points' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'luckyPointsLabel', languageCode: 'zh', translatedText: 'å¹¸è¿ç‚¹' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'claimRewardButton', languageCode: 'en', translatedText: 'Claim Reward' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'claimRewardButton', languageCode: 'zh', translatedText: 'é¢†å–å¥–åŠ±' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'inProgressButton', languageCode: 'en', translatedText: 'In Progress...' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'inProgressButton', languageCode: 'zh', translatedText: 'è¿›è¡Œä¸­...' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'completedOnLabel', languageCode: 'en', translatedText: 'Completed on' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'completedOnLabel', languageCode: 'zh', translatedText: 'å®Œæˆäº' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'noRewardsMessage', languageCode: 'en', translatedText: 'No timely rewards available' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'noRewardsMessage', languageCode: 'zh', translatedText: 'æš‚æ— åŠæ—¶å¥–åŠ±' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'typeLabel', languageCode: 'zh', translatedText: 'ç±»å‹' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusLabel', languageCode: 'en', translatedText: 'Status' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'statusLabel', languageCode: 'zh', translatedText: 'çŠ¶æ€' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'progressLabel', languageCode: 'en', translatedText: 'Progress' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'progressLabel', languageCode: 'zh', translatedText: 'è¿›åº¦' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'startTimeLabel', languageCode: 'en', translatedText: 'Start Time' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'startTimeLabel', languageCode: 'zh', translatedText: 'å¼€å§‹æ—¶é—´' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'endTimeLabel', languageCode: 'en', translatedText: 'End Time' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'endTimeLabel', languageCode: 'zh', translatedText: 'ç»“æŸæ—¶é—´' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'completedTimeLabel', languageCode: 'en', translatedText: 'Completed Time' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'completedTimeLabel', languageCode: 'zh', translatedText: 'å®Œæˆæ—¶é—´' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'continueEffortButton', languageCode: 'en', translatedText: 'Keep Going' },
    { scopeKey: 'timelyRewardsPageView.rewardCard', labelKey: 'continueEffortButton', languageCode: 'zh', translatedText: 'ç»§ç»­åŠªåŠ›' },

    // å¹¸è¿æŠ½å¥–æ ‡ç­¾
    { scopeKey: 'timelyRewardsPageView.luckyDraw', labelKey: 'title', languageCode: 'en', translatedText: 'Lucky Draw' },
    { scopeKey: 'timelyRewardsPageView.luckyDraw', labelKey: 'title', languageCode: 'zh', translatedText: 'å¹¸è¿æŠ½å¥–' },
    { scopeKey: 'timelyRewardsPageView.luckyDraw', labelKey: 'buttonText', languageCode: 'en', translatedText: 'Lucky Draw' },
    { scopeKey: 'timelyRewardsPageView.luckyDraw', labelKey: 'buttonText', languageCode: 'zh', translatedText: 'å¹¸è¿æŠ½å¥–' },

    // å¹¸è¿ç‚¹æ˜¾ç¤ºç»„ä»¶æ ‡ç­¾
    { scopeKey: 'luckyPointsDisplay', labelKey: 'label', languageCode: 'en', translatedText: 'Lucky Points' },
    { scopeKey: 'luckyPointsDisplay', labelKey: 'label', languageCode: 'zh', translatedText: 'å¹¸è¿ç‚¹' },
    { scopeKey: 'luckyPointsDisplay', labelKey: 'loadingText', languageCode: 'en', translatedText: 'Loading...' },
    { scopeKey: 'luckyPointsDisplay', labelKey: 'loadingText', languageCode: 'zh', translatedText: 'åŠ è½½ä¸­...' },

    // å¹¸è¿æŠ½å¥–ç»„ä»¶æ ‡ç­¾
    { scopeKey: 'luckyDraw', labelKey: 'title', languageCode: 'en', translatedText: 'Lucky Draw' },
    { scopeKey: 'luckyDraw', labelKey: 'title', languageCode: 'zh', translatedText: 'å¹¸è¿æŠ½å¥–' },
    { scopeKey: 'luckyDraw', labelKey: 'basicDrawLabel', languageCode: 'en', translatedText: 'Basic Draw' },
    { scopeKey: 'luckyDraw', labelKey: 'basicDrawLabel', languageCode: 'zh', translatedText: 'åŸºç¡€æŠ½å¥–' },
    { scopeKey: 'luckyDraw', labelKey: 'basicDrawDescription', languageCode: 'en', translatedText: 'Chance to get common rewards' },
    { scopeKey: 'luckyDraw', labelKey: 'basicDrawDescription', languageCode: 'zh', translatedText: 'è·å¾—æ™®é€šå¥–åŠ±çš„æœºä¼š' },
    { scopeKey: 'luckyDraw', labelKey: 'premiumDrawLabel', languageCode: 'en', translatedText: 'Premium Draw' },
    { scopeKey: 'luckyDraw', labelKey: 'premiumDrawLabel', languageCode: 'zh', translatedText: 'é«˜çº§æŠ½å¥–' },
    { scopeKey: 'luckyDraw', labelKey: 'premiumDrawDescription', languageCode: 'en', translatedText: 'Higher chance to get rare rewards' },
    { scopeKey: 'luckyDraw', labelKey: 'premiumDrawDescription', languageCode: 'zh', translatedText: 'è·å¾—ç¨€æœ‰å¥–åŠ±çš„æ›´é«˜æœºä¼š' },
    { scopeKey: 'luckyDraw', labelKey: 'deluxeDrawLabel', languageCode: 'en', translatedText: 'Deluxe Draw' },
    { scopeKey: 'luckyDraw', labelKey: 'deluxeDrawLabel', languageCode: 'zh', translatedText: 'è±ªåæŠ½å¥–' },
    { scopeKey: 'luckyDraw', labelKey: 'deluxeDrawDescription', languageCode: 'en', translatedText: 'Highest chance to get epic and legendary rewards' },
    { scopeKey: 'luckyDraw', labelKey: 'deluxeDrawDescription', languageCode: 'zh', translatedText: 'è·å¾—å²è¯—å’Œä¼ è¯´å¥–åŠ±çš„æœ€é«˜æœºä¼š' },
    { scopeKey: 'luckyDraw', labelKey: 'notEnoughPointsError', languageCode: 'en', translatedText: 'Not enough lucky points' },
    { scopeKey: 'luckyDraw', labelKey: 'notEnoughPointsError', languageCode: 'zh', translatedText: 'å¹¸è¿ç‚¹ä¸è¶³' },
    { scopeKey: 'luckyDraw', labelKey: 'loadPointsError', languageCode: 'en', translatedText: 'Failed to load lucky points, please try again' },
    { scopeKey: 'luckyDraw', labelKey: 'loadPointsError', languageCode: 'zh', translatedText: 'åŠ è½½å¹¸è¿ç‚¹å¤±è´¥ï¼Œè¯·é‡è¯•' },
    { scopeKey: 'luckyDraw', labelKey: 'drawError', languageCode: 'en', translatedText: 'Failed to perform lucky draw, please try again' },
    { scopeKey: 'luckyDraw', labelKey: 'drawError', languageCode: 'zh', translatedText: 'æŠ½å¥–å¤±è´¥ï¼Œè¯·é‡è¯•' },
    { scopeKey: 'luckyDraw', labelKey: 'continueDrawingButton', languageCode: 'en', translatedText: 'Continue Drawing' },
    { scopeKey: 'luckyDraw', labelKey: 'continueDrawingButton', languageCode: 'zh', translatedText: 'ç»§ç»­æŠ½å¥–' },
    { scopeKey: 'luckyDraw', labelKey: 'closeButton', languageCode: 'en', translatedText: 'Close' },
    { scopeKey: 'luckyDraw', labelKey: 'closeButton', languageCode: 'zh', translatedText: 'å…³é—­' },
    { scopeKey: 'luckyDraw', labelKey: 'drawingButton', languageCode: 'en', translatedText: 'Drawing...' },
    { scopeKey: 'luckyDraw', labelKey: 'drawingButton', languageCode: 'zh', translatedText: 'æŠ½å¥–ä¸­...' },
    { scopeKey: 'luckyDraw', labelKey: 'drawButton', languageCode: 'en', translatedText: 'Draw' },
    { scopeKey: 'luckyDraw', labelKey: 'drawButton', languageCode: 'zh', translatedText: 'æŠ½å¥–' },

    // Challenge Discovery Card Labels
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'closeButtonAriaLabel', languageCode: 'en', translatedText: 'Close' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'closeButtonAriaLabel', languageCode: 'zh', translatedText: 'å…³é—­' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading challenge...' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: 'åŠ è½½æŒ‘æˆ˜ä¸­...' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'errorLoadingChallenge', languageCode: 'en', translatedText: 'Failed to load challenge, please try again' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'errorLoadingChallenge', languageCode: 'zh', translatedText: 'åŠ è½½æŒ‘æˆ˜å¤±è´¥ï¼Œè¯·é‡è¯•' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'cannotLoadChallenge', languageCode: 'en', translatedText: 'Unable to load challenge data' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'cannotLoadChallenge', languageCode: 'zh', translatedText: 'æ— æ³•åŠ è½½æŒ‘æˆ˜æ•°æ®' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'startDateLabel', languageCode: 'en', translatedText: 'Start Date' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'startDateLabel', languageCode: 'zh', translatedText: 'å¼€å§‹æ—¥æœŸ' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'endDateLabel', languageCode: 'en', translatedText: 'End Date' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'endDateLabel', languageCode: 'zh', translatedText: 'ç»“æŸæ—¥æœŸ' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'laterButton', languageCode: 'en', translatedText: 'Maybe Later' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'laterButton', languageCode: 'zh', translatedText: 'ç¨åå†è¯´' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'acceptButton', languageCode: 'en', translatedText: 'Accept Challenge' },
    { scopeKey: 'challengesView.challengeDiscoveryCard', labelKey: 'acceptButton', languageCode: 'zh', translatedText: 'æ¥å—æŒ‘æˆ˜' },

    // Challenge Recommendation Card Labels
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'matchScoreLabel', languageCode: 'en', translatedText: 'Match Score' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'matchScoreLabel', languageCode: 'zh', translatedText: 'åŒ¹é…åº¦' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyEasy', languageCode: 'en', translatedText: 'Easy' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyEasy', languageCode: 'zh', translatedText: 'ç®€å•' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyMedium', languageCode: 'en', translatedText: 'Medium' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyMedium', languageCode: 'zh', translatedText: 'ä¸­ç­‰' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyHard', languageCode: 'en', translatedText: 'Hard' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyHard', languageCode: 'zh', translatedText: 'å›°éš¾' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyExpert', languageCode: 'en', translatedText: 'Expert' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyExpert', languageCode: 'zh', translatedText: 'ä¸“å®¶' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyUnknown', languageCode: 'en', translatedText: 'Unknown' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'difficultyUnknown', languageCode: 'zh', translatedText: 'æœªçŸ¥' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'startDateLabel', languageCode: 'en', translatedText: 'Start Date' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'startDateLabel', languageCode: 'zh', translatedText: 'å¼€å§‹æ—¥æœŸ' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'endDateLabel', languageCode: 'en', translatedText: 'End Date' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'endDateLabel', languageCode: 'zh', translatedText: 'ç»“æŸæ—¥æœŸ' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'viewDetailsButton', languageCode: 'en', translatedText: 'View Details' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'viewDetailsButton', languageCode: 'zh', translatedText: 'æŸ¥çœ‹è¯¦æƒ…' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'acceptButton', languageCode: 'en', translatedText: 'Accept Challenge' },
    { scopeKey: 'challengesView.challengeRecommendationCard', labelKey: 'acceptButton', languageCode: 'zh', translatedText: 'æ¥å—æŒ‘æˆ˜' },

    // å•†åº—é¡µé¢æ ‡ç­¾
    { scopeKey: 'storeView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Store' },
    { scopeKey: 'storeView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: 'å•†åº—' },
    { scopeKey: 'storeView', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading store content...' },
    { scopeKey: 'storeView', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: 'åŠ è½½å•†åº—å†…å®¹...' },
    { scopeKey: 'storeView', labelKey: 'errorTitle', languageCode: 'en', translatedText: 'Store Page Error' },
    { scopeKey: 'storeView', labelKey: 'errorTitle', languageCode: 'zh', translatedText: 'å•†åº—é¡µé¢é”™è¯¯' },
    { scopeKey: 'storeView', labelKey: 'retryButtonText', languageCode: 'en', translatedText: 'Retry' },
    { scopeKey: 'storeView', labelKey: 'retryButtonText', languageCode: 'zh', translatedText: 'é‡è¯•' },
    { scopeKey: 'storeView.vipToggleButton', labelKey: 'showVip', languageCode: 'en', translatedText: 'View VIP Membership' },
    { scopeKey: 'storeView.vipToggleButton', labelKey: 'showVip', languageCode: 'zh', translatedText: 'æŸ¥çœ‹VIPä¼šå‘˜' },
    { scopeKey: 'storeView.vipToggleButton', labelKey: 'backToStore', languageCode: 'en', translatedText: 'Back to Store' },
    { scopeKey: 'storeView.vipToggleButton', labelKey: 'backToStore', languageCode: 'zh', translatedText: 'è¿”å›å•†åº—' },
    { scopeKey: 'storeView', labelKey: 'featuredItemsTitle', languageCode: 'en', translatedText: 'Featured Items' },
    { scopeKey: 'storeView', labelKey: 'featuredItemsTitle', languageCode: 'zh', translatedText: 'ç‰¹è‰²ç‰©å“' },
    { scopeKey: 'storeView', labelKey: 'saleItemsTitle', languageCode: 'en', translatedText: 'Sale Items' },
    { scopeKey: 'storeView', labelKey: 'saleItemsTitle', languageCode: 'zh', translatedText: 'ä¿ƒé”€ç‰©å“' },
    { scopeKey: 'storeView', labelKey: 'categoryItemsTitle', languageCode: 'en', translatedText: 'Category Items' },
    { scopeKey: 'storeView', labelKey: 'categoryItemsTitle', languageCode: 'zh', translatedText: 'åˆ†ç±»ç‰©å“' },
    { scopeKey: 'storeView', labelKey: 'noItemsMessage', languageCode: 'en', translatedText: 'No items in this category' },
    { scopeKey: 'storeView', labelKey: 'noItemsMessage', languageCode: 'zh', translatedText: 'è¯¥ç±»åˆ«æš‚æ— ç‰©å“' },

    // èŒ¶å®¤é¡µé¢æ ‡ç­¾
    { scopeKey: 'teaRoomView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Tea Room' },
    { scopeKey: 'teaRoomView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: 'é™å¿ƒèŒ¶å®¤' },
    { scopeKey: 'teaRoomView', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading tea room content...' },
    { scopeKey: 'teaRoomView', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: 'åŠ è½½èŒ¶å®¤å†…å®¹...' },
    { scopeKey: 'teaRoomView', labelKey: 'errorTitle', languageCode: 'en', translatedText: 'Tea Room Page Error' },
    { scopeKey: 'teaRoomView', labelKey: 'errorTitle', languageCode: 'zh', translatedText: 'èŒ¶å®¤é¡µé¢é”™è¯¯' },
    { scopeKey: 'teaRoomView', labelKey: 'retryButtonText', languageCode: 'en', translatedText: 'Retry' },
    { scopeKey: 'teaRoomView', labelKey: 'retryButtonText', languageCode: 'zh', translatedText: 'é‡è¯•' },
    { scopeKey: 'teaRoomView.moodTrackingSection', labelKey: 'title', languageCode: 'en', translatedText: 'Mood Tracking' },
    { scopeKey: 'teaRoomView.moodTrackingSection', labelKey: 'title', languageCode: 'zh', translatedText: 'æƒ…ç»ªè¿½è¸ª' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'title', languageCode: 'en', translatedText: 'Reflection' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'title', languageCode: 'zh', translatedText: 'åæ€' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'description', languageCode: 'en', translatedText: 'Take some time to reflect on your experiences, feelings, and thoughts to better understand yourself and find direction.' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'description', languageCode: 'zh', translatedText: 'èŠ±ç‚¹æ—¶é—´åæ€ä½ çš„ç»å†ã€æ„Ÿå—å’Œæƒ³æ³•ï¼Œå¯ä»¥å¸®åŠ©ä½ æ›´å¥½åœ°äº†è§£è‡ªå·±ï¼Œå¹¶æ‰¾åˆ°å‰è¿›çš„æ–¹å‘ã€‚' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'startReflectionButton', languageCode: 'en', translatedText: 'Start Reflection' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'startReflectionButton', languageCode: 'zh', translatedText: 'å¼€å§‹åæ€' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'viewHistoryButton', languageCode: 'en', translatedText: 'View Reflection History' },
    { scopeKey: 'teaRoomView.reflectionSection', labelKey: 'viewHistoryButton', languageCode: 'zh', translatedText: 'æŸ¥çœ‹å†å²åæ€' },
    { scopeKey: 'teaRoomView.dailyTipSection', labelKey: 'title', languageCode: 'en', translatedText: 'Daily Wisdom' },
    { scopeKey: 'teaRoomView.dailyTipSection', labelKey: 'title', languageCode: 'zh', translatedText: 'æ¯æ—¥æ™ºæ…§' },
    { scopeKey: 'teaRoomView.dailyTipSection', labelKey: 'content', languageCode: 'en', translatedText: 'Self-compassion is an essential part of mental health. When facing difficulties, try to treat yourself as you would a good friend, with understanding and kindness.' },
    { scopeKey: 'teaRoomView.dailyTipSection', labelKey: 'content', languageCode: 'zh', translatedText: 'è‡ªæˆ‘å…³æ€€æ˜¯å¿ƒç†å¥åº·çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚é¢å¯¹å›°éš¾æ—¶ï¼Œè¯•ç€åƒå¯¹å¾…å¥½æœ‹å‹ä¸€æ ·å¯¹å¾…è‡ªå·±ï¼Œç»™äºˆç†è§£å’Œå–„æ„ã€‚' },

    // èƒ½åŠ›é¡µé¢æ ‡ç­¾
    { scopeKey: 'abilitiesView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Panda Abilities' },
    { scopeKey: 'abilitiesView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: 'ç†ŠçŒ«èƒ½åŠ›' },
    { scopeKey: 'abilitiesView', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading abilities...' },
    { scopeKey: 'abilitiesView', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: 'åŠ è½½èƒ½åŠ›ä¸­...' },
    { scopeKey: 'abilitiesView', labelKey: 'errorTitle', languageCode: 'en', translatedText: 'Abilities Page Error' },
    { scopeKey: 'abilitiesView', labelKey: 'errorTitle', languageCode: 'zh', translatedText: 'èƒ½åŠ›é¡µé¢é”™è¯¯' },
    { scopeKey: 'abilitiesView', labelKey: 'errorMessage', languageCode: 'en', translatedText: 'Failed to load abilities' },
    { scopeKey: 'abilitiesView', labelKey: 'errorMessage', languageCode: 'zh', translatedText: 'åŠ è½½èƒ½åŠ›å¤±è´¥' },
    { scopeKey: 'abilitiesView', labelKey: 'retryButtonText', languageCode: 'en', translatedText: 'Retry' },
    { scopeKey: 'abilitiesView', labelKey: 'retryButtonText', languageCode: 'zh', translatedText: 'é‡è¯•' },
    { scopeKey: 'abilitiesView', labelKey: 'pandaLevelLabel', languageCode: 'en', translatedText: 'Panda Level' },
    { scopeKey: 'abilitiesView', labelKey: 'pandaLevelLabel', languageCode: 'zh', translatedText: 'ç†ŠçŒ«ç­‰çº§' },
    { scopeKey: 'abilitiesView', labelKey: 'unlockedAbilitiesLabel', languageCode: 'en', translatedText: 'Unlocked Abilities' },
    { scopeKey: 'abilitiesView', labelKey: 'unlockedAbilitiesLabel', languageCode: 'zh', translatedText: 'å·²è§£é”èƒ½åŠ›' },
    { scopeKey: 'abilitiesView', labelKey: 'abilitiesDescription', languageCode: 'en', translatedText: 'Abilities are special powers that your panda can use to help you in your tasks.' },
    { scopeKey: 'abilitiesView', labelKey: 'abilitiesDescription', languageCode: 'zh', translatedText: 'èƒ½åŠ›æ˜¯ç†ŠçŒ«å¯ä»¥ä½¿ç”¨çš„ç‰¹æ®ŠåŠ›é‡ï¼Œå¯ä»¥å¸®åŠ©ä½ å®Œæˆä»»åŠ¡ã€‚' },
    { scopeKey: 'abilitiesView', labelKey: 'noAbilitiesMessage', languageCode: 'en', translatedText: 'No abilities found' },
    { scopeKey: 'abilitiesView', labelKey: 'noAbilitiesMessage', languageCode: 'zh', translatedText: 'æš‚æ— èƒ½åŠ›' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'statusLabel', languageCode: 'en', translatedText: 'Status' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'statusLabel', languageCode: 'zh', translatedText: 'çŠ¶æ€' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'typeLabel', languageCode: 'zh', translatedText: 'ç±»å‹' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'allLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'allLabel', languageCode: 'zh', translatedText: 'å…¨éƒ¨' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'unlockedLabel', languageCode: 'en', translatedText: 'Unlocked' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'unlockedLabel', languageCode: 'zh', translatedText: 'å·²è§£é”' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'activeLabel', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'activeLabel', languageCode: 'zh', translatedText: 'å·²æ¿€æ´»' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'lockedLabel', languageCode: 'en', translatedText: 'Locked' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'lockedLabel', languageCode: 'zh', translatedText: 'å·²é”å®š' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'passiveLabel', languageCode: 'en', translatedText: 'Passive' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'passiveLabel', languageCode: 'zh', translatedText: 'è¢«åŠ¨' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'ultimateLabel', languageCode: 'en', translatedText: 'Ultimate' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'ultimateLabel', languageCode: 'zh', translatedText: 'ç»ˆæ' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'clearFiltersLabel', languageCode: 'en', translatedText: 'Clear All Filters' },
    { scopeKey: 'abilitiesView.filters', labelKey: 'clearFiltersLabel', languageCode: 'zh', translatedText: 'æ¸…é™¤æ‰€æœ‰è¿‡æ»¤å™¨' },

    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typePassive', languageCode: 'en', translatedText: 'Passive' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typePassive', languageCode: 'zh', translatedText: 'è¢«åŠ¨' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typeActive', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typeActive', languageCode: 'zh', translatedText: 'ä¸»åŠ¨' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typeUltimate', languageCode: 'en', translatedText: 'Ultimate' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typeUltimate', languageCode: 'zh', translatedText: 'ç»ˆæ' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typeUnknown', languageCode: 'en', translatedText: 'Unknown' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'typeUnknown', languageCode: 'zh', translatedText: 'æœªçŸ¥' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityCommon', languageCode: 'en', translatedText: 'Common' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityCommon', languageCode: 'zh', translatedText: 'æ™®é€š' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityUncommon', languageCode: 'en', translatedText: 'Uncommon' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityUncommon', languageCode: 'zh', translatedText: 'ä¸å¸¸è§' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityRare', languageCode: 'en', translatedText: 'Rare' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityRare', languageCode: 'zh', translatedText: 'ç¨€æœ‰' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityEpic', languageCode: 'en', translatedText: 'Epic' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityEpic', languageCode: 'zh', translatedText: 'å²è¯—' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityLegendary', languageCode: 'en', translatedText: 'Legendary' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'rarityLegendary', languageCode: 'zh', translatedText: 'ä¼ è¯´' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'requiredLevelLabel', languageCode: 'en', translatedText: 'Required Level' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'requiredLevelLabel', languageCode: 'zh', translatedText: 'éœ€è¦ç­‰çº§' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'cooldownLabel', languageCode: 'en', translatedText: 'Cooldown' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'cooldownLabel', languageCode: 'zh', translatedText: 'å†·å´æ—¶é—´' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'cooldownRemainingLabel', languageCode: 'en', translatedText: 'Cooling down' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'cooldownRemainingLabel', languageCode: 'zh', translatedText: 'å†·å´ä¸­' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'activateButtonText', languageCode: 'en', translatedText: 'Activate Ability' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'activateButtonText', languageCode: 'zh', translatedText: 'æ¿€æ´»èƒ½åŠ›' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'alreadyActivatedText', languageCode: 'en', translatedText: 'Already Activated' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'alreadyActivatedText', languageCode: 'zh', translatedText: 'å·²æ¿€æ´»' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'minutesUnit', languageCode: 'en', translatedText: 'min' },
    { scopeKey: 'abilitiesView.abilityCard', labelKey: 'minutesUnit', languageCode: 'zh', translatedText: 'åˆ†é’Ÿ' },

    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'title', languageCode: 'en', translatedText: 'Ability Details' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'title', languageCode: 'zh', translatedText: 'èƒ½åŠ›è¯¦æƒ…' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'requiredLevelLabel', languageCode: 'en', translatedText: 'Required Level' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'requiredLevelLabel', languageCode: 'zh', translatedText: 'è§£é”ç­‰çº§' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'levelsNeededText', languageCode: 'en', translatedText: 'Need' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'levelsNeededText', languageCode: 'zh', translatedText: 'è¿˜éœ€' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'cooldownLabel', languageCode: 'en', translatedText: 'Cooldown' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'cooldownLabel', languageCode: 'zh', translatedText: 'å†·å´æ—¶é—´' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'rarityLabel', languageCode: 'en', translatedText: 'Rarity' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'rarityLabel', languageCode: 'zh', translatedText: 'ç¨€æœ‰åº¦' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'typeLabel', languageCode: 'zh', translatedText: 'ç±»å‹' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'effectLabel', languageCode: 'en', translatedText: 'Effect Value' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'effectLabel', languageCode: 'zh', translatedText: 'æ•ˆæœå€¼' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'activateButtonText', languageCode: 'en', translatedText: 'Activate Ability' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'activateButtonText', languageCode: 'zh', translatedText: 'æ¿€æ´»èƒ½åŠ›' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'alreadyActivatedText', languageCode: 'en', translatedText: 'Already Activated' },
    { scopeKey: 'abilitiesView.abilityDetail', labelKey: 'alreadyActivatedText', languageCode: 'zh', translatedText: 'å·²æ¿€æ´»' },

    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'title', languageCode: 'en', translatedText: 'Ability Unlocked' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'title', languageCode: 'zh', translatedText: 'èƒ½åŠ›è§£é”' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'newAbilityTitle', languageCode: 'en', translatedText: 'New Ability Unlocked!' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'newAbilityTitle', languageCode: 'zh', translatedText: 'è§£é”æ–°èƒ½åŠ›ï¼' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'nextButtonText', languageCode: 'en', translatedText: 'Next Ability' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'nextButtonText', languageCode: 'zh', translatedText: 'ä¸‹ä¸€ä¸ªèƒ½åŠ›' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'viewAllButtonText', languageCode: 'en', translatedText: 'View All Abilities' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'viewAllButtonText', languageCode: 'zh', translatedText: 'æŸ¥çœ‹æ‰€æœ‰èƒ½åŠ›' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'allUnlockedTitle', languageCode: 'en', translatedText: 'Newly Unlocked Abilities' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'allUnlockedTitle', languageCode: 'zh', translatedText: 'æ–°è§£é”çš„èƒ½åŠ›' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'closeButtonText', languageCode: 'en', translatedText: 'Close' },
    { scopeKey: 'abilitiesView.abilityUnlockNotification', labelKey: 'closeButtonText', languageCode: 'zh', translatedText: 'å…³é—­' },

    // Ability names and descriptions
    { scopeKey: 'abilities', labelKey: 'bambooHeart.name', languageCode: 'en', translatedText: 'Bamboo Heart' },
    { scopeKey: 'abilities', labelKey: 'bambooHeart.name', languageCode: 'zh', translatedText: 'ç«¹æ—ä¹‹å¿ƒ' },
    { scopeKey: 'abilities', labelKey: 'bambooHeart.description', languageCode: 'en', translatedText: 'Passive: Increases experience gained from completing tasks by 10%' },
    { scopeKey: 'abilities', labelKey: 'bambooHeart.description', languageCode: 'zh', translatedText: 'è¢«åŠ¨ï¼šå®Œæˆä»»åŠ¡æ—¶è·å¾—çš„ç»éªŒå€¼å¢åŠ 10%' },

    { scopeKey: 'abilities', labelKey: 'pandaVitality.name', languageCode: 'en', translatedText: 'Panda Vitality' },
    { scopeKey: 'abilities', labelKey: 'pandaVitality.name', languageCode: 'zh', translatedText: 'ç†ŠçŒ«æ´»åŠ›' },
    { scopeKey: 'abilities', labelKey: 'pandaVitality.description', languageCode: 'en', translatedText: 'Passive: Increases panda energy recovery rate by 15%' },
    { scopeKey: 'abilities', labelKey: 'pandaVitality.description', languageCode: 'zh', translatedText: 'è¢«åŠ¨ï¼šç†ŠçŒ«èƒ½é‡æ¢å¤é€Ÿåº¦æé«˜15%' },

    { scopeKey: 'abilities', labelKey: 'bambooFocus.name', languageCode: 'en', translatedText: 'Bamboo Focus' },
    { scopeKey: 'abilities', labelKey: 'bambooFocus.name', languageCode: 'zh', translatedText: 'ç«¹å½±ä¸“æ³¨' },
    { scopeKey: 'abilities', labelKey: 'bambooFocus.description', languageCode: 'en', translatedText: 'Active: When activated, increases experience gained from completing tasks by 25% for 1 hour' },
    { scopeKey: 'abilities', labelKey: 'bambooFocus.description', languageCode: 'zh', translatedText: 'ä¸»åŠ¨ï¼šæ¿€æ´»åï¼Œ1å°æ—¶å†…å®Œæˆä»»åŠ¡è·å¾—çš„ç»éªŒå€¼å¢åŠ 25%' },

    { scopeKey: 'abilities', labelKey: 'pandaWisdom.name', languageCode: 'en', translatedText: 'Panda Wisdom' },
    { scopeKey: 'abilities', labelKey: 'pandaWisdom.name', languageCode: 'zh', translatedText: 'ç†ŠçŒ«æ™ºæ…§' },
    { scopeKey: 'abilities', labelKey: 'pandaWisdom.description', languageCode: 'en', translatedText: 'Active: When activated, increases rewards from completed tasks by 20% for 2 hours' },
    { scopeKey: 'abilities', labelKey: 'pandaWisdom.description', languageCode: 'zh', translatedText: 'ä¸»åŠ¨ï¼šæ¿€æ´»åï¼Œ2å°æ—¶å†…ä»»åŠ¡å®Œæˆå¥–åŠ±æ•°é‡å¢åŠ 20%' },

    { scopeKey: 'abilities', labelKey: 'bambooMaster.name', languageCode: 'en', translatedText: 'Bamboo Master' },
    { scopeKey: 'abilities', labelKey: 'bambooMaster.name', languageCode: 'zh', translatedText: 'ç«¹æ—å¤§å¸ˆ' },
    { scopeKey: 'abilities', labelKey: 'bambooMaster.description', languageCode: 'en', translatedText: 'Ultimate: When activated, increases all ability effects by 50% for 4 hours' },
    { scopeKey: 'abilities', labelKey: 'bambooMaster.description', languageCode: 'zh', translatedText: 'ç»ˆæï¼šæ¿€æ´»åï¼Œ4å°æ—¶å†…æ‰€æœ‰èƒ½åŠ›æ•ˆæœæå‡50%' },

    // åŠæ—¶å¥–åŠ±é¡µé¢æ ‡ç­¾
    { scopeKey: 'timelyRewardsView', labelKey: 'pageTitle', languageCode: 'en', translatedText: 'Timely Rewards' },
    { scopeKey: 'timelyRewardsView', labelKey: 'pageTitle', languageCode: 'zh', translatedText: 'åŠæ—¶å¥–åŠ±' },
    { scopeKey: 'timelyRewardsView', labelKey: 'loadingMessage', languageCode: 'en', translatedText: 'Loading rewards...' },
    { scopeKey: 'timelyRewardsView', labelKey: 'loadingMessage', languageCode: 'zh', translatedText: 'åŠ è½½å¥–åŠ±ä¸­...' },
    { scopeKey: 'timelyRewardsView', labelKey: 'errorTitle', languageCode: 'en', translatedText: 'Timely Rewards Page Error' },
    { scopeKey: 'timelyRewardsView', labelKey: 'errorTitle', languageCode: 'zh', translatedText: 'åŠæ—¶å¥–åŠ±é¡µé¢é”™è¯¯' },
    { scopeKey: 'timelyRewardsView', labelKey: 'noRewardsMessage', languageCode: 'en', translatedText: 'No rewards found' },
    { scopeKey: 'timelyRewardsView', labelKey: 'noRewardsMessage', languageCode: 'zh', translatedText: 'æš‚æ— å¥–åŠ±' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusLabel', languageCode: 'en', translatedText: 'Status' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusLabel', languageCode: 'zh', translatedText: 'çŠ¶æ€' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'allLabel', languageCode: 'en', translatedText: 'All' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'allLabel', languageCode: 'zh', translatedText: 'å…¨éƒ¨' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusActiveLabel', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusActiveLabel', languageCode: 'zh', translatedText: 'è¿›è¡Œä¸­' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusCompletedLabel', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusCompletedLabel', languageCode: 'zh', translatedText: 'å·²å®Œæˆ' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusExpiredLabel', languageCode: 'en', translatedText: 'Expired' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'statusExpiredLabel', languageCode: 'zh', translatedText: 'å·²è¿‡æœŸ' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeLabel', languageCode: 'zh', translatedText: 'ç±»å‹' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeDailyLabel', languageCode: 'en', translatedText: 'Daily' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeDailyLabel', languageCode: 'zh', translatedText: 'æ¯æ—¥' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeWeeklyLabel', languageCode: 'en', translatedText: 'Weekly' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeWeeklyLabel', languageCode: 'zh', translatedText: 'æ¯å‘¨' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeStreakLabel', languageCode: 'en', translatedText: 'Streak' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeStreakLabel', languageCode: 'zh', translatedText: 'è¿ç»­å®Œæˆ' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeSpecialLabel', languageCode: 'en', translatedText: 'Special' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'typeSpecialLabel', languageCode: 'zh', translatedText: 'ç‰¹æ®Š' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'clearFiltersLabel', languageCode: 'en', translatedText: 'Clear All Filters' },
    { scopeKey: 'timelyRewardsView.filters', labelKey: 'clearFiltersLabel', languageCode: 'zh', translatedText: 'æ¸…é™¤æ‰€æœ‰è¿‡æ»¤å™¨' },
    { scopeKey: 'timelyRewardsView.luckyDraw', labelKey: 'buttonText', languageCode: 'en', translatedText: 'Lucky Draw' },
    { scopeKey: 'timelyRewardsView.luckyDraw', labelKey: 'buttonText', languageCode: 'zh', translatedText: 'å¹¸è¿æŠ½å¥–' },
    { scopeKey: 'timelyRewardsView.luckyDraw', labelKey: 'title', languageCode: 'en', translatedText: 'Lucky Draw' },
    { scopeKey: 'timelyRewardsView.luckyDraw', labelKey: 'title', languageCode: 'zh', translatedText: 'å¹¸è¿æŠ½å¥–' },

    // TimelyRewardCard ç»„ä»¶æ ‡ç­¾
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeLabel', languageCode: 'en', translatedText: 'Type' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeLabel', languageCode: 'zh', translatedText: 'ç±»å‹' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeDaily', languageCode: 'en', translatedText: 'Daily Reward' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeDaily', languageCode: 'zh', translatedText: 'æ¯æ—¥å¥–åŠ±' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeMorning', languageCode: 'en', translatedText: 'Early Bird Reward' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeMorning', languageCode: 'zh', translatedText: 'æ—©èµ·é¸Ÿå¥–åŠ±' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeStreak', languageCode: 'en', translatedText: 'Streak Reward' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeStreak', languageCode: 'zh', translatedText: 'è¿ç»­å®Œæˆå¥–åŠ±' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeSpecial', languageCode: 'en', translatedText: 'Special Reward' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'typeSpecial', languageCode: 'zh', translatedText: 'ç‰¹æ®Šå¥–åŠ±' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusLabel', languageCode: 'en', translatedText: 'Status' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusLabel', languageCode: 'zh', translatedText: 'çŠ¶æ€' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusActive', languageCode: 'en', translatedText: 'Active' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusActive', languageCode: 'zh', translatedText: 'è¿›è¡Œä¸­' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusCompleted', languageCode: 'en', translatedText: 'Completed' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusCompleted', languageCode: 'zh', translatedText: 'å·²å®Œæˆ' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusExpired', languageCode: 'en', translatedText: 'Expired' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusExpired', languageCode: 'zh', translatedText: 'å·²è¿‡æœŸ' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusUpcoming', languageCode: 'en', translatedText: 'Upcoming' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'statusUpcoming', languageCode: 'zh', translatedText: 'å³å°†å¼€å§‹' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'remainingTimeLabel', languageCode: 'en', translatedText: 'Remaining time' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'remainingTimeLabel', languageCode: 'zh', translatedText: 'å‰©ä½™æ—¶é—´' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'timeEnded', languageCode: 'en', translatedText: 'Ended' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'timeEnded', languageCode: 'zh', translatedText: 'å·²ç»“æŸ' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'hourUnit', languageCode: 'en', translatedText: 'h' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'hourUnit', languageCode: 'zh', translatedText: 'å°æ—¶' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'minuteUnit', languageCode: 'en', translatedText: 'm' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'minuteUnit', languageCode: 'zh', translatedText: 'åˆ†é’Ÿ' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'luckyPointsLabel', languageCode: 'en', translatedText: 'Lucky Points' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'luckyPointsLabel', languageCode: 'zh', translatedText: 'å¹¸è¿ç‚¹' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'claimRewardButton', languageCode: 'en', translatedText: 'Claim Reward' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'claimRewardButton', languageCode: 'zh', translatedText: 'é¢†å–å¥–åŠ±' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'inProgressButton', languageCode: 'en', translatedText: 'In Progress...' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'inProgressButton', languageCode: 'zh', translatedText: 'è¿›è¡Œä¸­...' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedOnLabel', languageCode: 'en', translatedText: 'Completed on' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedOnLabel', languageCode: 'zh', translatedText: 'å®Œæˆäº' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'progressLabel', languageCode: 'en', translatedText: 'Progress' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'progressLabel', languageCode: 'zh', translatedText: 'è¿›åº¦' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'startTimeLabel', languageCode: 'en', translatedText: 'Start Time' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'startTimeLabel', languageCode: 'zh', translatedText: 'å¼€å§‹æ—¶é—´' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'endTimeLabel', languageCode: 'en', translatedText: 'End Time' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'endTimeLabel', languageCode: 'zh', translatedText: 'ç»“æŸæ—¶é—´' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedTimeLabel', languageCode: 'en', translatedText: 'Completed Time' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'completedTimeLabel', languageCode: 'zh', translatedText: 'å®Œæˆæ—¶é—´' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'continueEffortButton', languageCode: 'en', translatedText: 'Keep Going' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'continueEffortButton', languageCode: 'zh', translatedText: 'ç»§ç»­åŠªåŠ›' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'noRewardsMessage', languageCode: 'en', translatedText: 'No timely rewards available' },
    { scopeKey: 'timelyRewardsView.rewardCard', labelKey: 'noRewardsMessage', languageCode: 'zh', translatedText: 'æš‚æ— åŠæ—¶å¥–åŠ±' },
  ];
  await db.uiLabels.bulkAdd(labels);
  console.log("Final V3 DB populated.");
}
</file>

<file path="src/router.tsx">
// src/router.tsx
import React, { Suspense, lazy } from 'react';
import { Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { AnimatePresence } from 'framer-motion';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// Lazy load page components
const HomePage = lazy(() => import('@/pages/HomePage'));
const SettingsPage = lazy(() => import('@/pages/SettingsPage'));
const TasksPage = lazy(() => import('@/pages/TasksPage'));
const AbilitiesPage = lazy(() => import('@/pages/AbilitiesPage'));
const ChallengesPage = lazy(() => import('@/pages/ChallengesPage'));
const TimelyRewardsPage = lazy(() => import('@/pages/TimelyRewardsPage'));
const TeaRoomPage = lazy(() => import('@/pages/TeaRoomPage'));
const StorePage = lazy(() => import('@/pages/StorePage'));

const AppRouter: React.FC = () => {
  const location = useLocation();

  return (
    <Suspense fallback={<LoadingSpinner variant="jade" text="Loading view..." />}>
      <Routes location={location}>
        <Route path="/" element={<HomePage />} />
        <Route path="/tasks" element={<TasksPage />} />
        <Route path="/abilities" element={<AbilitiesPage />} />
        <Route path="/challenges" element={<ChallengesPage />} />
        <Route path="/rewards" element={<TimelyRewardsPage />} />
        <Route path="/tearoom" element={<TeaRoomPage />} />
        <Route path="/store" element={<StorePage />} />
        <Route path="/settings" element={<SettingsPage />} />
        <Route path="*" element={<Navigate to="/" replace />} /> {/* Fallback route */}
      </Routes>
    </Suspense>
  );
};
export default AppRouter;
</file>

<file path="src/services/localizedContentService.ts">
import { db } from '@/db';
import type {
  Language, LocalizedContent,
  HomePageViewLabelsBundle, HomePageViewDataPayload, MoodItem,
  SettingsPageViewLabelsBundle,
  TasksPageViewLabelsBundle,
  ChallengesPageViewLabelsBundle,
  TimelyRewardsPageViewLabelsBundle,
  AbilitiesPageViewLabelsBundle,
  StorePageViewLabelsBundle,
  TeaRoomPageViewLabelsBundle,
  GlobalLayoutLabelsBundle,
  ComponentsLabelsBundle,
  UILabelRecord, ApiError,
  FetchHomePageViewResult, FetchSettingsPageViewResult, FetchGlobalLayoutViewResult,
  FetchTasksPageViewResult, FetchChallengesPageViewResult, FetchTimelyRewardsPageViewResult,
  FetchAbilitiesPageViewResult, FetchStorePageViewResult, FetchTeaRoomPageViewResult,
  FetchComponentsLabelsResult
} from '@/types';

const SIMULATED_DELAY_MS = 150;

function buildLabelsObject<TLabelsBundle>(records: UILabelRecord[], baseScope: string): TLabelsBundle {
  const labels = {} as any;
  records.forEach(record => {
    let keyPath = record.labelKey;
    if (record.scopeKey.startsWith(baseScope + '.') && record.scopeKey.length > baseScope.length) {
        const sectionPath = record.scopeKey.substring(baseScope.length + 1);
        keyPath = `${sectionPath}.${record.labelKey}`;
    } else if (record.scopeKey !== baseScope) {
        // This label is not directly under baseScope or a direct sub-scope path, might be an issue or intended for a different structure.
        // For this demo, we'll assume labels fetched by getScopedLabels are correctly targeted.
        // console.warn(`Label with key ${record.labelKey} has scope ${record.scopeKey} which is not directly under or part of ${baseScope}`);
    }

    const keys = keyPath.split('.');
    let current = labels;
    keys.forEach((key, index) => {
      if (index === keys.length - 1) {
        current[key] = record.translatedText;
      } else {
        current[key] = current[key] || {};
        current = current[key];
      }
    });
  });
  return labels as TLabelsBundle;
}

async function getScopedLabels<TLabelsBundle>(baseScopeKey: string, lang: Language): Promise<TLabelsBundle> {
  let labelRecords = await db.uiLabels
    .where('languageCode').equals(lang)
    .and((record: UILabelRecord) => record.scopeKey.startsWith(baseScopeKey))
    .toArray();

  if (!labelRecords.length && lang !== 'en') {
    console.warn(`No '${lang}' labels for scope ${baseScopeKey}, falling back to 'en'`);
    labelRecords = await db.uiLabels
      .where('languageCode').equals('en')
      .and((record: UILabelRecord) => record.scopeKey.startsWith(baseScopeKey))
      .toArray();
  }

  if (!labelRecords.length) {
    const errorMessage = `CRITICAL: No labels found for essential scope ${baseScopeKey} (lang: ${lang} or fallback 'en').`;
    console.error(errorMessage);
    // In a real app, you might throw an error or have a more robust fallback
    return {} as TLabelsBundle;
  }
  return buildLabelsObject<TLabelsBundle>(labelRecords, baseScopeKey);
}

export async function fetchGlobalLayoutView(lang: Language): Promise<FetchGlobalLayoutViewResult> {
  console.log(`SVC_DEXIE: Fetching GLOBAL LAYOUT VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<GlobalLayoutLabelsBundle>('globalLayout', lang);
  return { labels, data: null };
}

export async function fetchHomePageView(lang: Language): Promise<FetchHomePageViewResult> {
  console.log(`SVC_DEXIE: Fetching HOME PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS));
  const labels = await getScopedLabels<HomePageViewLabelsBundle>('homeView', lang);

  const moods: MoodItem[] = [
    { id: 1, name: labels.moodsSection?.sectionTitle || (lang === 'zh' ? 'å¿ƒæƒ…' : 'Moods'), feeling: lang === 'zh' ? 'ä¸“æ³¨çš„' : 'Focused' },
    { id: 2, name: lang === 'zh' ? 'é”»ç‚¼ä¼šè®®' : 'Workout Session', feeling: lang === 'zh' ? 'ç²¾åŠ›å……æ²›çš„' : 'Energized' },
  ];
  const data: HomePageViewDataPayload = { username: "DevUser", moods };
  return { labels, data };
}

export async function fetchSettingsPageView(lang: Language): Promise<FetchSettingsPageViewResult> {
  console.log(`SVC_DEXIE: Fetching SETTINGS PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<SettingsPageViewLabelsBundle>('settingsView', lang);
  return { labels, data: null };
}

export async function fetchTasksPageView(lang: Language): Promise<FetchTasksPageViewResult> {
  console.log(`SVC_DEXIE: Fetching TASKS PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<TasksPageViewLabelsBundle>('tasksView', lang);
  return { labels, data: null };
}

export async function fetchChallengesPageView(lang: Language): Promise<FetchChallengesPageViewResult> {
  console.log(`SVC_DEXIE: Fetching CHALLENGES PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<ChallengesPageViewLabelsBundle>('challengesView', lang);
  return { labels, data: null };
}

export async function fetchTimelyRewardsPageView(lang: Language): Promise<FetchTimelyRewardsPageViewResult> {
  console.log(`SVC_DEXIE: Fetching TIMELY REWARDS PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<TimelyRewardsPageViewLabelsBundle>('timelyRewardsView', lang);
  return { labels, data: null };
}

export async function fetchAbilitiesPageView(lang: Language): Promise<FetchAbilitiesPageViewResult> {
  console.log(`SVC_DEXIE: Fetching ABILITIES PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<AbilitiesPageViewLabelsBundle>('abilitiesView', lang);
  return { labels, data: null };
}

export async function fetchStorePageView(lang: Language): Promise<FetchStorePageViewResult> {
  console.log(`SVC_DEXIE: Fetching STORE PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<StorePageViewLabelsBundle>('storeView', lang);
  return { labels, data: null };
}

export async function fetchTeaRoomPageView(lang: Language): Promise<FetchTeaRoomPageViewResult> {
  console.log(`SVC_DEXIE: Fetching TEA ROOM PAGE VIEW for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<TeaRoomPageViewLabelsBundle>('teaRoomView', lang);
  return { labels, data: null };
}

/**
 * Fetches localized labels for common UI components
 *
 * @param lang - The language to fetch labels for
 * @returns A promise that resolves to the localized component labels
 */
export async function fetchComponentsLabels(lang: Language): Promise<FetchComponentsLabelsResult> {
  console.log(`SVC_DEXIE: Fetching COMPONENTS LABELS for lang: ${lang}`);
  await new Promise(r => setTimeout(r, SIMULATED_DELAY_MS / 2));
  const labels = await getScopedLabels<ComponentsLabelsBundle>('components', lang);
  return { labels, data: null };
}
</file>

<file path="src/types/index.ts">
// src/types/index.ts
export type Language = "en" | "zh";

export interface LanguageContextType {
  language: Language;
  setLanguage: (lang: Language) => void;
}

export interface ApiError extends Error { errorCode?: string; statusCode?: number; }

// Structure for Dexie uiLabels store
export interface UILabelRecord {
  id?: number;
  scopeKey: string; // e.g., "globalLayout", "homeView", "homeView.welcomeSection", "components.button"
  labelKey: string; // e.g., "appTitle", "welcomeMessage", "confirmText"
  languageCode: Language;
  translatedText: string;
}

// --- Generic Localized Content Structure (from services) ---
export interface LocalizedContent<TDataPayload, TLabelsBundle> {
  labels: TLabelsBundle;
  data: TDataPayload | null;
}

// --- Common Components Labels ---
export interface ButtonLabels {
  loading: string;
  retry: string;
  confirm: string;
  cancel: string;
  save: string;
  close: string;
  submit: string;
  edit: string;
  delete: string;
  back: string;
  next: string;
}

export interface LoadingLabels {
  generic: string;
  data: string;
  content: string;
  saving: string;
  processing: string;
}

export interface ErrorLabels {
  generic: string;
  title: string;
  retry: string;
  details: string;
  networkError: string;
  serverError: string;
  unknownError: string;
}

export interface EmptyStateLabels {
  generic: string;
  noData: string;
  noResults: string;
  noItems: string;
}

export interface ModalLabels {
  close: string;
  confirm: string;
  cancel: string;
}

export interface TaskReminderLabels {
  title: string;
  subtitle: string;
  defaultMessage: string;
  reminderTimeLabel: string;
  dismissButton: string;
  laterButton: string;
  viewTaskButton: string;
  unknownTask: string;
}

export interface ComponentsLabelsBundle {
  button: ButtonLabels;
  loading: LoadingLabels;
  error: ErrorLabels;
  emptyState: EmptyStateLabels;
  modal: ModalLabels;
  taskReminder: TaskReminderLabels;
}

export type FetchComponentsLabelsResult = LocalizedContent<null, ComponentsLabelsBundle>;

// --- Global / Layout Content Types ---
export interface GlobalLayoutLabelsBundle {
  appTitle: string;
  navHome: string;
  navTasks: string;
  navAbilities: string;
  navRewards: string;
  navChallenges: string;
  navSettings: string;
  footerText: string;
  loadingGeneric: string;
  errorGeneric: string;
  appErrorHeading?: string;
  appErrorGeneralMessage?: string;
}
export type FetchGlobalLayoutViewResult = LocalizedContent<null, GlobalLayoutLabelsBundle>;

// --- Home Page/View Specific Types ---
export interface HomeWelcomeSectionLabels {
  welcomeMessage: string;
}
export interface MoodItem { readonly id: number; readonly name: string; readonly feeling: string; }
export interface HomeMoodsSectionLabels {
  sectionTitle: string;
  noMoodsMessage: string;
  refreshButtonText: string;
}
export interface HomePandaSectionLabels {
  sectionTitle: string;
  levelLabel: string;
  experienceLabel: string;
  interactButtonText: string;
  feedButtonText: string;
  playButtonText: string;
  trainButtonText: string;
}
export interface HomePageViewLabelsBundle {
  pageTitle: string;
  welcomeSection: HomeWelcomeSectionLabels;
  moodsSection: HomeMoodsSectionLabels;
  pandaSection: HomePandaSectionLabels;
  someActionText: string; // Example of a page-level label for a generic action
}
export interface HomePageViewDataPayload {
  username: string;
  moods: readonly MoodItem[];
}
export type FetchHomePageViewResult = LocalizedContent<HomePageViewDataPayload, HomePageViewLabelsBundle>;

// --- Settings Page/View Specific Types ---
export interface SettingsLanguageSectionLabels {
  sectionTitle: string;
  selectLanguagePrompt: string;
  currentLanguageIs: string;
  langNameEn: string;
  langNameZh: string;
  saveButtonText: string;
  successMessage: string;
}
export interface SettingsPageViewLabelsBundle {
  pageTitle: string;
  languageSection: SettingsLanguageSectionLabels;
}
export type FetchSettingsPageViewResult = LocalizedContent<null, SettingsPageViewLabelsBundle>;

// --- Tasks Page/View Specific Types ---
export interface TaskManagerLabels {
  sectionTitle: string;
  createTaskButton: string;
  filterAllLabel: string;
  filterTodoLabel: string;
  filterInProgressLabel: string;
  filterCompletedLabel: string;
  noTasksMessage: string;
}
export interface TasksPageViewLabelsBundle {
  pageTitle: string;
  taskManager: TaskManagerLabels;
  loadingMessage?: string;
  errorTitle?: string;
  errorMessage?: string;
  retryButtonText?: string;
}
export type FetchTasksPageViewResult = LocalizedContent<null, TasksPageViewLabelsBundle>;

// --- Challenges Page/View Specific Types ---
export interface ChallengeFilterLabels {
  statusLabel: string;
  typeLabel: string;
  difficultyLabel: string;
  allLabel: string;
  activeLabel: string;
  completedLabel: string;
  upcomingLabel: string;
  typeAllLabel: string;
  typeDailyLabel: string;
  typeWeeklyLabel: string;
  typeEventLabel: string;
  typeOngoingLabel: string;
  difficultyAllLabel: string;
  difficultyEasyLabel: string;
  difficultyMediumLabel: string;
  difficultyHardLabel: string;
  difficultyExpertLabel: string;
  clearFiltersLabel: string;
}

export interface ChallengeCardLabels {
  statusActive?: string;
  statusCompleted?: string;
  statusExpired?: string;
  statusUpcoming?: string;
  difficultyEasy?: string;
  difficultyMedium?: string;
  difficultyHard?: string;
  difficultyExpert?: string;
  startLabel?: string;
  endLabel?: string;
  completedOnLabel?: string;
  completeButtonText?: string;
  inProgressText?: string;
}

export interface ChallengeDiscoveryCardLabels {
  closeButtonAriaLabel?: string;
  loadingMessage?: string;
  errorLoadingChallenge?: string;
  cannotLoadChallenge?: string;
  startDateLabel?: string;
  endDateLabel?: string;
  laterButton?: string;
  acceptButton?: string;
}

export interface ChallengeRecommendationCardLabels {
  matchRateLabel?: string;
  startDateLabel?: string;
  endDateLabel?: string;
  viewDetailsButton?: string;
  acceptButton?: string;
}

export interface SocialChallengeCardLabels {
  progressLabel?: string;
  shareButton?: string;
  leaveButton?: string;
  joinButton?: string;
}

export interface ChallengesPageViewLabelsBundle {
  pageTitle: string;
  filters: ChallengeFilterLabels;
  statusFilterLabel?: string;
  typeFilterLabel?: string;
  difficultyFilterLabel?: string;
  noChallengesMessage: string;
  loadingMessage?: string;
  errorTitle?: string;
  errorMessage?: string;
  retryButtonText?: string;
  challengeCard?: ChallengeCardLabels;
  challengeDiscoveryCard?: ChallengeDiscoveryCardLabels;
  challengeRecommendationCard?: ChallengeRecommendationCardLabels;
  socialChallengeCard?: SocialChallengeCardLabels;
}
export type FetchChallengesPageViewResult = LocalizedContent<null, ChallengesPageViewLabelsBundle>;

// --- Timely Rewards Page/View Specific Types ---
export interface TimelyRewardFilterLabels {
  allLabel: string;
  activeLabel: string;
  completedLabel: string;
  upcomingLabel: string;
  typeAllLabel: string;
  typeDailyLabel: string;
  typeMorningLabel: string;
  typeStreakLabel: string;
  typeSpecialLabel: string;
  clearFiltersLabel: string;
}

export interface LuckyDrawLabels {
  title: string;
  buttonText: string;
  basicDrawLabel: string;
  advancedDrawLabel: string;
  premiumDrawLabel: string;
  basicDrawDescription: string;
  advancedDrawDescription: string;
  premiumDrawDescription: string;
  insufficientPointsLabel: string;
  drawingLabel: string;
  closeLabel: string;
  continueLabel: string;
}

export interface TimelyRewardCardLabels {
  typeDaily: string;
  typeMorning: string;
  typeStreak: string;
  typeSpecial: string;
  statusActive: string;
  statusCompleted: string;
  statusExpired: string;
  statusUpcoming: string;
  remainingTimeLabel: string;
  timeEnded: string;
  hourUnit: string;
  minuteUnit: string;
  luckyPointsLabel: string;
  claimRewardButton: string;
  inProgressButton: string;
  completedOnLabel: string;
  typeLabel?: string;
  statusLabel?: string;
  progressLabel?: string;
  startTimeLabel?: string;
  endTimeLabel?: string;
  completedTimeLabel?: string;
  continueEffortButton?: string;
  noRewardsMessage?: string;
}

export interface TimelyRewardsPageViewLabelsBundle {
  pageTitle: string;
  filters: TimelyRewardFilterLabels;
  luckyDraw: LuckyDrawLabels;
  noRewardsMessage: string;
  rewardCard: TimelyRewardCardLabels;
  loadingMessage?: string;
  errorTitle?: string;
  errorMessage?: string;
}
export type FetchTimelyRewardsPageViewResult = LocalizedContent<null, TimelyRewardsPageViewLabelsBundle>;

// --- Abilities Page/View Specific Types ---
export interface AbilityFilterLabels {
  statusLabel: string;
  typeLabel: string;
  allLabel: string;
  unlockedLabel: string;
  lockedLabel: string;
  passiveLabel: string;
  activeLabel: string;
  ultimateLabel: string;
  clearFiltersLabel: string;
}

export interface AbilityCardLabels {
  typePassive: string;
  typeActive: string;
  typeUltimate: string;
  typeUnknown: string;
  rarityCommon: string;
  rarityUncommon: string;
  rarityRare: string;
  rarityEpic: string;
  rarityLegendary: string;
  requiredLevelLabel: string;
  cooldownLabel: string;
  cooldownRemainingLabel: string;
  activateButtonText: string;
  alreadyActivatedText: string;
  minutesUnit: string;
}

export interface AbilityDetailLabels {
  title: string;
  requiredLevelLabel: string;
  levelsNeededText: string;
  cooldownLabel: string;
  rarityLabel: string;
  typeLabel: string;
  effectLabel: string;
  activateButtonText: string;
  alreadyActivatedText: string;
}

export interface AbilityUnlockNotificationLabels {
  title: string;
  newAbilityTitle: string;
  nextButtonText: string;
  viewAllButtonText: string;
  allUnlockedTitle: string;
  closeButtonText: string;
}

export interface AbilitiesPageViewLabelsBundle {
  pageTitle: string;
  filters: AbilityFilterLabels;
  noAbilitiesMessage: string;
  loadingMessage?: string;
  errorTitle?: string;
  errorMessage?: string;
  retryButtonText?: string;
  pandaLevelLabel?: string;
  unlockedAbilitiesLabel?: string;
  abilitiesDescription?: string;
  abilityCard?: AbilityCardLabels;
  abilityDetail?: AbilityDetailLabels;
  abilityUnlockNotification?: AbilityUnlockNotificationLabels;
}
export type FetchAbilitiesPageViewResult = LocalizedContent<null, AbilitiesPageViewLabelsBundle>;

// --- Store Page/View Specific Types ---
export interface StorePageViewLabelsBundle {
  pageTitle: string;
  loadingMessage?: string;
  errorTitle?: string;
  retryButtonText?: string;
  currencySection?: {
    coinsLabel?: string;
    jadeLabel?: string;
    vipLabel?: string;
  };
  vipToggleButton?: {
    showVip?: string;
    backToStore?: string;
  };
  vipSection?: {
    description?: string;
    tierLabels?: {
      basic?: string;
      premium?: string;
      deluxe?: string;
    }
  };
  categoriesTitle?: string;
  featuredItemsTitle?: string;
  saleItemsTitle?: string;
  categoryItemsTitle?: string;
  noCategoriesMessage?: string;
  noItemsMessage?: string;
}
export type FetchStorePageViewResult = LocalizedContent<null, StorePageViewLabelsBundle>;

// --- Tea Room Page/View Specific Types ---
export interface TeaRoomPageViewLabelsBundle {
  pageTitle: string;
  loadingMessage?: string;
  errorTitle?: string;
  retryButtonText?: string;
  moodTrackingSection?: {
    title?: string;
    description?: string;
    currentMoodQuestion?: string;
    recordMoodButton?: string;
    intensityLabel?: string;
    noteLabel?: string;
    historyLabel?: string;
  };
  reflectionSection?: {
    title?: string;
    description?: string;
    startReflectionButton?: string;
    viewHistoryButton?: string;
  };
  dailyTipSection?: {
    title?: string;
    content?: string;
  };
  reflectionTriggers?: {
    title?: string;
    description?: string;
  };
}
export type FetchTeaRoomPageViewResult = LocalizedContent<null, TeaRoomPageViewLabelsBundle>;
</file>

</files>
